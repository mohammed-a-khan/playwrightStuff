ApiResponse.java
--------------------------------
package com.qaf.framework.util;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

/**
 * Enhanced class representing an API response with improved JSON handling.
 */
public class ApiResponse {
    private final int statusCode;
    private final String responseBody;
    private final Map<String, List<String>> headers;
    private JSONObject jsonObject;
    private JSONArray jsonArray;

    /**
     * Constructor for ApiResponse.
     * 
     * @param statusCode the HTTP status code
     * @param responseBody the response body as a string
     * @param headers response headers
     */
    public ApiResponse(int statusCode, String responseBody, Map<String, List<String>> headers) {
        this.statusCode = statusCode;
        this.responseBody = responseBody;
        this.headers = headers;
        
        // Parse JSON if possible
        if (responseBody != null && !responseBody.isEmpty()) {
            try {
                if (responseBody.trim().startsWith("{")) {
                    this.jsonObject = new JSONObject(responseBody);
                } else if (responseBody.trim().startsWith("[")) {
                    this.jsonArray = new JSONArray(responseBody);
                }
            } catch (JSONException e) {
                // Not valid JSON, keep as null
            }
        }
    }

    /**
     * Gets the HTTP status code.
     * 
     * @return the HTTP status code
     */
    public int getStatusCode() {
        return statusCode;
    }

    /**
     * Gets the response body as a string.
     * 
     * @return the response body
     */
    public String getResponseBody() {
        return responseBody;
    }

    /**
     * Gets the response headers.
     * 
     * @return map of header names to values
     */
    public Map<String, List<String>> getHeaders() {
        return headers;
    }

    /**
     * Checks if the response was successful (status code 2xx).
     * 
     * @return true if the status code is between 200 and 299
     */
    public boolean isSuccessful() {
        return statusCode >= 200 && statusCode < 300;
    }

    /**
     * Gets a header value.
     * 
     * @param headerName the header name
     * @return the first value of the header, or null if not found
     */
    public String getHeader(String headerName) {
        List<String> values = headers.get(headerName);
        return (values != null && !values.isEmpty()) ? values.get(0) : null;
    }

    /**
     * Gets all header values.
     * 
     * @param headerName the header name
     * @return list of values for the header, or empty list if not found
     */
    public List<String> getHeaders(String headerName) {
        List<String> values = headers.get(headerName);
        return values != null ? values : new ArrayList<>();
    }

    /**
     * Gets the response as a JSONObject.
     * 
     * @return JSONObject representing the response, or null if not valid JSON object
     */
    public JSONObject getJsonObject() {
        return jsonObject;
    }

    /**
     * Gets the response as a JSONArray.
     * 
     * @return JSONArray representing the response, or null if not valid JSON array
     */
    public JSONArray getJsonArray() {
        return jsonArray;
    }

    /**
     * Gets a value from the JSON response by key.
     * 
     * @param key the JSON key
     * @return the value as a string, or null if not found
     */
    public String getValueFromJson(String key) {
        if (jsonObject != null && jsonObject.has(key)) {
            Object value = jsonObject.get(key);
            return value == JSONObject.NULL ? null : value.toString();
        }
        return null;
    }

    /**
     * Checks if a field exists in the JSON response.
     * 
     * @param field the field name
     * @return true if the field exists, false otherwise
     */
    public boolean hasJsonField(String field) {
        return jsonObject != null && jsonObject.has(field);
    }

    /**
     * Gets a nested value from the JSON response using dot notation.
     * 
     * @param path the dot-notated path (e.g., "data.user.name")
     * @return the value as a string, or null if not found
     */
    public String getNestedValue(String path) {
        if (jsonObject == null || path == null || path.isEmpty()) {
            return null;
        }
        
        try {
            String[] parts = path.split("\\.");
            Object current = jsonObject;
            
            for (String part : parts) {
                if (current instanceof JSONObject) {
                    JSONObject currentJson = (JSONObject) current;
                    if (!currentJson.has(part)) {
                        return null;
                    }
                    current = currentJson.get(part);
                } else {
                    return null;
                }
            }
            
            return current == JSONObject.NULL ? null : current.toString();
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Checks if the response body contains a specific text.
     * 
     * @param text the text to check for
     * @return true if the response body contains the text
     */
    public boolean responseContains(String text) {
        return responseBody != null && responseBody.contains(text);
    }
    
    /**
     * Gets an item from a JSON array in the response.
     * 
     * @param arrayField the field name of the array
     * @param index the index of the item in the array
     * @return the JSON object at the specified index, or null if not found
     */
    public JSONObject getArrayItem(String arrayField, int index) {
        try {
            if (jsonObject != null && jsonObject.has(arrayField)) {
                JSONArray array = jsonObject.getJSONArray(arrayField);
                if (index >= 0 && index < array.length()) {
                    return array.getJSONObject(index);
                }
            }
        } catch (Exception e) {
            // Not a valid JSON structure or not an object at that index
        }
        return null;
    }
    
    /**
     * Gets all items from a JSON array in the response as a list of maps.
     * 
     * @param arrayField the field name of the array
     * @return list of maps representing the array items, or empty list if not found
     */
    public List<Map<String, Object>> getArrayItems(String arrayField) {
        List<Map<String, Object>> result = new ArrayList<>();
        
        try {
            if (jsonObject != null && jsonObject.has(arrayField)) {
                JSONArray array = jsonObject.getJSONArray(arrayField);
                for (int i = 0; i < array.length(); i++) {
                    if (array.get(i) instanceof JSONObject) {
                        JSONObject item = array.getJSONObject(i);
                        Map<String, Object> itemMap = new HashMap<>();
                        for (String key : item.keySet()) {
                            itemMap.put(key, item.get(key));
                        }
                        result.add(itemMap);
                    }
                }
            }
        } catch (Exception e) {
            // Not a valid JSON structure
        }
        
        return result;
    }
    
    /**
     * Gets the size of an array in the JSON response.
     * 
     * @param arrayField the field name of the array
     * @return the size of the array, or -1 if not found
     */
    public int getArraySize(String arrayField) {
        try {
            if (jsonObject != null && jsonObject.has(arrayField)) {
                JSONArray array = jsonObject.getJSONArray(arrayField);
                return array.length();
            }
        } catch (Exception e) {
            // Not a valid JSON structure
        }
        return -1;
    }
    
    /**
     * Checks if JSON response matches the expected schema.
     * 
     * @param expectedSchema map of field names to expected data types
     * @return true if the schema matches, false otherwise
     */
    public boolean matchesSchema(Map<String, Class<?>> expectedSchema) {
        if (jsonObject == null || expectedSchema == null || expectedSchema.isEmpty()) {
            return false;
        }
        
        for (Map.Entry<String, Class<?>> entry : expectedSchema.entrySet()) {
            String field = entry.getKey();
            Class<?> expectedType = entry.getValue();
            
            if (!jsonObject.has(field)) {
                return false;
            }
            
            Object value = jsonObject.get(field);
            
            if (value == JSONObject.NULL) {
                continue; // Null values are allowed
            }
            
            // Check if the value is of the expected type
            if (expectedType == String.class && !(value instanceof String)) {
                return false;
            } else if (expectedType == Integer.class && !(value instanceof Integer)) {
                return false;
            } else if (expectedType == Long.class && !(value instanceof Long)) {
                return false;
            } else if (expectedType == Double.class && !(value instanceof Double)) {
                return false;
            } else if (expectedType == Boolean.class && !(value instanceof Boolean)) {
                return false;
            } else if (expectedType == JSONObject.class && !(value instanceof JSONObject)) {
                return false;
            } else if (expectedType == JSONArray.class && !(value instanceof JSONArray)) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Extracts data from the response based on a pattern.
     * 
     * @param pattern the regex pattern
     * @param groupIndex the group index to extract
     * @return the extracted data, or null if not found
     */
    public String extractDataWithPattern(String pattern, int groupIndex) {
        if (responseBody == null || responseBody.isEmpty()) {
            return null;
        }
        
        java.util.regex.Matcher matcher = Pattern.compile(pattern).matcher(responseBody);
        if (matcher.find() && groupIndex <= matcher.groupCount()) {
            return matcher.group(groupIndex);
        }
        
        return null;
    }
    
    /**
     * Converts the response to a map.
     * 
     * @return map representation of the response, or empty map if not valid JSON
     */
    public Map<String, Object> toMap() {
        Map<String, Object> result = new HashMap<>();
        
        if (jsonObject != null) {
            for (String key : jsonObject.keySet()) {
                result.put(key, jsonObject.get(key));
            }
        }
        
        return result;
    }
    
    /**
     * Returns a string representation of the response.
     * 
     * @return string representation of the response
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Status Code: ").append(statusCode).append("\n");
        
        if (headers != null && !headers.isEmpty()) {
            sb.append("Headers:\n");
            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {
                if (entry.getKey() != null) { // Skip null key which contains status line
                    sb.append("  ").append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
                }
            }
        }
        
        sb.append("Body: ").append(responseBody);
        return sb.toString();
    }
}

ApiClientUtil.java
---------------------

package com.qaf.framework.util;

import com.qaf.framework.config.ApiConfig;
import com.qmetry.qaf.automation.core.ConfigurationManager;
import org.apache.commons.io.IOUtils;
import org.json.JSONObject;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.net.ssl.*;
import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Enhanced utility class for making API requests with improved template processing.
 */
public class ApiClientUtil {
    private static final Log logger = LogFactory.getLog(ApiClientUtil.class);
    private static final Pattern VARIABLE_PATTERN = Pattern.compile("\\$\\{([^}]+)\\}");

    /**
     * Sends an HTTP request to the specified endpoint.
     * 
     * @param endpoint the API endpoint (path)
     * @param method HTTP method (GET, POST, PUT, DELETE, PATCH)
     * @param payload request payload (for POST, PUT, PATCH)
     * @param headers request headers
     * @return ApiResponse containing the response
     * @throws Exception if there's an error making the request
     */
    public static ApiResponse sendRequest(String endpoint, String method, String payload, Map<String, String> headers) throws Exception {
        // Determine if endpoint is a full URL or just a path
        String fullUrl;
        if (endpoint.startsWith("http")) {
            fullUrl = endpoint;
        } else {
            // If it's just a path, prefix with the base URL
            String baseUrl = ApiConfig.getBaseUrl();
            
            // Ensure endpoint starts with / if base URL doesn't end with /
            if (!baseUrl.endsWith("/") && !endpoint.startsWith("/")) {
                endpoint = "/" + endpoint;
            }
            
            fullUrl = baseUrl + endpoint;
        }
        
        logger.info("Sending " + method + " request to: " + fullUrl);
        if (payload != null && !payload.isEmpty()) {
            logger.debug("Request payload: " + payload);
        }
        
        // Create connection
        URL url = new URL(fullUrl);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();

        // Configure SSL for HTTPS connections
        if (conn instanceof HttpsURLConnection httpsConn) {
            logger.info("Configuring HTTPS connection");
            
            // Check if certificates are required
            boolean useCustomCert = ConfigurationManager.getBundle().getBoolean("ssl.custom.cert", false);
            if (useCustomCert) {
                httpsConn.setSSLSocketFactory(getSSLSocketFactory());
            } else {
                // Trust all certificates for testing environments
                TrustManager[] trustAllCerts = new TrustManager[] { 
                    new X509TrustManager() {
                        public X509Certificate[] getAcceptedIssuers() { return null; }
                        public void checkClientTrusted(X509Certificate[] certs, String authType) { }
                        public void checkServerTrusted(X509Certificate[] certs, String authType) { }
                    }
                };
                
                SSLContext sc = SSLContext.getInstance("TLS");
                sc.init(null, trustAllCerts, new SecureRandom());
                httpsConn.setSSLSocketFactory(sc.getSocketFactory());
                httpsConn.setHostnameVerifier((hostname, session) -> true);
            }
        }

        // Configure proxy if enabled
        boolean useProxy = ConfigurationManager.getBundle().getBoolean("proxy.enabled", false);
        if (useProxy) {
            String proxyHost = ConfigurationManager.getBundle().getString("proxy.host");
            String proxyPort = ConfigurationManager.getBundle().getString("proxy.port");
            logger.info("Using proxy: " + proxyHost + ":" + proxyPort);
            System.setProperty("https.proxyHost", proxyHost);
            System.setProperty("https.proxyPort", proxyPort);
        }

        // Configure request
        conn.setRequestMethod(method.toUpperCase());
        conn.setDoInput(true);
        
        // Set default headers if none provided
        if (headers == null) {
            headers = new HashMap<>();
        }
        
        // Add default content type if not specified
        if (!headers.containsKey("Content-Type")) {
            headers.put("Content-Type", "application/json");
        }
        
        // Add default accept if not specified  
        if (!headers.containsKey("Accept")) {
            headers.put("Accept", "application/json");
        }
        
        // Set headers
        for (Map.Entry<String, String> header : headers.entrySet()) {
            conn.setRequestProperty(header.getKey(), header.getValue());
        }

        // Set timeout properties
        int timeout = ConfigurationManager.getBundle().getInt("connection.timeout", 30000);
        conn.setConnectTimeout(timeout);
        conn.setReadTimeout(timeout);

        // Send payload for POST, PUT, PATCH requests
        if (payload != null && !payload.isEmpty() && 
            (method.equalsIgnoreCase("POST") || method.equalsIgnoreCase("PUT") || method.equalsIgnoreCase("PATCH"))) {
            conn.setDoOutput(true);
            try (OutputStream os = conn.getOutputStream()) {
                os.write(payload.getBytes(StandardCharsets.UTF_8));
                os.flush();
            }
        }

        // Get response
        int statusCode = conn.getResponseCode();
        logger.info("Response status code: " + statusCode);

        // Read response body
        String responseBody;
        try (InputStream is = (statusCode >= 200 && statusCode < 300) ? 
             conn.getInputStream() : conn.getErrorStream()) {
            if (is != null) {
                responseBody = IOUtils.toString(is, StandardCharsets.UTF_8);
            } else {
                responseBody = "";
            }
        }
        
        if (!responseBody.isEmpty()) {
            logger.debug("Response body: " + responseBody);
        }
        
        // Create and return the API response
        return new ApiResponse(statusCode, responseBody, conn.getHeaderFields());
    }

    /**
     * Creates an SSLSocketFactory with the certificate from properties.
     * 
     * @return SSLSocketFactory configured with the certificate
     * @throws Exception if there's an error setting up the SSL context
     */
    private static SSLSocketFactory getSSLSocketFactory() throws Exception {
        String certPath = ConfigurationManager.getBundle().getString("certificate.path");
        String certPassword = ConfigurationManager.getBundle().getString("certificate.password");

        logger.info("Setting up SSL with certificate: " + certPath);
        
        // Check if certificate file exists
        File certFile = new File(certPath);
        if (!certFile.exists()) {
            logger.error("Certificate file not found: " + certPath);
            throw new FileNotFoundException("Certificate file not found: " + certPath);
        }

        // Load the keystore
        KeyStore keyStore = KeyStore.getInstance("PKCS12");
        try (InputStream keyInput = new FileInputStream(certPath)) {
            keyStore.load(keyInput, certPassword.toCharArray());
        }

        // Set up key manager
        KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
        kmf.init(keyStore, certPassword.toCharArray());

        // Set up SSL context
        SSLContext sslContext = SSLContext.getInstance("TLSv1.2");
        sslContext.init(kmf.getKeyManagers(), null, new SecureRandom());
        return sslContext.getSocketFactory();
    }

    /**
     * Loads a payload file from the configured payload directory.
     * 
     * @param fileName name of the payload file
     * @return the content of the payload file as a string
     * @throws IOException if there's an error reading the file
     */
    public static String readPayload(String fileName) throws IOException {
        // If no extension is provided, assume .json
        if (!fileName.contains(".")) {
            fileName = fileName + ".json";
        }
        
        // Determine payload directory
        String payloadDir = ConfigurationManager.getBundle().getString("payload.dir", "resources/payloads");
        String path = payloadDir + "/" + fileName;
        
        File payloadFile = new File(path);
        if (!payloadFile.exists()) {
            logger.error("Payload file not found: " + path);
            throw new FileNotFoundException("Payload file not found: " + path);
        }
        
        logger.info("Reading payload from: " + path);
        try (InputStream is = new FileInputStream(path)) {
            return IOUtils.toString(is, StandardCharsets.UTF_8);
        }
    }
    
    /**
     * Processes a template by substituting variables with values from a data map.
     * This enhanced version handles different data types appropriately.
     * 
     * @param template the template string with placeholders like ${variable}
     * @param data the map containing values to substitute
     * @return the processed template with all placeholders replaced
     */
    public static String processTemplate(String template, Map<String, Object> data) {
        if (template == null || data == null || data.isEmpty()) {
            return template;
        }
        
        StringBuilder result = new StringBuilder(template);
        Matcher matcher = VARIABLE_PATTERN.matcher(template);
        
        // Track offsets as we modify the string
        int offset = 0;
        
        while (matcher.find()) {
            String placeholder = matcher.group(0);
            String key = matcher.group(1);
            
            if (data.containsKey(key)) {
                Object value = data.get(key);
                String replacement;
                
                // Handle different types appropriately
                if (value == null) {
                    replacement = "null";  // JSON null
                } else if (value instanceof Number || value instanceof Boolean) {
                    replacement = value.toString();  // Unquoted for numbers and booleans
                } else {
                    // For strings and other types, preserve as string
                    replacement = value.toString();
                    
                    // Check if we need to add quotes based on context
                    int placeholderStart = matcher.start() + offset;
                    int placeholderEnd = matcher.end() + offset;
                    
                    // If not already in quotes, add them for string values
                    boolean needsQuotes = true;
                    
                    // Check if already in quotes
                    if (placeholderStart > 0 && placeholderEnd < result.length()) {
                        char before = result.charAt(placeholderStart - 1);
                        char after = result.charAt(placeholderEnd);
                        if (before == '"' && after == '"') {
                            needsQuotes = false;
                        }
                    }
                    
                    if (needsQuotes) {
                        replacement = "\"" + replacement + "\"";
                    }
                }
                
                // Replace the placeholder
                int start = matcher.start() + offset;
                int end = matcher.end() + offset;
                result.replace(start, end, replacement);
                
                // Update offset for next replacement
                offset += replacement.length() - placeholder.length();
            }
        }
        
        return result.toString();
    }
    
    /**
     * Generates a unique message ID for API requests.
     * 
     * @return a unique message ID string
     */
    public static String generateMessageId() {
        return "Test-" + UUID.randomUUID().toString();
    }
    
    /**
     * Creates a basic API payload with common fields.
     * 
     * @param additionalFields additional fields to include in the payload
     * @return JSON string payload
     */
    public static String createBasicPayload(Map<String, Object> additionalFields) {
        JSONObject payload = new JSONObject();
        payload.put("messageId", generateMessageId());
        
        if (additionalFields != null) {
            for (Map.Entry<String, Object> entry : additionalFields.entrySet()) {
                payload.put(entry.getKey(), entry.getValue());
            }
        }
        
        return payload.toString();
    }
}

ApiConfig.java
-----------------
package com.qaf.framework.config;

import com.qmetry.qaf.automation.core.ConfigurationManager;
import com.qmetry.qaf.automation.util.PropertyUtil;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.Enumeration;

/**
 * Configuration class for API endpoints.
 * Centralizes all API endpoint configurations.
 */
public class ApiConfig {
    
    private static final Log logger = LogFactory.getLog(ApiConfig.class);
    private static final PropertyUtil props = ConfigurationManager.getBundle();
    private static final Map<String, String> ENDPOINTS = new HashMap<>();
    
    // Initialize endpoints when the class is loaded
    static {
        loadAllEndpoints();
    }
    
    /**
     * Loads all endpoints - both default endpoints and those from properties.
     */
    private static void loadAllEndpoints() {
        // Load default endpoints from properties first (if defined)
        loadEndpointsFromProperties();
        
        // Define fallback endpoints only if they aren't already defined in properties
        setDefaultEndpointIfNotExists("Employee Calendar", "/api/v1/emp/empcalendar");
        setDefaultEndpointIfNotExists("Deal Static Info", "/api/v1/abo/dealstaticinfo");
        setDefaultEndpointIfNotExists("Asset Layout", "/api/v1/spc/assetlayout");
    }
    
    /**
     * Sets a default endpoint only if it doesn't already exist.
     * 
     * @param apiName the API name
     * @param endpoint the default endpoint
     */
    private static void setDefaultEndpointIfNotExists(String apiName, String endpoint) {
        if (!ENDPOINTS.containsKey(apiName)) {
            ENDPOINTS.put(apiName, endpoint);
            logger.info("Set default endpoint: " + apiName + " = " + endpoint);
        }
    }
    
    /**
     * Loads API endpoints from properties file.
     */
    private static void loadEndpointsFromProperties() {
        String prefix = "api.endpoint.";
        
        // Get properties as a Java Properties object
        Properties properties = props.getProperties();
        
        // Iterate through all properties
        Enumeration<?> propertyNames = properties.propertyNames();
        while (propertyNames.hasMoreElements()) {
            String key = (String) propertyNames.nextElement();
            
            if (key.startsWith(prefix)) {
                String name = key.substring(prefix.length());
                String endpoint = props.getString(key);
                ENDPOINTS.put(name, endpoint);
                logger.info("Loaded API endpoint from properties: " + name + " = " + endpoint);
            }
        }
    }
    
    /**
     * Gets the endpoint URL for the specified API name.
     * 
     * @param apiName the API name
     * @return the endpoint URL, or null if not found
     */
    public static String getEndpoint(String apiName) {
        return ENDPOINTS.get(apiName);
    }
    
    /**
     * Adds or updates an endpoint.
     * 
     * @param apiName the API name
     * @param endpoint the endpoint URL
     */
    public static void setEndpoint(String apiName, String endpoint) {
        ENDPOINTS.put(apiName, endpoint);
        logger.info("Added/updated API endpoint: " + apiName + " = " + endpoint);
    }
    
    /**
     * Gets the base URL for API requests.
     * 
     * @return the base URL
     */
    public static String getBaseUrl() {
        return props.getString("base.url", "https://api.example.com");
    }
    
    /**
     * Gets all configured endpoints.
     * 
     * @return map of API names to endpoints
     */
    public static Map<String, String> getAllEndpoints() {
        return new HashMap<>(ENDPOINTS);
    }
}

GenericApiSteps:
-----------------
package com.qaf.framework.stepdefs;

import com.qaf.framework.config.ApiConfig;
import com.qaf.framework.service.GenericApiService;
import com.qaf.framework.util.ApiResponse;
import com.qaf.framework.util.TestContextManager;
import com.qaf.framework.util.ApiClientUtil;
import com.qmetry.qaf.automation.step.QAFTestStep;
import com.qmetry.qaf.automation.util.Reporter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.testng.Assert;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Generic step definitions for API testing.
 */
public class GenericApiSteps {
    
    private static final Log logger = LogFactory.getLog(GenericApiSteps.class);
    
    /**
     * Sets up testing for a specific API.
     * 
     * @param apiName the API name as defined in ApiConfig
     */
    @QAFTestStep(description = "I am testing the {apiName} API")
    public void setupApiTest(String apiName) {
        String endpoint = ApiConfig.getEndpoint(apiName);
        if (endpoint == null) {
            throw new IllegalArgumentException("Unknown API name: " + apiName);
        }
        
        TestContextManager.setCurrentApi(apiName, endpoint);
        Reporter.log("Set up for testing the " + apiName + " API at endpoint: " + endpoint);
    }
    
    /**
     * Sets a value in the test data map.
     * 
     * @param key the key
     * @param value the value
     */
    @QAFTestStep(description = "I set test data {key} to {value}")
    public void setTestDataValue(String key, String value) {
        Object processedValue = value;
        
        // Try to convert to number if possible
        try {
            if (value.contains(".")) {
                processedValue = Double.parseDouble(value);
            } else {
                processedValue = Integer.parseInt(value);
            }
        } catch (NumberFormatException e) {
            // Keep as string if not a valid number
        }
        
        TestContextManager.setTestData(key, processedValue);
        Reporter.log("Set test data: " + key + " = " + processedValue);
    }
    
    /**
     * Sets multiple values in the test data map.
     * 
     * @param data map of key-value pairs
     */
    @QAFTestStep(description = "I set test data {data}")
    public void setTestDataValues(Map<String, String> data) {
        for (Map.Entry<String, String> entry : data.entrySet()) {
            setTestDataValue(entry.getKey(), entry.getValue());
        }
    }
    
    /**
     * Clears all test data.
     */
    @QAFTestStep(description = "I clear all test data")
    public void clearAllTestData() {
        TestContextManager.clearTestData();
        Reporter.log("Cleared all test data");
    }
    
    /**
     * Sends a request to the current API with a payload file.
     * 
     * @param method the HTTP method (GET, POST, PUT, DELETE, PATCH)
     * @param payloadFile the payload file name
     */
    @QAFTestStep(description = "I send a {method} request with payload file {payloadFile}")
    public void sendRequestWithPayloadFile(String method, String payloadFile) {
        String endpoint = TestContextManager.getCurrentApiEndpoint();
        if (endpoint == null) {
            throw new IllegalStateException("No API has been set up. Use 'I am testing the {apiName} API' first.");
        }
        
        try {
            ApiResponse response = GenericApiService.sendRequestWithPayloadFile(
                endpoint, method, payloadFile, null);
            
            Reporter.log(method.toUpperCase() + " request sent successfully to " + endpoint);
            Reporter.log("Response status: " + response.getStatusCode());
            Reporter.log("Response body: " + response.getResponseBody());
            
        } catch (Exception e) {
            logger.error("Error sending request: " + e.getMessage(), e);
            Reporter.log("Error sending request: " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Sends a request to a named API with a payload file.
     * 
     * @param method the HTTP method (GET, POST, PUT, DELETE, PATCH)
     * @param apiName the API name as defined in ApiConfig
     * @param payloadFile the payload file name
     */
    @QAFTestStep(description = "I send a {method} request to {apiName} API with payload file {payloadFile}")
    public void sendRequestToNamedApiWithPayloadFile(String method, String apiName, String payloadFile) {
        String endpoint = ApiConfig.getEndpoint(apiName);
        if (endpoint == null) {
            throw new IllegalArgumentException("Unknown API name: " + apiName);
        }
        
        TestContextManager.setCurrentApi(apiName, endpoint);
        
        try {
            ApiResponse response = GenericApiService.sendRequestWithPayloadFile(
                endpoint, method, payloadFile, null);
            
            Reporter.log(method.toUpperCase() + " request sent successfully to " + apiName + " API");
            Reporter.log("Response status: " + response.getStatusCode());
            Reporter.log("Response body: " + response.getResponseBody());
            
        } catch (Exception e) {
            logger.error("Error sending request: " + e.getMessage(), e);
            Reporter.log("Error sending request: " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Sends a request with raw payload.
     * 
     * @param method the HTTP method (GET, POST, PUT, DELETE, PATCH)
     * @param payload the raw payload
     */
    @QAFTestStep(description = "I send a {method} request with payload: {payload}")
    public void sendRequestWithRawPayload(String method, String payload) {
        String endpoint = TestContextManager.getCurrentApiEndpoint();
        if (endpoint == null) {
            throw new IllegalStateException("No API has been set up. Use 'I am testing the {apiName} API' first.");
        }
        
        try {
            ApiResponse response = GenericApiService.sendRequest(endpoint, method, payload, null);
            
            Reporter.log(method.toUpperCase() + " request sent successfully to " + endpoint);
            Reporter.log("Response status: " + response.getStatusCode());
            Reporter.log("Response body: " + response.getResponseBody());
            
        } catch (Exception e) {
            logger.error("Error sending request: " + e.getMessage(), e);
            Reporter.log("Error sending request: " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Verifies the response status code.
     * 
     * @param expectedStatus the expected status code
     */
    @QAFTestStep(description = "the response status code should be {expectedStatus}")
    public void verifyStatusCode(int expectedStatus) {
        ApiResponse response = TestContextManager.getLastApiResponse();
        if (response == null) {
            Assert.fail("No API response available. Make sure to send a request first.");
            return;
        }
        
        int actualStatus = response.getStatusCode();
        Reporter.log("Verifying status code: expected=" + expectedStatus + ", actual=" + actualStatus);
        Assert.assertEquals(actualStatus, expectedStatus, "Response status code mismatch");
    }
    
    /**
     * Verifies the response is successful (2xx status code).
     */
    @QAFTestStep(description = "the response should be successful")
    public void verifyResponseSuccessful() {
        ApiResponse response = TestContextManager.getLastApiResponse();
        if (response == null) {
            Assert.fail("No API response available. Make sure to send a request first.");
            return;
        }
        
        boolean successful = response.isSuccessful();
        Reporter.log("Verifying response is successful: " + successful);
        Assert.assertTrue(successful, "Response is not successful. Status code: " + response.getStatusCode());
    }
    
    /**
     * Verifies the response contains a field.
     * 
     * @param field the field name to check
     */
    @QAFTestStep(description = "the response should contain field {field}")
    public void verifyResponseContainsField(String field) {
        ApiResponse response = TestContextManager.getLastApiResponse();
        if (response == null) {
            Assert.fail("No API response available. Make sure to send a request first.");
            return;
        }
        
        boolean hasField = response.hasJsonField(field);
        Reporter.log("Verifying response contains field '" + field + "': " + hasField);
        Assert.assertTrue(hasField, "Response does not contain field: " + field);
    }
    
    /**
     * Verifies a response field has a specific value.
     * 
     * @param field the field name
     * @param expectedValue the expected value
     */
    @QAFTestStep(description = "the response field {field} should be {expectedValue}")
    public void verifyResponseFieldValue(String field, String expectedValue) {
        ApiResponse response = TestContextManager.getLastApiResponse();
        if (response == null) {
            Assert.fail("No API response available. Make sure to send a request first.");
            return;
        }
        
        String actualValue = response.getValueFromJson(field);
        Reporter.log("Verifying field '" + field + "': expected=" + expectedValue + ", actual=" + actualValue);
        Assert.assertEquals(actualValue, expectedValue, "Field value mismatch for: " + field);
    }
    
    /**
     * Verifies a response field contains a substring.
     * 
     * @param field the field name
     * @param expectedText the expected substring
     */
    @QAFTestStep(description = "the response field {field} should contain {expectedText}")
    public void verifyResponseFieldContains(String field, String expectedText) {
        ApiResponse response = TestContextManager.getLastApiResponse();
        if (response == null) {
            Assert.fail("No API response available. Make sure to send a request first.");
            return;
        }
        
        String actualValue = response.getValueFromJson(field);
        Reporter.log("Verifying field '" + field + "' contains: " + expectedText);
        Assert.assertTrue(actualValue != null && actualValue.contains(expectedText), 
                          "Field '" + field + "' does not contain: " + expectedText);
    }
    
    /**
     * Verifies a validation error message.
     * 
     * @param field the field with validation error
     * @param expectedMessage the expected validation message
     */
    @QAFTestStep(description = "the validation error message for {field} should be {expectedMessage}")
    public void verifyValidationErrorMessage(String field, String expectedMessage) {
        ApiResponse response = TestContextManager.getLastApiResponse();
        if (response == null) {
            Assert.fail("No API response available. Make sure to send a request first.");
            return;
        }
        
        String path = "validationErrorMessage." + field;
        String actualMessage = response.getNestedValue(path);
        
        Reporter.log("Verifying validation error for field '" + field + "': expected=" + expectedMessage + ", actual=" + actualMessage);
        Assert.assertEquals(actualMessage, expectedMessage, "Validation error message mismatch for field: " + field);
    }
    
    /**
     * Validates API response against UI captured data.
     * 
     * @param dataType the data type (e.g., "employeeCalendar", "dealStaticInfo")
     * @param responsePath the path to the array in the response (e.g., "empCalendarList", "dealStaticInfo")
     */
    @QAFTestStep(description = "I validate {dataType} API response against UI data using path {responsePath}")
    public void validateApiResponseAgainstUiData(String dataType, String responsePath) {
        TestContextManager.ValidationResult result = TestContextManager.validateApiResponseAgainstUiData(dataType, responsePath);
        
        if (result.isSuccess()) {
            Reporter.log("API response validation successful for " + dataType);
        } else {
            Reporter.log("API response validation failed: " + result.getMessage());
            Reporter.log(result.getFormattedIssues());
            Assert.fail("API response validation failed: " + result.getMessage() + "\n" + result.getFormattedIssues());
        }
    }
}

TestContextManager:
------------------

package com.qaf.framework.util;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;

import com.qmetry.qaf.automation.core.TestBaseProvider;
import org.json.JSONArray;
import org.json.JSONObject;

/**
 * Enhanced test context manager that supports any API response structure.
 */
public class TestContextManager {
    
    private static final String TEST_DATA_KEY = "api.test.data";
    private static final String EXPECTED_DATA_KEY = "api.expected.data";
    private static final String LAST_API_RESPONSE_KEY = "api.last.response";
    private static final String CURRENT_API_KEY = "api.current";
    private static final String UI_CAPTURED_DATA_KEY = "ui.captured.data";
    
    /**
     * Gets the shared test data map.
     * 
     * @return map of test data
     */
    public static Map<String, Object> getTestData() {
        Map<String, Object> testData = (Map<String, Object>) TestBaseProvider.instance().get()
                .getContext().getProperty(TEST_DATA_KEY);
        
        if (testData == null) {
            testData = new HashMap<>();
            TestBaseProvider.instance().get().getContext().setProperty(TEST_DATA_KEY, testData);
        }
        
        return testData;
    }
    
    /**
     * Sets a test data value.
     * 
     * @param key the key
     * @param value the value
     */
    public static void setTestData(String key, Object value) {
        getTestData().put(key, value);
    }
    
    /**
     * Gets a test data value.
     * 
     * @param key the key
     * @return the value, or null if not found
     */
    public static Object getTestDataValue(String key) {
        return getTestData().get(key);
    }
    
    /**
     * Clears all test data.
     */
    public static void clearTestData() {
        getTestData().clear();
    }
    
    /**
     * Sets the current API being tested.
     * 
     * @param apiName the API name
     * @param endpoint the API endpoint
     */
    public static void setCurrentApi(String apiName, String endpoint) {
        Map<String, String> apiInfo = new HashMap<>();
        apiInfo.put("name", apiName);
        apiInfo.put("endpoint", endpoint);
        TestBaseProvider.instance().get().getContext().setProperty(CURRENT_API_KEY, apiInfo);
    }
    
    /**
     * Gets the current API endpoint.
     * 
     * @return the current API endpoint, or null if not set
     */
    public static String getCurrentApiEndpoint() {
        Map<String, String> apiInfo = (Map<String, String>) TestBaseProvider.instance().get()
                .getContext().getProperty(CURRENT_API_KEY);
        return apiInfo != null ? apiInfo.get("endpoint") : null;
    }
    
    /**
     * Gets the current API name.
     * 
     * @return the current API name, or null if not set
     */
    public static String getCurrentApiName() {
        Map<String, String> apiInfo = (Map<String, String>) TestBaseProvider.instance().get()
                .getContext().getProperty(CURRENT_API_KEY);
        return apiInfo != null ? apiInfo.get("name") : null;
    }
    
    /**
     * Sets the last API response.
     * 
     * @param response the API response
     */
    public static void setLastApiResponse(ApiResponse response) {
        TestBaseProvider.instance().get().getContext().setProperty(LAST_API_RESPONSE_KEY, response);
    }
    
    /**
     * Gets the last API response.
     * 
     * @return the last API response, or null if not set
     */
    public static ApiResponse getLastApiResponse() {
        return (ApiResponse) TestBaseProvider.instance().get().getContext().getProperty(LAST_API_RESPONSE_KEY);
    }
    
    /**
     * Stores UI captured data for validation.
     * 
     * @param dataType the type of data (e.g., "empCalendar", "dealStaticInfo")
     * @param data list of data records (each record is a map)
     */
    public static void storeUiCapturedData(String dataType, List<Map<String, String>> data) {
        Map<String, List<Map<String, String>>> uiData = getUiCapturedDataMap();
        uiData.put(dataType, data);
    }
    
    /**
     * Gets UI captured data by type.
     * 
     * @param dataType the type of data
     * @return list of data records, or null if not found
     */
    public static List<Map<String, String>> getUiCapturedData(String dataType) {
        Map<String, List<Map<String, String>>> uiData = getUiCapturedDataMap();
        return uiData.get(dataType);
    }
    
    /**
     * Gets the UI captured data map.
     * 
     * @return map of UI captured data
     */
    @SuppressWarnings("unchecked")
    private static Map<String, List<Map<String, String>>> getUiCapturedDataMap() {
        Map<String, List<Map<String, String>>> uiData = 
            (Map<String, List<Map<String, String>>>) TestBaseProvider.instance().get()
                .getContext().getProperty(UI_CAPTURED_DATA_KEY);
        
        if (uiData == null) {
            uiData = new HashMap<>();
            TestBaseProvider.instance().get().getContext().setProperty(UI_CAPTURED_DATA_KEY, uiData);
        }
        
        return uiData;
    }
    
    /**
     * Adds a UI captured data record.
     * 
     * @param dataType the type of data
     * @param record the data record
     */
    public static void addUiCapturedDataRecord(String dataType, Map<String, String> record) {
        List<Map<String, String>> data = getUiCapturedData(dataType);
        
        if (data == null) {
            data = new ArrayList<>();
            storeUiCapturedData(dataType, data);
        }
        
        data.add(record);
    }
    
    /**
     * Creates a new UI captured data record and returns it.
     * 
     * @param dataType the type of data
     * @return the new record
     */
    public static Map<String, String> createUiCapturedDataRecord(String dataType) {
        Map<String, String> record = new HashMap<>();
        addUiCapturedDataRecord(dataType, record);
        return record;
    }
    
    /**
     * Generic method to compare expected data with API response.
     * 
     * @param dataType the type of data to validate
     * @param responseArrayPath the path to the array in the response (e.g., "empCalendarList")
     * @return validation result with details
     */
    public static ValidationResult validateApiResponseAgainstUiData(String dataType, String responseArrayPath) {
        ApiResponse response = getLastApiResponse();
        if (response == null) {
            return new ValidationResult(false, "No API response available");
        }
        
        List<Map<String, String>> expectedData = getUiCapturedData(dataType);
        if (expectedData == null || expectedData.isEmpty()) {
            return new ValidationResult(false, "No expected data available for type: " + dataType);
        }
        
        JSONObject jsonResponse = response.getJsonObject();
        if (jsonResponse == null) {
            return new ValidationResult(false, "Invalid JSON response");
        }
        
        // Check for errors in the response
        if (jsonResponse.has("errorMessage") && !jsonResponse.isNull("errorMessage")) {
            String errorMessage = jsonResponse.getString("errorMessage");
            if (errorMessage != null && !errorMessage.isEmpty()) {
                return new ValidationResult(false, "API returned error: " + errorMessage);
            }
        }
        
        if (!jsonResponse.has(responseArrayPath) || jsonResponse.isNull(responseArrayPath)) {
            return new ValidationResult(false, "Response does not contain path: " + responseArrayPath);
        }
        
        JSONArray responseArray = jsonResponse.getJSONArray(responseArrayPath);
        if (responseArray.length() == 0) {
            return new ValidationResult(false, responseArrayPath + " array is empty");
        }
        
        // Track validation issues
        ValidationResult result = new ValidationResult(true, "Validation successful");
        
        // Validate each field in expected data against the response
        for (int i = 0; i < expectedData.size(); i++) {
            Map<String, String> expectedRecord = expectedData.get(i);
            
            // Check if we have corresponding record in the response
            if (i >= responseArray.length()) {
                result.addIssue("Expected record at index " + i + " not found in response");
                continue;
            }
            
            JSONObject actualRecord = responseArray.getJSONObject(i);
            
            // Validate each field
            for (Map.Entry<String, String> entry : expectedRecord.entrySet()) {
                String fieldName = entry.getKey();
                String expectedValue = entry.getValue();
                
                if (!actualRecord.has(fieldName)) {
                    result.addIssue("Field '" + fieldName + "' missing in response record " + i);
                    continue;
                }
                
                Object actualObj = actualRecord.get(fieldName);
                String actualValue = actualObj != null ? actualObj.toString() : "null";
                
                if (actualObj == JSONObject.NULL) {
                    actualValue = "null";
                }
                
                if (!expectedValue.equals(actualValue)) {
                    result.addIssue("Field '" + fieldName + "' mismatch in record " + i + 
                                   " - Expected: " + expectedValue + ", Actual: " + actualValue);
                }
            }
        }
        
        return result;
    }
    
    /**
     * Class to track validation results and issues.
     */
    public static class ValidationResult {
        private boolean success;
        private String message;
        private List<String> issues;
        
        public ValidationResult(boolean success, String message) {
            this.success = success;
            this.message = message;
            this.issues = new ArrayList<>();
        }
        
        public void addIssue(String issue) {
            this.issues.add(issue);
            this.success = false;
        }
        
        public boolean isSuccess() {
            return success;
        }
        
        public String getMessage() {
            return message;
        }
        
        public List<String> getIssues() {
            return issues;
        }
        
        public String getFormattedIssues() {
            if (issues.isEmpty()) {
                return "";
            }
            
            StringBuilder sb = new StringBuilder();
            sb.append("Validation issues:");
            for (String issue : issues) {
                sb.append("\n- ").append(issue);
            }
            return sb.toString();
        }
    }
}

ApiService:
----------------

package com.qaf.framework.service;

import com.qaf.framework.util.ApiClientUtil;
import com.qaf.framework.util.ApiResponse;
import com.qaf.framework.util.TestContextManager;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.json.JSONObject;

import java.util.HashMap;
import java.util.Map;

/**
 * Enhanced generic service implementation for all API operations.
 */
public class GenericApiService {
    
    private static final Log logger = LogFactory.getLog(GenericApiService.class);
    
    /**
     * Sends a request to an API endpoint.
     * 
     * @param endpoint the API endpoint
     * @param method the HTTP method (GET, POST, PUT, DELETE)
     * @param payload the request payload
     * @param headers the request headers (optional)
     * @return ApiResponse containing the response
     */
    public static ApiResponse sendRequest(String endpoint, String method, String payload, Map<String, String> headers) {
        try {
            logger.info("Sending " + method + " request to " + endpoint);
            logger.debug("Payload: " + payload);
            
            if (headers == null) {
                headers = getDefaultHeaders();
            }
            
            ApiResponse response = ApiClientUtil.sendRequest(endpoint, method, payload, headers);
            TestContextManager.setLastApiResponse(response);
            
            logger.info("Received response with status code: " + response.getStatusCode());
            logger.debug("Response body: " + response.getResponseBody());
            
            return response;
        } catch (Exception e) {
            logger.error("Error sending request: " + e.getMessage(), e);
            throw new RuntimeException("Failed to send API request: " + e.getMessage(), e);
        }
    }
    
    /**
     * Sends a request to an API endpoint with a payload file.
     * 
     * @param endpoint the API endpoint
     * @param method the HTTP method (GET, POST, PUT, DELETE)
     * @param payloadFile the payload file name
     * @param headers the request headers (optional)
     * @return ApiResponse containing the response
     */
    public static ApiResponse sendRequestWithPayloadFile(String endpoint, String method, String payloadFile, Map<String, String> headers) {
        try {
            String payload = ApiClientUtil.readPayload(payloadFile);
            
            // Apply test data to payload
            Map<String, Object> testData = TestContextManager.getTestData();
            if (testData != null && !testData.isEmpty()) {
                payload = ApiClientUtil.processTemplate(payload, testData);
            }
            
            return sendRequest(endpoint, method, payload, headers);
        } catch (Exception e) {
            logger.error("Error sending request with payload file: " + e.getMessage(), e);
            throw new RuntimeException("Failed to send API request: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets default headers for API requests.
     * 
     * @return map of default headers
     */
    public static Map<String, String> getDefaultHeaders() {
        Map<String, String> headers = new HashMap<>();
        headers.put("Content-Type", "application/json");
        headers.put("Accept", "application/json");
        return headers;
    }
}
/**
 * Enhanced method to compare expected data with API response.
 * Uses key fields to match records rather than relying on order.
 * 
 * @param dataType the type of data to validate
 * @param responseArrayPath the path to the array in the response
 * @param keyFields array of field names to use for matching records
 * @return validation result with details
 */
public static ValidationResult validateApiResponseAgainstUiData(String dataType, String responseArrayPath, String... keyFields) {
    ApiResponse response = getLastApiResponse();
    if (response == null) {
        return new ValidationResult(false, "No API response available");
    }
    
    List<Map<String, String>> expectedData = getUiCapturedData(dataType);
    if (expectedData == null || expectedData.isEmpty()) {
        return new ValidationResult(false, "No expected data available for type: " + dataType);
    }
    
    JSONObject jsonResponse = response.getJsonObject();
    if (jsonResponse == null) {
        return new ValidationResult(false, "Invalid JSON response");
    }
    
    if (!jsonResponse.has(responseArrayPath) || jsonResponse.isNull(responseArrayPath)) {
        return new ValidationResult(false, "Response does not contain path: " + responseArrayPath);
    }
    
    JSONArray responseArray = jsonResponse.getJSONArray(responseArrayPath);
    if (responseArray.length() == 0) {
        return new ValidationResult(false, responseArrayPath + " array is empty");
    }
    
    // Track validation issues
    ValidationResult result = new ValidationResult(true, "Validation successful");
    
    // Convert response array to a list of maps for easier processing
    List<Map<String, Object>> actualRecords = new ArrayList<>();
    for (int i = 0; i < responseArray.length(); i++) {
        JSONObject obj = responseArray.getJSONObject(i);
        Map<String, Object> map = new HashMap<>();
        for (String key : obj.keySet()) {
            map.put(key, obj.get(key));
        }
        actualRecords.add(map);
    }
    
    // Default to using all fields as key fields if none specified
    if (keyFields == null || keyFields.length == 0) {
        // Use first record to determine fields
        if (!expectedData.isEmpty() && !expectedData.get(0).isEmpty()) {
            keyFields = expectedData.get(0).keySet().toArray(new String[0]);
        }
    }
    
    // For each expected record, find a matching actual record
    for (Map<String, String> expectedRecord : expectedData) {
        boolean foundMatch = false;
        
        // Create a key for this record
        StringBuilder recordKey = new StringBuilder();
        for (String keyField : keyFields) {
            if (expectedRecord.containsKey(keyField)) {
                recordKey.append(keyField).append("=").append(expectedRecord.get(keyField)).append(";");
            }
        }
        String recordKeyStr = recordKey.toString();
        
        // Find matching record in actual data
        for (Map<String, Object> actualRecord : actualRecords) {
            // Create key for actual record
            StringBuilder actualKey = new StringBuilder();
            for (String keyField : keyFields) {
                if (actualRecord.containsKey(keyField)) {
                    actualKey.append(keyField).append("=").append(actualRecord.get(keyField)).append(";");
                }
            }
            String actualKeyStr = actualKey.toString();
            
            // If keys match, compare all fields
            if (recordKeyStr.equals(actualKeyStr)) {
                foundMatch = true;
                
                // Compare all fields
                for (Map.Entry<String, String> entry : expectedRecord.entrySet()) {
                    String fieldName = entry.getKey();
                    String expectedValue = entry.getValue();
                    
                    if (!actualRecord.containsKey(fieldName)) {
                        result.addIssue("Field '" + fieldName + "' missing in matching response record " + recordKeyStr);
                        continue;
                    }
                    
                    Object actualObj = actualRecord.get(fieldName);
                    String actualValue = actualObj != null ? actualObj.toString() : "null";
                    
                    if (!expectedValue.equals(actualValue)) {
                        result.addIssue("Field '" + fieldName + "' mismatch in matching record " + recordKeyStr + 
                                       " - Expected: " + expectedValue + ", Actual: " + actualValue);
                    }
                }
                
                break; // Found matching record, no need to check others
            }
        }
        
        if (!foundMatch) {
            result.addIssue("No matching record found for expected record with key: " + recordKeyStr);
        }
    }
    
    return result;
}
