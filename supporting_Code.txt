// src/support/hooks.ts
import { Before, After, BeforeStep, AfterStep, setDefaultTimeout } from '@cucumber/cucumber';
import { chromium, firefox, webkit, Browser, BrowserType, devices } from '@playwright/test';
import { TestContext } from './test-context';
import { Logger } from '../framework/utils/logger';
import { ConfigManager } from '../framework/utils/config-manager';

// Get configuration
const config = ConfigManager.getInstance();

// Set default timeout from configuration
setDefaultTimeout(config.getDefaultTimeout());

let browser: Browser | null;

// Before each scenario
Before(async function(this: TestContext, scenario) {
  // Create a unique test ID based on scenario name and timestamp
  const testId = `${scenario.pickle.name.replace(/[^a-zA-Z0-9]/g, '-')}-${Date.now()}`;
  
  // Initialize logger with test ID
  this.logger = new Logger(testId);
  this.logger.setScenario(scenario.pickle.name);
  
  // Log environment information
  this.logger.info(`Running tests in ${config.getEnvironment().toUpperCase()} environment`);
  
  // Create test data object for sharing data between steps
  this.testData = {};
  
  // For UI tests, initialize browser
  if (scenario.pickle.tags.some(tag => tag.name === '@web' || tag.name === '@ui')) {
    // Launch browser if not already launched
    if (!browser) {
      this.logger.info('Launching browser');
      
      // Get browser configuration
      const browserConfig = config.getBrowserConfig();
      const browserType = config.getBrowserType().toLowerCase();
      
      // Select browser based on configuration
      let browserInstance: BrowserType;
      switch (browserType) {
        case 'firefox':
          browserInstance = firefox;
          break;
        case 'webkit':
          browserInstance = webkit;
          break;
        case 'chromium':
        default:
          browserInstance = chromium;
          break;
      }
      
      this.logger.info(`Using browser: ${browserType}`);
      
      // Launch browser
      browser = await browserInstance.launch({
        headless: browserConfig.headless,
        slowMo: browserConfig.slowMo,
        args: browserConfig.args
      });
    }
    
    // Context options
    const contextOptions: any = {};
    
    // Set viewport size if device is not specified
    const devicePreset = config.getDevicePreset();
    if (devicePreset && devices[devicePreset]) {
      this.logger.info(`Using device preset: ${devicePreset}`);
      Object.assign(contextOptions, devices[devicePreset]);
    } else {
      const viewportSize = config.getViewportSize();
      contextOptions.viewport = viewportSize;
      this.logger.info(`Using viewport: ${viewportSize.width}x${viewportSize.height}`);
    }
    
    // Record video if enabled
    if (config.shouldRecordVideo()) {
      contextOptions.recordVideo = { dir: 'videos/' };
    }
    
    // Create a new context and page for each scenario
    this.context = await browser.newContext(contextOptions);
    
    // Add ability to set breakpoints if needed
    if (config.isDebugMode()) {
      this.context.setDefaultTimeout(0); // No timeout during debugging
    }
    
    this.page = await this.context.newPage();
    this.logger.info('Browser initialized');
  } 
  // For API tests, initialize API-specific objects
  else if (scenario.pickle.tags.some(tag => tag.name === '@api')) {
    this.logger.info('Initializing API test');
    
    // API clients will be initialized in step definitions when needed
  }
});

// Before each step
BeforeStep(async function(this: TestContext, testStepResult) {
  if (this.logger) {
    this.logger.info(`Executing step: ${testStepResult.pickleStep.text}`);
  }
});

// After each step
AfterStep(async function(this: TestContext, testStepResult) {
  if (this.logger) {
    if (testStepResult.result.status === 'PASSED') {
      this.logger.info(`Step passed: ${testStepResult.pickleStep.text}`);
    } else if (testStepResult.result.status === 'FAILED') {
      this.logger.error(`Step failed: ${testStepResult.pickleStep.text}`);
      
      // In newer versions, the error might be stored differently
      // Let's use a type-safe approach
      const stepResult = testStepResult.result;
      const errorMessage = (stepResult as any).message 
        || (stepResult as any).error?.message 
        || 'Unknown error';
      
      this.logger.error(`Error: ${errorMessage}`);
      
      // For UI tests, take a screenshot on failure
      if (this.page && config.shouldTakeScreenshotOnFailure()) {
        const timestamp = Date.now();
        const scenarioName = this.logger.getScenarioName()?.replace(/[^a-zA-Z0-9]/g, '-') || 'unknown';
        const screenshotPath = `./screenshots/failed-${scenarioName}-${timestamp}.png`;
        this.logger.info(`Taking screenshot: ${screenshotPath}`);
        
        try {
          const screenshot = await this.page.screenshot({ 
            path: screenshotPath,
            fullPage: true 
          });
          this.attach(screenshot, 'image/png');
        } catch (error: unknown) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          this.logger.error(`Failed to take screenshot: ${errorMessage}`);
        }
      }
    }
  }
});

// After each scenario
After(async function(this: TestContext, scenario) {
  // Store result status for use in clean-up
  if (scenario.result) {
    this.result = { status: scenario.result.status };
    
    // Log scenario result
    if (this.logger) {
      this.logger.info(`Scenario ${scenario.result.status}: ${scenario.pickle.name}`);
    }
  } else {
    this.result = { status: 'unknown' };
    if (this.logger) {
      this.logger.info(`Scenario status unknown: ${scenario.pickle.name}`);
    }
  }
  
  // Clean up UI resources
  if (this.page && this.context) {
    // Close context and page
    this.logger.info('Closing browser context');
    await this.context.close();
  }
  
  // Clean up API resources if needed
  if (this.testData.userId && this.userApiClient && this.authToken) {
    try {
      this.logger.info(`Cleaning up test user: ${this.testData.userId}`);
      await this.userApiClient.deleteUser(this.testData.userId, this.authToken);
    } catch (error) {
      // Ignore errors during cleanup
      this.logger.warn(`Cleanup error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  if (this.testData.productId && this.productApiClient && this.authToken) {
    try {
      this.logger.info(`Cleaning up test product: ${this.testData.productId}`);
      await this.productApiClient.deleteProduct(this.testData.productId, this.authToken);
    } catch (error) {
      // Ignore errors during cleanup
      this.logger.warn(`Cleanup error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  // Add logs to Cucumber report
  if (this.logger) {
    const logs = this.logger.getLogs();
    if (logs.length > 0) {
      this.attach(logs.join('\n'), 'text/plain');
    }
  }
});

// After all scenarios
After(async function() {
  if (browser) {
    await browser.close();
    browser = null;
  }
});

/**
 * Debug breakpoint helper function
 * Add this to your code where you want to set a breakpoint
 */
export async function debugBreakpoint(): Promise<void> {
  if (ConfigManager.getInstance().isDebugMode()) {
    // eslint-disable-next-line no-debugger
    debugger;
    // This pauses execution if running with --inspect flag and dev tools are open
  }
}
