// src/support/browser-manager.ts
import { Browser, BrowserContext, Page, chromium, firefox, webkit } from '@playwright/test';
import { ConfigManager } from '../framework/utils/config-manager';

// Module-level singleton
let browserInstance: Browser | null = null;
let browserLaunchCount = 0;

export async function getBrowser(): Promise<Browser> {
  if (!browserInstance) {
    browserLaunchCount++;
    console.log(`[BROWSER] Launching new browser instance (count: ${browserLaunchCount})`);
    
    const config = ConfigManager.getInstance();
    const browserType = config.getBrowserType().toLowerCase();
    const browserConfig = config.getBrowserConfig();
    
    console.log(`[BROWSER] Using browser type: ${browserType} with config:`, browserConfig);
    
    try {
      switch (browserType) {
        case 'firefox':
          browserInstance = await firefox.launch(browserConfig);
          break;
        case 'webkit':
          browserInstance = await webkit.launch(browserConfig);
          break;
        default:
          browserInstance = await chromium.launch(browserConfig);
      }
      console.log('[BROWSER] Browser launched successfully');
    } catch (error) {
      console.error('[BROWSER] Failed to launch browser:', error);
      throw error;
    }
  } else {
    console.log('[BROWSER] Reusing existing browser instance');
  }
  
  return browserInstance;
}

export async function createBrowserContext(browser: Browser, options = {}): Promise<BrowserContext> {
  console.log('[BROWSER] Creating new browser context');
  return await browser.newContext(options);
}

export async function createPage(context: BrowserContext): Promise<Page> {
  console.log('[BROWSER] Creating new page');
  return await context.newPage();
}

export async function closeBrowser(): Promise<void> {
  if (browserInstance) {
    console.log('[BROWSER] Closing browser instance');
    await browserInstance.close();
    browserInstance = null;
    console.log('[BROWSER] Browser instance closed');
  } else {
    console.log('[BROWSER] No browser instance to close');
  }
}

// src/support/hooks.ts
import { Before, After, AfterAll, BeforeStep, AfterStep, setDefaultTimeout } from '@cucumber/cucumber';
import { TestContext } from './test-context';
import { Logger } from '../framework/utils/logger';
import { ConfigManager } from '../framework/utils/config-manager';
import { getBrowser, createBrowserContext, createPage, closeBrowser } from './browser-manager';

// Get configuration
const config = ConfigManager.getInstance();

// Set default timeout from configuration
setDefaultTimeout(config.getDefaultTimeout());

// Before each scenario
Before(async function(this: TestContext, scenario) {
  console.log(`[HOOK] Before scenario: ${scenario.pickle.name}`);
  
  // Create a unique test ID based on scenario name and timestamp
  const testId = `${scenario.pickle.name.replace(/[^a-zA-Z0-9]/g, '-')}-${Date.now()}`;
  
  // Initialize logger with test ID
  this.logger = new Logger(testId);
  this.logger.setScenario(scenario.pickle.name);
  
  // Log environment information
  this.logger.info(`Running tests in ${config.getEnvironment().toUpperCase()} environment`);
  
  // Create test data object for sharing data between steps
  this.testData = {};
  
  // For UI tests, initialize browser
  if (scenario.pickle.tags.some(tag => tag.name === '@web' || tag.name === '@ui')) {
    this.logger.info('Initializing web test');
    
    // Get browser instance (shared across scenarios)
    const browser = await getBrowser();
    
    // Context options
    const contextOptions: any = {};
    
    // Set viewport size if device is not specified
    const devicePreset = config.getDevicePreset();
    if (devicePreset) {
      this.logger.info(`Using device preset: ${devicePreset}`);
      contextOptions.userAgent = devicePreset;
    } else {
      const viewportSize = config.getViewportSize();
      contextOptions.viewport = viewportSize;
      this.logger.info(`Using viewport: ${viewportSize.width}x${viewportSize.height}`);
    }
    
    // Record video if enabled
    if (config.shouldRecordVideo()) {
      contextOptions.recordVideo = { dir: 'videos/' };
    }
    
    // Create a new context and page for each scenario
    this.context = await createBrowserContext(browser, contextOptions);
    
    // Add ability to set breakpoints if needed
    if (config.isDebugMode()) {
      this.context.setDefaultTimeout(0); // No timeout during debugging
    }
    
    this.page = await createPage(this.context);
    this.logger.info('Browser initialized');
  } 
  // For API tests, initialize API-specific objects
  else if (scenario.pickle.tags.some(tag => tag.name === '@api')) {
    this.logger.info('Initializing API test');
  }
});

// After each scenario
After(async function(this: TestContext, scenario) {
  console.log(`[HOOK] After scenario: ${scenario.pickle.name}`);
  
  // Store result status for use in clean-up
  if (scenario.result) {
    this.result = { status: scenario.result.status };
    
    // Log scenario result
    if (this.logger) {
      this.logger.info(`Scenario ${scenario.result.status}: ${scenario.pickle.name}`);
    }
  }
  
  // Clean up UI resources
  if (this.page && this.context) {
    // Close context and page
    this.logger.info('Closing browser context');
    await this.context.close();
  }
  
  // Clean up API resources if needed
  // Rest of your cleanup code
});

// After all scenarios
AfterAll(async function() {
  console.log('[HOOK] AfterAll: Closing browser');
  await closeBrowser();
});

// src/framework/utils/config-manager.ts
import { env, envNumber, envBoolean, getEnvironment } from './env';

// Module-level singleton variable
let configInstance: ConfigManager | null = null;
let instanceCount = 0;

export class ConfigManager {
  private environment: string;
  private instanceNumber: number;

  private constructor() {
    instanceCount++;
    this.instanceNumber = instanceCount;
    this.environment = getEnvironment();
    console.log(`[CONFIG] ConfigManager instance #${this.instanceNumber} initialized for ${this.environment} environment`);
  }

  public static getInstance(): ConfigManager {
    if (!configInstance) {
      configInstance = new ConfigManager();
    }
    return configInstance;
  }
  
  // Rest of your methods
}

