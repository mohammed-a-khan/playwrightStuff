ApiResponse.java
--------------------------------
package com.qaf.framework.util;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

/**
 * Enhanced class representing an API response with improved JSON handling.
 */
public class ApiResponse {
    private final int statusCode;
    private final String responseBody;
    private final Map<String, List<String>> headers;
    private JSONObject jsonObject;
    private JSONArray jsonArray;

    /**
     * Constructor for ApiResponse.
     * 
     * @param statusCode the HTTP status code
     * @param responseBody the response body as a string
     * @param headers response headers
     */
    public ApiResponse(int statusCode, String responseBody, Map<String, List<String>> headers) {
        this.statusCode = statusCode;
        this.responseBody = responseBody;
        this.headers = headers;
        
        // Parse JSON if possible
        if (responseBody != null && !responseBody.isEmpty()) {
            try {
                if (responseBody.trim().startsWith("{")) {
                    this.jsonObject = new JSONObject(responseBody);
                } else if (responseBody.trim().startsWith("[")) {
                    this.jsonArray = new JSONArray(responseBody);
                }
            } catch (JSONException e) {
                // Not valid JSON, keep as null
            }
        }
    }

    /**
     * Gets the HTTP status code.
     * 
     * @return the HTTP status code
     */
    public int getStatusCode() {
        return statusCode;
    }

    /**
     * Gets the response body as a string.
     * 
     * @return the response body
     */
    public String getResponseBody() {
        return responseBody;
    }

    /**
     * Gets the response headers.
     * 
     * @return map of header names to values
     */
    public Map<String, List<String>> getHeaders() {
        return headers;
    }

    /**
     * Checks if the response was successful (status code 2xx).
     * 
     * @return true if the status code is between 200 and 299
     */
    public boolean isSuccessful() {
        return statusCode >= 200 && statusCode < 300;
    }

    /**
     * Gets a header value.
     * 
     * @param headerName the header name
     * @return the first value of the header, or null if not found
     */
    public String getHeader(String headerName) {
        List<String> values = headers.get(headerName);
        return (values != null && !values.isEmpty()) ? values.get(0) : null;
    }

    /**
     * Gets all header values.
     * 
     * @param headerName the header name
     * @return list of values for the header, or empty list if not found
     */
    public List<String> getHeaders(String headerName) {
        List<String> values = headers.get(headerName);
        return values != null ? values : new ArrayList<>();
    }

    /**
     * Gets the response as a JSONObject.
     * 
     * @return JSONObject representing the response, or null if not valid JSON object
     */
    public JSONObject getJsonObject() {
        return jsonObject;
    }

    /**
     * Gets the response as a JSONArray.
     * 
     * @return JSONArray representing the response, or null if not valid JSON array
     */
    public JSONArray getJsonArray() {
        return jsonArray;
    }

    /**
     * Gets a value from the JSON response by key.
     * 
     * @param key the JSON key
     * @return the value as a string, or null if not found
     */
    public String getValueFromJson(String key) {
        if (jsonObject != null && jsonObject.has(key)) {
            Object value = jsonObject.get(key);
            return value == JSONObject.NULL ? null : value.toString();
        }
        return null;
    }

    /**
     * Checks if a field exists in the JSON response.
     * 
     * @param field the field name
     * @return true if the field exists, false otherwise
     */
    public boolean hasJsonField(String field) {
        return jsonObject != null && jsonObject.has(field);
    }

    /**
     * Gets a nested value from the JSON response using dot notation.
     * 
     * @param path the dot-notated path (e.g., "data.user.name")
     * @return the value as a string, or null if not found
     */
    public String getNestedValue(String path) {
        if (jsonObject == null || path == null || path.isEmpty()) {
            return null;
        }
        
        try {
            String[] parts = path.split("\\.");
            Object current = jsonObject;
            
            for (String part : parts) {
                if (current instanceof JSONObject) {
                    JSONObject currentJson = (JSONObject) current;
                    if (!currentJson.has(part)) {
                        return null;
                    }
                    current = currentJson.get(part);
                } else {
                    return null;
                }
            }
            
            return current == JSONObject.NULL ? null : current.toString();
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Checks if the response body contains a specific text.
     * 
     * @param text the text to check for
     * @return true if the response body contains the text
     */
    public boolean responseContains(String text) {
        return responseBody != null && responseBody.contains(text);
    }
    
    /**
     * Gets an item from a JSON array in the response.
     * 
     * @param arrayField the field name of the array
     * @param index the index of the item in the array
     * @return the JSON object at the specified index, or null if not found
     */
    public JSONObject getArrayItem(String arrayField, int index) {
        try {
            if (jsonObject != null && jsonObject.has(arrayField)) {
                JSONArray array = jsonObject.getJSONArray(arrayField);
                if (index >= 0 && index < array.length()) {
                    return array.getJSONObject(index);
                }
            }
        } catch (Exception e) {
            // Not a valid JSON structure or not an object at that index
        }
        return null;
    }
    
    /**
     * Gets all items from a JSON array in the response as a list of maps.
     * 
     * @param arrayField the field name of the array
     * @return list of maps representing the array items, or empty list if not found
     */
    public List<Map<String, Object>> getArrayItems(String arrayField) {
        List<Map<String, Object>> result = new ArrayList<>();
        
        try {
            if (jsonObject != null && jsonObject.has(arrayField)) {
                JSONArray array = jsonObject.getJSONArray(arrayField);
                for (int i = 0; i < array.length(); i++) {
                    if (array.get(i) instanceof JSONObject) {
                        JSONObject item = array.getJSONObject(i);
                        Map<String, Object> itemMap = new HashMap<>();
                        for (String key : item.keySet()) {
                            itemMap.put(key, item.get(key));
                        }
                        result.add(itemMap);
                    }
                }
            }
        } catch (Exception e) {
            // Not a valid JSON structure
        }
        
        return result;
    }
    
    /**
     * Gets the size of an array in the JSON response.
     * 
     * @param arrayField the field name of the array
     * @return the size of the array, or -1 if not found
     */
    public int getArraySize(String arrayField) {
        try {
            if (jsonObject != null && jsonObject.has(arrayField)) {
                JSONArray array = jsonObject.getJSONArray(arrayField);
                return array.length();
            }
        } catch (Exception e) {
            // Not a valid JSON structure
        }
        return -1;
    }
    
    /**
     * Checks if JSON response matches the expected schema.
     * 
     * @param expectedSchema map of field names to expected data types
     * @return true if the schema matches, false otherwise
     */
    public boolean matchesSchema(Map<String, Class<?>> expectedSchema) {
        if (jsonObject == null || expectedSchema == null || expectedSchema.isEmpty()) {
            return false;
        }
        
        for (Map.Entry<String, Class<?>> entry : expectedSchema.entrySet()) {
            String field = entry.getKey();
            Class<?> expectedType = entry.getValue();
            
            if (!jsonObject.has(field)) {
                return false;
            }
            
            Object value = jsonObject.get(field);
            
            if (value == JSONObject.NULL) {
                continue; // Null values are allowed
            }
            
            // Check if the value is of the expected type
            if (expectedType == String.class && !(value instanceof String)) {
                return false;
            } else if (expectedType == Integer.class && !(value instanceof Integer)) {
                return false;
            } else if (expectedType == Long.class && !(value instanceof Long)) {
                return false;
            } else if (expectedType == Double.class && !(value instanceof Double)) {
                return false;
            } else if (expectedType == Boolean.class && !(value instanceof Boolean)) {
                return false;
            } else if (expectedType == JSONObject.class && !(value instanceof JSONObject)) {
                return false;
            } else if (expectedType == JSONArray.class && !(value instanceof JSONArray)) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Extracts data from the response based on a pattern.
     * 
     * @param pattern the regex pattern
     * @param groupIndex the group index to extract
     * @return the extracted data, or null if not found
     */
    public String extractDataWithPattern(String pattern, int groupIndex) {
        if (responseBody == null || responseBody.isEmpty()) {
            return null;
        }
        
        java.util.regex.Matcher matcher = Pattern.compile(pattern).matcher(responseBody);
        if (matcher.find() && groupIndex <= matcher.groupCount()) {
            return matcher.group(groupIndex);
        }
        
        return null;
    }
    
    /**
     * Converts the response to a map.
     * 
     * @return map representation of the response, or empty map if not valid JSON
     */
    public Map<String, Object> toMap() {
        Map<String, Object> result = new HashMap<>();
        
        if (jsonObject != null) {
            for (String key : jsonObject.keySet()) {
                result.put(key, jsonObject.get(key));
            }
        }
        
        return result;
    }
    
    /**
     * Returns a string representation of the response.
     * 
     * @return string representation of the response
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Status Code: ").append(statusCode).append("\n");
        
        if (headers != null && !headers.isEmpty()) {
            sb.append("Headers:\n");
            for (Map.Entry<String, List<String>> entry : headers.entrySet()) {
                if (entry.getKey() != null) { // Skip null key which contains status line
                    sb.append("  ").append(entry.getKey()).append(": ").append(entry.getValue()).append("\n");
                }
            }
        }
        
        sb.append("Body: ").append(responseBody);
        return sb.toString();
    }
}

ApiClientUtil.java
---------------------

package com.qaf.framework.util;

import com.qaf.framework.config.ApiConfig;
import com.qmetry.qaf.automation.core.ConfigurationManager;
import org.apache.commons.io.IOUtils;
import org.json.JSONObject;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.net.ssl.*;
import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Enhanced utility class for making API requests with improved template processing.
 */
public class ApiClientUtil {
    private static final Log logger = LogFactory.getLog(ApiClientUtil.class);
    private static final Pattern VARIABLE_PATTERN = Pattern.compile("\\$\\{([^}]+)\\}");

    /**
     * Sends an HTTP request to the specified endpoint.
     * 
     * @param endpoint the API endpoint (path)
     * @param method HTTP method (GET, POST, PUT, DELETE, PATCH)
     * @param payload request payload (for POST, PUT, PATCH)
     * @param headers request headers
     * @return ApiResponse containing the response
     * @throws Exception if there's an error making the request
     */
    public static ApiResponse sendRequest(String endpoint, String method, String payload, Map<String, String> headers) throws Exception {
        // Determine if endpoint is a full URL or just a path
        String fullUrl;
        if (endpoint.startsWith("http")) {
            fullUrl = endpoint;
        } else {
            // If it's just a path, prefix with the base URL
            String baseUrl = ApiConfig.getBaseUrl();
            
            // Ensure endpoint starts with / if base URL doesn't end with /
            if (!baseUrl.endsWith("/") && !endpoint.startsWith("/")) {
                endpoint = "/" + endpoint;
            }
            
            fullUrl = baseUrl + endpoint;
        }
        
        logger.info("Sending " + method + " request to: " + fullUrl);
        if (payload != null && !payload.isEmpty()) {
            logger.debug("Request payload: " + payload);
        }
        
        // Create connection
        URL url = new URL(fullUrl);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();

        // Configure SSL for HTTPS connections
        if (conn instanceof HttpsURLConnection httpsConn) {
            logger.info("Configuring HTTPS connection");
            
            // Check if certificates are required
            boolean useCustomCert = ConfigurationManager.getBundle().getBoolean("ssl.custom.cert", false);
            if (useCustomCert) {
                httpsConn.setSSLSocketFactory(getSSLSocketFactory());
            } else {
                // Trust all certificates for testing environments
                TrustManager[] trustAllCerts = new TrustManager[] { 
                    new X509TrustManager() {
                        public X509Certificate[] getAcceptedIssuers() { return null; }
                        public void checkClientTrusted(X509Certificate[] certs, String authType) { }
                        public void checkServerTrusted(X509Certificate[] certs, String authType) { }
                    }
                };
                
                SSLContext sc = SSLContext.getInstance("TLS");
                sc.init(null, trustAllCerts, new SecureRandom());
                httpsConn.setSSLSocketFactory(sc.getSocketFactory());
                httpsConn.setHostnameVerifier((hostname, session) -> true);
            }
        }

        // Configure proxy if enabled
        boolean useProxy = ConfigurationManager.getBundle().getBoolean("proxy.enabled", false);
        if (useProxy) {
            String proxyHost = ConfigurationManager.getBundle().getString("proxy.host");
            String proxyPort = ConfigurationManager.getBundle().getString("proxy.port");
            logger.info("Using proxy: " + proxyHost + ":" + proxyPort);
            System.setProperty("https.proxyHost", proxyHost);
            System.setProperty("https.proxyPort", proxyPort);
        }

        // Configure request
        conn.setRequestMethod(method.toUpperCase());
        conn.setDoInput(true);
        
        // Set default headers if none provided
        if (headers == null) {
            headers = new HashMap<>();
        }
        
        // Add default content type if not specified
        if (!headers.containsKey("Content-Type")) {
            headers.put("Content-Type", "application/json");
        }
        
        // Add default accept if not specified  
        if (!headers.containsKey("Accept")) {
            headers.put("Accept", "application/json");
        }
        
        // Set headers
        for (Map.Entry<String, String> header : headers.entrySet()) {
            conn.setRequestProperty(header.getKey(), header.getValue());
        }

        // Set timeout properties
        int timeout = ConfigurationManager.getBundle().getInt("connection.timeout", 30000);
        conn.setConnectTimeout(timeout);
        conn.setReadTimeout(timeout);

        // Send payload for POST, PUT, PATCH requests
        if (payload != null && !payload.isEmpty() && 
            (method.equalsIgnoreCase("POST") || method.equalsIgnoreCase("PUT") || method.equalsIgnoreCase("PATCH"))) {
            conn.setDoOutput(true);
            try (OutputStream os = conn.getOutputStream()) {
                os.write(payload.getBytes(StandardCharsets.UTF_8));
                os.flush();
            }
        }

        // Get response
        int statusCode = conn.getResponseCode();
        logger.info("Response status code: " + statusCode);

        // Read response body
        String responseBody;
        try (InputStream is = (statusCode >= 200 && statusCode < 300) ? 
             conn.getInputStream() : conn.getErrorStream()) {
            if (is != null) {
                responseBody = IOUtils.toString(is, StandardCharsets.UTF_8);
            } else {
                responseBody = "";
            }
        }
        
        if (!responseBody.isEmpty()) {
            logger.debug("Response body: " + responseBody);
        }
        
        // Create and return the API response
        return new ApiResponse(statusCode, responseBody, conn.getHeaderFields());
    }

    /**
     * Creates an SSLSocketFactory with the certificate from properties.
     * 
     * @return SSLSocketFactory configured with the certificate
     * @throws Exception if there's an error setting up the SSL context
     */
    private static SSLSocketFactory getSSLSocketFactory() throws Exception {
        String certPath = ConfigurationManager.getBundle().getString("certificate.path");
        String certPassword = ConfigurationManager.getBundle().getString("certificate.password");

        logger.info("Setting up SSL with certificate: " + certPath);
        
        // Check if certificate file exists
        File certFile = new File(certPath);
        if (!certFile.exists()) {
            logger.error("Certificate file not found: " + certPath);
            throw new FileNotFoundException("Certificate file not found: " + certPath);
        }

        // Load the keystore
        KeyStore keyStore = KeyStore.getInstance("PKCS12");
        try (InputStream keyInput = new FileInputStream(certPath)) {
            keyStore.load(keyInput, certPassword.toCharArray());
        }

        // Set up key manager
        KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
        kmf.init(keyStore, certPassword.toCharArray());

        // Set up SSL context
        SSLContext sslContext = SSLContext.getInstance("TLSv1.2");
        sslContext.init(kmf.getKeyManagers(), null, new SecureRandom());
        return sslContext.getSocketFactory();
    }

    /**
     * Loads a payload file from the configured payload directory.
     * 
     * @param fileName name of the payload file
     * @return the content of the payload file as a string
     * @throws IOException if there's an error reading the file
     */
    public static String readPayload(String fileName) throws IOException {
        // If no extension is provided, assume .json
        if (!fileName.contains(".")) {
            fileName = fileName + ".json";
        }
        
        // Determine payload directory
        String payloadDir = ConfigurationManager.getBundle().getString("payload.dir", "resources/payloads");
        String path = payloadDir + "/" + fileName;
        
        File payloadFile = new File(path);
        if (!payloadFile.exists()) {
            logger.error("Payload file not found: " + path);
            throw new FileNotFoundException("Payload file not found: " + path);
        }
        
        logger.info("Reading payload from: " + path);
        try (InputStream is = new FileInputStream(path)) {
            return IOUtils.toString(is, StandardCharsets.UTF_8);
        }
    }
    
    /**
     * Processes a template by substituting variables with values from a data map.
     * This enhanced version handles different data types appropriately.
     * 
     * @param template the template string with placeholders like ${variable}
     * @param data the map containing values to substitute
     * @return the processed template with all placeholders replaced
     */
    public static String processTemplate(String template, Map<String, Object> data) {
        if (template == null || data == null || data.isEmpty()) {
            return template;
        }
        
        StringBuilder result = new StringBuilder(template);
        Matcher matcher = VARIABLE_PATTERN.matcher(template);
        
        // Track offsets as we modify the string
        int offset = 0;
        
        while (matcher.find()) {
            String placeholder = matcher.group(0);
            String key = matcher.group(1);
            
            if (data.containsKey(key)) {
                Object value = data.get(key);
                String replacement;
                
                // Handle different types appropriately
                if (value == null) {
                    replacement = "null";  // JSON null
                } else if (value instanceof Number || value instanceof Boolean) {
                    replacement = value.toString();  // Unquoted for numbers and booleans
                } else {
                    // For strings and other types, preserve as string
                    replacement = value.toString();
                    
                    // Check if we need to add quotes based on context
                    int placeholderStart = matcher.start() + offset;
                    int placeholderEnd = matcher.end() + offset;
                    
                    // If not already in quotes, add them for string values
                    boolean needsQuotes = true;
                    
                    // Check if already in quotes
                    if (placeholderStart > 0 && placeholderEnd < result.length()) {
                        char before = result.charAt(placeholderStart - 1);
                        char after = result.charAt(placeholderEnd);
                        if (before == '"' && after == '"') {
                            needsQuotes = false;
                        }
                    }
                    
                    if (needsQuotes) {
                        replacement = "\"" + replacement + "\"";
                    }
                }
                
                // Replace the placeholder
                int start = matcher.start() + offset;
                int end = matcher.end() + offset;
                result.replace(start, end, replacement);
                
                // Update offset for next replacement
                offset += replacement.length() - placeholder.length();
            }
        }
        
        return result.toString();
    }
    
    /**
     * Generates a unique message ID for API requests.
     * 
     * @return a unique message ID string
     */
    public static String generateMessageId() {
        return "Test-" + UUID.randomUUID().toString();
    }
    
    /**
     * Creates a basic API payload with common fields.
     * 
     * @param additionalFields additional fields to include in the payload
     * @return JSON string payload
     */
    public static String createBasicPayload(Map<String, Object> additionalFields) {
        JSONObject payload = new JSONObject();
        payload.put("messageId", generateMessageId());
        
        if (additionalFields != null) {
            for (Map.Entry<String, Object> entry : additionalFields.entrySet()) {
                payload.put(entry.getKey(), entry.getValue());
            }
        }
        
        return payload.toString();
    }
}

ApiConfig.java
-----------------
package com.qaf.framework.config;

import com.qmetry.qaf.automation.core.ConfigurationManager;
import com.qmetry.qaf.automation.util.PropertyUtil;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.Enumeration;

/**
 * Configuration class for API endpoints.
 * Centralizes all API endpoint configurations.
 */
public class ApiConfig {
    
    private static final Log logger = LogFactory.getLog(ApiConfig.class);
    private static final PropertyUtil props = ConfigurationManager.getBundle();
    private static final Map<String, String> ENDPOINTS = new HashMap<>();
    
    // Initialize endpoints when the class is loaded
    static {
        loadAllEndpoints();
    }
    
    /**
     * Loads all endpoints - both default endpoints and those from properties.
     */
    private static void loadAllEndpoints() {
        // Load default endpoints from properties first (if defined)
        loadEndpointsFromProperties();
        
        // Define fallback endpoints only if they aren't already defined in properties
        setDefaultEndpointIfNotExists("Employee Calendar", "/api/v1/emp/empcalendar");
        setDefaultEndpointIfNotExists("Deal Static Info", "/api/v1/abo/dealstaticinfo");
        setDefaultEndpointIfNotExists("Asset Layout", "/api/v1/spc/assetlayout");
    }
    
    /**
     * Sets a default endpoint only if it doesn't already exist.
     * 
     * @param apiName the API name
     * @param endpoint the default endpoint
     */
    private static void setDefaultEndpointIfNotExists(String apiName, String endpoint) {
        if (!ENDPOINTS.containsKey(apiName)) {
            ENDPOINTS.put(apiName, endpoint);
            logger.info("Set default endpoint: " + apiName + " = " + endpoint);
        }
    }
    
    /**
     * Loads API endpoints from properties file.
     */
    private static void loadEndpointsFromProperties() {
        String prefix = "api.endpoint.";
        
        // Get properties as a Java Properties object
        Properties properties = props.getProperties();
        
        // Iterate through all properties
        Enumeration<?> propertyNames = properties.propertyNames();
        while (propertyNames.hasMoreElements()) {
            String key = (String) propertyNames.nextElement();
            
            if (key.startsWith(prefix)) {
                String name = key.substring(prefix.length());
                String endpoint = props.getString(key);
                ENDPOINTS.put(name, endpoint);
                logger.info("Loaded API endpoint from properties: " + name + " = " + endpoint);
            }
        }
    }
    
    /**
     * Gets the endpoint URL for the specified API name.
     * 
     * @param apiName the API name
     * @return the endpoint URL, or null if not found
     */
    public static String getEndpoint(String apiName) {
        return ENDPOINTS.get(apiName);
    }
    
    /**
     * Adds or updates an endpoint.
     * 
     * @param apiName the API name
     * @param endpoint the endpoint URL
     */
    public static void setEndpoint(String apiName, String endpoint) {
        ENDPOINTS.put(apiName, endpoint);
        logger.info("Added/updated API endpoint: " + apiName + " = " + endpoint);
    }
    
    /**
     * Gets the base URL for API requests.
     * 
     * @return the base URL
     */
    public static String getBaseUrl() {
        return props.getString("base.url", "https://api.example.com");
    }
    
    /**
     * Gets all configured endpoints.
     * 
     * @return map of API names to endpoints
     */
    public static Map<String, String> getAllEndpoints() {
        return new HashMap<>(ENDPOINTS);
    }
}

GenericApiSteps:
-----------------
package com.qaf.framework.stepdefs;

import com.qaf.framework.config.ApiConfig;
import com.qaf.framework.service.GenericApiService;
import com.qaf.framework.util.ApiResponse;
import com.qaf.framework.util.TestContextManager;
import com.qaf.framework.util.ApiClientUtil;
import com.qmetry.qaf.automation.step.QAFTestStep;
import com.qmetry.qaf.automation.util.Reporter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.testng.Assert;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Generic step definitions for API testing.
 */
public class GenericApiSteps {
    
    private static final Log logger = LogFactory.getLog(GenericApiSteps.class);
    
    /**
     * Sets up testing for a specific API.
     * 
     * @param apiName the API name as defined in ApiConfig
     */
    @QAFTestStep(description = "I am testing the {apiName} API")
    public void setupApiTest(String apiName) {
        String endpoint = ApiConfig.getEndpoint(apiName);
        if (endpoint == null) {
            throw new IllegalArgumentException("Unknown API name: " + apiName);
        }
        
        TestContextManager.setCurrentApi(apiName, endpoint);
        Reporter.log("Set up for testing the " + apiName + " API at endpoint: " + endpoint);
    }
    
    /**
     * Sets a value in the test data map.
     * 
     * @param key the key
     * @param value the value
     */
    @QAFTestStep(description = "I set test data {key} to {value}")
    public void setTestDataValue(String key, String value) {
        Object processedValue = value;
        
        // Try to convert to number if possible
        try {
            if (value.contains(".")) {
                processedValue = Double.parseDouble(value);
            } else {
                processedValue = Integer.parseInt(value);
            }
        } catch (NumberFormatException e) {
            // Keep as string if not a valid number
        }
        
        TestContextManager.setTestData(key, processedValue);
        Reporter.log("Set test data: " + key + " = " + processedValue);
    }
    
    /**
     * Sets multiple values in the test data map.
     * 
     * @param data map of key-value pairs
     */
    @QAFTestStep(description = "I set test data {data}")
    public void setTestDataValues(Map<String, String> data) {
        for (Map.Entry<String, String> entry : data.entrySet()) {
            setTestDataValue(entry.getKey(), entry.getValue());
        }
    }
    
    /**
     * Clears all test data.
     */
    @QAFTestStep(description = "I clear all test data")
    public void clearAllTestData() {
        TestContextManager.clearTestData();
        Reporter.log("Cleared all test data");
    }
    
    /**
     * Sends a request to the current API with a payload file.
     * 
     * @param method the HTTP method (GET, POST, PUT, DELETE, PATCH)
     * @param payloadFile the payload file name
     */
    @QAFTestStep(description = "I send a {method} request with payload file {payloadFile}")
    public void sendRequestWithPayloadFile(String method, String payloadFile) {
        String endpoint = TestContextManager.getCurrentApiEndpoint();
        if (endpoint == null) {
            throw new IllegalStateException("No API has been set up. Use 'I am testing the {apiName} API' first.");
        }
        
        try {
            ApiResponse response = GenericApiService.sendRequestWithPayloadFile(
                endpoint, method, payloadFile, null);
            
            Reporter.log(method.toUpperCase() + " request sent successfully to " + endpoint);
            Reporter.log("Response status: " + response.getStatusCode());
            Reporter.log("Response body: " + response.getResponseBody());
            
        } catch (Exception e) {
            logger.error("Error sending request: " + e.getMessage(), e);
            Reporter.log("Error sending request: " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Sends a request to a named API with a payload file.
     * 
     * @param method the HTTP method (GET, POST, PUT, DELETE, PATCH)
     * @param apiName the API name as defined in ApiConfig
     * @param payloadFile the payload file name
     */
    @QAFTestStep(description = "I send a {method} request to {apiName} API with payload file {payloadFile}")
    public void sendRequestToNamedApiWithPayloadFile(String method, String apiName, String payloadFile) {
        String endpoint = ApiConfig.getEndpoint(apiName);
        if (endpoint == null) {
            throw new IllegalArgumentException("Unknown API name: " + apiName);
        }
        
        TestContextManager.setCurrentApi(apiName, endpoint);
        
        try {
            ApiResponse response = GenericApiService.sendRequestWithPayloadFile(
                endpoint, method, payloadFile, null);
            
            Reporter.log(method.toUpperCase() + " request sent successfully to " + apiName + " API");
            Reporter.log("Response status: " + response.getStatusCode());
            Reporter.log("Response body: " + response.getResponseBody());
            
        } catch (Exception e) {
            logger.error("Error sending request: " + e.getMessage(), e);
            Reporter.log("Error sending request: " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Sends a request with raw payload.
     * 
     * @param method the HTTP method (GET, POST, PUT, DELETE, PATCH)
     * @param payload the raw payload
     */
    @QAFTestStep(description = "I send a {method} request with payload: {payload}")
    public void sendRequestWithRawPayload(String method, String payload) {
        String endpoint = TestContextManager.getCurrentApiEndpoint();
        if (endpoint == null) {
            throw new IllegalStateException("No API has been set up. Use 'I am testing the {apiName} API' first.");
        }
        
        try {
            ApiResponse response = GenericApiService.sendRequest(endpoint, method, payload, null);
            
            Reporter.log(method.toUpperCase() + " request sent successfully to " + endpoint);
            Reporter.log("Response status: " + response.getStatusCode());
            Reporter.log("Response body: " + response.getResponseBody());
            
        } catch (Exception e) {
            logger.error("Error sending request: " + e.getMessage(), e);
            Reporter.log("Error sending request: " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Verifies the response status code.
     * 
     * @param expectedStatus the expected status code
     */
    @QAFTestStep(description = "the response status code should be {expectedStatus}")
    public void verifyStatusCode(int expectedStatus) {
        ApiResponse response = TestContextManager.getLastApiResponse();
        if (response == null) {
            Assert.fail("No API response available. Make sure to send a request first.");
            return;
        }
        
        int actualStatus = response.getStatusCode();
        Reporter.log("Verifying status code: expected=" + expectedStatus + ", actual=" + actualStatus);
        Assert.assertEquals(actualStatus, expectedStatus, "Response status code mismatch");
    }
    
    /**
     * Verifies the response is successful (2xx status code).
     */
    @QAFTestStep(description = "the response should be successful")
    public void verifyResponseSuccessful() {
        ApiResponse response = TestContextManager.getLastApiResponse();
        if (response == null) {
            Assert.fail("No API response available. Make sure to send a request first.");
            return;
        }
        
        boolean successful = response.isSuccessful();
        Reporter.log("Verifying response is successful: " + successful);
        Assert.assertTrue(successful, "Response is not successful. Status code: " + response.getStatusCode());
    }
    
    /**
     * Verifies the response contains a field.
     * 
     * @param field the field name to check
     */
    @QAFTestStep(description = "the response should contain field {field}")
    public void verifyResponseContainsField(String field) {
        ApiResponse response = TestContextManager.getLastApiResponse();
        if (response == null) {
            Assert.fail("No API response available. Make sure to send a request first.");
            return;
        }
        
        boolean hasField = response.hasJsonField(field);
        Reporter.log("Verifying response contains field '" + field + "': " + hasField);
        Assert.assertTrue(hasField, "Response does not contain field: " + field);
    }
    
    /**
     * Verifies a response field has a specific value.
     * 
     * @param field the field name
     * @param expectedValue the expected value
     */
    @QAFTestStep(description = "the response field {field} should be {expectedValue}")
    public void verifyResponseFieldValue(String field, String expectedValue) {
        ApiResponse response = TestContextManager.getLastApiResponse();
        if (response == null) {
            Assert.fail("No API response available. Make sure to send a request first.");
            return;
        }
        
        String actualValue = response.getValueFromJson(field);
        Reporter.log("Verifying field '" + field + "': expected=" + expectedValue + ", actual=" + actualValue);
        Assert.assertEquals(actualValue, expectedValue, "Field value mismatch for: " + field);
    }
    
    /**
     * Verifies a response field contains a substring.
     * 
     * @param field the field name
     * @param expectedText the expected substring
     */
    @QAFTestStep(description = "the response field {field} should contain {expectedText}")
    public void verifyResponseFieldContains(String field, String expectedText) {
        ApiResponse response = TestContextManager.getLastApiResponse();
        if (response == null) {
            Assert.fail("No API response available. Make sure to send a request first.");
            return;
        }
        
        String actualValue = response.getValueFromJson(field);
        Reporter.log("Verifying field '" + field + "' contains: " + expectedText);
        Assert.assertTrue(actualValue != null && actualValue.contains(expectedText), 
                          "Field '" + field + "' does not contain: " + expectedText);
    }
    
    /**
     * Verifies a validation error message.
     * 
     * @param field the field with validation error
     * @param expectedMessage the expected validation message
     */
    @QAFTestStep(description = "the validation error message for {field} should be {expectedMessage}")
    public void verifyValidationErrorMessage(String field, String expectedMessage) {
        ApiResponse response = TestContextManager.getLastApiResponse();
        if (response == null) {
            Assert.fail("No API response available. Make sure to send a request first.");
            return;
        }
        
        String path = "validationErrorMessage." + field;
        String actualMessage = response.getNestedValue(path);
        
        Reporter.log("Verifying validation error for field '" + field + "': expected=" + expectedMessage + ", actual=" + actualMessage);
        Assert.assertEquals(actualMessage, expectedMessage, "Validation error message mismatch for field: " + field);
    }
    
    /**
     * Validates API response against UI captured data.
     * 
     * @param dataType the data type (e.g., "employeeCalendar", "dealStaticInfo")
     * @param responsePath the path to the array in the response (e.g., "empCalendarList", "dealStaticInfo")
     */
    @QAFTestStep(description = "I validate {dataType} API response against UI data using path {responsePath}")
    public void validateApiResponseAgainstUiData(String dataType, String responsePath) {
        TestContextManager.ValidationResult result = TestContextManager.validateApiResponseAgainstUiData(dataType, responsePath);
        
        if (result.isSuccess()) {
            Reporter.log("API response validation successful for " + dataType);
        } else {
            Reporter.log("API response validation failed: " + result.getMessage());
            Reporter.log(result.getFormattedIssues());
            Assert.fail("API response validation failed: " + result.getMessage() + "\n" + result.getFormattedIssues());
        }
    }
}

TestContextManager:
------------------

package com.qaf.framework.util;

import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;

import com.qmetry.qaf.automation.core.TestBaseProvider;
import org.json.JSONArray;
import org.json.JSONObject;

/**
 * Enhanced test context manager that supports any API response structure.
 */
public class TestContextManager {
    
    private static final String TEST_DATA_KEY = "api.test.data";
    private static final String EXPECTED_DATA_KEY = "api.expected.data";
    private static final String LAST_API_RESPONSE_KEY = "api.last.response";
    private static final String CURRENT_API_KEY = "api.current";
    private static final String UI_CAPTURED_DATA_KEY = "ui.captured.data";
    
    /**
     * Gets the shared test data map.
     * 
     * @return map of test data
     */
    public static Map<String, Object> getTestData() {
        Map<String, Object> testData = (Map<String, Object>) TestBaseProvider.instance().get()
                .getContext().getProperty(TEST_DATA_KEY);
        
        if (testData == null) {
            testData = new HashMap<>();
            TestBaseProvider.instance().get().getContext().setProperty(TEST_DATA_KEY, testData);
        }
        
        return testData;
    }
    
    /**
     * Sets a test data value.
     * 
     * @param key the key
     * @param value the value
     */
    public static void setTestData(String key, Object value) {
        getTestData().put(key, value);
    }
    
    /**
     * Gets a test data value.
     * 
     * @param key the key
     * @return the value, or null if not found
     */
    public static Object getTestDataValue(String key) {
        return getTestData().get(key);
    }
    
    /**
     * Clears all test data.
     */
    public static void clearTestData() {
        getTestData().clear();
    }
    
    /**
     * Sets the current API being tested.
     * 
     * @param apiName the API name
     * @param endpoint the API endpoint
     */
    public static void setCurrentApi(String apiName, String endpoint) {
        Map<String, String> apiInfo = new HashMap<>();
        apiInfo.put("name", apiName);
        apiInfo.put("endpoint", endpoint);
        TestBaseProvider.instance().get().getContext().setProperty(CURRENT_API_KEY, apiInfo);
    }
    
    /**
     * Gets the current API endpoint.
     * 
     * @return the current API endpoint, or null if not set
     */
    public static String getCurrentApiEndpoint() {
        Map<String, String> apiInfo = (Map<String, String>) TestBaseProvider.instance().get()
                .getContext().getProperty(CURRENT_API_KEY);
        return apiInfo != null ? apiInfo.get("endpoint") : null;
    }
    
    /**
     * Gets the current API name.
     * 
     * @return the current API name, or null if not set
     */
    public static String getCurrentApiName() {
        Map<String, String> apiInfo = (Map<String, String>) TestBaseProvider.instance().get()
                .getContext().getProperty(CURRENT_API_KEY);
        return apiInfo != null ? apiInfo.get("name") : null;
    }
    
    /**
     * Sets the last API response.
     * 
     * @param response the API response
     */
    public static void setLastApiResponse(ApiResponse response) {
        TestBaseProvider.instance().get().getContext().setProperty(LAST_API_RESPONSE_KEY, response);
    }
    
    /**
     * Gets the last API response.
     * 
     * @return the last API response, or null if not set
     */
    public static ApiResponse getLastApiResponse() {
        return (ApiResponse) TestBaseProvider.instance().get().getContext().getProperty(LAST_API_RESPONSE_KEY);
    }
    
    /**
     * Stores UI captured data for validation.
     * 
     * @param dataType the type of data (e.g., "empCalendar", "dealStaticInfo")
     * @param data list of data records (each record is a map)
     */
    public static void storeUiCapturedData(String dataType, List<Map<String, String>> data) {
        Map<String, List<Map<String, String>>> uiData = getUiCapturedDataMap();
        uiData.put(dataType, data);
    }
    
    /**
     * Gets UI captured data by type.
     * 
     * @param dataType the type of data
     * @return list of data records, or null if not found
     */
    public static List<Map<String, String>> getUiCapturedData(String dataType) {
        Map<String, List<Map<String, String>>> uiData = getUiCapturedDataMap();
        return uiData.get(dataType);
    }
    
    /**
     * Gets the UI captured data map.
     * 
     * @return map of UI captured data
     */
    @SuppressWarnings("unchecked")
    private static Map<String, List<Map<String, String>>> getUiCapturedDataMap() {
        Map<String, List<Map<String, String>>> uiData = 
            (Map<String, List<Map<String, String>>>) TestBaseProvider.instance().get()
                .getContext().getProperty(UI_CAPTURED_DATA_KEY);
        
        if (uiData == null) {
            uiData = new HashMap<>();
            TestBaseProvider.instance().get().getContext().setProperty(UI_CAPTURED_DATA_KEY, uiData);
        }
        
        return uiData;
    }
    
    /**
     * Adds a UI captured data record.
     * 
     * @param dataType the type of data
     * @param record the data record
     */
    public static void addUiCapturedDataRecord(String dataType, Map<String, String> record) {
        List<Map<String, String>> data = getUiCapturedData(dataType);
        
        if (data == null) {
            data = new ArrayList<>();
            storeUiCapturedData(dataType, data);
        }
        
        data.add(record);
    }
    
    /**
     * Creates a new UI captured data record and returns it.
     * 
     * @param dataType the type of data
     * @return the new record
     */
    public static Map<String, String> createUiCapturedDataRecord(String dataType) {
        Map<String, String> record = new HashMap<>();
        addUiCapturedDataRecord(dataType, record);
        return record;
    }
    
    /**
     * Generic method to compare expected data with API response.
     * 
     * @param dataType the type of data to validate
     * @param responseArrayPath the path to the array in the response (e.g., "empCalendarList")
     * @return validation result with details
     */
    public static ValidationResult validateApiResponseAgainstUiData(String dataType, String responseArrayPath) {
        ApiResponse response = getLastApiResponse();
        if (response == null) {
            return new ValidationResult(false, "No API response available");
        }
        
        List<Map<String, String>> expectedData = getUiCapturedData(dataType);
        if (expectedData == null || expectedData.isEmpty()) {
            return new ValidationResult(false, "No expected data available for type: " + dataType);
        }
        
        JSONObject jsonResponse = response.getJsonObject();
        if (jsonResponse == null) {
            return new ValidationResult(false, "Invalid JSON response");
        }
        
        // Check for errors in the response
        if (jsonResponse.has("errorMessage") && !jsonResponse.isNull("errorMessage")) {
            String errorMessage = jsonResponse.getString("errorMessage");
            if (errorMessage != null && !errorMessage.isEmpty()) {
                return new ValidationResult(false, "API returned error: " + errorMessage);
            }
        }
        
        if (!jsonResponse.has(responseArrayPath) || jsonResponse.isNull(responseArrayPath)) {
            return new ValidationResult(false, "Response does not contain path: " + responseArrayPath);
        }
        
        JSONArray responseArray = jsonResponse.getJSONArray(responseArrayPath);
        if (responseArray.length() == 0) {
            return new ValidationResult(false, responseArrayPath + " array is empty");
        }
        
        // Track validation issues
        ValidationResult result = new ValidationResult(true, "Validation successful");
        
        // Validate each field in expected data against the response
        for (int i = 0; i < expectedData.size(); i++) {
            Map<String, String> expectedRecord = expectedData.get(i);
            
            // Check if we have corresponding record in the response
            if (i >= responseArray.length()) {
                result.addIssue("Expected record at index " + i + " not found in response");
                continue;
            }
            
            JSONObject actualRecord = responseArray.getJSONObject(i);
            
            // Validate each field
            for (Map.Entry<String, String> entry : expectedRecord.entrySet()) {
                String fieldName = entry.getKey();
                String expectedValue = entry.getValue();
                
                if (!actualRecord.has(fieldName)) {
                    result.addIssue("Field '" + fieldName + "' missing in response record " + i);
                    continue;
                }
                
                Object actualObj = actualRecord.get(fieldName);
                String actualValue = actualObj != null ? actualObj.toString() : "null";
                
                if (actualObj == JSONObject.NULL) {
                    actualValue = "null";
                }
                
                if (!expectedValue.equals(actualValue)) {
                    result.addIssue("Field '" + fieldName + "' mismatch in record " + i + 
                                   " - Expected: " + expectedValue + ", Actual: " + actualValue);
                }
            }
        }
        
        return result;
    }
    
    /**
     * Class to track validation results and issues.
     */
    public static class ValidationResult {
        private boolean success;
        private String message;
        private List<String> issues;
        
        public ValidationResult(boolean success, String message) {
            this.success = success;
            this.message = message;
            this.issues = new ArrayList<>();
        }
        
        public void addIssue(String issue) {
            this.issues.add(issue);
            this.success = false;
        }
        
        public boolean isSuccess() {
            return success;
        }
        
        public String getMessage() {
            return message;
        }
        
        public List<String> getIssues() {
            return issues;
        }
        
        public String getFormattedIssues() {
            if (issues.isEmpty()) {
                return "";
            }
            
            StringBuilder sb = new StringBuilder();
            sb.append("Validation issues:");
            for (String issue : issues) {
                sb.append("\n- ").append(issue);
            }
            return sb.toString();
        }
    }
}

ApiService:
----------------

package com.qaf.framework.service;

import com.qaf.framework.util.ApiClientUtil;
import com.qaf.framework.util.ApiResponse;
import com.qaf.framework.util.TestContextManager;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.json.JSONObject;

import java.util.HashMap;
import java.util.Map;

/**
 * Enhanced generic service implementation for all API operations.
 */
public class GenericApiService {
    
    private static final Log logger = LogFactory.getLog(GenericApiService.class);
    
    /**
     * Sends a request to an API endpoint.
     * 
     * @param endpoint the API endpoint
     * @param method the HTTP method (GET, POST, PUT, DELETE)
     * @param payload the request payload
     * @param headers the request headers (optional)
     * @return ApiResponse containing the response
     */
    public static ApiResponse sendRequest(String endpoint, String method, String payload, Map<String, String> headers) {
        try {
            logger.info("Sending " + method + " request to " + endpoint);
            logger.debug("Payload: " + payload);
            
            if (headers == null) {
                headers = getDefaultHeaders();
            }
            
            ApiResponse response = ApiClientUtil.sendRequest(endpoint, method, payload, headers);
            TestContextManager.setLastApiResponse(response);
            
            logger.info("Received response with status code: " + response.getStatusCode());
            logger.debug("Response body: " + response.getResponseBody());
            
            return response;
        } catch (Exception e) {
            logger.error("Error sending request: " + e.getMessage(), e);
            throw new RuntimeException("Failed to send API request: " + e.getMessage(), e);
        }
    }
    
    /**
     * Sends a request to an API endpoint with a payload file.
     * 
     * @param endpoint the API endpoint
     * @param method the HTTP method (GET, POST, PUT, DELETE)
     * @param payloadFile the payload file name
     * @param headers the request headers (optional)
     * @return ApiResponse containing the response
     */
    public static ApiResponse sendRequestWithPayloadFile(String endpoint, String method, String payloadFile, Map<String, String> headers) {
        try {
            String payload = ApiClientUtil.readPayload(payloadFile);
            
            // Apply test data to payload
            Map<String, Object> testData = TestContextManager.getTestData();
            if (testData != null && !testData.isEmpty()) {
                payload = ApiClientUtil.processTemplate(payload, testData);
            }
            
            return sendRequest(endpoint, method, payload, headers);
        } catch (Exception e) {
            logger.error("Error sending request with payload file: " + e.getMessage(), e);
            throw new RuntimeException("Failed to send API request: " + e.getMessage(), e);
        }
    }
    
    /**
     * Gets default headers for API requests.
     * 
     * @return map of default headers
     */
    public static Map<String, String> getDefaultHeaders() {
        Map<String, String> headers = new HashMap<>();
        headers.put("Content-Type", "application/json");
        headers.put("Accept", "application/json");
        return headers;
    }
}

/**
 * Validates API response against UI captured data using specified key fields for matching.
 * 
 * @param dataType the data type (e.g., "employeeCalendar", "dealStaticInfo")
 * @param responsePath the path to the array in the response (e.g., "empCalendarList")
 * @param keyFields comma-separated list of fields to use as keys for matching records (optional)
 */
@QAFTestStep(description = "I validate {dataType} API response against UI data using path {responsePath} with keys {keyFields}")
public void validateApiResponseAgainstUiDataWithKeys(String dataType, String responsePath, String keyFields) {
    ApiResponse response = TestContextManager.getLastApiResponse();
    if (response == null) {
        Reporter.log("No API response available. Make sure to send a request first.", MessageTypes.Fail);
        Assert.fail("No API response available. Make sure to send a request first.");
        return;
    }
    
    List<Map<String, String>> expectedData = TestContextManager.getUiCapturedData(dataType);
    if (expectedData == null || expectedData.isEmpty()) {
        Reporter.log("No expected data available for type: " + dataType, MessageTypes.Fail);
        Assert.fail("No expected data available for type: " + dataType);
        return;
    }
    
    JSONObject jsonResponse = response.getJsonObject();
    if (jsonResponse == null) {
        Reporter.log("Invalid JSON response", MessageTypes.Fail);
        Assert.fail("Invalid JSON response");
        return;
    }
    
    if (!jsonResponse.has(responsePath) || jsonResponse.isNull(responsePath)) {
        Reporter.log("Response does not contain path: " + responsePath, MessageTypes.Fail);
        Assert.fail("Response does not contain path: " + responsePath);
        return;
    }
    
    JSONArray responseArray = jsonResponse.getJSONArray(responsePath);
    if (responseArray.length() == 0) {
        Reporter.log(responsePath + " array is empty", MessageTypes.Fail);
        Assert.fail(responsePath + " array is empty");
        return;
    }
    
    // Parse key fields if provided
    String[] keyFieldArray = null;
    if (keyFields != null && !keyFields.trim().isEmpty()) {
        keyFieldArray = keyFields.split(",");
        for (int i = 0; i < keyFieldArray.length; i++) {
            keyFieldArray[i] = keyFieldArray[i].trim();
        }
    }
    
    // Convert response array to a list of maps for easier processing
    List<Map<String, Object>> actualRecords = new ArrayList<>();
    for (int i = 0; i < responseArray.length(); i++) {
        JSONObject obj = responseArray.getJSONObject(i);
        Map<String, Object> map = new HashMap<>();
        for (String key : obj.keySet()) {
            map.put(key, obj.get(key));
        }
        actualRecords.add(map);
    }
    
    // Track matches and issues
    int matchedRecords = 0;
    int totalExpectedRecords = expectedData.size();
    int unprocessedActualRecords = actualRecords.size();
    int totalFieldsCompared = 0;
    int mismatchedFields = 0;
    List<String> issues = new ArrayList<>();
    
    // For key-based comparison
    if (keyFieldArray != null && keyFieldArray.length > 0) {
        // Create a map to track which actual records were matched
        Map<Integer, Boolean> actualRecordMatched = new HashMap<>();
        for (int i = 0; i < actualRecords.size(); i++) {
            actualRecordMatched.put(i, false);
        }
        
        // For each expected record, try to find exactly one matching actual record
        expectedLoop: for (Map<String, String> expectedRecord : expectedData) {
            // Check if expected record has all required key fields
            StringBuilder keyBuilder = new StringBuilder();
            for (String keyField : keyFieldArray) {
                if (!expectedRecord.containsKey(keyField)) {
                    issues.add("Expected record is missing key field: " + keyField);
                    continue expectedLoop;
                }
                keyBuilder.append(keyField).append("=").append(expectedRecord.get(keyField)).append(", ");
            }
            
            String compositeKey = keyBuilder.toString();
            if (compositeKey.endsWith(", ")) {
                compositeKey = compositeKey.substring(0, compositeKey.length() - 2);
            }
            
            // Look for exactly one matching record
            int matchingRecordIndex = -1;
            for (int i = 0; i < actualRecords.size(); i++) {
                // Skip records that have already been matched
                if (actualRecordMatched.get(i)) {
                    continue;
                }
                
                Map<String, Object> actualRecord = actualRecords.get(i);
                boolean keyMatch = true;
                
                // Check if all key fields match
                for (String keyField : keyFieldArray) {
                    if (!actualRecord.containsKey(keyField) || 
                        !expectedRecord.get(keyField).equals(String.valueOf(actualRecord.get(keyField)))) {
                        keyMatch = false;
                        break;
                    }
                }
                
                if (keyMatch) {
                    if (matchingRecordIndex == -1) {
                        // First match
                        matchingRecordIndex = i;
                    } else {
                        // Multiple matches - report as an issue
                        issues.add("Multiple actual records found matching key: " + compositeKey);
                        continue expectedLoop;
                    }
                }
            }
            
            if (matchingRecordIndex == -1) {
                // No match found
                issues.add("No matching record found for keys: " + compositeKey);
            } else {
                // Exactly one match found - compare all fields
                Map<String, Object> matchingRecord = actualRecords.get(matchingRecordIndex);
                actualRecordMatched.put(matchingRecordIndex, true);
                matchedRecords++;
                unprocessedActualRecords--;
                
                // Compare fields
                List<String> fieldIssues = new ArrayList<>();
                int fieldsCompared = compareFields(expectedRecord, matchingRecord, compositeKey, fieldIssues);
                totalFieldsCompared += fieldsCompared;
                mismatchedFields += fieldIssues.size();
                issues.addAll(fieldIssues);
            }
        }
    } else {
        // For index-based comparison (when no key fields are specified)
        for (int i = 0; i < expectedData.size(); i++) {
            Map<String, String> expectedRecord = expectedData.get(i);
            
            if (i < actualRecords.size()) {
                Map<String, Object> actualRecord = actualRecords.get(i);
                matchedRecords++;
                unprocessedActualRecords--;
                
                // Compare fields
                List<String> fieldIssues = new ArrayList<>();
                int fieldsCompared = compareFields(expectedRecord, actualRecord, "index " + i, fieldIssues);
                totalFieldsCompared += fieldsCompared;
                mismatchedFields += fieldIssues.size();
                issues.addAll(fieldIssues);
            } else {
                issues.add("Expected record at index " + i + " not found in response");
            }
        }
    }
    
    // Report results
    Reporter.log("API response validation results for " + dataType + ":", MessageTypes.Info);
    Reporter.log("- Total expected records: " + totalExpectedRecords, MessageTypes.Info);
    Reporter.log("- Total actual records: " + actualRecords.size(), MessageTypes.Info);
    Reporter.log("- Records matched: " + matchedRecords, MessageTypes.Info);
    Reporter.log("- Unprocessed actual records: " + unprocessedActualRecords, MessageTypes.Info);
    Reporter.log("- Total fields compared: " + totalFieldsCompared, MessageTypes.Info);
    
    if (mismatchedFields > 0) {
        Reporter.log("- Fields mismatched: " + mismatchedFields, MessageTypes.Fail);
    } else {
        Reporter.log("- Fields mismatched: " + mismatchedFields, MessageTypes.Pass);
    }
    
    if (!issues.isEmpty()) {
        Reporter.log("Validation issues (" + issues.size() + "):", MessageTypes.Fail);
        // Show at most 20 issues to avoid flooding the log
        int issuesToShow = Math.min(issues.size(), 20);
        for (int i = 0; i < issuesToShow; i++) {
            Reporter.log("  - " + issues.get(i), MessageTypes.Fail);
        }
        if (issues.size() > issuesToShow) {
            Reporter.log("  ... and " + (issues.size() - issuesToShow) + " more issues", MessageTypes.Fail);
        }
        Assert.fail("API response validation failed with " + issues.size() + " issues");
    } else {
        Reporter.log("Validation successful - all data matches!", MessageTypes.Pass);
    }
}

/**
 * Helper method to compare fields between expected and actual records.
 * 
 * @param expectedRecord the expected record
 * @param actualRecord the actual record
 * @param recordIdentifier identifier for this record (composite key or index)
 * @param issues list to add any issues found
 * @return number of fields compared
 */
private int compareFields(Map<String, String> expectedRecord, Map<String, Object> actualRecord, 
                         String recordIdentifier, List<String> issues) {
    int fieldsCompared = 0;
    
    for (Map.Entry<String, String> entry : expectedRecord.entrySet()) {
        String fieldName = entry.getKey();
        String expectedValue = entry.getValue();
        fieldsCompared++;
        
        if (!actualRecord.containsKey(fieldName)) {
            issues.add("Field '" + fieldName + "' missing in record with " + recordIdentifier);
            continue;
        }
        
        Object actualObj = actualRecord.get(fieldName);
        String actualValue = actualObj != null ? String.valueOf(actualObj) : "null";
        
        if (!expectedValue.equals(actualValue)) {
            issues.add("Field '" + fieldName + "' mismatch in record with " + recordIdentifier + 
                       " - Expected: '" + expectedValue + "', Actual: '" + actualValue + "'");
        }
    }
    
    return fieldsCompared;
}

/**
 * Validates API response against UI captured data using scorecard matching approach.
 * 
 * @param dataType the data type (e.g., "employeeCalendar", "dealStaticInfo")
 * @param responsePath the path to the array in the response (e.g., "empCalendarList")
 * @param keyFields comma-separated list of fields to use as keys for matching records (optional)
 */
@QAFTestStep(description = "I validate {dataType} API response against UI data using path {responsePath} with keys {keyFields}")
public void validateApiResponseAgainstUiDataWithKeys(String dataType, String responsePath, String keyFields) {
    ApiResponse response = TestContextManager.getLastApiResponse();
    if (response == null) {
        Reporter.log("No API response available. Make sure to send a request first.", MessageTypes.Fail);
        Assert.fail("No API response available. Make sure to send a request first.");
        return;
    }
    
    List<Map<String, String>> expectedData = TestContextManager.getUiCapturedData(dataType);
    if (expectedData == null || expectedData.isEmpty()) {
        Reporter.log("No expected data available for type: " + dataType, MessageTypes.Fail);
        Assert.fail("No expected data available for type: " + dataType);
        return;
    }
    
    Reporter.log("Retrieved " + expectedData.size() + " expected records for validation", MessageTypes.Info);
    
    JSONObject jsonResponse = response.getJsonObject();
    if (jsonResponse == null) {
        Reporter.log("Invalid JSON response", MessageTypes.Fail);
        Assert.fail("Invalid JSON response");
        return;
    }
    
    if (!jsonResponse.has(responsePath) || jsonResponse.isNull(responsePath)) {
        Reporter.log("Response does not contain path: " + responsePath, MessageTypes.Fail);
        Assert.fail("Response does not contain path: " + responsePath);
        return;
    }
    
    JSONArray responseArray = jsonResponse.getJSONArray(responsePath);
    if (responseArray.length() == 0) {
        Reporter.log(responsePath + " array is empty", MessageTypes.Fail);
        Assert.fail(responsePath + " array is empty");
        return;
    }
    
    Reporter.log("Response contains " + responseArray.length() + " records", MessageTypes.Info);
    
    // Parse key fields if provided
    String[] keyFieldArray = null;
    if (keyFields != null && !keyFields.trim().isEmpty()) {
        keyFieldArray = keyFields.split(",");
        for (int i = 0; i < keyFieldArray.length; i++) {
            keyFieldArray[i] = keyFieldArray[i].trim();
        }
        Reporter.log("Using key fields for matching: " + keyFields, MessageTypes.Info);
    } else {
        Reporter.log("No key fields specified - using scorecard matching", MessageTypes.Info);
    }
    
    // Convert response array to a list of maps for easier processing
    List<Map<String, Object>> actualRecordObjects = new ArrayList<>();
    for (int i = 0; i < responseArray.length(); i++) {
        JSONObject obj = responseArray.getJSONObject(i);
        Map<String, Object> map = new HashMap<>();
        for (String key : obj.keySet()) {
            map.put(key, obj.get(key));
        }
        actualRecordObjects.add(map);
    }
    
    // Convert Object values to String values for easier comparison
    List<Map<String, String>> actualRecords = new ArrayList<>();
    for (Map<String, Object> objMap : actualRecordObjects) {
        Map<String, String> strMap = new HashMap<>();
        for (Map.Entry<String, Object> entry : objMap.entrySet()) {
            strMap.put(entry.getKey(), entry.getValue() != null ? entry.getValue().toString() : "null");
        }
        actualRecords.add(strMap);
    }
    
    // Create a copy of actualRecords that we can modify
    List<Map<String, String>> remainingActualRecords = new ArrayList<>(actualRecords);
    
    // Track overall statistics
    int totalMatches = 0;
    int totalMismatches = 0;
    int unmatchedExpectedRecords = 0;
    boolean validationFailed = false;
    List<String> summaryIssues = new ArrayList<>();
    
    // Process each map in expected data
    for (int i = 0; i < expectedData.size(); i++) {
        Map<String, String> expectedRecord = expectedData.get(i);
        Reporter.log("\nValidating expected record #" + (i + 1) + ":", MessageTypes.Info);
        
        // Find the best matching map in actual data
        int bestMatchIndex = -1;
        
        // If key fields are provided, use them for exact matching
        if (keyFieldArray != null && keyFieldArray.length > 0) {
            bestMatchIndex = findExactMatchByKeys(expectedRecord, remainingActualRecords, keyFieldArray);
        }
        
        // If no match found by keys or no keys provided, use scorecard matching
        if (bestMatchIndex == -1) {
            bestMatchIndex = findBestMatch(expectedRecord, remainingActualRecords);
        }
        
        if (bestMatchIndex != -1) {
            Map<String, String> bestMatch = remainingActualRecords.get(bestMatchIndex);
            
            // Compare the maps in detail
            ComparisonResult result = compareIndividualMaps(expectedRecord, bestMatch, i);
            totalMatches += result.matchCount;
            totalMismatches += result.mismatchCount;
            
            if (result.mismatchCount > 0) {
                validationFailed = true;
            }
            
            // Remove the matched map to avoid matching it again
            remainingActualRecords.remove(bestMatchIndex);
        } else {
            Reporter.log("No matching record found for expected record #" + (i + 1), MessageTypes.Fail);
            unmatchedExpectedRecords++;
            validationFailed = true;
        }
    }
    
    // Report any unmatched records in actual data
    if (!remainingActualRecords.isEmpty()) {
        Reporter.log("\nUnmatched records in response (" + remainingActualRecords.size() + "):", MessageTypes.Info);
        for (int i = 0; i < Math.min(remainingActualRecords.size(), 3); i++) {
            Reporter.log("Unmatched response record: " + remainingActualRecords.get(i), MessageTypes.Info);
        }
        if (remainingActualRecords.size() > 3) {
            Reporter.log("... and " + (remainingActualRecords.size() - 3) + " more unmatched records", MessageTypes.Info);
        }
    }
    
    // Overall summary
    Reporter.log("\nValidation Summary:", MessageTypes.Info);
    Reporter.log("- Expected records: " + expectedData.size(), MessageTypes.Info);
    Reporter.log("- Actual records: " + actualRecords.size(), MessageTypes.Info);
    Reporter.log("- Matched records: " + (expectedData.size() - unmatchedExpectedRecords), MessageTypes.Info);
    Reporter.log("- Unmatched expected records: " + unmatchedExpectedRecords, MessageTypes.Info);
    Reporter.log("- Unmatched actual records: " + remainingActualRecords.size(), MessageTypes.Info);
    Reporter.log("- Matching fields: " + totalMatches, MessageTypes.Info);
    
    if (totalMismatches > 0) {
        Reporter.log("- Mismatched fields: " + totalMismatches, MessageTypes.Fail);
    } else {
        Reporter.log("- Mismatched fields: " + totalMismatches, MessageTypes.Pass);
    }
    
    if (validationFailed) {
        Reporter.log("\nValidation failed. See above for details.", MessageTypes.Fail);
        Assert.fail("API response validation failed with field mismatches or unmatched records");
    } else {
        Reporter.log("\nValidation successful - all expected records matched!", MessageTypes.Pass);
    }
}

/**
 * Find an exact match by specified key fields.
 * 
 * @param targetMap the map to find a match for
 * @param mapList the list of maps to search in
 * @param keyFields the fields to use as keys
 * @return index of the best match, or -1 if no match
 */
private int findExactMatchByKeys(Map<String, String> targetMap, List<Map<String, String>> mapList, String[] keyFields) {
    for (int i = 0; i < mapList.size(); i++) {
        Map<String, String> candidateMap = mapList.get(i);
        boolean allKeysMatch = true;
        
        for (String keyField : keyFields) {
            // Skip if target doesn't have the key
            if (!targetMap.containsKey(keyField)) {
                allKeysMatch = false;
                break;
            }
            
            // Skip if candidate doesn't have the key
            if (!candidateMap.containsKey(keyField)) {
                allKeysMatch = false;
                break;
            }
            
            // Compare values, treating null and blank as equal
            String targetValue = targetMap.get(keyField);
            String candidateValue = candidateMap.get(keyField);
            
            if (!isValueEqual(targetValue, candidateValue)) {
                allKeysMatch = false;
                break;
            }
        }
        
        if (allKeysMatch) {
            return i;
        }
    }
    
    return -1;
}

/**
 * Find the best matching map in mapList for the given target map.
 * Uses a scoring system based on matching key-value pairs.
 * 
 * @param targetMap the map to find a match for
 * @param mapList the list of maps to search in
 * @return index of the best match, or -1 if no match
 */
private int findBestMatch(Map<String, String> targetMap, List<Map<String, String>> mapList) {
    if (mapList.isEmpty()) {
        return -1;
    }
    
    int bestMatchIndex = -1;
    int highestScore = -1;
    
    for (int i = 0; i < mapList.size(); i++) {
        Map<String, String> candidateMap = mapList.get(i);
        int score = calculateMatchScore(targetMap, candidateMap);
        
        if (score > highestScore) {
            highestScore = score;
            bestMatchIndex = i;
        }
    }
    
    // Only consider it a match if score is above threshold
    return highestScore > 0 ? bestMatchIndex : -1;
}

/**
 * Calculate a match score between two maps.
 * Score is based on matching key-value pairs.
 * 
 * @param map1 first map
 * @param map2 second map
 * @return score representing match quality
 */
private int calculateMatchScore(Map<String, String> map1, Map<String, String> map2) {
    int score = 0;
    
    // Check all keys in map1
    for (String key : map1.keySet()) {
        if (map2.containsKey(key)) {
            String value1 = map1.get(key);
            String value2 = map2.get(key);
            
            if (isValueEqual(value1, value2)) {
                // Matching key-value pair
                score += 10;
            } else {
                // Key exists but values differ
                score += 2;
            }
        }
    }
    
    return score;
}

/**
 * Result class for storing comparison results.
 */
private static class ComparisonResult {
    int matchCount;
    int mismatchCount;
    int extraKeysCount;
    
    public ComparisonResult(int matchCount, int mismatchCount, int extraKeysCount) {
        this.matchCount = matchCount;
        this.mismatchCount = mismatchCount;
        this.extraKeysCount = extraKeysCount;
    }
}

/**
 * Compares two maps in detail and reports differences.
 * 
 * @param map1 expected map
 * @param map2 actual map
 * @param mapIndex index for reporting
 * @return ComparisonResult with match statistics
 */
private ComparisonResult compareIndividualMaps(Map<String, String> map1, Map<String, String> map2, int mapIndex) {
    // Track match statistics
    int matchCount = 0;
    int mismatchCount = 0;
    int extraKeysCount = 0;
    Set<String> processedKeys = new HashSet<>();
    
    Reporter.log("Record details:", MessageTypes.Info);
    
    // Check all keys in expected map
    for (String key : map1.keySet()) {
        processedKeys.add(key);
        
        if (map2.containsKey(key)) {
            String value1 = map1.get(key);
            String value2 = map2.get(key);
            
            if (isValueEqual(value1, value2)) {
                matchCount++;
                Reporter.log("✓ Field '" + key + "' matches: '" + value1 + "'", MessageTypes.Pass);
            } else {
                mismatchCount++;
                Reporter.log("✗ Field '" + key + "' mismatch - Expected: '" + value1 + "', Actual: '" + value2 + "'", MessageTypes.Fail);
            }
        } else {
            extraKeysCount++;
            Reporter.log("! Field '" + key + "' exists only in expected data with value '" + map1.get(key) + "'", MessageTypes.Fail);
        }
    }
    
    // Check for keys in actual map that aren't in expected map
    for (String key : map2.keySet()) {
        if (!processedKeys.contains(key)) {
            extraKeysCount++;
            Reporter.log("! Field '" + key + "' exists only in actual data with value '" + map2.get(key) + "'", MessageTypes.Info);
        }
    }
    
    // Summarize match/mismatch statistics
    Reporter.log("Match summary for record #" + (mapIndex + 1) + ":", MessageTypes.Info);
    Reporter.log("- " + matchCount + " matching fields", MessageTypes.Info);
    
    if (mismatchCount > 0) {
        Reporter.log("- " + mismatchCount + " mismatched fields", MessageTypes.Fail);
    } else {
        Reporter.log("- " + mismatchCount + " mismatched fields", MessageTypes.Pass);
    }
    
    Reporter.log("- " + extraKeysCount + " fields found in only one record", MessageTypes.Info);
    
    return new ComparisonResult(matchCount, mismatchCount, extraKeysCount);
}

/**
 * Checks if two string values are equal, treating null and blank as equal.
 * 
 * @param value1 first value
 * @param value2 second value
 * @return true if values are considered equal
 */
private boolean isValueEqual(String value1, String value2) {
    // If both are null or blank, consider them equal
    if (isNullOrBlank(value1) && isNullOrBlank(value2)) {
        return true;
    }
    
    // If one is null and the other isn't, they're not equal
    if (value1 == null || value2 == null) {
        return false;
    }
    
    // Compare the trimmed values
    return value1.trim().equals(value2.trim());
}

/**
 * Checks if a string is null, empty, or blank.
 * 
 * @param value the string to check
 * @return true if the string is null, empty, or blank
 */
private boolean isNullOrBlank(String value) {
    return value == null || value.trim().isEmpty();
}


# Generic API Testing Framework Quick Start Guide

## Setup

1. Configure API endpoints in `application.properties`:
   ```properties
   api.endpoint.UserProfile=/api/v1/users/profile
   api.endpoint.ProductCatalog=/api/v1/products/catalog
   api.endpoint.OrderManagement=/api/v1/orders
   ```

2. Create payload templates in `resources/payloads/`:
   ```json
   // user-profile.json
   {
     "messageId": "${messageId}",
     "userId": ${userId},
     "includePreferences": ${includePreferences}
   }
   ```

## Writing Tests

1. Write feature files using generic steps:
   ```gherkin
   Feature: User Profile API Testing

   Scenario: Test User Profile API
     # Step 1: Setup
     Given I am testing the "User Profile" API
     And I set test data "userId" to "12345"
     And I set test data "includePreferences" to true
     
     # Step 2: Capture UI data (if validating)
     Given I capture userProfile data with values
       | name | John Smith |
       | email | john.smith@example.com |
     
     # Step 3: Send request
     When I send a GET request with payload file "user-profile.json"
     
     # Step 4: Validate response
     Then the response status code should be 200
     And the response field "status" should be "success"
     And I validate userProfile API response against UI data using path "userData" with keys "name,email"
   ```

## Complete List of Generic API Steps

### Setup Steps
```gherkin
I am testing the "API Name" API
I set the API endpoint to "/api/v1/custom/endpoint"
I set test data "key" to "value"
I set test data "numericKey" to 12345
I set test data "booleanKey" to true
I set test data
  | key1 | value1 |
  | key2 | value2 |
I clear all test data
```

### Data Capture Steps
```gherkin
I create a new "dataType" data record
I add "field" with value "value" to "dataType" data
I capture "dataType" data with values
  | field1 | value1 |
  | field2 | value2 |
I clear stored "dataType" data
```

### Request Steps
```gherkin
I send a GET request with payload file "filename.json"
I send a POST request with payload file "filename.json"
I send a PUT request with payload file "filename.json"
I send a DELETE request with payload file "filename.json"
I send a PATCH request with payload file "filename.json"

I send a GET request to "API Name" API with payload file "filename.json"
I send a POST request to "API Name" API with payload file "filename.json"
I send a PUT request to "API Name" API with payload file "filename.json"
I send a DELETE request to "API Name" API with payload file "filename.json"
I send a PATCH request to "API Name" API with payload file "filename.json"

I send a GET request to "/api/custom/path" with payload file "filename.json"
I send a POST request to "/api/custom/path" with payload file "filename.json"
I send a PUT request to "/api/custom/path" with payload file "filename.json"
I send a DELETE request to "/api/custom/path" with payload file "filename.json"
I send a PATCH request to "/api/custom/path" with payload file "filename.json"

I send a GET request with payload: "{\"key\":\"value\"}"
I send a POST request with payload: "{\"key\":\"value\"}"
I send a PUT request with payload: "{\"key\":\"value\"}"
I send a DELETE request with payload: "{\"key\":\"value\"}"
I send a PATCH request with payload: "{\"key\":\"value\"}"
```

### Validation Steps
```gherkin
# Basic validations
the response status code should be 200
the response should be successful
the response should contain field "fieldName"
the response field "fieldName" should be "expectedValue"
the response field "fieldName" should contain "partialText"
the response field "fieldName" should not be "unexpectedValue"
the response field "fieldName" should not contain "unwantedText"
the validation error message for "fieldName" should be "errorMessage"

# Array validations
the response should contain a non-empty "items" array
the "items" array should have size 5
the "items" array at index 0 should contain field "name"
the "items" array at index 0 field "name" should be "expectedValue"

# Advanced validation against UI data
I validate "dataType" API response against UI data using path "path"
I validate "dataType" API response against UI data using path "path" with keys "key1,key2"
```

### Debugging Steps
```gherkin
I print all test data for debugging
I print the response body for debugging
I log the current API endpoint information
```

## Testing a New API

1. **Register the API**: Add to `application.properties` or `ApiConfig.java`
2. **Create Payload Templates**: Add JSON files in `resources/payloads/`
3. **Write Feature Files**: Use the generic steps shown above
4. **Run the Tests**: No additional Java code required!

## Example: Order Management API Test

```gherkin
Feature: Order Management API Testing

Scenario: Create a new order
  # Setup test data
  Given I am testing the "Order Management" API
  And I set test data "customerId" to "54321"
  And I set test data "items" to [{"productId": 101, "quantity": 2}, {"productId": 203, "quantity": 1}]
  And I set test data "shippingAddress" to {"street": "123 Main St", "city": "Anytown", "zip": "12345"}
  
  # Send create order request
  When I send a POST request with payload file "create-order.json"
  
  # Validate response
  Then the response status code should be 201
  And the response should be successful
  And the response should contain field "orderId"
  And the response should contain field "estimatedDelivery"
  And the response field "status" should be "PROCESSING"
```

## Example: Product Catalog API Test

```gherkin
Feature: Product Catalog API Testing

Scenario: Search products with filters
  # Setup test data
  Given I am testing the "Product Catalog" API
  And I set test data "category" to "electronics"
  And I set test data "minPrice" to 100
  And I set test data "maxPrice" to 500
  And I set test data "inStock" to true
  
  # Send search request
  When I send a GET request with payload file "product-search.json"
  
  # Validate response
  Then the response status code should be 200
  And the response should be successful
  And the response should contain field "products"
  And the response should contain field "totalCount"
  And the response field "totalCount" should be greater than "0"
  And the "products" array should have size greater than 0
  
  # Validate all returned products match our category filter
  And all items in "products" array should have field "category" with value "electronics"
```
Additional GenericApiSteps
--------------------------
//--------------------------------------------------------------------------------
// Database Integration Steps
//--------------------------------------------------------------------------------

/**
 * Executes a SQL query and stores the result for later validation.
 * 
 * @param query the SQL query to execute
 * @param resultName name to store the result under
 */
@QAFTestStep(description = "I execute SQL query {query} and store result as {resultName}")
public void executeSqlQuery(String query, String resultName) {
    try {
        // Apply test data variables to query
        query = processTemplateText(query);
        
        Reporter.log("Executing SQL query: " + query, MessageTypes.Info);
        List<Map<String, Object>> results = executeQuery(query);
        Reporter.log("Query returned " + results.size() + " rows", MessageTypes.Info);
        
        // Store result in test context
        TestContextManager.setContext("db.query." + resultName, results);
    } catch (Exception e) {
        Reporter.log("Error executing SQL query: " + e.getMessage(), MessageTypes.Fail);
        throw new RuntimeException("Failed to execute SQL query", e);
    }
}

/**
 * Executes a stored procedure and stores the result.
 * 
 * @param procedure the stored procedure name
 * @param parameters map of parameter names to values
 * @param resultName name to store the result under
 */
@QAFTestStep(description = "I execute stored procedure {procedure} with parameters {parameters} and store result as {resultName}")
public void executeStoredProcedure(String procedure, Map<String, Object> parameters, String resultName) {
    try {
        Reporter.log("Executing stored procedure: " + procedure, MessageTypes.Info);
        
        // Process parameters with test data
        Map<String, Object> processedParams = new HashMap<>();
        for (Map.Entry<String, Object> entry : parameters.entrySet()) {
            if (entry.getValue() instanceof String) {
                processedParams.put(entry.getKey(), processTemplateText((String) entry.getValue()));
            } else {
                processedParams.put(entry.getKey(), entry.getValue());
            }
        }
        
        List<Map<String, Object>> results = executeStoredProc(procedure, processedParams);
        Reporter.log("Stored procedure returned " + results.size() + " rows", MessageTypes.Info);
        
        // Store result in test context
        TestContextManager.setContext("db.proc." + resultName, results);
    } catch (Exception e) {
        Reporter.log("Error executing stored procedure: " + e.getMessage(), MessageTypes.Fail);
        throw new RuntimeException("Failed to execute stored procedure", e);
    }
}

/**
 * Executes a SQL query and uses the results as test data.
 * 
 * @param query the SQL query to execute
 */
@QAFTestStep(description = "I execute SQL query {query} and use results as test data")
public void executeSqlQueryAsTestData(String query) {
    try {
        // Apply test data variables to query
        query = processTemplateText(query);
        
        Reporter.log("Executing SQL query for test data: " + query, MessageTypes.Info);
        List<Map<String, Object>> results = executeQuery(query);
        Reporter.log("Query returned " + results.size() + " rows", MessageTypes.Info);
        
        // If no results, nothing to do
        if (results.isEmpty()) {
            Reporter.log("Query returned no results, no test data to set", MessageTypes.Warn);
            return;
        }
        
        // Take the first row and use its columns as test data
        Map<String, Object> firstRow = results.get(0);
        for (Map.Entry<String, Object> entry : firstRow.entrySet()) {
            if (entry.getValue() != null) {
                TestContextManager.setTestData(entry.getKey(), entry.getValue());
                Reporter.log("Set test data from query: " + entry.getKey() + " = " + entry.getValue(), MessageTypes.Info);
            }
        }
        
        // Store all results for potential later use
        TestContextManager.setContext("db.lastQueryResults", results);
        
        if (results.size() > 1) {
            Reporter.log("Query returned multiple rows, only first row used for test data", MessageTypes.Info);
        }
    } catch (Exception e) {
        Reporter.log("Error executing SQL query for test data: " + e.getMessage(), MessageTypes.Fail);
        throw new RuntimeException("Failed to execute SQL query for test data", e);
    }
}

/**
 * Validates that API response matches a database query result.
 * The keyField parameter is optional for matching records.
 * 
 * @param responseField the response field to validate
 * @param queryResult the stored query result name
 * @param keyField the field to use as a key for matching records (optional)
 */
@QAFTestStep(description = "I validate response field {responseField} against SQL query result {queryResult} with key {keyField}")
public void validateResponseAgainstQueryResult(String responseField, String queryResult, String keyField) {
    validateResponseAgainstQueryResultInternal(responseField, queryResult, keyField);
}

/**
 * Validates that API response matches a database query result without specifying a key field.
 * 
 * @param responseField the response field to validate
 * @param queryResult the stored query result name
 */
@QAFTestStep(description = "I validate response field {responseField} against SQL query result {queryResult}")
public void validateResponseAgainstQueryResultNoKey(String responseField, String queryResult) {
    validateResponseAgainstQueryResultInternal(responseField, queryResult, null);
}

/**
 * Internal implementation of response validation against query result.
 */
private void validateResponseAgainstQueryResultInternal(String responseField, String queryResult, String keyField) {
    ApiResponse response = TestContextManager.getLastApiResponse();
    if (response == null) {
        Reporter.log("No API response available. Make sure to send a request first.", MessageTypes.Fail);
        Assert.fail("No API response available");
        return;
    }
    
    @SuppressWarnings("unchecked")
    List<Map<String, Object>> dbResults = (List<Map<String, Object>>) TestContextManager.getContext("db.query." + queryResult);
    if (dbResults == null || dbResults.isEmpty()) {
        Reporter.log("No database results available for key: " + queryResult, MessageTypes.Fail);
        Assert.fail("No database results available");
        return;
    }
    
    // Convert DB results to string values for comparison
    List<Map<String, String>> expectedData = convertDbResultsToStringMaps(dbResults);
    
    // Extract the response data
    JSONObject jsonResponse = response.getJsonObject();
    if (!jsonResponse.has(responseField)) {
        Reporter.log("Response does not contain field: " + responseField, MessageTypes.Fail);
        Assert.fail("Response field not found: " + responseField);
        return;
    }
    
    JSONArray responseArray;
    if (jsonResponse.get(responseField) instanceof JSONArray) {
        responseArray = jsonResponse.getJSONArray(responseField);
    } else if (jsonResponse.get(responseField) instanceof JSONObject) {
        // If it's a single object, wrap in array for consistent processing
        responseArray = new JSONArray();
        responseArray.put(jsonResponse.getJSONObject(responseField));
    } else {
        Reporter.log("Response field is not an array or object: " + responseField, MessageTypes.Fail);
        Assert.fail("Invalid response field type");
        return;
    }
    
    // Convert response array to list of maps
    List<Map<String, String>> actualData = new ArrayList<>();
    for (int i = 0; i < responseArray.length(); i++) {
        JSONObject obj = responseArray.getJSONObject(i);
        Map<String, String> map = new HashMap<>();
        for (String key : obj.keySet()) {
            map.put(key, obj.get(key) != null ? obj.get(key).toString() : "null");
        }
        actualData.add(map);
    }
    
    // Split key fields if provided
    String[] keyFields = keyField != null && !keyField.isEmpty() ? keyField.split(",") : null;
    if (keyFields != null) {
        for (int i = 0; i < keyFields.length; i++) {
            keyFields[i] = keyFields[i].trim();
        }
    }
    
    // Validate the data
    validateDataSets(expectedData, actualData, keyFields, "Database", "Response");
}

//--------------------------------------------------------------------------------
// Request Chaining Steps
//--------------------------------------------------------------------------------

/**
 * Extracts a value from the response and stores it as test data.
 * 
 * @param responseField the field to extract
 * @param testDataKey the key to store the value under
 */
@QAFTestStep(description = "I extract response field {responseField} and store as test data {testDataKey}")
public void extractResponseField(String responseField, String testDataKey) {
    ApiResponse response = TestContextManager.getLastApiResponse();
    if (response == null) {
        Reporter.log("No API response available. Make sure to send a request first.", MessageTypes.Fail);
        Assert.fail("No API response available");
        return;
    }
    
    String value = response.getValueFromJson(responseField);
    if (value == null) {
        Reporter.log("Response field not found: " + responseField, MessageTypes.Fail);
        Assert.fail("Response field not found: " + responseField);
        return;
    }
    
    TestContextManager.setTestData(testDataKey, value);
    Reporter.log("Extracted response field '" + responseField + "' value '" + value + "' and stored as '" + testDataKey + "'", MessageTypes.Info);
}

/**
 * Extracts a value from a nested path in the response and stores it as test data.
 * 
 * @param responsePath the path to extract (e.g. "data.pagination.nextPageToken")
 * @param testDataKey the key to store the value under
 */
@QAFTestStep(description = "I extract value from response path {responsePath} and store as test data {testDataKey}")
public void extractResponsePath(String responsePath, String testDataKey) {
    ApiResponse response = TestContextManager.getLastApiResponse();
    if (response == null) {
        Reporter.log("No API response available. Make sure to send a request first.", MessageTypes.Fail);
        Assert.fail("No API response available");
        return;
    }
    
    String value = response.getNestedValue(responsePath);
    if (value == null) {
        Reporter.log("Response path not found: " + responsePath, MessageTypes.Fail);
        Assert.fail("Response path not found: " + responsePath);
        return;
    }
    
    TestContextManager.setTestData(testDataKey, value);
    Reporter.log("Extracted response path '" + responsePath + "' value '" + value + "' and stored as '" + testDataKey + "'", MessageTypes.Info);
}

/**
 * Extracts multiple values from response and stores them as test data.
 * 
 * @param fieldsToExtract map of response fields to test data keys
 */
@QAFTestStep(description = "I extract response fields {fieldsToExtract} and store as test data")
public void extractMultipleResponseFields(Map<String, String> fieldsToExtract) {
    ApiResponse response = TestContextManager.getLastApiResponse();
    if (response == null) {
        Reporter.log("No API response available. Make sure to send a request first.", MessageTypes.Fail);
        Assert.fail("No API response available");
        return;
    }
    
    for (Map.Entry<String, String> entry : fieldsToExtract.entrySet()) {
        String responseField = entry.getKey();
        String testDataKey = entry.getValue();
        
        String value = response.getValueFromJson(responseField);
        if (value != null) {
            TestContextManager.setTestData(testDataKey, value);
            Reporter.log("Extracted response field '" + responseField + "' value '" + value + "' and stored as '" + testDataKey + "'", MessageTypes.Info);
        } else {
            Reporter.log("Response field not found: " + responseField, MessageTypes.Warn);
        }
    }
}

//--------------------------------------------------------------------------------
// Response Storage and Comparison Steps
//--------------------------------------------------------------------------------

/**
 * Stores the current response for later comparison.
 * 
 * @param responseName the name to store the response under
 */
@QAFTestStep(description = "I store current response as {responseName}")
public void storeCurrentResponse(String responseName) {
    ApiResponse response = TestContextManager.getLastApiResponse();
    if (response == null) {
        Reporter.log("No API response available. Make sure to send a request first.", MessageTypes.Fail);
        Assert.fail("No API response available");
        return;
    }
    
    Map<String, ApiResponse> storedResponses = getStoredResponsesMap();
    storedResponses.put(responseName, response);
    
    Reporter.log("Stored current response as '" + responseName + "'", MessageTypes.Info);
}

/**
 * Validates that the current response matches a previously stored response.
 * 
 * @param responseName the name of the stored response
 */
@QAFTestStep(description = "I validate current response matches stored response {responseName}")
public void validateAgainstStoredResponse(String responseName) {
    ApiResponse currentResponse = TestContextManager.getLastApiResponse();
    if (currentResponse == null) {
        Reporter.log("No API response available. Make sure to send a request first.", MessageTypes.Fail);
        Assert.fail("No API response available");
        return;
    }
    
    Map<String, ApiResponse> storedResponses = getStoredResponsesMap();
    ApiResponse storedResponse = storedResponses.get(responseName);
    
    if (storedResponse == null) {
        Reporter.log("No stored response found with name: " + responseName, MessageTypes.Fail);
        Assert.fail("No stored response found with name: " + responseName);
        return;
    }
    
    // Compare the response bodies
    String currentBody = currentResponse.getResponseBody();
    String storedBody = storedResponse.getResponseBody();
    
    if (currentBody.equals(storedBody)) {
        Reporter.log("Current response matches stored response '" + responseName + "'", MessageTypes.Pass);
    } else {
        Reporter.log("Current response does not match stored response '" + responseName + "'", MessageTypes.Fail);
        Reporter.log("Expected: " + storedBody, MessageTypes.Info);
        Reporter.log("Actual: " + currentBody, MessageTypes.Info);
        Assert.fail("Current response does not match stored response '" + responseName + "'");
    }
}

//--------------------------------------------------------------------------------
// Advanced Validation Steps
//--------------------------------------------------------------------------------

/**
 * Validates that the response matches a JSON schema.
 * 
 * @param schemaFileName the JSON schema file name
 */
@QAFTestStep(description = "I validate response against JSON schema {schemaFileName}")
public void validateResponseSchema(String schemaFileName) {
    ApiResponse response = TestContextManager.getLastApiResponse();
    if (response == null) {
        Reporter.log("No API response available. Make sure to send a request first.", MessageTypes.Fail);
        Assert.fail("No API response available");
        return;
    }
    
    try {
        String schemaDir = ConfigurationManager.getBundle().getString("schema.dir", "resources/schemas");
        String path = schemaDir + "/" + schemaFileName;
        
        File schemaFile = new File(path);
        if (!schemaFile.exists()) {
            Reporter.log("Schema file not found: " + path, MessageTypes.Fail);
            Assert.fail("Schema file not found: " + path);
            return;
        }
        
        // Load schema
        JSONObject rawSchema = new JSONObject(new JSONTokener(new FileInputStream(schemaFile)));
        Schema schema = SchemaLoader.load(rawSchema);
        
        // Parse response body
        JSONObject responseJson;
        try {
            responseJson = new JSONObject(response.getResponseBody());
        } catch (Exception e) {
            Reporter.log("Response is not a valid JSON object", MessageTypes.Fail);
            Assert.fail("Response is not a valid JSON object");
            return;
        }
        
        // Validate
        try {
            schema.validate(responseJson);
            Reporter.log("Response validates against schema '" + schemaFileName + "'", MessageTypes.Pass);
        } catch (Exception e) {
            Reporter.log("Schema validation failed: " + e.getMessage(), MessageTypes.Fail);
            Assert.fail("Schema validation failed: " + e.getMessage());
        }
    } catch (Exception e) {
        Reporter.log("Error during schema validation: " + e.getMessage(), MessageTypes.Fail);
        throw new RuntimeException("Schema validation error", e);
    }
}

/**
 * Validates that a field matches a regular expression pattern.
 * 
 * @param field the field to check
 * @param pattern the regular expression pattern
 */
@QAFTestStep(description = "the response field {field} should match pattern {pattern}")
public void fieldShouldMatchPattern(String field, String pattern) {
    ApiResponse response = TestContextManager.getLastApiResponse();
    if (response == null) {
        Reporter.log("No API response available. Make sure to send a request first.", MessageTypes.Fail);
        Assert.fail("No API response available");
        return;
    }
    
    String value = response.getValueFromJson(field);
    if (value == null) {
        Reporter.log("Response field not found: " + field, MessageTypes.Fail);
        Assert.fail("Response field not found");
        return;
    }
    
    boolean matches = Pattern.matches(pattern, value);
    
    if (matches) {
        Reporter.log("Field '" + field + "' with value '" + value + "' matches pattern '" + pattern + "'", MessageTypes.Pass);
    } else {
        Reporter.log("Field '" + field + "' with value '" + value + "' does not match pattern '" + pattern + "'", MessageTypes.Fail);
        Assert.fail("Field does not match pattern");
    }
}

//--------------------------------------------------------------------------------
// Conditional and Flow Control Steps
//--------------------------------------------------------------------------------

/**
 * Polls an API endpoint until a condition is met or timeout is reached.
 * 
 * @param apiName the API name
 * @param intervalSeconds the polling interval in seconds
 * @param maxTimeMinutes the maximum polling time in minutes
 * @param field the field to check
 * @param expectedStatus the expected status to wait for
 */
@QAFTestStep(description = "I poll {apiName} API every {intervalSeconds} seconds for maximum {maxTimeMinutes} minutes until field {field} is {expectedStatus}")
public void pollApiUntilCondition(String apiName, int intervalSeconds, int maxTimeMinutes, String field, String expectedStatus) {
    LocalDateTime startTime = LocalDateTime.now();
    LocalDateTime endTime = startTime.plusMinutes(maxTimeMinutes);
    boolean conditionMet = false;
    
    String endpoint = ApiConfig.getEndpoint(apiName);
    if (endpoint == null) {
        Reporter.log("Unknown API name: " + apiName, MessageTypes.Fail);
        Assert.fail("Unknown API name");
        return;
    }
    
    // Store original API endpoint to restore later
    String originalEndpoint = TestContextManager.getCurrentApiEndpoint();
    
    try {
        // Set up for polling
        TestContextManager.setCurrentApi(apiName, endpoint);
        
        Reporter.log("Polling " + apiName + " API until field '" + field + "' is '" + expectedStatus + "' (timeout: " + maxTimeMinutes + " minutes)", MessageTypes.Info);
        
        int pollCount = 0;
        while (LocalDateTime.now().isBefore(endTime) && !conditionMet) {
            pollCount++;
            
            // Send API request
            try {
                Reporter.log("Poll attempt #" + pollCount, MessageTypes.Info);
                
                // Assuming the payload file uses the API name
                String payloadFile = apiName.toLowerCase().replace(" ", "-") + "-poll.json";
                GenericApiService.sendRequestWithPayloadFile(endpoint, "GET", payloadFile, null);
                
                // Check condition
                ApiResponse response = TestContextManager.getLastApiResponse();
                String actualValue = response.getValueFromJson(field);
                
                if (expectedStatus.equals(actualValue)) {
                    conditionMet = true;
                    Reporter.log("Condition met: field '" + field + "' is '" + expectedStatus + "' after " + pollCount + " attempts", MessageTypes.Pass);
                } else {
                    Reporter.log("Current value of field '" + field + "' is '" + actualValue + "', waiting for '" + expectedStatus + "'", MessageTypes.Info);
                }
            } catch (Exception e) {
                Reporter.log("Error during polling attempt: " + e.getMessage(), MessageTypes.Info);
            }
            
            // Wait for next interval if not done
            if (!conditionMet && LocalDateTime.now().isBefore(endTime)) {
                Thread.sleep(intervalSeconds * 1000);
            }
        }
        
        if (!conditionMet) {
            Reporter.log("Timeout reached. Condition not met after " + maxTimeMinutes + " minutes", MessageTypes.Fail);
            Assert.fail("Polling timeout reached");
        }
    } catch (Exception e) {
        Reporter.log("Error during polling: " + e.getMessage(), MessageTypes.Fail);
        throw new RuntimeException("Polling failed", e);
    } finally {
        // Restore original API endpoint if there was one
        if (originalEndpoint != null) {
            TestContextManager.setCurrentApi("Original", originalEndpoint);
        }
    }
}

/**
 * Helper method to execute a SQL query and return results.
 */
private List<Map<String, Object>> executeQuery(String query) throws Exception {
    List<Map<String, Object>> results = new ArrayList<>();
    Connection conn = null;
    Statement stmt = null;
    ResultSet rs = null;
    
    try {
        conn = getDatabaseConnection();
        stmt = conn.createStatement();
        rs = stmt.executeQuery(query);
        
        // Get column names
        int columnCount = rs.getMetaData().getColumnCount();
        String[] columnNames = new String[columnCount];
        for (int i = 1; i <= columnCount; i++) {
            columnNames[i-1] = rs.getMetaData().getColumnName(i);
        }
        
        // Process rows
        while (rs.next()) {
            Map<String, Object> row = new HashMap<>();
            for (String columnName : columnNames) {
                row.put(columnName, rs.getObject(columnName));
            }
            results.add(row);
        }
    } finally {
        if (rs != null) try { rs.close(); } catch (Exception e) { /* ignore */ }
        if (stmt != null) try { stmt.close(); } catch (Exception e) { /* ignore */ }
        if (conn != null) try { conn.close(); } catch (Exception e) { /* ignore */ }
    }
    
    return results;
}

/**
 * Helper method to execute a stored procedure and return results.
 */
private List<Map<String, Object>> executeStoredProc(String procedure, Map<String, Object> parameters) throws Exception {
    // Implementation as provided earlier...
}

/**
 * Helper method to convert database results to string maps.
 */
private List<Map<String, String>> convertDbResultsToStringMaps(List<Map<String, Object>> dbResults) {
    List<Map<String, String>> result = new ArrayList<>();
    
    for (Map<String, Object> row : dbResults) {
        Map<String, String> stringMap = new HashMap<>();
        for (Map.Entry<String, Object> entry : row.entrySet()) {
            stringMap.put(entry.getKey(), entry.getValue() != null ? entry.getValue().toString() : "null");
        }
        result.add(stringMap);
    }
    
    return result;
}

/**
 * Helper method to get stored responses map.
 */
@SuppressWarnings("unchecked")
private Map<String, ApiResponse> getStoredResponsesMap() {
    Map<String, ApiResponse> storedResponses = 
        (Map<String, ApiResponse>) TestContextManager.getContext(STORED_RESPONSES_KEY);
    
    if (storedResponses == null) {
        storedResponses = new HashMap<>();
        TestContextManager.setContext(STORED_RESPONSES_KEY, storedResponses);
    }
    
    return storedResponses;
}

/**
 * Helper method to process template text with test data.
 */
private String processTemplateText(String template) {
    if (template == null) {
        return null;
    }
    
    Map<String, Object> testData = TestContextManager.getTestData();
    return ApiClientUtil.processTemplate(template, testData);
}

/**
 * Helper method to get a database connection.
 */
private Connection getDatabaseConnection() throws Exception {
    String url = ConfigurationManager.getBundle().getString("db.url");
    String username = ConfigurationManager.getBundle().getString("db.username");
    String password = ConfigurationManager.getBundle().getString("db.password");
    
    return DriverManager.getConnection(url, username, password);
}
