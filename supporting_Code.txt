// File: src/framework/utils/logger.ts
import winston from 'winston';
import path from 'path';
import fs from 'fs';

// Create a map to store loggers by ID to avoid creating duplicates
const loggerMap = new Map<string, Logger>();

/**
 * Memory transport for Winston that stores logs in memory
 */
class MemoryTransport extends winston.Transport {
  private logs: string[] = [];

  constructor(opts?: winston.TransportOptions) {
    super(opts);
  }

  log(info: winston.LogEntry, callback: () => void) {
    setImmediate(() => {
      this.emit('logged', info);
    });

    // Store the formatted log message
    const formattedMessage = `[${info.timestamp}] [${info.level.toUpperCase()}] [${info.testId}]: ${info.message}`;
    this.logs.push(formattedMessage);

    callback();
  }

  getLogs(): string[] {
    return this.logs;
  }
}

/**
 * Enhanced Logger using Winston with memory storage for test automation
 */
export class Logger {
  private logger: winston.Logger;
  private testId: string;
  private memoryTransport: MemoryTransport;
  private scenarioName?: string;
  private static fileTransportInitialized = false;
  private static consoleTransportInitialized = false;
  private static sharedLoggers: Map<string, winston.transport> = new Map();

  /**
   * Get a logger instance by ID (creates one if it doesn't exist)
   * @param testId - Identifier for the test/context
   * @returns Logger instance
   */
  public static getLogger(testId: string): Logger {
    if (!loggerMap.has(testId)) {
      const logger = new Logger(testId);
      loggerMap.set(testId, logger);
    }
    return loggerMap.get(testId)!;
  }

  /**
   * Constructor for the Logger
   * @param testId - Identifier for the test/context
   */
  constructor(testId: string) {
    this.testId = testId;
    const logsDir = path.join(process.cwd(), 'reports', 'logs');
    
    // Create logs directory if it doesn't exist
    if (!fs.existsSync(logsDir)) {
      fs.mkdirSync(logsDir, { recursive: true });
    }
    
    // Create memory transport for storing logs in memory
    this.memoryTransport = new MemoryTransport();
    
    // Define shared transports if not already created
    if (!Logger.consoleTransportInitialized) {
      Logger.sharedLoggers.set('console', new winston.transports.Console({
        format: winston.format.combine(
          winston.format.colorize(),
          winston.format.simple()
        )
      }));
      Logger.consoleTransportInitialized = true;
    }
    
    if (!Logger.fileTransportInitialized) {
      Logger.sharedLoggers.set('file', new winston.transports.File({
        filename: path.join(logsDir, `test-run-${Date.now()}.log`)
      }));
      Logger.fileTransportInitialized = true;
    }
    
    // Create instance-specific file logger for this test ID
    const testFileTransport = new winston.transports.File({
      filename: path.join(logsDir, `test-${testId}.log`)
    });
    
    // Create Winston logger with transports
    this.logger = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.printf((info) => {
          // Add testId to info object for memory transport
          info.testId = this.testId;
          return `[${info.timestamp}] [${info.level.toUpperCase()}] [${this.testId}]: ${info.message}`;
        })
      ),
      transports: [
        Logger.sharedLoggers.get('console')!,
        Logger.sharedLoggers.get('file')!,
        testFileTransport,
        this.memoryTransport
      ]
    });
  }

  /**
   * Log a debug message
   * @param message - Message to log
   */
  debug(message: string): void {
    this.logger.debug(message);
  }

  /**
   * Log an info message
   * @param message - Message to log
   */
  info(message: string): void {
    this.logger.info(message);
  }

  /**
   * Log a warning message
   * @param message - Message to log
   */
  warn(message: string): void {
    this.logger.warn(message);
  }

  /**
   * Log an error message
   * @param message - Message to log
   */
  error(message: string): void {
    this.logger.error(message);
  }

  /**
   * Set the current scenario name for logging
   * @param scenarioName - Name of the scenario
   */
  setScenario(scenarioName: string): void {
    this.scenarioName = scenarioName;
    this.info(`Starting scenario: ${scenarioName}`);
  }

  /**
   * Get all logs from memory
   * @returns string[] - Array of log messages
   */
  getLogs(): string[] {
    return this.memoryTransport.getLogs();
  }

  /**
   * Get the current test ID
   * @returns string - Test ID
   */
  getTestId(): string {
    return this.testId;
  }

  /**
   * Get the current scenario name
   * @returns string | undefined - Scenario name
   */
  getScenarioName(): string | undefined {
    return this.scenarioName;
  }
  
  /**
   * Close and clean up logger resources
   */
  close(): void {
    // Remove from map to allow garbage collection
    loggerMap.delete(this.testId);
  }
}
