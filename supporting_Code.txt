// File: src/framework/base-api-client.ts
import axios, { AxiosRequestConfig, AxiosResponse } from 'axios';
import { expect } from '@playwright/test';
import { Logger } from './utils/logger';
import { ConfigManager } from './utils/config-manager';

/**
 * Interface for API request options
 */
export interface ApiRequestOptions {
  headers?: Record<string, string>;
  params?: Record<string, any>;
  data?: any;
  timeout?: number;
  validateStatus?: boolean;
}

/**
 * Base API client for all API interactions
 */
export class BaseApiClient {
  readonly apiBaseUrl: string;
  readonly defaultTimeout: number;
  readonly logger: Logger;
  readonly defaultHeaders: Record<string, string>;
  readonly config: ConfigManager;

  /**
   * Constructor for the BaseApiClient
   * @param apiBaseUrl - Base URL for API requests
   * @param defaultHeaders - Default headers to include in all requests
   */
  constructor(
    apiBaseUrl?: string,
    defaultHeaders: Record<string, string> = {}
  ) {
    this.config = ConfigManager.getInstance();
    this.apiBaseUrl = apiBaseUrl || this.config.getString('API_BASE_URL', 'https://api.example.com');
    this.defaultTimeout = this.config.getNumber('DEFAULT_TIMEOUT', 30000);
    this.logger = new Logger(this.constructor.name);
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      ...defaultHeaders
    };
  }

  /**
   * Make a GET request
   * @param endpoint - API endpoint
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  async get(endpoint: string, options?: ApiRequestOptions): Promise<AxiosResponse> {
    const url = new URL(endpoint, this.apiBaseUrl).toString();
    this.logger.info(`Making GET request to: ${url}`);
    
    const config: AxiosRequestConfig = {
      headers: { ...this.defaultHeaders, ...options?.headers },
      params: options?.params || {},
      timeout: options?.timeout || this.defaultTimeout,
      validateStatus: options?.validateStatus !== false ? undefined : () => true
    };

    try {
      // Add request timing metadata
      config.metadata = { startTime: Date.now() };
      
      const response = await axios.get(url, config);
      
      // Add response timing metadata
      response.config.metadata = { ...response.config.metadata, endTime: Date.now() };
      
      this.logResponse(response);
      return response;
    } catch (error) {
      this.logError(error);
      throw error;
    }
  }

  /**
   * Make a POST request
   * @param endpoint - API endpoint
   * @param data - Request body
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  async post(endpoint: string, data?: any, options?: ApiRequestOptions): Promise<AxiosResponse> {
    const url = new URL(endpoint, this.apiBaseUrl).toString();
    this.logger.info(`Making POST request to: ${url}`);
    
    const config: AxiosRequestConfig = {
      headers: { ...this.defaultHeaders, ...options?.headers },
      params: options?.params || {},
      timeout: options?.timeout || this.defaultTimeout,
      validateStatus: options?.validateStatus !== false ? undefined : () => true
    };

    try {
      // Add request timing metadata
      config.metadata = { startTime: Date.now() };
      
      const response = await axios.post(url, data || {}, config);
      
      // Add response timing metadata
      response.config.metadata = { ...response.config.metadata, endTime: Date.now() };
      
      this.logResponse(response);
      return response;
    } catch (error) {
      this.logError(error);
      throw error;
    }
  }

  /**
   * Make a PUT request
   * @param endpoint - API endpoint
   * @param data - Request body
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  async put(endpoint: string, data?: any, options?: ApiRequestOptions): Promise<AxiosResponse> {
    const url = new URL(endpoint, this.apiBaseUrl).toString();
    this.logger.info(`Making PUT request to: ${url}`);
    
    const config: AxiosRequestConfig = {
      headers: { ...this.defaultHeaders, ...options?.headers },
      params: options?.params || {},
      timeout: options?.timeout || this.defaultTimeout,
      validateStatus: options?.validateStatus !== false ? undefined : () => true
    };

    try {
      // Add request timing metadata
      config.metadata = { startTime: Date.now() };
      
      const response = await axios.put(url, data || {}, config);
      
      // Add response timing metadata
      response.config.metadata = { ...response.config.metadata, endTime: Date.now() };
      
      this.logResponse(response);
      return response;
    } catch (error) {
      this.logError(error);
      throw error;
    }
  }

  /**
   * Make a PATCH request
   * @param endpoint - API endpoint
   * @param data - Request body
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  async patch(endpoint: string, data?: any, options?: ApiRequestOptions): Promise<AxiosResponse> {
    const url = new URL(endpoint, this.apiBaseUrl).toString();
    this.logger.info(`Making PATCH request to: ${url}`);
    
    const config: AxiosRequestConfig = {
      headers: { ...this.defaultHeaders, ...options?.headers },
      params: options?.params || {},
      timeout: options?.timeout || this.defaultTimeout,
      validateStatus: options?.validateStatus !== false ? undefined : () => true
    };

    try {
      // Add request timing metadata
      config.metadata = { startTime: Date.now() };
      
      const response = await axios.patch(url, data || {}, config);
      
      // Add response timing metadata
      response.config.metadata = { ...response.config.metadata, endTime: Date.now() };
      
      this.logResponse(response);
      return response;
    } catch (error) {
      this.logError(error);
      throw error;
    }
  }

  /**
   * Make a DELETE request
   * @param endpoint - API endpoint
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  async delete(endpoint: string, options?: ApiRequestOptions): Promise<AxiosResponse> {
    const url = new URL(endpoint, this.apiBaseUrl).toString();
    this.logger.info(`Making DELETE request to: ${url}`);
    
    const config: AxiosRequestConfig = {
      headers: { ...this.defaultHeaders, ...options?.headers },
      params: options?.params || {},
      data: options?.data || {},
      timeout: options?.timeout || this.defaultTimeout,
      validateStatus: options?.validateStatus !== false ? undefined : () => true
    };

    try {
      // Add request timing metadata
      config.metadata = { startTime: Date.now() };
      
      const response = await axios.delete(url, config);
      
      // Add response timing metadata
      response.config.metadata = { ...response.config.metadata, endTime: Date.now() };
      
      this.logResponse(response);
      return response;
    } catch (error) {
      this.logError(error);
      throw error;
    }
  }

  /**
   * Assert API response status code
   * @param response - Axios response
   * @param expectedStatus - Expected status code
   */
  assertStatusCode(response: AxiosResponse, expectedStatus: number): void {
    this.logger.debug(`Asserting status code: ${expectedStatus}`);
    expect(response.status).toBe(expectedStatus);
  }

  /**
   * Assert API response contains specific data
   * @param response - Axios response
   * @param expectedData - Data to check for
   */
  assertResponseData(response: AxiosResponse, expectedData: any): void {
    this.logger.debug(`Asserting response data`);
    expect(response.data).toMatchObject(expectedData);
  }

  /**
   * Assert response header has a specific value
   * @param response - Axios response
   * @param headerName - Header name
   * @param expectedValue - Expected header value
   */
  assertHeader(response: AxiosResponse, headerName: string, expectedValue: string): void {
    this.logger.debug(`Asserting header ${headerName} has value ${expectedValue}`);
    const headerValue = response.headers[headerName.toLowerCase()];
    expect(headerValue).toBe(expectedValue);
  }

  /**
   * Assert response time is within acceptable limits
   * @param response - Axios response
   * @param maxTime - Maximum acceptable response time in ms
   */
  assertResponseTime(response: AxiosResponse, maxTime: number): void {
    if (response.config && response.config.metadata && response.config.metadata.endTime && response.config.metadata.startTime) {
      const duration = response.config.metadata.endTime - response.config.metadata.startTime;
      this.logger.debug(`Response time: ${duration}ms, Max allowed: ${maxTime}ms`);
      expect(duration).toBeLessThanOrEqual(maxTime);
    } else {
      this.logger.warn('Response time metrics not available');
    }
  }

  /**
   * Get authentication token (to be implemented by derived classes)
   * @returns Promise<string> - Authentication token
   */
  async getAuthToken(): Promise<string> {
    throw new Error('getAuthToken() method must be implemented by derived API client classes');
  }

  /**
   * Create auth header with token
   * @param token - Authentication token
   * @returns Record<string, string> - Headers with authentication
   */
  createAuthHeader(token: string): Record<string, string> {
    return { 'Authorization': `Bearer ${token}` };
  }

  /**
   * Retry a request until it succeeds or max attempts reached
   * @param requestFn - Function to retry
   * @param options - Retry options
   * @returns Promise<AxiosResponse> - API response
   */
  async retryRequest(
    requestFn: () => Promise<AxiosResponse>,
    options?: {
      maxAttempts?: number;
      retryDelay?: number;
      retryCondition?: (error: any) => boolean;
    }
  ): Promise<AxiosResponse> {
    const maxAttempts = options?.maxAttempts || 3;
    const retryDelay = options?.retryDelay || 1000;
    const retryCondition = options?.retryCondition || (() => true);
    
    let lastError: any;
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        this.logger.debug(`Request attempt ${attempt}/${maxAttempts}`);
        return await requestFn();
      } catch (error) {
        lastError = error;
        this.logger.debug(`Attempt ${attempt} failed: ${error.message}`);
        
        if (attempt < maxAttempts && retryCondition(error)) {
          await new Promise(resolve => setTimeout(resolve, retryDelay));
        } else {
          break;
        }
      }
    }
    
    throw lastError;
  }

  /**
   * Log response details
   * @private
   * @param response - Axios response
   */
  private logResponse(response: AxiosResponse): void {
    this.logger.debug(`Response status: ${response.status}`);
    this.logger.debug(`Response headers: ${JSON.stringify(response.headers)}`);
    
    // Calculate response time if metadata is available
    if (response.config && response.config.metadata && response.config.metadata.endTime && response.config.metadata.startTime) {
      const duration = response.config.metadata.endTime - response.config.metadata.startTime;
      this.logger.debug(`Response time: ${duration}ms`);
    }
    
    // Log response body in a safe way (truncate if too large)
    try {
      const responseBody = JSON.stringify(response.data);
      if (responseBody.length > 1000) {
        this.logger.debug(`Response body (truncated): ${responseBody.substring(0, 1000)}...`);
      } else {
        this.logger.debug(`Response body: ${responseBody}`);
      }
    } catch (error) {
      this.logger.debug('Response body: [Could not stringify response data]');
    }
  }

  /**
   * Log error details
   * @private
   * @param error - Axios error
   */
  private logError(error: any): void {
    if (error.response) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx
      this.logger.error(`Response error: ${error.response.status} - ${error.message}`);
      this.logger.debug(`Error response data: ${JSON.stringify(error.response.data)}`);
      this.logger.debug(`Error response headers: ${JSON.stringify(error.response.headers)}`);
    } else if (error.request) {
      // The request was made but no response was received
      this.logger.error(`Request error: ${error.message}`);
    } else {
      // Something happened in setting up the request that triggered an Error
      this.logger.error(`Error: ${error.message}`);
    }
  }
}
