// File: src/framework/utils/config-manager.ts
import fs from 'fs';
import path from 'path';

/**
 * Configuration Manager for handling environment-specific configurations
 * Implements singleton pattern to ensure configuration is loaded only once
 */
export class ConfigManager {
  private static instance: ConfigManager;
  private config: Record<string, any>;
  private initialized: boolean = false;

  /**
   * Private constructor for singleton pattern
   */
  private constructor() {
    this.config = {};
    this.loadConfiguration();
  }

  /**
   * Get singleton instance
   * @returns ConfigManager instance
   */
  public static getInstance(): ConfigManager {
    if (!ConfigManager.instance) {
      ConfigManager.instance = new ConfigManager();
    }
    return ConfigManager.instance;
  }

  /**
   * Load configuration from files and environment variables
   * @private
   */
  private loadConfiguration(): void {
    if (this.initialized) {
      return;
    }

    try {
      // Load environment-specific config
      const env = process.env.NODE_ENV || 'default';
      const configPath = path.join(process.cwd(), 'config', `${env}.json`);
      
      if (fs.existsSync(configPath)) {
        console.log(`Loading configuration from: ${configPath}`);
        this.config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
      } else {
        // Load default config if environment-specific config doesn't exist
        const defaultConfigPath = path.join(process.cwd(), 'config', 'default.json');
        if (fs.existsSync(defaultConfigPath)) {
          console.log(`Loading default configuration from: ${defaultConfigPath}`);
          this.config = JSON.parse(fs.readFileSync(defaultConfigPath, 'utf8'));
        } else {
          console.warn('No configuration file found, using empty configuration');
        }
      }
      
      // Override with environment variables
      this.mergeEnvironmentVariables();
      
      this.initialized = true;
    } catch (error) {
      console.error(`Error loading configuration: ${error}`);
    }
  }

  /**
   * Get configuration value
   * @param key - Configuration key (supports dot notation)
   * @param defaultValue - Default value if configuration not found
   * @returns Configuration value
   */
  public get<T>(key: string, defaultValue?: T): T {
    if (!this.initialized) {
      this.loadConfiguration();
    }
    
    const keys = key.split('.');
    let value: any = this.config;
    
    for (const k of keys) {
      value = value && value[k] !== undefined ? value[k] : undefined;
    }
    
    return (value !== undefined ? value : defaultValue) as T;
  }

  /**
   * Set configuration value
   * @param key - Configuration key (supports dot notation)
   * @param value - Configuration value
   */
  public set<T>(key: string, value: T): void {
    if (!this.initialized) {
      this.loadConfiguration();
    }
    
    const keys = key.split('.');
    let current = this.config;
    
    for (let i = 0; i < keys.length - 1; i++) {
      const k = keys[i];
      current[k] = current[k] || {};
      current = current[k];
    }
    
    current[keys[keys.length - 1]] = value;
  }

  /**
   * Get entire configuration object
   * @returns Configuration object
   */
  public getAll(): Record<string, any> {
    if (!this.initialized) {
      this.loadConfiguration();
    }
    
    return { ...this.config };
  }

  /**
   * Override configuration with environment variables
   * Only processes variables with TEST_ prefix
   * @private
   */
  private mergeEnvironmentVariables(): void {
    for (const [key, value] of Object.entries(process.env)) {
      if (key.startsWith('TEST_') && value !== undefined) {
        const configKey = key.replace('TEST_', '').toLowerCase().replace(/_([a-z])/g, (g) => g[1].toUpperCase());
        this.set(configKey, value);
      }
    }
  }
}
