// File: src/framework/utils/config-manager.ts
import dotenv from 'dotenv';
import path from 'path';
import fs from 'fs';

/**
 * Configuration Manager for handling environment-specific configurations
 * Implements singleton pattern to ensure configuration is loaded only once
 * Uses .env files instead of JSON files
 */
export class ConfigManager {
  private static instance: ConfigManager;
  private config: Record<string, any> = {};
  private initialized: boolean = false;

  /**
   * Private constructor for singleton pattern
   */
  private constructor() {
    this.loadConfiguration();
  }

  /**
   * Get singleton instance
   * @returns ConfigManager instance
   */
  public static getInstance(): ConfigManager {
    if (!ConfigManager.instance) {
      ConfigManager.instance = new ConfigManager();
    }
    return ConfigManager.instance;
  }

  /**
   * Load configuration from .env files and process.env
   * @private
   */
  private loadConfiguration(): void {
    if (this.initialized) {
      return;
    }

    try {
      // Load base .env file first (if exists)
      const baseEnvPath = path.resolve(process.cwd(), '.env');
      if (fs.existsSync(baseEnvPath)) {
        console.log(`Loading base environment from: ${baseEnvPath}`);
        dotenv.config({ path: baseEnvPath });
      }

      // Load environment-specific .env file if specified
      const env = process.env.NODE_ENV || 'development';
      const envSpecificPath = path.resolve(process.cwd(), `.env.${env}`);
      
      if (fs.existsSync(envSpecificPath)) {
        console.log(`Loading environment-specific config from: ${envSpecificPath}`);
        // Override with environment-specific values
        dotenv.config({ path: envSpecificPath, override: true });
      }

      // Copy all environment variables to our config object
      // We'll convert them to appropriate types later in the get method
      this.config = { ...process.env };
      
      this.initialized = true;
    } catch (error) {
      console.error(`Error loading environment configuration: ${error}`);
    }
  }

  /**
   * Get configuration value with type conversion
   * @param key - Configuration key
   * @param defaultValue - Default value if configuration not found
   * @returns Configuration value with appropriate type
   */
  public get<T>(key: string, defaultValue?: T): T {
    if (!this.initialized) {
      this.loadConfiguration();
    }
    
    // Check if the key exists in our config
    const value = this.config[key];
    
    if (value === undefined) {
      return defaultValue as T;
    }
    
    // Try to convert the string value to the appropriate type
    // based on the defaultValue or just return as is
    if (defaultValue !== undefined) {
      const defaultType = typeof defaultValue;
      
      if (defaultType === 'number') {
        const numberValue = Number(value);
        return (isNaN(numberValue) ? defaultValue : numberValue) as T;
      } else if (defaultType === 'boolean') {
        if (value.toLowerCase() === 'true') return true as unknown as T;
        if (value.toLowerCase() === 'false') return false as unknown as T;
        return defaultValue;
      } else if (defaultType === 'object' && Array.isArray(defaultValue)) {
        try {
          // Try to parse as JSON if it looks like an array
          if (value.startsWith('[') && value.endsWith(']')) {
            return JSON.parse(value) as T;
          }
          // Otherwise split by comma (common for env vars)
          return value.split(',').map(item => item.trim()) as unknown as T;
        } catch (e) {
          return defaultValue;
        }
      } else if (defaultType === 'object') {
        try {
          return JSON.parse(value) as T;
        } catch (e) {
          return defaultValue;
        }
      }
    }
    
    // If no defaultValue or no special conversion needed, return as is
    return value as unknown as T;
  }

  /**
   * Set configuration value (mainly for testing)
   * @param key - Configuration key
   * @param value - Configuration value
   */
  public set<T>(key: string, value: T): void {
    if (!this.initialized) {
      this.loadConfiguration();
    }
    
    // Store in our config object
    this.config[key] = value;
    
    // Also set in process.env for consistency
    process.env[key] = String(value);
  }

  /**
   * Get entire configuration object
   * @returns Configuration object
   */
  public getAll(): Record<string, any> {
    if (!this.initialized) {
      this.loadConfiguration();
    }
    
    return { ...this.config };
  }

  /**
   * Get boolean value (convenience method)
   * @param key - Configuration key
   * @param defaultValue - Default value if not found
   */
  public getBoolean(key: string, defaultValue: boolean = false): boolean {
    return this.get<boolean>(key, defaultValue);
  }

  /**
   * Get number value (convenience method)
   * @param key - Configuration key
   * @param defaultValue - Default value if not found
   */
  public getNumber(key: string, defaultValue: number = 0): number {
    return this.get<number>(key, defaultValue);
  }

  /**
   * Get string value (convenience method)
   * @param key - Configuration key
   * @param defaultValue - Default value if not found
   */
  public getString(key: string, defaultValue: string = ''): string {
    return this.get<string>(key, defaultValue);
  }
}
