package com.cssmart.core.pom;

import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

/**
 * Represents a Page Object Model for testing web pages
 * Contains page elements, actions, and verification methods
 */
@Slf4j
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PageObjectModel {
    
    private String id;
    private String name;
    private String description;
    private String pageUrl;
    private String packageName;
    private String className;
    
    private List<PageElement> elements;
    private List<PageAction> actions;
    private List<PageVerification> verifications;
    
    /**
     * Add an element to the page object model
     * @param element Page element to add
     */
    public void addElement(PageElement element) {
        if (elements == null) {
            elements = new ArrayList<>();
        }
        elements.add(element);
    }
    
    /**
     * Add an action to the page object model
     * @param action Page action to add
     */
    public void addAction(PageAction action) {
        if (actions == null) {
            actions = new ArrayList<>();
        }
        actions.add(action);
    }
    
    /**
     * Add a verification to the page object model
     * @param verification Page verification to add
     */
    public void addVerification(PageVerification verification) {
        if (verifications == null) {
            verifications = new ArrayList<>();
        }
        verifications.add(verification);
    }
    
    /**
     * Generate Java code for this page object model
     * @return Generated Java code
     */
    public String generateCode() {
        StringBuilder code = new StringBuilder();
        
        // Add package and imports
        if (packageName != null && !packageName.isEmpty()) {
            code.append("package ").append(packageName).append(";\n\n");
        } else {
            code.append("package com.cssmart.pom.pages;\n\n");
        }
        
        code.append("import org.openqa.selenium.WebDriver;\n");
        code.append("import org.openqa.selenium.WebElement;\n");
        code.append("import org.openqa.selenium.support.FindBy;\n");
        code.append("import org.openqa.selenium.support.PageFactory;\n");
        code.append("import lombok.extern.slf4j.Slf4j;\n");
        code.append("import java.util.List;\n\n");
        
        // Add class javadoc
        code.append("/**\n");
        code.append(" * Page Object Model for ").append(name != null ? name : "Web Page").append("\n");
        if (description != null && !description.isEmpty()) {
            code.append(" * ").append(description).append("\n");
        }
        code.append(" * Generated by CS Smart Test Framework\n");
        code.append(" */\n");
        
        // Add class declaration
        code.append("@Slf4j\n");
        code.append("public class ").append(className != null ? className : "PageObject").append(" {\n\n");
        
        // Add WebDriver field
        code.append("    private final WebDriver driver;\n\n");
        
        // Add element fields with @FindBy annotations
        if (elements != null && !elements.isEmpty()) {
            for (PageElement element : elements) {
                // Add javadoc for element
                code.append("    /**\n");
                code.append("     * ").append(element.getDescription()).append("\n");
                code.append("     */\n");
                
                // Add @FindBy annotation
                code.append("    @FindBy(");
                switch (element.getLocatorType()) {
                    case ID:
                        code.append("id = \"");
                        break;
                    case NAME:
                        code.append("name = \"");
                        break;
                    case CLASS_NAME:
                        code.append("className = \"");
                        break;
                    case TAG_NAME:
                        code.append("tagName = \"");
                        break;
                    case XPATH:
                        code.append("xpath = \"");
                        break;
                    case CSS:
                        code.append("css = \"");
                        break;
                    case LINK_TEXT:
                        code.append("linkText = \"");
                        break;
                    case PARTIAL_LINK_TEXT:
                        code.append("partialLinkText = \"");
                        break;
                    default:
                        code.append("id = \"");
                }
                code.append(element.getLocatorValue()).append("\")\n");
                
                // Add element field
                if (element.isList()) {
                    code.append("    private List<WebElement> ").append(element.getName()).append(";\n\n");
                } else {
                    code.append("    private WebElement ").append(element.getName()).append(";\n\n");
                }
            }
        }
        
        // Add constructor
        code.append("    /**\n");
        code.append("     * Constructor\n");
        code.append("     * @param driver WebDriver instance\n");
        code.append("     */\n");
        code.append("    public ").append(className != null ? className : "PageObject").append("(WebDriver driver) {\n");
        code.append("        this.driver = driver;\n");
        code.append("        PageFactory.initElements(driver, this);\n");
        if (pageUrl != null && !pageUrl.isEmpty()) {
            code.append("        // Page URL: ").append(pageUrl).append("\n");
        }
        code.append("    }\n\n");
        
        // Add action methods
        if (actions != null && !actions.isEmpty()) {
            for (PageAction action : actions) {
                // Add javadoc for action
                code.append("    /**\n");
                code.append("     * ").append(action.getDescription()).append("\n");
                
                // Add param javadoc if method has parameters
                if (action.getParameters() != null && !action.getParameters().isEmpty()) {
                    for (Map.Entry<String, String> param : action.getParameters().entrySet()) {
                        code.append("     * @param ").append(param.getKey())
                            .append(" ").append(param.getValue()).append("\n");
                    }
                }
                
                // Add return javadoc if method returns a value
                if (action.isReturnsPage()) {
                    code.append("     * @return This page object for method chaining\n");
                }
                
                code.append("     */\n");
                
                // Add method signature
                code.append("    public ");
                if (action.isReturnsPage()) {
                    code.append(className != null ? className : "PageObject");
                } else {
                    code.append("void");
                }
                code.append(" ").append(action.getName()).append("(");
                
                // Add method parameters
                if (action.getParameters() != null && !action.getParameters().isEmpty()) {
                    boolean first = true;
                    for (Map.Entry<String, String> param : action.getParameters().entrySet()) {
                        if (!first) {
                            code.append(", ");
                        }
                        code.append("String ").append(param.getKey());
                        first = false;
                    }
                }
                code.append(") {\n");
                
                // Add method body
                code.append("        log.info(\"").append(action.getDescription()).append("\");\n");
                if (action.getImplementation() != null && !action.getImplementation().isEmpty()) {
                    // Add custom implementation
                    String[] lines = action.getImplementation().split("\n");
                    for (String line : lines) {
                        code.append("        ").append(line).append("\n");
                    }
                } else {
                    // Add default implementation based on action type
                    switch (action.getType()) {
                        case CLICK:
                            code.append("        ").append(action.getElementName()).append(".click();\n");
                            break;
                        case TYPE:
                            if (action.getParameters() != null && !action.getParameters().isEmpty()) {
                                String paramName = action.getParameters().keySet().iterator().next();
                                code.append("        ").append(action.getElementName()).append(".clear();\n");
                                code.append("        ").append(action.getElementName()).append(".sendKeys(").append(paramName).append(");\n");
                            }
                            break;
                        case SELECT:
                            if (action.getParameters() != null && !action.getParameters().isEmpty()) {
                                String paramName = action.getParameters().keySet().iterator().next();
                                code.append("        new org.openqa.selenium.support.ui.Select(").append(action.getElementName()).append(")")
                                    .append(".selectByVisibleText(").append(paramName).append(");\n");
                            }
                            break;
                        case NAVIGATE:
                            if (pageUrl != null && !pageUrl.isEmpty()) {
                                code.append("        driver.get(\"").append(pageUrl).append("\");\n");
                            } else {
                                code.append("        // TODO: Implement navigation to page URL\n");
                            }
                            break;
                        default:
                            code.append("        // TODO: Implement ").append(action.getType()).append(" action\n");
                    }
                }
                
                // Add return statement if method returns a value
                if (action.isReturnsPage()) {
                    code.append("        return this;\n");
                }
                
                code.append("    }\n\n");
            }
        }
        
        // Add verification methods
        if (verifications != null && !verifications.isEmpty()) {
            for (PageVerification verification : verifications) {
                // Add javadoc for verification
                code.append("    /**\n");
                code.append("     * ").append(verification.getDescription()).append("\n");
                code.append("     * @return true if verification passes, false otherwise\n");
                code.append("     */\n");
                
                // Add method signature
                code.append("    public boolean ").append(verification.getName()).append("() {\n");
                
                // Add method body
                code.append("        log.info(\"").append(verification.getDescription()).append("\");\n");
                if (verification.getImplementation() != null && !verification.getImplementation().isEmpty()) {
                    // Add custom implementation
                    String[] lines = verification.getImplementation().split("\n");
                    for (String line : lines) {
                        code.append("        ").append(line).append("\n");
                    }
                } else {
                    // Add default implementation based on verification type
                    switch (verification.getType()) {
                        case ELEMENT_PRESENT:
                            code.append("        return ").append(verification.getElementName()).append(" != null && ")
                                .append(verification.getElementName()).append(".isDisplayed();\n");
                            break;
                        case ELEMENT_TEXT:
                            if (verification.getExpectedValue() != null) {
                                code.append("        return ").append(verification.getElementName()).append(".getText()")
                                    .append(".contains(\"").append(verification.getExpectedValue()).append("\");\n");
                            } else {
                                code.append("        // TODO: Verify text content of element\n");
                                code.append("        return false;\n");
                            }
                            break;
                        case PAGE_TITLE:
                            if (verification.getExpectedValue() != null) {
                                code.append("        return driver.getTitle().contains(\"")
                                    .append(verification.getExpectedValue()).append("\");\n");
                            } else {
                                code.append("        // TODO: Verify page title\n");
                                code.append("        return false;\n");
                            }
                            break;
                        case URL:
                            if (verification.getExpectedValue() != null) {
                                code.append("        return driver.getCurrentUrl().contains(\"")
                                    .append(verification.getExpectedValue()).append("\");\n");
                            } else {
                                code.append("        // TODO: Verify page URL\n");
                                code.append("        return false;\n");
                            }
                            break;
                        default:
                            code.append("        // TODO: Implement ").append(verification.getType()).append(" verification\n");
                            code.append("        return false;\n");
                    }
                }
                
                code.append("    }\n\n");
            }
        }
        
        // Add waitForPageToLoad method
        code.append("    /**\n");
        code.append("     * Wait for the page to load completely\n");
        code.append("     * @return This page object for method chaining\n");
        code.append("     */\n");
        code.append("    public ").append(className != null ? className : "PageObject").append(" waitForPageToLoad() {\n");
        code.append("        // Wait for page to be fully loaded using JavaScript\n");
        code.append("        org.openqa.selenium.support.ui.WebDriverWait wait = new org.openqa.selenium.support.ui.WebDriverWait(driver, java.time.Duration.ofSeconds(30));\n");
        code.append("        wait.until(driver -> ((org.openqa.selenium.JavascriptExecutor) driver).executeScript(\"return document.readyState\").equals(\"complete\"));\n");
        code.append("        return this;\n");
        code.append("    }\n");
        
        // Close class
        code.append("}\n");
        
        return code.toString();
    }
}

/**
 * Represents an element on a web page
 */
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
class PageElement {
    private String name;
    private String description;
    private LocatorType locatorType;
    private String locatorValue;
    private boolean isList;
    
    /**
     * Types of element locators
     */
    public enum LocatorType {
        ID,
        NAME,
        CLASS_NAME,
        TAG_NAME,
        XPATH,
        CSS,
        LINK_TEXT,
        PARTIAL_LINK_TEXT
    }
}

/**
 * Represents an action that can be performed on a page
 */
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
class PageAction {
    private String name;
    private String description;
    private ActionType type;
    private String elementName;
    private Map<String, String> parameters;
    private String implementation;
    private boolean returnsPage;
    
    /**
     * Types of page actions
     */
    public enum ActionType {
        CLICK,
        TYPE,
        SELECT,
        HOVER,
        NAVIGATE,
        WAIT,
        CUSTOM
    }
}

/**
 * Represents a verification that can be performed on a page
 */
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
class PageVerification {
    private String name;
    private String description;
    private VerificationType type;
    private String elementName;
    private String expectedValue;
    private String implementation;
    
    /**
     * Types of page verifications
     */
    public enum VerificationType {
        ELEMENT_PRESENT,
        ELEMENT_TEXT,
        PAGE_TITLE,
        URL,
        CUSTOM
    }
}


package com.cssmart.ui.recorder.model;

import com.cssmart.core.pom.PageObjectModel;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * Extended test case model with Page Object Model support
 */
@Slf4j
@Getter
@Setter
@NoArgsConstructor
public class POMTestCase extends TestCase {
    
    private List<PageObjectModel> pageObjects;
    private boolean usesPageObjectModel;
    
    /**
     * Create a new POM Test Case based on an existing TestCase
     * @param testCase Base test case
     */
    public POMTestCase(TestCase testCase) {
        // Copy all fields from base test case
        this.setId(testCase.getId());
        this.setName(testCase.getName());
        this.setDescription(testCase.getDescription());
        this.setClassName(testCase.getClassName());
        this.setMethodName(testCase.getMethodName());
        this.setCode(testCase.getCode());
        this.setSteps(testCase.getSteps());
        this.setStartTime(testCase.getStartTime());
        this.setEndTime(testCase.getEndTime());
        
        // Initialize POM-specific fields
        this.pageObjects = new ArrayList<>();
        this.usesPageObjectModel = false;
    }
    
    /**
     * Add a page object to this test case
     * @param pageObject Page object to add
     */
    public void addPageObject(PageObjectModel pageObject) {
        if (pageObjects == null) {
            pageObjects = new ArrayList<>();
        }
        pageObjects.add(pageObject);
        usesPageObjectModel = true;
    }
    
    /**
     * Generate POM-based test code
     * @return Generated test code using page objects
     */
    public String generatePOMCode() {
        if (!usesPageObjectModel || pageObjects == null || pageObjects.isEmpty()) {
            // If no page objects defined, return regular code
            return getCode();
        }
        
        StringBuilder code = new StringBuilder();
        
        // Add package and imports
        code.append("package com.cssmart.tests.generated;\n\n");
        code.append("import com.cssmart.core.base.CSSmartTestBase;\n");
        code.append("import com.cssmart.core.annotations.CSSmartTest;\n");
        code.append("import org.testng.annotations.Test;\n");
        code.append("import org.openqa.selenium.WebDriver;\n");
        code.append("import org.testng.Assert;\n");
        code.append("import lombok.extern.slf4j.Slf4j;\n");
        
        // Import page object classes
        for (PageObjectModel pageObject : pageObjects) {
            code.append("import ").append(pageObject.getPackageName()).append(".")
                .append(pageObject.getClassName()).append(";\n");
        }
        code.append("\n");
        
        // Add class javadoc
        code.append("/**\n");
        code.append(" * ").append(getDescription()).append("\n");
        code.append(" * Generated by CS Smart Test Framework - POM Version\n");
        code.append(" */\n");
        
        // Add class declaration
        code.append("@Slf4j\n");
        code.append("public class ").append(getClassName()).append(" extends CSSmartTestBase {\n\n");
        
        // Add page object fields
        for (PageObjectModel pageObject : pageObjects) {
            code.append("    private ").append(pageObject.getClassName()).append(" ")
                .append(Character.toLowerCase(pageObject.getClassName().charAt(0)))
                .append(pageObject.getClassName().substring(1)).append(";\n");
        }
        code.append("\n");
        
        // Add test method
        code.append("    @Test\n");
        code.append("    @CSSmartTest(description = \"").append(getDescription()).append("\")\n");
        code.append("    public void ").append(getMethodName()).append("() {\n");
        code.append("        log.info(\"Starting test: ").append(getDescription()).append("\");\n\n");
        
        // Initialize page objects
        for (PageObjectModel pageObject : pageObjects) {
            String variableName = Character.toLowerCase(pageObject.getClassName().charAt(0)) 
                + pageObject.getClassName().substring(1);
            
            code.append("        // Initialize ").append(pageObject.getName()).append(" page object\n");
            code.append("        ").append(variableName).append(" = new ")
                .append(pageObject.getClassName()).append("(driver);\n\n");
        }
        
        // Use page objects to implement test steps
        if (getSteps() != null && !getSteps().isEmpty()) {
            code.append("        // Execute test steps using page objects\n");
            
            // Group steps by page object
            for (PageObjectModel pageObject : pageObjects) {
                String variableName = Character.toLowerCase(pageObject.getClassName().charAt(0)) 
                    + pageObject.getClassName().substring(1);
                
                code.append("        // ").append(pageObject.getName()).append(" actions\n");
                
                // Find actions in this page object that match steps
                for (RecordedStep step : getSteps()) {
                    // Check if this step can be mapped to an action in this page object
                    if (matchesPageObject(step, pageObject)) {
                        mapStepToPageObjectAction(step, pageObject, variableName, code);
                    }
                }
                
                code.append("\n");
            }
        } else {
            code.append("        // TODO: Implement test steps using page objects\n\n");
        }
        
        code.append("        log.info(\"Test completed successfully\");\n");
        code.append("    }\n");
        
        // Close class
        code.append("}\n");
        
        return code.toString();
    }
    
    /**
     * Check if a step matches actions in a page object
     * @param step Recorded step
     * @param pageObject Page object
     * @return true if step can be mapped to this page object
     */
    private boolean matchesPageObject(RecordedStep step, PageObjectModel pageObject) {
        // This is a simple implementation - in a real app, you'd use AI to match steps to page objects
        // For now, we'll use a simple heuristic: if the element name appears in the page object elements
        if (step.getElement() == null || step.getElement().isEmpty()) {
            return false;
        }
        
        if (pageObject.getElements() != null) {
            for (com.cssmart.core.pom.PageElement element : pageObject.getElements()) {
                if (step.getElement().toLowerCase().contains(element.getName().toLowerCase())) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Map a recorded step to a page object action
     * @param step Recorded step
     * @param pageObject Page object
     * @param variableName Variable name for the page object
     * @param code StringBuilder to append code to
     */
    private void mapStepToPageObjectAction(RecordedStep step, PageObjectModel pageObject, 
                                          String variableName, StringBuilder code) {
        // This is a simple implementation - in a real app, you'd use AI to map steps to actions
        String actionName = "";
        String actionCall = "";
        
        switch (step.getAction()) {
            case "CLICK":
                actionName = "click" + toCamelCase(step.getElement());
                actionCall = actionName + "()";
                break;
                
            case "TYPE":
                actionName = "enter" + toCamelCase(step.getElement());
                actionCall = actionName + "(\"" + step.getValue() + "\")";
                break;
                
            case "SELECT":
                actionName = "select" + toCamelCase(step.getElement());
                actionCall = actionName + "(\"" + step.getValue() + "\")";
                break;
                
            case "VERIFY_PRESENCE":
                actionName = "verify" + toCamelCase(step.getElement()) + "IsPresent";
                code.append("        Assert.assertTrue(").append(variableName).append(".")
                    .append(actionName).append("(), \"")
                    .append(step.getElement()).append(" should be present\");\n");
                return;
                
            case "NAVIGATE":
                code.append("        ").append(variableName).append(".navigateToPage();\n");
                return;
                
            default:
                code.append("        // TODO: Map ").append(step.getAction())
                    .append(" action for ").append(step.getElement()).append("\n");
                return;
        }
        
        code.append("        ").append(variableName).append(".")
            .append(actionCall).append(";\n");
    }
    
    /**
     * Convert a string to camel case
     * @param input Input string
     * @return Camel case string
     */
    private String toCamelCase(String input) {
        if (input == null || input.isEmpty()) {
            return "";
        }
        
        // Replace non-alphanumeric with spaces
        String clean = input.replaceAll("[^a-zA-Z0-9]", " ");
        
        // Split into words
        String[] words = clean.trim().split("\\s+");
        StringBuilder result = new StringBuilder();
        
        for (String word : words) {
            if (word.length() > 0) {
                // Capitalize first letter of each word
                result.append(Character.toUpperCase(word.charAt(0)));
                if (word.length() > 1) {
                    result.append(word.substring(1).toLowerCase());
                }
            }
        }
        
        return result.toString();
    }
}

package com.cssmart.ui.service;

import com.cssmart.ai.engine.AIEngine;
import com.cssmart.core.pom.PageObjectModel;
import com.cssmart.ui.recorder.model.RecordedStep;
import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.recorder.model.POMTestCase;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Service for generating Page Object Models using AI
 */
@Slf4j
@Service
public class PageObjectGenerator {
    
    private final AIEngine aiEngine;
    private static final String POM_DIR = "src/main/java/com/cssmart/pom/pages";
    
    @Autowired
    public PageObjectGenerator(AIEngine aiEngine) {
        this.aiEngine = aiEngine;
        
        // Ensure directory exists
        File pomDir = new File(POM_DIR);
        if (!pomDir.exists()) {
            pomDir.mkdirs();
        }
    }
    
    /**
     * Generate a Page Object Model from a test case
     * @param testCase Test case to analyze
     * @return Generated Page Object Model
     */
    public PageObjectModel generatePageObject(TestCase testCase) {
        log.info("Generating Page Object Model for test case: {}", testCase.getName());
        
        try {
            // Extract URL from test case steps
            String pageUrl = extractPageUrl(testCase);
            
            // Extract page name from URL or test case name
            String pageName = extractPageName(testCase, pageUrl);
            
            // Create POM with basic information
            PageObjectModel pageObject = PageObjectModel.builder()
                .id(UUID.randomUUID().toString())
                .name(pageName)
                .description("Page Object Model for " + pageName)
                .pageUrl(pageUrl)
                .packageName("com.cssmart.pom.pages")
                .className(generateClassName(pageName))
                .elements(new ArrayList<>())
                .actions(new ArrayList<>())
                .verifications(new ArrayList<>())
                .build();
            
            // Use AI to identify page elements
            identifyPageElements(pageObject, testCase);
            
            // Use AI to create actions from steps
            generateActionsFromSteps(pageObject, testCase);
            
            // Use AI to create verifications
            generateVerifications(pageObject, testCase);
            
            // Generate and save Java code
            String code = pageObject.generateCode();
            savePageObjectToFile(pageObject, code);
            
            return pageObject;
        } catch (Exception e) {
            log.error("Error generating Page Object Model", e);
            throw new RuntimeException("Failed to generate Page Object Model: " + e.getMessage(), e);
        }
    }
    
    /**
     * Convert a test case to a POM-based test case
     * @param testCase Original test case
     * @return POM-based test case
     */
    public POMTestCase convertToPOMTestCase(TestCase testCase) {
        log.info("Converting test case to POM-based test case: {}", testCase.getName());
        
        try {
            // Create POM test case from regular test case
            POMTestCase pomTestCase = new POMTestCase(testCase);
            
            // Group steps by page to determine how many page objects we need
            Map<String, List<RecordedStep>> stepsByPage = groupStepsByPage(testCase);
            
            // Generate a page object for each group
            for (Map.Entry<String, List<RecordedStep>> entry : stepsByPage.entrySet()) {
                String pageName = entry.getKey();
                
                // Create a temporary test case with only steps for this page
                TestCase pageTestCase = new TestCase();
                pageTestCase.setName(testCase.getName() + " - " + pageName);
                pageTestCase.setDescription(testCase.getDescription());
                pageTestCase.setSteps(entry.getValue());
                
                // Generate page object for this page
                PageObjectModel pageObject = generatePageObject(pageTestCase);
                
                // Add to POM test case
                pomTestCase.addPageObject(pageObject);
            }
            
            // Generate POM-based test code
            String pomCode = pomTestCase.generatePOMCode();
            pomTestCase.setCode(pomCode);
            
            // Save the POM test code
            saveTestCode(pomTestCase);
            
            return pomTestCase;
        } catch (Exception e) {
            log.error("Error converting to POM test case", e);
            throw new RuntimeException("Failed to convert to POM test case: " + e.getMessage(), e);
        }
    }
    
    /**
     * Group test steps by page
     * @param testCase Test case with steps
     * @return Map of page name to list of steps
     */
    private Map<String, List<RecordedStep>> groupStepsByPage(TestCase testCase) {
        Map<String, List<RecordedStep>> stepsByPage = new HashMap<>();
        
        if (testCase.getSteps() == null || testCase.getSteps().isEmpty()) {
            // If no steps, create a default page
            stepsByPage.put("MainPage", new ArrayList<>());
            return stepsByPage;
        }
        
        // Initialize with a default page
        String currentPage = "MainPage";
        List<RecordedStep> currentSteps = new ArrayList<>();
        stepsByPage.put(currentPage, currentSteps);
        
        // In a real implementation, you would use AI to identify page transitions
        // For simplicity, we'll use a heuristic based on NAVIGATE actions
        for (RecordedStep step : testCase.getSteps()) {
            if ("NAVIGATE".equals(step.getAction()) && step.getValue() != null) {
                // Extract page name from URL
                String url = step.getValue();
                String pageName = extractPageNameFromUrl(url);
                
                // If this is a new page, create a new list
                if (!stepsByPage.containsKey(pageName)) {
                    currentPage = pageName;
                    currentSteps = new ArrayList<>();
                    stepsByPage.put(currentPage, currentSteps);
                } else {
                    // If we've seen this page before, switch back to it
                    currentPage = pageName;
                    currentSteps = stepsByPage.get(currentPage);
                }
            }
            
            // Add step to current page's list
            currentSteps.add(step);
        }
        
        return stepsByPage;
    }
    
    /**
     * Extract page URL from test case steps
     * @param testCase Test case with steps
     * @return Page URL or empty string if not found
     */
    private String extractPageUrl(TestCase testCase) {
        if (testCase.getSteps() != null) {
            for (RecordedStep step : testCase.getSteps()) {
                if ("NAVIGATE".equals(step.getAction()) && step.getValue() != null) {
                    return step.getValue();
                }
            }
        }
        return "";
    }
    
    /**
     * Extract page name from test case and URL
     * @param testCase Test case
     * @param pageUrl Page URL
     * @return Page name
     */
    private String extractPageName(TestCase testCase, String pageUrl) {
        // Try to extract from URL first
        if (pageUrl != null && !pageUrl.isEmpty()) {
            String pageNameFromUrl = extractPageNameFromUrl(pageUrl);
            if (!pageNameFromUrl.isEmpty()) {
                return pageNameFromUrl;
            }
        }
        
        // Fall back to test case name
        String testName = testCase.getName();
        if (testName != null && !testName.isEmpty()) {
            // Remove "Test" suffix if present
            if (testName.endsWith(" Test")) {
                testName = testName.substring(0, testName.length() - 5);
            }
            return testName + " Page";
        }
        
        return "Page";
    }
    
    /**
     * Extract page name from URL
     * @param url URL to parse
     * @return Page name
     */
    private String extractPageNameFromUrl(String url) {
        if (url == null || url.isEmpty()) {
            return "";
        }
        
        try {
            // Remove protocol and domain
            String path = url.replaceAll("https?://[^/]+", "");
            
            // Split path into segments
            String[] segments = path.split("/");
            
            // Find the last non-empty segment
            for (int i = segments.length - 1; i >= 0; i--) {
                if (!segments[i].isEmpty()) {
                    // Remove any query parameters or fragments
                    String segment = segments[i].split("[?#]")[0];
                    
                    // Convert to proper case
                    if (!segment.isEmpty()) {
                        return toProperCase(segment) + "Page";
                    }
                }
            }
            
            // If we got here, use the domain
            String domain = url.replaceAll("https?://([^/]+).*", "$1");
            domain = domain.replaceAll("www\\.", "");
            
            return toProperCase(domain) + "Page";
        } catch (Exception e) {
            log.warn("Error extracting page name from URL: {}", url, e);
            return "Page";
        }
    }
    
    /**
     * Generate a class name from page name
     * @param pageName Page name
     * @return Class name
     */
    private String generateClassName(String pageName) {
        // Remove "Page" suffix if present - we'll add it back
        if (pageName.endsWith("Page")) {
            pageName = pageName.substring(0, pageName.length() - 4);
        }
        
        // Replace non-alphanumeric with spaces and split into words
        String[] words = pageName.replaceAll("[^a-zA-Z0-9]", " ").trim().split("\\s+");
        
        StringBuilder className = new StringBuilder();
        for (String word : words) {
            if (!word.isEmpty()) {
                className.append(Character.toUpperCase(word.charAt(0)))
                       .append(word.substring(1).toLowerCase());
            }
        }
        
        return className.toString() + "Page";
    }
    
    /**
     * Identify page elements using AI
     * @param pageObject Page object to populate
     * @param testCase Test case to analyze
     */
    private void identifyPageElements(PageObjectModel pageObject, TestCase testCase) {
        if (testCase.getSteps() == null || testCase.getSteps().isEmpty()) {
            return;
        }
        
        // Map to keep track of elements we've seen
        Map<String, com.cssmart.core.pom.PageElement> elementMap = new HashMap<>();
        
        for (RecordedStep step : testCase.getSteps()) {
            if (step.getElement() != null && !step.getElement().isEmpty()) {
                String elementName = generateElementName(step.getElement());
                
                // Skip if we've already processed this element
                if (elementMap.containsKey(elementName)) {
                    continue;
                }
                
                // In a real implementation, you would use AI to determine the best locator
                // For now, we'll use a simple heuristic based on the element description
                com.cssmart.core.pom.PageElement.LocatorType locatorType = determineLocatorType(step.getElement());
                String locatorValue = generateLocatorValue(step.getElement(), locatorType);
                
                // Create and add the element
                com.cssmart.core.pom.PageElement element = com.cssmart.core.pom.PageElement.builder()
                    .name(elementName)
                    .description(step.getElement())
                    .locatorType(locatorType)
                    .locatorValue(locatorValue)
                    .isList(false) // For simplicity, we'll assume elements are not lists
                    .build();
                
                pageObject.addElement(element);
                elementMap.put(elementName, element);
            }
        }
        
        log.info("Identified {} elements for page object", elementMap.size());
    }
    
    /**
     * Generate actions from test steps
     * @param pageObject Page object to populate
     * @param testCase Test case to analyze
     */
    private void generateActionsFromSteps(PageObjectModel pageObject, TestCase testCase) {
        if (testCase.getSteps() == null || testCase.getSteps().isEmpty()) {
            return;
        }
        
        // Map to keep track of actions we've seen
        Map<String, com.cssmart.core.pom.PageAction> actionMap = new HashMap<>();
        
        // Add a navigate action
        if (pageObject.getPageUrl() != null && !pageObject.getPageUrl().isEmpty()) {
            com.cssmart.core.pom.PageAction navigateAction = com.cssmart.core.pom.PageAction.builder()
                .name("navigateToPage")
                .description("Navigate to " + pageObject.getName())
                .type(com.cssmart.core.pom.PageAction.ActionType.NAVIGATE)
                .returnsPage(true)
                .build();
            
            pageObject.addAction(navigateAction);
            actionMap.put(navigateAction.getName(), navigateAction);
        }
        
        for (RecordedStep step : testCase.getSteps()) {
            if (step.getElement() != null && !step.getElement().isEmpty()) {
                // Skip navigation steps (already handled)
                if ("NAVIGATE".equals(step.getAction())) {
                    continue;
                }
                
                String elementName = generateElementName(step.getElement());
                String actionName = generateActionName(step);
                
                // Skip if we've already processed this action
                if (actionMap.containsKey(actionName)) {
                    continue;
                }
                
                // In a real implementation, you would use AI to determine the action type
                com.cssmart.core.pom.PageAction.ActionType actionType = mapActionType(step.getAction());
                
                // Create parameters map if needed
                Map<String, String> parameters = null;
                if ("TYPE".equals(step.getAction()) || "SELECT".equals(step.getAction())) {
                    parameters = new HashMap<>();
                    parameters.put("value", "Value to enter");
                }
                
                // Create and add the action
                com.cssmart.core.pom.PageAction action = com.cssmart.core.pom.PageAction.builder()
                    .name(actionName)
                    .description(step.getDescription())
                    .type(actionType)
                    .elementName(elementName)
                    .parameters(parameters)
                    .returnsPage(true) // For fluent API
                    .build();
                
                pageObject.addAction(action);
                actionMap.put(actionName, action);
            }
        }
        
        log.info("Generated {} actions for page object", actionMap.size());
    }
    
    /**
     * Generate verifications for page elements
     * @param pageObject Page object to populate
     * @param testCase Test case to analyze
     */
    private void generateVerifications(PageObjectModel pageObject, TestCase testCase) {
        if (pageObject.getElements() == null || pageObject.getElements().isEmpty()) {
            return;
        }
        
        // Generate element presence verifications for each element
        for (com.cssmart.core.pom.PageElement element : pageObject.getElements()) {
            String verificationName = "verify" + capitalize(element.getName()) + "IsPresent";
            
            com.cssmart.core.pom.PageVerification verification = com.cssmart.core.pom.PageVerification.builder()
                .name(verificationName)
                .description("Verify that " + element.getDescription() + " is present")
                .type(com.cssmart.core.pom.PageVerification.VerificationType.ELEMENT_PRESENT)
                .elementName(element.getName())
                .build();
            
            pageObject.addVerification(verification);
        }
        
        // In a real implementation, you would use AI to identify additional verifications
        
        log.info("Generated {} verifications for page object", pageObject.getVerifications().size());
    }
    
    /**
     * Save page object Java code to file
     * @param pageObject Page object
     * @param code Generated code
     */
    private void savePageObjectToFile(PageObjectModel pageObject, String code) {
        try {
            // Create package directories if they don't exist
            String packagePath = pageObject.getPackageName().replace('.', '/');
            File packageDir = new File("src/main/java", packagePath);
            if (!packageDir.exists()) {
                packageDir.mkdirs();
            }
            
            // Save Java file
            File javaFile = new File(packageDir, pageObject.getClassName() + ".java");
            Files.writeString(javaFile.toPath(), code);
            
            log.info("Saved page object to: {}", javaFile.getAbsolutePath());
        } catch (Exception e) {
            log.error("Error saving page object to file", e);
            throw new RuntimeException("Failed to save page object: " + e.getMessage(), e);
        }
    }
    
    /**
     * Save test code to file
     * @param pomTestCase POM test case
     */
    private void saveTestCode(POMTestCase pomTestCase) {
        try {
            // Create package directories if they don't exist
            String packagePath = "com/cssmart/tests/generated";
            File packageDir = new File("src/main/java", packagePath);
            if (!packageDir.exists()) {
                packageDir.mkdirs();
            }
            
            // Save Java file
            File javaFile = new File(packageDir, pomTestCase.getClassName() + ".java");
            Files.writeString(javaFile.toPath(), pomTestCase.getCode());
            
            log.info("Saved POM test code to: {}", javaFile.getAbsolutePath());
        } catch (Exception e) {
            log.error("Error saving POM test code", e);
            throw new RuntimeException("Failed to save POM test code: " + e.getMessage(), e);
        }
    }
    
    /**
     * Generate an element name from element description
     * @param elementDescription Element description
     * @return Element name
     */
    private String generateElementName(String elementDescription) {
        // Replace non-alphanumeric with spaces
        String clean = elementDescription.replaceAll("[^a-zA-Z0-9]", " ");
        
        // Split into words
        String[] words = clean.trim().split("\\s+");
        
        if (words.length == 0) {
            return "element";
        }
        
        // Use camel case with first word lowercase
        StringBuilder name = new StringBuilder(words[0].toLowerCase());
        
        for (int i = 1; i < words.length; i++) {
            if (words[i].length() > 0) {
                name.append(Character.toUpperCase(words[i].charAt(0)));
                if (words[i].length() > 1) {
                    name.append(words[i].substring(1).toLowerCase());
                }
            }
        }
        
        return name.toString();
    }
    
    /**
     * Determine locator type based on element description
     * @param elementDescription Element description
     * @return Locator type
     */
    private com.cssmart.core.pom.PageElement.LocatorType determineLocatorType(String elementDescription) {
        String lowerDesc = elementDescription.toLowerCase();
        
        // In a real implementation, you would use AI to determine the best locator
        // For now, we'll use simple heuristics
        if (lowerDesc.contains("button")) {
            return com.cssmart.core.pom.PageElement.LocatorType.XPATH;
        } else if (lowerDesc.contains("link")) {
            return com.cssmart.core.pom.PageElement.LocatorType.LINK_TEXT;
        } else if (lowerDesc.contains("field") || lowerDesc.contains("input")) {
            return com.cssmart.core.pom.PageElement.LocatorType.NAME;
        } else {
            return com.cssmart.core.pom.PageElement.LocatorType.ID;
        }
    }
    
    /**
     * Generate a locator value based on element description and type
     * @param elementDescription Element description
     * @param locatorType Locator type
     * @return Locator value
     */
    private String generateLocatorValue(String elementDescription, com.cssmart.core.pom.PageElement.LocatorType locatorType) {
        // In a real implementation, you would use AI to generate appropriate locators
        // For now, we'll use simple heuristics
        switch (locatorType) {
            case ID:
                return generateElementName(elementDescription);
                
            case NAME:
                return generateElementName(elementDescription);
                
            case CLASS_NAME:
                return elementDescription.toLowerCase().replaceAll("[^a-z0-9]", "-");
                
            case TAG_NAME:
                if (elementDescription.toLowerCase().contains("button")) {
                    return "button";
                } else if (elementDescription.toLowerCase().contains("link")) {
                    return "a";
                } else if (elementDescription.toLowerCase().contains("input") || 
                           elementDescription.toLowerCase().contains("field")) {
                    return "input";
                } else {
                    return "div";
                }
                
            case XPATH:
                // Generate a simple XPath based on text contains
                return "//*[contains(text(),'" + elementDescription + "')]";
                
            case CSS:
                return "#" + generateElementName(elementDescription);
                
            case LINK_TEXT:
                return elementDescription;
                
            case PARTIAL_LINK_TEXT:
                // Use the first few words
                String[] words = elementDescription.split("\\s+");
                if (words.length > 2) {
                    return words[0] + " " + words[1];
                }
                return elementDescription;
                
            default:
                return generateElementName(elementDescription);
        }
    }
    
    /**
     * Generate an action name from a step
     * @param step Recorded step
     * @return Action name
     */
    private String generateActionName(RecordedStep step) {
        if (step.getElement() == null || step.getElement().isEmpty()) {
            return "performAction";
        }
        
        String actionPrefix;
        switch (step.getAction()) {
            case "CLICK":
                actionPrefix = "click";
                break;
            case "TYPE":
                actionPrefix = "enter";
                break;
            case "SELECT":
                actionPrefix = "select";
                break;
            case "HOVER":
                actionPrefix = "hoverOver";
                break;
            case "VERIFY_PRESENCE":
                actionPrefix = "verify";
                return actionPrefix + toProperCase(generateElementName(step.getElement())) + "IsPresent";
            case "VERIFY_TEXT":
                actionPrefix = "verify";
                return actionPrefix + toProperCase(generateElementName(step.getElement())) + "Text";
            default:
                actionPrefix = "interact";
                break;
        }
        
        return actionPrefix + toProperCase(generateElementName(step.getElement()));
    }
    
    /**
     * Map a recorded step action to a page action type
     * @param stepAction Step action
     * @return Page action type
     */
    private com.cssmart.core.pom.PageAction.ActionType mapActionType(String stepAction) {
        switch (stepAction) {
            case "CLICK":
                return com.cssmart.core.pom.PageAction.ActionType.CLICK;
            case "TYPE":
                return com.cssmart.core.pom.PageAction.ActionType.TYPE;
            case "SELECT":
                return com.cssmart.core.pom.PageAction.ActionType.SELECT;
            case "HOVER":
                return com.cssmart.core.pom.PageAction.ActionType.HOVER;
            case "NAVIGATE":
                return com.cssmart.core.pom.PageAction.ActionType.NAVIGATE;
            case "WAIT":
                return com.cssmart.core.pom.PageAction.ActionType.WAIT;
            default:
                return com.cssmart.core.pom.PageAction.ActionType.CUSTOM;
        }
    }
    
    /**
     * Convert a string to proper case (first letter of each word capitalized)
     * @param input Input string
     * @return Proper case string
     */
    private String toProperCase(String input) {
        if (input == null || input.isEmpty()) {
            return "";
        }
        
        // Replace non-alphanumeric with spaces
        String clean = input.replaceAll("[^a-zA-Z0-9]", " ");
        
        // Split into words
        String[] words = clean.trim().split("\\s+");
        StringBuilder result = new StringBuilder();
        
        for (String word : words) {
            if (word.length() > 0) {
                // Capitalize first letter of each word
                result.append(Character.toUpperCase(word.charAt(0)));
                if (word.length() > 1) {
                    result.append(word.substring(1).toLowerCase());
                }
                result.append(" ");
            }
        }
        
        return result.toString().trim();
    }
    
    /**
     * Capitalize the first letter of a string
     * @param input Input string
     * @return String with first letter capitalized
     */
    private String capitalize(String input) {
        if (input == null || input.isEmpty()) {
            return input;
        }
        return Character.toUpperCase(input.charAt(0)) + input.substring(1);
    }
}

package com.cssmart.ui.controller;

import com.cssmart.core.pom.PageObjectModel;
import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.recorder.model.POMTestCase;
import com.cssmart.ui.service.PageObjectGenerator;
import com.cssmart.ui.service.TestRecordingService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import lombok.extern.slf4j.Slf4j;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * REST controller for POM-related operations
 */
@Slf4j
@RestController
@RequestMapping("/api/pom")
public class POMRecorderController {
    
    private final PageObjectGenerator pageObjectGenerator;
    private final TestRecordingService testRecordingService;
    
    @Autowired
    public POMRecorderController(PageObjectGenerator pageObjectGenerator,
                                TestRecordingService testRecordingService) {
        this.pageObjectGenerator = pageObjectGenerator;
        this.testRecordingService = testRecordingService;
    }
    
    /**
     * Generate a page object model from a test case
     * @param id Test case ID
     * @return Generated page object model
     */
    @GetMapping("/generate/{id}")
    public ResponseEntity<PageObjectModel> generatePageObject(@PathVariable("id") String id) {
        log.info("Generating page object model for test case: {}", id);
        
        try {
            // Get the test case
            TestCase testCase = testRecordingService.getRecordedTest(id);
            
            if (testCase == null) {
                log.warn("Test case not found: {}", id);
                return ResponseEntity.notFound().build();
            }
            
            // Generate page object model
            PageObjectModel pageObject = pageObjectGenerator.generatePageObject(testCase);
            
            return ResponseEntity.ok(pageObject);
        } catch (Exception e) {
            log.error("Error generating page object model", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Convert a test case to a POM-based test case
     * @param id Test case ID
     * @return POM-based test case
     */
    @GetMapping("/convert/{id}")
    public ResponseEntity<POMTestCase> convertToPOMTestCase(@PathVariable("id") String id) {
        log.info("Converting test case to POM-based test case: {}", id);
        
        try {
            // Get the test case
            TestCase testCase = testRecordingService.getRecordedTest(id);
            
            if (testCase == null) {
                log.warn("Test case not found: {}", id);
                return ResponseEntity.notFound().build();
            }
            
            // Convert to POM test case
            POMTestCase pomTestCase = pageObjectGenerator.convertToPOMTestCase(testCase);
            
            return ResponseEntity.ok(pomTestCase);
        } catch (Exception e) {
            log.error("Error converting to POM test case", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Save a POM-based test case
     * @param pomTestCase POM test case to save
     * @return Saved POM test case
     */
    @PostMapping("/save")
    public ResponseEntity<POMTestCase> savePOMTestCase(@RequestBody POMTestCase pomTestCase) {
        log.info("Saving POM test case: {}", pomTestCase.getName());
        
        try {
            // Save using test recording service - this will handle saving both metadata and code
            TestCase savedTestCase = testRecordingService.saveRecordedTest(pomTestCase);
            
            if (savedTestCase instanceof POMTestCase) {
                return ResponseEntity.ok((POMTestCase) savedTestCase);
            } else {
                log.warn("Saved test case is not a POM test case");
                return ResponseEntity.status(500).body(null);
            }
        } catch (Exception e) {
            log.error("Error saving POM test case", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Run a POM-based test
     * @param id Test ID
     * @return Execution status
     */
    @PostMapping("/{id}/run")
    public ResponseEntity<Map<String, Object>> runPOMTest(@PathVariable("id") String id) {
        log.info("Running POM test: {}", id);
        
        try {
            // In a real implementation, this would invoke the test execution service
            // For now, return a simple status message
            Map<String, Object> result = new HashMap<>();
            result.put("status", "success");
            result.put("message", "POM test execution started");
            result.put("executionId", java.util.UUID.randomUUID().toString());
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("Error running POM test", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Get page objects for a test case
     * @param id Test case ID
     * @return List of page objects
     */
    @GetMapping("/{id}/page-objects")
    public ResponseEntity<List<PageObjectModel>> getPageObjects(@PathVariable("id") String id) {
        log.info("Getting page objects for test case: {}", id);
        
        try {
            // Get the test case
            TestCase testCase = testRecordingService.getRecordedTest(id);
            
            if (testCase == null) {
                log.warn("Test case not found: {}", id);
                return ResponseEntity.notFound().build();
            }
            
            // If it's already a POM test case, return its page objects
            if (testCase instanceof POMTestCase) {
                POMTestCase pomTestCase = (POMTestCase) testCase;
                return ResponseEntity.ok(pomTestCase.getPageObjects());
            }
            
            // Otherwise, convert it first
            POMTestCase pomTestCase = pageObjectGenerator.convertToPOMTestCase(testCase);
            
            return ResponseEntity.ok(pomTestCase.getPageObjects());
        } catch (Exception e) {
            log.error("Error getting page objects", e);
            return ResponseEntity.status(500).body(null);
        }
    }
}

// src/main/webapp/src/components/recorder/POMTestRecorder.jsx
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import RecordedSteps from './RecordedSteps';
import RecorderConfig from './RecorderConfig';
import PageObjectList from './PageObjectList';
import TestCodeViewer from './TestCodeViewer';
import Button from '../common/Button';
import Card from '../common/Card';
import Alert from '../common/Alert';
import Spinner from '../common/Spinner';
import Tabs, { Tab } from '../common/Tabs';
import { useNotification } from '../../context/NotificationContext';

const POMTestRecorder = () => {
  const navigate = useNavigate();
  const { addNotification } = useNotification();
  const [isRecording, setIsRecording] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [recordedSteps, setRecordedSteps] = useState([]);
  const [testCase, setTestCase] = useState(null);
  const [pomTestCase, setPOMTestCase] = useState(null);
  const [pageObjects, setPageObjects] = useState([]);
  const [activeTab, setActiveTab] = useState('steps');
  const [error, setError] = useState(null);
  const [successMessage, setSuccessMessage] = useState(null);
  const [config, setConfig] = useState({
    url: 'https://example.com',
    browser: 'chrome',
    headless: false,
    generatePageObjects: true
  });
  const websocket = useRef(null);
  
  // Handle WebSocket cleanup on component unmount
  useEffect(() => {
    return () => {
      if (websocket.current) {
        websocket.current.close();
      }
    };
  }, []);
  
  // Connect to WebSocket when starting recording
  const connectWebSocket = () => {
    try {
      setIsConnecting(true);
      setError(null);
      
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/recorder`;
      
      websocket.current = new WebSocket(wsUrl);
      
      websocket.current.onopen = () => {
        console.log('WebSocket connected');
        setIsConnecting(false);
        
        // Send recording configuration to the server
        websocket.current.send(JSON.stringify({ 
          type: 'START_RECORDING',
          data: config
        }));
      };
      
      websocket.current.onmessage = (event) => {
        const message = JSON.parse(event.data);
        
        if (message.type === 'RECORDING_STARTED') {
          console.log('Recording started');
          setIsRecording(true);
          addNotification('Recording started successfully!', 'success');
        } else if (message.type === 'ACTION_RECORDED') {
          console.log('Action recorded');
        } else if (message.type === 'STEP_RECORDED') {
          console.log('Step recorded:', message.data);
          setRecordedSteps(prev => [...prev, message.data]);
        } else if (message.type === 'TEST_CASE') {
          console.log('Test case received:', message.data);
          setTestCase(message.data);
          setIsRecording(false);
          
          // If POM mode is enabled, generate page objects
          if (config.generatePageObjects) {
            convertToPOMTestCase(message.data.id);
          }
        } else if (message.type === 'ERROR') {
          console.error('WebSocket error:', message.data);
          setError(`Error: ${message.data}`);
          setIsRecording(false);
          setIsConnecting(false);
          addNotification(`Recording error: ${message.data}`, 'error');
        }
      };
      
      websocket.current.onerror = (error) => {
        console.error('WebSocket error:', error);
        setError('Failed to connect to the recording service. Please check if the server is running.');
        setIsRecording(false);
        setIsConnecting(false);
        addNotification('Failed to connect to recording service', 'error');
      };
      
      websocket.current.onclose = () => {
        console.log('WebSocket disconnected');
        if (isRecording) {
          setIsRecording(false);
          addNotification('Recording connection closed', 'warning');
        }
      };
      
      return true;
    } catch (error) {
      console.error('Error connecting to WebSocket:', error);
      setError(`Connection error: ${error.message}`);
      setIsRecording(false);
      setIsConnecting(false);
      addNotification(`Connection error: ${error.message}`, 'error');
      return false;
    }
  };
  
  // Start recording
  const startRecording = () => {
    setRecordedSteps([]);
    setTestCase(null);
    setPOMTestCase(null);
    setPageObjects([]);
    setError(null);
    setSuccessMessage(null);
    
    const connected = connectWebSocket();
    if (!connected) {
      setError('Failed to start recording. Could not connect to server.');
    }
  };
  
  // Stop recording
  const stopRecording = () => {
    if (websocket.current && websocket.current.readyState === WebSocket.OPEN) {
      websocket.current.send(JSON.stringify({ type: 'STOP_RECORDING' }));
      setIsGenerating(true);
    } else {
      setError('WebSocket is not connected. Cannot stop recording.');
      addNotification('Cannot stop recording: connection lost', 'error');
    }
  };
  
  // Convert a test case to POM test case
  const convertToPOMTestCase = async (testId) => {
    try {
      setIsGenerating(true);
      
      // Call the API to convert the test case
      const response = await fetch(`/api/pom/convert/${testId}`);
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      setPOMTestCase(data);
      setPageObjects(data.pageObjects || []);
      setActiveTab('pageObjects');
      
      setIsGenerating(false);
      addNotification('Page Objects generated successfully!', 'success');
      
    } catch (error) {
      console.error('Error generating Page Objects:', error);
      setError(`Failed to generate Page Objects: ${error.message}`);
      setIsGenerating(false);
      addNotification(`Error generating Page Objects: ${error.message}`, 'error');
    }
  };
  
  // Update configuration
  const updateConfig = (newConfig) => {
    setConfig(newConfig);
  };
  
  // Save test case
  const saveTestCase = async () => {
    if (!testCase) return;
    
    try {
      // Depending on whether we're in POM mode or not, save different things
      if (pomTestCase) {
        const response = await fetch('/api/pom/save', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(pomTestCase),
        });
        
        if (!response.ok) {
          throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }
        
        const savedPomTestCase = await response.json();
        setPOMTestCase(savedPomTestCase);
        setSuccessMessage('POM test case saved successfully!');
        addNotification('POM test case saved successfully!', 'success');
      } else {
        const response = await fetch('/api/recorder/save', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(testCase),
        });
        
        if (!response.ok) {
          throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }
        
        const savedTestCase = await response.json();
        setTestCase(savedTestCase);
        setSuccessMessage('Test case saved successfully!');
        addNotification('Test case saved successfully!', 'success');
      }
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (error) {
      console.error('Error saving test case:', error);
      setError(`Failed to save test case: ${error.message}`);
      addNotification(`Failed to save test case: ${error.message}`, 'error');
    }
  };
  
  // Run test
  const runTest = async () => {
    if (!testCase) {
      setError('Please record a test first');
      return;
    }
    
    try {
      // Determine which API to call based on whether we're in POM mode
      const apiPath = pomTestCase ? `/api/pom/${testCase.id}/run` : `/api/tests/${testCase.id}/run`;
      
      const response = await fetch(apiPath, {
        method: 'POST',
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      setSuccessMessage('Test execution started successfully!');
      addNotification('Test execution started. Check Reports for results.', 'success');
      
      // Redirect to reports page after a delay
      setTimeout(() => {
        navigate('/reports');
      }, 3000);
    } catch (error) {
      console.error('Error running test:', error);
      setError(`Failed to run test: ${error.message}`);
      addNotification(`Failed to run test: ${error.message}`, 'error');
    }
  };
  
  // Switch between standard mode and POM mode
  const togglePOMMode = () => {
    if (!testCase) {
      setError('Please record a test first');
      return;
    }
    
    if (!pomTestCase && testCase) {
      // If we don't have a POM test case yet, generate one
      convertToPOMTestCase(testCase.id);
    } else {
      // Toggle between regular and POM modes
      if (activeTab === 'pageObjects' || activeTab === 'pomCode') {
        setActiveTab('steps');
      } else {
        setActiveTab('pageObjects');
      }
    }
  };
  
  // Manually regenerate page objects
  const regeneratePageObjects = () => {
    if (!testCase) {
      setError('Please record a test first');
      return;
    }
    
    convertToPOMTestCase(testCase.id);
  };
  
  return (
    <div className="space-y-6">
      {/* Header with action buttons */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold">POM Test Recorder</h1>
        <div className="flex space-x-2">
          {!isRecording ? (
            <Button
              variant="primary"
              disabled={isConnecting}
              onClick={startRecording}
            >
              {isConnecting ? (
                <>
                  <Spinner size="sm" color="white" className="mr-2" />
                  Connecting...
                </>
              ) : (
                'Start Recording'
              )}
            </Button>
          ) : (
            <Button
              variant="danger"
              onClick={stopRecording}
            >
              Stop Recording
            </Button>
          )}
        </div>
      </div>
      
      {/* Error and success messages */}
      {error && (
        <Alert
          type="error"
          title="Error"
          onClose={() => setError(null)}
        >
          {error}
        </Alert>
      )}
      
      {successMessage && (
        <Alert
          type="success"
          title="Success"
          onClose={() => setSuccessMessage(null)}
        >
          {successMessage}
        </Alert>
      )}
      
      {/* Configuration */}
      <RecorderConfig 
        config={config} 
        updateConfig={updateConfig} 
        disabled={isRecording || isConnecting}
        showPOMOptions={true}
      />
      
      {/* Content with tabs */}
      {(testCase || isRecording) && (
        <Card>
          <Tabs
            value={activeTab}
            onChange={setActiveTab}
          >
            <Tab value="steps" label="Recorded Steps">
              <RecordedSteps 
                steps={recordedSteps} 
                isRecording={isRecording}
              />
            </Tab>
            
            {pageObjects.length > 0 && (
              <Tab value="pageObjects" label="Page Objects">
                <PageObjectList 
                  pageObjects={pageObjects} 
                />
              </Tab>
            )}
            
            {testCase && (
              <Tab value="testCode" label="Test Code">
                <TestCodeViewer code={testCase.code} />
              </Tab>
            )}
            
            {pomTestCase && (
              <Tab value="pomCode" label="POM Test Code">
                <TestCodeViewer code={pomTestCase.code} />
              </Tab>
            )}
          </Tabs>
          
          {/* Action buttons */}
          <div className="mt-6 flex justify-end space-x-2">
            {testCase && (
              <>
                {config.generatePageObjects && !pomTestCase && isGenerating && (
                  <div className="flex items-center mr-auto">
                    <Spinner size="sm" className="mr-2" />
                    <span>Generating Page Objects...</span>
                  </div>
                )}
                
                <Button
                  variant={pomTestCase ? "success" : "outline"}
                  onClick={togglePOMMode}
                  disabled={isGenerating}
                >
                  {pomTestCase ? "View Regular Mode" : "Generate Page Objects"}
                </Button>
                
                <Button
                  variant="primary"
                  onClick={saveTestCase}
                  disabled={isGenerating}
                >
                  Save Test
                </Button>
                
                <Button
                  variant="secondary"
                  onClick={runTest}
                  disabled={isGenerating}
                >
                  Run Test
                </Button>
              </>
            )}
          </div>
        </Card>
      )}
      
      {/* Initial state message */}
      {!testCase && !isRecording && !isGenerating && (
        <Card>
          <div className="p-6 text-center">
            <p className="text-gray-600 mb-4">
              Click "Start Recording" to begin capturing your test steps. The recorder will create Page Object Models automatically when you stop recording.
            </p>
            <p className="text-sm text-gray-500">
              Page Object Models encapsulate page structure and behavior, making your tests more maintainable and easier to understand.
            </p>
          </div>
        </Card>
      )}
      
      {/* Processing state */}
      {isGenerating && !pomTestCase && !isRecording && (
        <Card>
          <div className="flex flex-col items-center justify-center py-8">
            <Spinner size="lg" className="mb-4" />
            <p className="text-lg text-gray-700">Generating Page Objects...</p>
            <p className="text-gray-500 text-sm mt-2">This may take a few moments as our AI analyzes your test.</p>
          </div>
        </Card>
      )}
      
      {/* Recording indicator */}
      {isRecording && (
        <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-red-600 text-white px-4 py-2 rounded-md shadow-lg animate-pulse">
          Recording in progress... Actions performed in the browser are being captured.
        </div>
      )}
    </div>
  );
};

export default POMTestRecorder;

// src/main/webapp/src/components/recorder/PageObjectList.jsx
import React, { useState } from 'react';
import Card from '../common/Card';
import TestCodeViewer from './TestCodeViewer';
import Button from '../common/Button';

const PageObjectList = ({ pageObjects = [] }) => {
  const [selectedPageObject, setSelectedPageObject] = useState(null);
  
  if (!pageObjects || pageObjects.length === 0) {
    return (
      <div className="text-gray-500 text-center py-8">
        No Page Objects available. Generate Page Objects to see them here.
      </div>
    );
  }

  // Select the first page object by default
  if (!selectedPageObject && pageObjects.length > 0) {
    setSelectedPageObject(pageObjects[0]);
  }

  return (
    <div className="mt-4">
      <div className="mb-4">
        <h3 className="text-lg font-medium text-gray-900 mb-2">Available Page Objects</h3>
        <p className="text-sm text-gray-600 mb-4">
          Page Objects encapsulate page structure and behavior, making your tests more maintainable.
        </p>
        
        <div className="flex flex-wrap gap-2 mb-4">
          {pageObjects.map((pageObject) => (
            <Button
              key={pageObject.id}
              variant={selectedPageObject && selectedPageObject.id === pageObject.id ? "primary" : "outline"}
              size="sm"
              onClick={() => setSelectedPageObject(pageObject)}
            >
              {pageObject.name}
            </Button>
          ))}
        </div>
      </div>

      {selectedPageObject && (
        <div className="space-y-4">
          <div className="bg-gray-50 p-4 rounded-lg">
            <h3 className="font-medium">{selectedPageObject.name}</h3>
            <p className="text-sm text-gray-600">{selectedPageObject.description}</p>
            {selectedPageObject.pageUrl && (
              <p className="text-sm text-gray-500 mt-1">URL: {selectedPageObject.pageUrl}</p>
            )}
          </div>
          
          <div>
            <h4 className="font-medium mb-2">Elements ({selectedPageObject.elements?.length || 0})</h4>
            {selectedPageObject.elements && selectedPageObject.elements.length > 0 ? (
              <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                {selectedPageObject.elements.map((element, index) => (
                  <div key={index} className="border rounded p-2 text-sm">
                    <div className="font-medium">{element.name}</div>
                    <div className="text-gray-600 text-xs">{element.description}</div>
                    <div className="text-gray-500 text-xs mt-1">
                      {element.locatorType}: {element.locatorValue}
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <p className="text-sm text-gray-500">No elements defined</p>
            )}
          </div>
          
          <div>
            <h4 className="font-medium mb-2">Actions ({selectedPageObject.actions?.length || 0})</h4>
            {selectedPageObject.actions && selectedPageObject.actions.length > 0 ? (
              <div className="space-y-2">
                {selectedPageObject.actions.map((action, index) => (
                  <div key={index} className="border rounded p-2 text-sm">
                    <div className="font-medium">{action.name}()</div>
                    <div className="text-gray-600 text-xs">{action.description}</div>
                    {action.elementName && (
                      <div className="text-gray-500 text-xs mt-1">
                        Element: {action.elementName}
                      </div>
                    )}
                    {action.parameters && Object.keys(action.parameters).length > 0 && (
                      <div className="text-gray-500 text-xs mt-1">
                        Parameters: {Object.keys(action.parameters).join(', ')}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ) : (
              <p className="text-sm text-gray-500">No actions defined</p>
            )}
          </div>
          
          <div>
            <h4 className="font-medium mb-2">Verifications ({selectedPageObject.verifications?.length || 0})</h4>
            {selectedPageObject.verifications && selectedPageObject.verifications.length > 0 ? (
              <div className="space-y-2">
                {selectedPageObject.verifications.map((verification, index) => (
                  <div key={index} className="border rounded p-2 text-sm">
                    <div className="font-medium">{verification.name}()</div>
                    <div className="text-gray-600 text-xs">{verification.description}</div>
                    {verification.elementName && (
                      <div className="text-gray-500 text-xs mt-1">
                        Element: {verification.elementName}
                      </div>
                    )}
                    {verification.expectedValue && (
                      <div className="text-gray-500 text-xs mt-1">
                        Expected: {verification.expectedValue}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ) : (
              <p className="text-sm text-gray-500">No verifications defined</p>
            )}
          </div>
          
          <div>
            <h4 className="font-medium mb-2">Generated Code</h4>
            <TestCodeViewer code={selectedPageObject.generateCode()} />
          </div>
        </div>
      )}
    </div>
  );
};

export default PageObjectList;

// src/main/webapp/src/components/recorder/RecorderConfig.jsx
import React, { useState, useEffect } from 'react';
import TextField from '../common/TextField';
import SelectField from '../common/SelectField';
import Checkbox from '../common/Checkbox';
import Card from '../common/Card';
import Spinner from '../common/Spinner';

const RecorderConfig = ({ 
  config, 
  updateConfig, 
  disabled = false,
  showPOMOptions = false
}) => {
  const [browserOptions, setBrowserOptions] = useState([
    { value: 'chrome', label: 'Chrome' },
    { value: 'firefox', label: 'Firefox' },
    { value: 'edge', label: 'Edge' },
    { value: 'safari', label: 'Safari' }
  ]);
  const [loading, setLoading] = useState(false);
  
  // Fetch browser configuration options from the server
  useEffect(() => {
    const fetchBrowserConfig = async () => {
      try {
        setLoading(true);
        const response = await fetch('/api/recorder/browser-config');
        
        if (response.ok) {
          const data = await response.json();
          if (data && data.browsers && Array.isArray(data.browsers)) {
            setBrowserOptions(data.browsers);
          }
        }
      } catch (error) {
        console.error('Error fetching browser configuration:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchBrowserConfig();
  }, []);
  
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    updateConfig({
      ...config,
      [name]: type === 'checkbox' ? checked : value
    });
  };
  
  return (
    <Card title="Recording Configuration">
      {loading ? (
        <div className="flex justify-center items-center py-4">
          <Spinner size="md" />
          <span className="ml-2">Loading browser options...</span>
        </div>
      ) : (
        <div className="space-y-4">
          <TextField 
            label="URL to test"
            name="url"
            placeholder="https://example.com"
            value={config.url}
            onChange={handleChange}
            disabled={disabled}
            required
            helperText="The URL where the test recording will start"
          />
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <SelectField
              label="Browser"
              name="browser"
              value={config.browser}
              onChange={handleChange}
              options={browserOptions}
              disabled={disabled}
              required
            />
            
            <div className="space-y-2">
              <Checkbox
                label="Run in headless mode"
                name="headless"
                checked={config.headless}
                onChange={handleChange}
                disabled={disabled}
              />
              
              {showPOMOptions && (
                <Checkbox
                  label="Generate Page Objects automatically"
                  name="generatePageObjects"
                  checked={config.generatePageObjects}
                  onChange={handleChange}
                  disabled={disabled}
                  helperText="Uses AI to automatically generate Page Object Models when recording stops"
                />
              )}
            </div>
          </div>
          
          {showPOMOptions && (
            <div className="bg-blue-50 p-3 rounded text-sm text-blue-900 mt-2">
              <strong>Page Object Mode:</strong> When enabled, the recorder will use AI to analyze your test steps and create page objects 
              that can be reused across multiple tests. This helps create more maintainable tests by separating page structure 
              from test logic.
            </div>
          )}
        </div>
      )}
    </Card>
  );
};

export default RecorderConfig;

// src/main/webapp/src/App.jsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, useNavigate } from 'react-router-dom';
import Navbar from './components/common/Navbar';
import Sidebar from './components/common/Sidebar';
import Dashboard from './components/dashboard/Dashboard';
import TestRecorder from './components/recorder/TestRecorder';
import POMTestRecorder from './components/recorder/POMTestRecorder';
import TestGenerator from './components/generator/TestGenerator';
import Reports from './components/reports/Reports';
import Configuration from './components/config/Configuration';
import { NotificationProvider } from './context/NotificationContext';
import { ThemeProvider } from './context/ThemeContext';

// Main layout component that includes the sidebar and content
const MainLayout = ({ children }) => {
  const navigate = useNavigate();
  
  // Handler for "New Test" button
  const handleNewTest = () => {
    // Navigate to the recorder page
    navigate('/recorder');
  };
  
  return (
    <div className="flex h-screen bg-gray-100">
      <Sidebar />
      <div className="flex-1 flex flex-col overflow-hidden">
        <Navbar onNewTest={handleNewTest} />
        <main className="flex-1 overflow-x-hidden overflow-y-auto bg-gray-100 p-4">
          {children}
        </main>
      </div>
    </div>
  );
};

const App = () => {
  return (
    <Router>
      <ThemeProvider>
        <NotificationProvider>
          <Routes>
            <Route path="/" element={
              <MainLayout>
                <Dashboard />
              </MainLayout>
            } />
            <Route path="/dashboard" element={
              <MainLayout>
                <Dashboard />
              </MainLayout>
            } />
            <Route path="/recorder" element={
              <MainLayout>
                <TestRecorder />
              </MainLayout>
            } />
            <Route path="/pom-recorder" element={
              <MainLayout>
                <POMTestRecorder />
              </MainLayout>
            } />
            <Route path="/generator" element={
              <MainLayout>
                <TestGenerator />
              </MainLayout>
            } />
            <Route path="/reports" element={
              <MainLayout>
                <Reports />
              </MainLayout>
            } />
            <Route path="/config" element={
              <MainLayout>
                <Configuration />
              </MainLayout>
            } />
            <Route path="*" element={<Navigate to="/" replace />} />
          </Routes>
        </NotificationProvider>
      </ThemeProvider>
    </Router>
  );
};

export default App;


// src/main/webapp/src/components/common/Sidebar.jsx
import React from 'react';
import { useLocation, useNavigate } from 'react-router-dom';

const Sidebar = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const currentPath = location.pathname;
  
  // Navigation items
  const navItems = [
    { 
      id: 'dashboard', 
      path: '/dashboard',
      label: 'Dashboard', 
      icon: 'M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6' 
    },
    { 
      id: 'recorder', 
      path: '/recorder',
      label: 'Test Recorder', 
      icon: 'M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z' 
    },
    { 
      id: 'pom-recorder', 
      path: '/pom-recorder',
      label: 'POM Test Recorder', 
      icon: 'M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10' 
    },
    { 
      id: 'generator', 
      path: '/generator',
      label: 'Test Generator', 
      icon: 'M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4' 
    },
    { 
      id: 'reports', 
      path: '/reports',
      label: 'Reports', 
      icon: 'M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z' 
    },
    { 
      id: 'config', 
      path: '/config',
      label: 'Configuration', 
      icon: 'M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4' 
    }
  ];

  // Navigate to the selected page
  const handleNavigation = (path) => {
    navigate(path);
  };

  return (
    <div className="bg-indigo-800 text-white w-64 space-y-6 py-7 px-2 absolute inset-y-0 left-0 transform -translate-x-full md:relative md:translate-x-0 transition duration-200 ease-in-out">
      <div className="flex items-center space-x-2 px-4">
        <svg className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12l2 2 4-4M7.835 4.697a3.42 3.42 0 001.946-.806 3.42 3.42 0 014.438 0 3.42 3.42 0 001.946.806 3.42 3.42 0 013.138 3.138 3.42 3.42 0 00.806 1.946 3.42 3.42 0 010 4.438 3.42 3.42 0 00-.806 1.946 3.42 3.42 0 01-3.138 3.138 3.42 3.42 0 00-1.946.806 3.42 3.42 0 01-4.438 0 3.42 3.42 0 00-1.946-.806 3.42 3.42 0 01-3.138-3.138 3.42 3.42 0 00-.806-1.946 3.42 3.42 0 010-4.438 3.42 3.42 0 00.806-1.946 3.42 3.42 0 013.138-3.138z" />
        </svg>
        <span className="text-lg font-extrabold">CS Smart Test</span>
      </div>
      <nav>
        {navItems.map(item => (
          <button 
            key={item.id}
            className={`block py-2.5 px-4 rounded transition duration-200 w-full text-left ${
              currentPath === item.path || (currentPath === '/' && item.path === '/dashboard') 
                ? 'bg-indigo-700' 
                : 'hover:bg-indigo-700'
            }`}
            onClick={() => handleNavigation(item.path)}
          >
            <div className="flex items-center">
              <svg className="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d={item.icon} />
              </svg>
              {item.label}
            </div>
          </button>
        ))}
      </nav>
      
      {/* Version indicator */}
      <div className="px-4 mt-auto pt-6">
        <div className="text-xs text-indigo-300 border-t border-indigo-700 pt-2">
          CS Smart Test Framework v1.0
        </div>
      </div>
    </div>
  );
};

export default Sidebar;


package com.cssmart.ai.engine;

import com.cssmart.ai.engine.model.Action;
import com.cssmart.ai.engine.model.ActionType;
import com.cssmart.ai.patterns.model.Pattern;
import com.cssmart.core.pom.PageObjectModel;
import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.recorder.model.RecordedStep;

import lombok.extern.slf4j.Slf4j;
import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.util.stream.Collectors;

/**
 * AI Engine for CS Smart Test Framework
 * Central hub for all AI-powered functionality
 */
@Slf4j
public class AIEngine {
    private static AIEngine instance;
    
    // Components
    private ElementPredictor elementPredictor;
    private PatternRecognizer patternRecognizer;
    private ActionGenerator actionGenerator;
    private LocatorGenerator locatorGenerator;
    private PageObjectAnalyzer pageObjectAnalyzer;
    
    private AIEngine() {
        this.elementPredictor = new ElementPredictor();
        this.patternRecognizer = new PatternRecognizer();
        this.actionGenerator = new ActionGenerator();
        this.locatorGenerator = new LocatorGenerator();
        this.pageObjectAnalyzer = new PageObjectAnalyzer();
        
        log.info("AI Engine initialized");
    }
    
    public static synchronized AIEngine getInstance() {
        if (instance == null) {
            instance = new AIEngine();
        }
        return instance;
    }
    
    /**
     * Enhance a test case with AI insights
     * @param testCase Test case to enhance
     * @return Enhanced test case
     */
    public TestCase enhanceTestCase(TestCase testCase) {
        try {
            log.info("Enhancing test case: {}", testCase.getName());
            
            // Extract actions from test steps
            List<Action> actions = extractActionsFromSteps(testCase);
            
            // Recognize patterns in actions
            List<Pattern> patterns = recognizePatterns(actions);
            
            // Apply patterns to improve test case
            applyPatterns(testCase, patterns);
            
            // Improve element locators
            improveElementLocators(testCase);
            
            return testCase;
        } catch (Exception e) {
            log.error("Error enhancing test case", e);
            return testCase;
        }
    }
    
    /**
     * Recognize patterns in a sequence of actions
     * @param actions List of actions
     * @return Recognized patterns
     */
    public List<Pattern> recognizePatterns(List<Action> actions) {
        try {
            log.info("Recognizing patterns in {} actions", actions.size());
            
            // Delegate to pattern recognizer
            return patternRecognizer.recognizePatterns(actions);
        } catch (Exception e) {
            log.error("Error recognizing patterns", e);
            return new ArrayList<>();
        }
    }
    
    /**
     * Generate locators for elements
     * @param elementDescription Description of the element
     * @param context Additional context (optional)
     * @return Map of locator type to locator value
     */
    public Map<String, String> generateLocators(String elementDescription, String context) {
        try {
            log.info("Generating locators for element: {}", elementDescription);
            
            // Delegate to locator generator
            return locatorGenerator.generateLocators(elementDescription, context);
        } catch (Exception e) {
            log.error("Error generating locators", e);
            return new HashMap<>();
        }
    }
    
    /**
     * Analyze a test case for Page Object Model
     * @param testCase Test case to analyze
     * @return Page Object Model recommendations
     */
    public PageObjectAnalysisResult analyzeForPageObjects(TestCase testCase) {
        try {
            log.info("Analyzing test case for Page Object Model: {}", testCase.getName());
            
            // Delegate to page object analyzer
            return pageObjectAnalyzer.analyzeTestCase(testCase);
        } catch (Exception e) {
            log.error("Error analyzing for page objects", e);
            return new PageObjectAnalysisResult();
        }
    }
    
    /**
     * Generate a Page Object Model from a test case
     * @param testCase Test case to analyze
     * @param pageName Name of the page (optional)
     * @return Generated Page Object Model
     */
    public PageObjectModel generatePageObjectModel(TestCase testCase, String pageName) {
        try {
            log.info("Generating Page Object Model for: {}", testCase.getName());
            
            // Get analysis result
            PageObjectAnalysisResult analysisResult = analyzeForPageObjects(testCase);
            
            // Use analyzer to generate the page object model
            return pageObjectAnalyzer.generatePageObjectModel(testCase, analysisResult, pageName);
        } catch (Exception e) {
            log.error("Error generating Page Object Model", e);
            return null;
        }
    }
    
    /**
     * Extract actions from test steps
     * @param testCase Test case containing steps
     * @return List of actions
     */
    private List<Action> extractActionsFromSteps(TestCase testCase) {
        List<Action> actions = new ArrayList<>();
        
        if (testCase.getSteps() != null) {
            for (RecordedStep step : testCase.getSteps()) {
                try {
                    if (step.getAction() != null) {
                        ActionType actionType = ActionType.valueOf(step.getAction());
                        Action action = new Action(actionType);
                        action.setValue(step.getValue());
                        action.setElement(step.getElement());
                        action.setDescription(step.getDescription());
                        actions.add(action);
                    }
                } catch (IllegalArgumentException e) {
                    // Skip unknown action types
                    log.warn("Unknown action type: {}", step.getAction());
                }
            }
        }
        
        return actions;
    }
    
    /**
     * Apply recognized patterns to improve a test case
     * @param testCase Test case to improve
     * @param patterns Recognized patterns
     */
    private void applyPatterns(TestCase testCase, List<Pattern> patterns) {
        if (patterns.isEmpty()) {
            return;
        }
        
        // Sort patterns by confidence
        patterns.sort((p1, p2) -> Double.compare(p2.getConfidence(), p1.getConfidence()));
        
        // Use the highest confidence pattern for naming
        Pattern topPattern = patterns.get(0);
        
        // Improve test name if it's generic
        if (testCase.getName() == null || testCase.getName().contains("Recorded Test")) {
            testCase.setName(topPattern.getName() + " Test");
        }
        
        // Improve description
        if (testCase.getDescription() == null || testCase.getDescription().isEmpty() || 
            testCase.getDescription().equals("Automatically recorded test case")) {
            testCase.setDescription(topPattern.getDescription());
        }
        
        // Improve class and method names
        if (testCase.getClassName() == null || testCase.getClassName().isEmpty() || 
            testCase.getClassName().contains("RecordedTest")) {
            String className = topPattern.getName().replaceAll("[^a-zA-Z0-9]", "") + "Test";
            testCase.setClassName(className);
        }
        
        if (testCase.getMethodName() == null || testCase.getMethodName().isEmpty() || 
            testCase.getMethodName().contains("test")) {
            String methodName = "test" + topPattern.getName().replaceAll("[^a-zA-Z0-9]", "");
            testCase.setMethodName(methodName);
        }
    }
    
    /**
     * Improve element locators in a test case
     * @param testCase Test case to improve
     */
    private void improveElementLocators(TestCase testCase) {
        if (testCase.getSteps() == null || testCase.getSteps().isEmpty()) {
            return;
        }
        
        // Map to keep track of elements we've seen
        Map<String, String> elementToLocator = new HashMap<>();
        
        for (RecordedStep step : testCase.getSteps()) {
            if (step.getElement() != null && !step.getElement().isEmpty()) {
                // If we haven't seen this element before, generate a locator
                if (!elementToLocator.containsKey(step.getElement())) {
                    Map<String, String> locators = locatorGenerator.generateLocators(step.getElement(), "");
                    if (!locators.isEmpty()) {
                        // Pick the best locator (in a real implementation, you'd use
                        // AI to determine which locator is best)
                        String bestLocator = locators.entrySet().iterator().next().getValue();
                        elementToLocator.put(step.getElement(), bestLocator);
                    }
                }
                
                // Update the step with the improved locator if available
                String improvedLocator = elementToLocator.get(step.getElement());
                if (improvedLocator != null) {
                    // In a real implementation, you would update the step's element information
                    // For now, we'll just log that we found a better locator
                    log.debug("Improved locator for element '{}': {}", step.getElement(), improvedLocator);
                }
            }
        }
    }
}

/**
 * Page Object Analyzer component
 */
@Slf4j
class PageObjectAnalyzer {
    
    /**
     * Analyze a test case for Page Object Model structure
     * @param testCase Test case to analyze
     * @return Analysis result
     */
    public PageObjectAnalysisResult analyzeTestCase(TestCase testCase) {
        PageObjectAnalysisResult result = new PageObjectAnalysisResult();
        
        if (testCase.getSteps() == null || testCase.getSteps().isEmpty()) {
            return result;
        }
        
        try {
            // Identify pages in the test
            List<String> pages = identifyPages(testCase);
            result.setPages(pages);
            
            // Identify elements in each page
            Map<String, List<String>> elementsPerPage = identifyElements(testCase, pages);
            result.setElementsPerPage(elementsPerPage);
            
            // Identify actions in each page
            Map<String, List<String>> actionsPerPage = identifyActions(testCase, pages, elementsPerPage);
            result.setActionsPerPage(actionsPerPage);
            
            return result;
        } catch (Exception e) {
            log.error("Error analyzing test case for Page Object Model", e);
            return result;
        }
    }
    
    /**
     * Generate a Page Object Model from analysis
     * @param testCase Test case
     * @param analysisResult Analysis result
     * @param pageName Optional page name
     * @return Page Object Model
     */
    public PageObjectModel generatePageObjectModel(TestCase testCase, PageObjectAnalysisResult analysisResult, String pageName) {
        try {
            // Extract page URL from navigation steps
            String pageUrl = extractPageUrl(testCase);
            
            // Determine page name if not provided
            String effectivePageName;
            if (pageName != null && !pageName.isEmpty()) {
                effectivePageName = pageName;
            } else if (analysisResult.getPages() != null && !analysisResult.getPages().isEmpty()) {
                effectivePageName = analysisResult.getPages().get(0);
            } else {
                // Extract from URL or test name
                effectivePageName = extractPageNameFromUrl(pageUrl);
                if (effectivePageName.isEmpty() && testCase.getName() != null) {
                    effectivePageName = testCase.getName() + " Page";
                }
            }
            
            // Generate class name
            String className = generateClassName(effectivePageName);
            
            // Create the Page Object Model
            PageObjectModel pageObject = PageObjectModel.builder()
                .id(java.util.UUID.randomUUID().toString())
                .name(effectivePageName)
                .description("Page Object Model for " + effectivePageName)
                .pageUrl(pageUrl)
                .packageName("com.cssmart.pom.pages")
                .className(className)
                .elements(new ArrayList<>())
                .actions(new ArrayList<>())
                .verifications(new ArrayList<>())
                .build();
            
            // Add elements and actions based on analysis
            populatePageObjectFromAnalysis(pageObject, testCase, analysisResult);
            
            return pageObject;
        } catch (Exception e) {
            log.error("Error generating Page Object Model", e);
            return null;
        }
    }
    
    /**
     * Identify pages in a test case
     * @param testCase Test case to analyze
     * @return List of page names
     */
    private List<String> identifyPages(TestCase testCase) {
        Set<String> pages = new HashSet<>();
        
        // Add a default page
        String defaultPage = "MainPage";
        pages.add(defaultPage);
        
        // Look for navigation steps to identify different pages
        for (RecordedStep step : testCase.getSteps()) {
            if ("NAVIGATE".equals(step.getAction()) && step.getValue() != null) {
                String url = step.getValue();
                String pageName = extractPageNameFromUrl(url);
                if (!pageName.isEmpty()) {
                    pages.add(pageName);
                }
            }
        }
        
        return new ArrayList<>(pages);
    }
    
    /**
     * Identify elements in each page
     * @param testCase Test case
     * @param pages List of pages
     * @return Map of page name to list of elements
     */
    private Map<String, List<String>> identifyElements(TestCase testCase, List<String> pages) {
        Map<String, List<String>> elementsPerPage = new HashMap<>();
        
        // Initialize lists for each page
        for (String page : pages) {
            elementsPerPage.put(page, new ArrayList<>());
        }
        
        // Default page for elements without explicit page assignment
        String currentPage = pages.get(0);
        
        // Track current page based on navigation steps
        for (RecordedStep step : testCase.getSteps()) {
            if ("NAVIGATE".equals(step.getAction()) && step.getValue() != null) {
                String url = step.getValue();
                String pageName = extractPageNameFromUrl(url);
                if (!pageName.isEmpty() && pages.contains(pageName)) {
                    currentPage = pageName;
                }
            }
            
            // Add element to current page if present
            if (step.getElement() != null && !step.getElement().isEmpty()) {
                List<String> elements = elementsPerPage.get(currentPage);
                if (!elements.contains(step.getElement())) {
                    elements.add(step.getElement());
                }
            }
        }
        
        return elementsPerPage;
    }
    
    /**
     * Identify actions in each page
     * @param testCase Test case
     * @param pages List of pages
     * @param elementsPerPage Map of page name to list of elements
     * @return Map of page name to list of actions
     */
    private Map<String, List<String>> identifyActions(TestCase testCase, List<String> pages, 
                                                   Map<String, List<String>> elementsPerPage) {
        Map<String, List<String>> actionsPerPage = new HashMap<>();
        
        // Initialize lists for each page
        for (String page : pages) {
            actionsPerPage.put(page, new ArrayList<>());
        }
        
        // Default page for elements without explicit page assignment
        String currentPage = pages.get(0);
        
        // Track current page based on navigation steps
        for (RecordedStep step : testCase.getSteps()) {
            if ("NAVIGATE".equals(step.getAction()) && step.getValue() != null) {
                String url = step.getValue();
                String pageName = extractPageNameFromUrl(url);
                if (!pageName.isEmpty() && pages.contains(pageName)) {
                    currentPage = pageName;
                }
                
                // Add navigate action to the page
                List<String> actions = actionsPerPage.get(currentPage);
                if (!actions.contains("navigate")) {
                    actions.add("navigate");
                }
                continue;
            }
            
            // Add action based on step
            if (step.getAction() != null && step.getElement() != null) {
                // Create an action identifier
                String actionId = step.getAction().toLowerCase() + "_" + step.getElement();
                
                List<String> actions = actionsPerPage.get(currentPage);
                if (!actions.contains(actionId)) {
                    actions.add(actionId);
                }
            }
        }
        
        return actionsPerPage;
    }
    
    /**
     * Populate a Page Object Model from analysis
     * @param pageObject Page Object Model to populate
     * @param testCase Test case
     * @param analysisResult Analysis result
     */
    private void populatePageObjectFromAnalysis(PageObjectModel pageObject, TestCase testCase, 
                                                PageObjectAnalysisResult analysisResult) {
        // Determine which page in the analysis we're using
        String pageName = pageObject.getName();
        String usePage = analysisResult.getPages().stream()
            .filter(p -> p.equals(pageName))
            .findFirst()
            .orElse(analysisResult.getPages().get(0));
        
        // Get elements for this page
        List<String> pageElements = analysisResult.getElementsPerPage().get(usePage);
        
        // Create elements
        LocatorGenerator locatorGenerator = new LocatorGenerator();
        for (String elementDescription : pageElements) {
            // Generate a name for the element
            String elementName = generateElementName(elementDescription);
            
            // Generate locators
            Map<String, String> locators = locatorGenerator.generateLocators(elementDescription, "");
            
            // Pick the best locator type and value
            com.cssmart.core.pom.PageElement.LocatorType locatorType = determineLocatorType(elementDescription);
            String locatorValue = "";
            
            if (!locators.isEmpty()) {
                // In a real implementation, you'd select the best locator
                // For simplicity, take the first one
                Map.Entry<String, String> entry = locators.entrySet().iterator().next();
                locatorValue = entry.getValue();
            } else {
                // Generate a simple locator based on the element description
                locatorValue = generateLocatorValue(elementDescription, locatorType);
            }
            
            // Create the element
            com.cssmart.core.pom.PageElement element = com.cssmart.core.pom.PageElement.builder()
                .name(elementName)
                .description(elementDescription)
                .locatorType(locatorType)
                .locatorValue(locatorValue)
                .isList(false) // For simplicity, assume elements are not lists
                .build();
            
            pageObject.addElement(element);
        }
        
        // Get actions for this page
        List<String> pageActions = analysisResult.getActionsPerPage().get(usePage);
        
        // Add a navigate action if page has a URL
        if (pageObject.getPageUrl() != null && !pageObject.getPageUrl().isEmpty()) {
            com.cssmart.core.pom.PageAction navigateAction = com.cssmart.core.pom.PageAction.builder()
                .name("navigateToPage")
                .description("Navigate to " + pageObject.getName())
                .type(com.cssmart.core.pom.PageAction.ActionType.NAVIGATE)
                .returnsPage(true)
                .build();
            
            pageObject.addAction(navigateAction);
        }
        
        // Create actions from test steps
        Map<String, com.cssmart.core.pom.PageAction> actionMap = new HashMap<>();
        
        for (RecordedStep step : testCase.getSteps()) {
            // Skip steps that don't have an element
            if (step.getElement() == null || step.getElement().isEmpty()) {
                continue;
            }
            
            // Check if this element belongs to this page
            if (!pageElements.contains(step.getElement())) {
                continue;
            }
            
            // Skip navigation steps (already handled)
            if ("NAVIGATE".equals(step.getAction())) {
                continue;
            }
            
            String elementName = generateElementName(step.getElement());
            String actionName = generateActionName(step);
            
            // Skip if we've already processed this action
            if (actionMap.containsKey(actionName)) {
                continue;
            }
            
            // Determine action type
            com.cssmart.core.pom.PageAction.ActionType actionType = mapActionType(step.getAction());
            
            // Create parameters map if needed
            Map<String, String> parameters = null;
            if ("TYPE".equals(step.getAction()) || "SELECT".equals(step.getAction())) {
                parameters = new HashMap<>();
                parameters.put("value", "Value to enter");
            }
            
            // Create the action
            com.cssmart.core.pom.PageAction action = com.cssmart.core.pom.PageAction.builder()
                .name(actionName)
                .description(step.getDescription() != null ? step.getDescription() : "Perform action on " + step.getElement())
                .type(actionType)
                .elementName(elementName)
                .parameters(parameters)
                .returnsPage(true) // For fluent API
                .build();
            
            pageObject.addAction(action);
            actionMap.put(actionName, action);
        }
        
        // Create verifications for each element
        for (com.cssmart.core.pom.PageElement element : pageObject.getElements()) {
            String verificationName = "verify" + capitalizeFirstLetter(element.getName()) + "IsPresent";
            
            com.cssmart.core.pom.PageVerification verification = com.cssmart.core.pom.PageVerification.builder()
                .name(verificationName)
                .description("Verify that " + element.getDescription() + " is present")
                .type(com.cssmart.core.pom.PageVerification.VerificationType.ELEMENT_PRESENT)
                .elementName(element.getName())
                .build();
            
            pageObject.addVerification(verification);
        }
    }
    
    /**
     * Extract page URL from test case steps
     * @param testCase Test case with steps
     * @return Page URL or empty string if not found
     */
    private String extractPageUrl(TestCase testCase) {
        if (testCase.getSteps() != null) {
            for (RecordedStep step : testCase.getSteps()) {
                if ("NAVIGATE".equals(step.getAction()) && step.getValue() != null) {
                    return step.getValue();
                }
            }
        }
        return "";
    }
    
    /**
     * Extract page name from URL
     * @param url URL to parse
     * @return Page name
     */
    private String extractPageNameFromUrl(String url) {
        if (url == null || url.isEmpty()) {
            return "";
        }
        
        try {
            // Remove protocol and domain
            String path = url.replaceAll("https?://[^/]+", "");
            
            // Split path into segments
            String[] segments = path.split("/");
            
            // Find the last non-empty segment
            for (int i = segments.length - 1; i >= 0; i--) {
                if (!segments[i].isEmpty()) {
                    // Remove any query parameters or fragments
                    String segment = segments[i].split("[?#]")[0];
                    
                    // Convert to proper case
                    if (!segment.isEmpty()) {
                        return toProperCase(segment) + "Page";
                    }
                }
            }
            
            // If we got here, use the domain
            String domain = url.replaceAll("https?://([^/]+).*", "$1");
            domain = domain.replaceAll("www\\.", "");
            
            return toProperCase(domain) + "Page";
        } catch (Exception e) {
            log.warn("Error extracting page name from URL: {}", url, e);
            return "Page";
        }
    }
    
    /**
     * Generate a class name from page name
     * @param pageName Page name
     * @return Class name
     */
    private String generateClassName(String pageName) {
        // Remove "Page" suffix if present - we'll add it back
        if (pageName.endsWith("Page")) {
            pageName = pageName.substring(0, pageName.length() - 4);
        }
        
        // Replace non-alphanumeric with spaces and split into words
        String[] words = pageName.replaceAll("[^a-zA-Z0-9]", " ").trim().split("\\s+");
        
        StringBuilder className = new StringBuilder();
        for (String word : words) {
            if (!word.isEmpty()) {
                className.append(Character.toUpperCase(word.charAt(0)))
                       .append(word.substring(1).toLowerCase());
            }
        }
        
        return className.toString() + "Page";
    }
    
    /**
     * Generate an element name from element description
     * @param elementDescription Element description
     * @return Element name
     */
    private String generateElementName(String elementDescription) {
        // Replace non-alphanumeric with spaces
        String clean = elementDescription.replaceAll("[^a-zA-Z0-9]", " ");
        
        // Split into words
        String[] words = clean.trim().split("\\s+");
        
        if (words.length == 0) {
            return "element";
        }
        
        // Use camel case with first word lowercase
        StringBuilder name = new StringBuilder(words[0].toLowerCase());
        
        for (int i = 1; i < words.length; i++) {
            if (words[i].length() > 0) {
                name.append(Character.toUpperCase(words[i].charAt(0)));
                if (words[i].length() > 1) {
                    name.append(words[i].substring(1).toLowerCase());
                }
            }
        }
        
        return name.toString();
    }
    
    /**
     * Determine locator type based on element description
     * @param elementDescription Element description
     * @return Locator type
     */
    private com.cssmart.core.pom.PageElement.LocatorType determineLocatorType(String elementDescription) {
        String lowerDesc = elementDescription.toLowerCase();
        
        // Use heuristics to determine locator type
        if (lowerDesc.contains("button")) {
            return com.cssmart.core.pom.PageElement.LocatorType.XPATH;
        } else if (lowerDesc.contains("link")) {
            return com.cssmart.core.pom.PageElement.LocatorType.LINK_TEXT;
        } else if (lowerDesc.contains("field") || lowerDesc.contains("input") || lowerDesc.contains("text")) {
            return com.cssmart.core.pom.PageElement.LocatorType.NAME;
        } else {
            return com.cssmart.core.pom.PageElement.LocatorType.ID;
        }
    }
    
    /**
     * Generate a locator value based on element description and type
     * @param elementDescription Element description
     * @param locatorType Locator type
     * @return Locator value
     */
    private String generateLocatorValue(String elementDescription, com.cssmart.core.pom.PageElement.LocatorType locatorType) {
        switch (locatorType) {
            case ID:
                return generateElementName(elementDescription);
                
            case NAME:
                return generateElementName(elementDescription);
                
            case CLASS_NAME:
                return elementDescription.toLowerCase().replaceAll("[^a-z0-9]", "-");
                
            case TAG_NAME:
                if (elementDescription.toLowerCase().contains("button")) {
                    return "button";
                } else if (elementDescription.toLowerCase().contains("link")) {
                    return "a";
                } else if (elementDescription.toLowerCase().contains("input") || 
                           elementDescription.toLowerCase().contains("field")) {
                    return "input";
                } else {
                    return "div";
                }
                
            case XPATH:
                // Generate a simple XPath based on text contains
                return "//*[contains(text(),'" + elementDescription + "')]";
                
            case CSS:
                return "#" + generateElementName(elementDescription);
                
            case LINK_TEXT:
                return elementDescription;
                
            case PARTIAL_LINK_TEXT:
                // Use the first few words
                String[] words = elementDescription.split("\\s+");
                if (words.length > 2) {
                    return words[0] + " " + words[1];
                }
                return elementDescription;
                
            default:
                return generateElementName(elementDescription);
        }
    }
    
    /**
     * Generate an action name from a step
     * @param step Recorded step
     * @return Action name
     */
    private String generateActionName(RecordedStep step) {
        if (step.getElement() == null || step.getElement().isEmpty()) {
            return "performAction";
        }
        
        String actionPrefix;
        switch (step.getAction()) {
            case "CLICK":
                actionPrefix = "click";
                break;
            case "TYPE":
                actionPrefix = "enter";
                break;
            case "SELECT":
                actionPrefix = "select";
                break;
            case "HOVER":
                actionPrefix = "hoverOver";
                break;
            case "VERIFY_PRESENCE":
                actionPrefix = "verify";
                return actionPrefix + toProperCase(generateElementName(step.getElement())) + "IsPresent";
            case "VERIFY_TEXT":
                actionPrefix = "verify";
                return actionPrefix + toProperCase(generateElementName(step.getElement())) + "Text";
            default:
                actionPrefix = "interact";
                break;
        }
        
        return actionPrefix + toProperCase(generateElementName(step.getElement()));
    }
    
    /**
     * Map a recorded step action to a page action type
     * @param stepAction Step action
     * @return Page action type
     */
    private com.cssmart.core.pom.PageAction.ActionType mapActionType(String stepAction) {
        switch (stepAction) {
            case "CLICK":
                return com.cssmart.core.pom.PageAction.ActionType.CLICK;
            case "TYPE":
                return com.cssmart.core.pom.PageAction.ActionType.TYPE;
            case "SELECT":
                return com.cssmart.core.pom.PageAction.ActionType.SELECT;
            case "HOVER":
                return com.cssmart.core.pom.PageAction.ActionType.HOVER;
            case "NAVIGATE":
                return com.cssmart.core.pom.PageAction.ActionType.NAVIGATE;
            case "WAIT":
                return com.cssmart.core.pom.PageAction.ActionType.WAIT;
            default:
                return com.cssmart.core.pom.PageAction.ActionType.CUSTOM;
        }
    }
    
    /**
     * Convert a string to proper case
     * @param input Input string
     * @return Proper case string
     */
    private String toProperCase(String input) {
        if (input == null || input.isEmpty()) {
            return "";
        }
        
        // Replace non-alphanumeric with spaces
        String clean = input.replaceAll("[^a-zA-Z0-9]", " ");
        
        // Split into words
        String[] words = clean.trim().split("\\s+");
        StringBuilder result = new StringBuilder();
        
        for (String word : words) {
            if (word.length() > 0) {
                // Capitalize first letter of each word
                result.append(Character.toUpperCase(word.charAt(0)));
                if (word.length() > 1) {
                    result.append(word.substring(1).toLowerCase());
                }
            }
        }
        
        return result.toString();
    }
    
    /**
     * Capitalize first letter of a string
     * @param input Input string
     * @return String with first letter capitalized
     */
    private String capitalizeFirstLetter(String input) {
        if (input == null || input.isEmpty()) {
            return input;
        }
        return Character.toUpperCase(input.charAt(0)) + input.substring(1);
    }
}

/**
 * Element Predictor component for predicting web elements from natural language
 */
@Slf4j
class ElementPredictor {
    
    /**
     * Predict web elements from a natural language description
     * @param description Natural language description
     * @return Predicted elements
     */
    public List<PredictedElement> predictElements(String description) {
        // Implement element prediction logic
        return new ArrayList<>();
    }
}

/**
 * Pattern Recognizer component for identifying patterns in test sequences
 */
@Slf4j
class PatternRecognizer {
    
    /**
     * Recognize patterns in a sequence of actions
     * @param actions List of actions
     * @return Recognized patterns
     */
    public List<Pattern> recognizePatterns(List<Action> actions) {
        // Implement pattern recognition logic
        List<Pattern> patterns = new ArrayList<>();
        
        // Sample pattern - in a real system, this would use ML/AI
        if (actions.size() >= 2) {
            boolean hasLogin = actions.stream()
                .anyMatch(a -> a.getElement() != null && a.getElement().toLowerCase().contains("username"));
            
            boolean hasPassword = actions.stream()
                .anyMatch(a -> a.getElement() != null && a.getElement().toLowerCase().contains("password"));
            
            boolean hasLoginButton = actions.stream()
                .anyMatch(a -> a.getElement() != null && a.getElement().toLowerCase().contains("login") && 
                          a.getType() == ActionType.CLICK);
            
            if (hasLogin && hasPassword && hasLoginButton) {
                patterns.add(new Pattern(
                    "Login",
                    "User authentication test that verifies login functionality",
                    0.9
                ));
            }
        }
        
        return patterns;
    }
}

/**
 * Action Generator component for suggesting actions for elements
 */
@Slf4j
class ActionGenerator {
    
    /**
     * Suggest actions for an element
     * @param elementType Type of element
     * @param context Additional context (optional)
     * @return Suggested actions
     */
    public List<String> suggestActions(String elementType, String context) {
        // Implement action suggestion logic
        return new ArrayList<>();
    }
}

/**
 * Locator Generator component for generating element locators
 */
@Slf4j
class LocatorGenerator {
    
    /**
     * Generate locators for an element
     * @param elementDescription Description of the element
     * @param context Additional context (optional)
     * @return Map of locator type to locator value
     */
    public Map<String, String> generateLocators(String elementDescription, String context) {
        Map<String, String> locators = new HashMap<>();
        
        // In a real implementation, this would use AI to generate appropriate locators
        // For now, just generate some sample locators
        String elementName = elementDescription.toLowerCase().replaceAll("[^a-z0-9]", "-");
        
        if (elementDescription.toLowerCase().contains("button")) {
            locators.put("xpath", "//button[contains(text(),'" + elementDescription + "')]");
            locators.put("css", "button:contains('" + elementDescription + "')");
        } else if (elementDescription.toLowerCase().contains("link")) {
            locators.put("linkText", elementDescription);
            locators.put("partialLinkText", elementDescription.split("\\s+")[0]);
        } else if (elementDescription.toLowerCase().contains("input") || 
                  elementDescription.toLowerCase().contains("field")) {
            locators.put("id", elementName);
            locators.put("name", elementName);
            locators.put("css", "input[placeholder*='" + elementDescription + "']");
        } else {
            locators.put("id", elementName);
            locators.put("css", "#" + elementName);
            locators.put("xpath", "//*[contains(text(),'" + elementDescription + "')]");
        }
        
        return locators;
    }
}

/**
 * Predicted Element model class
 */
class PredictedElement {
    private String name;
    private String description;
    private double confidence;
    private Map<String, String> locators;
    
    // Getters and setters
}

/**
 * Page Object Analysis Result class
 */
class PageObjectAnalysisResult {
    private List<String> pages = new ArrayList<>();
    private Map<String, List<String>> elementsPerPage = new HashMap<>();
    private Map<String, List<String>> actionsPerPage = new HashMap<>();
    
    // Getters and setters
    public List<String> getPages() {
        return pages;
    }
    
    public void setPages(List<String> pages) {
        this.pages = pages;
    }
    
    public Map<String, List<String>> getElementsPerPage() {
        return elementsPerPage;
    }
    
    public void setElementsPerPage(Map<String, List<String>> elementsPerPage) {
        this.elementsPerPage = elementsPerPage;
    }
    
    public Map<String, List<String>> getActionsPerPage() {
        return actionsPerPage;
    }
    
    public void setActionsPerPage(Map<String, List<String>> actionsPerPage) {
        this.actionsPerPage = actionsPerPage;
    }
}


package com.cssmart.ui.service;

import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.recorder.model.POMTestCase;
import com.cssmart.ui.recorder.model.RecordedStep;
import com.cssmart.ai.engine.AIEngine;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.UUID;

/**
 * Service for managing test recording and integration with AI
 */
@Slf4j
@Service
public class TestRecordingService {
    
    private final AIEngine aiEngine;
    private final Map<String, TestCase> recordedTests = new ConcurrentHashMap<>();
    private static final String RECORDED_TESTS_DIR = "recorded-tests";
    
    @Autowired
    public TestRecordingService(AIEngine aiEngine) {
        this.aiEngine = aiEngine;
        
        // Ensure recorded tests directory exists
        File dir = new File(RECORDED_TESTS_DIR);
        if (!dir.exists()) {
            dir.mkdirs();
        }
    }
    
    /**
     * Save a recorded test case
     * @param testCase Test case to save
     * @return Saved test case
     */
    public TestCase saveRecordedTest(TestCase testCase) {
        try {
            log.info("Saving recorded test: {}", testCase.getName());
            
            // Ensure test case has an ID
            if (testCase.getId() == null || testCase.getId().isEmpty()) {
                testCase.setId(UUID.randomUUID().toString());
            }
            
            // Use AI to enhance the test case if it hasn't been enhanced yet
            if (testCase.getCode() == null || testCase.getCode().isEmpty()) {
                testCase = aiEngine.enhanceTestCase(testCase);
            }
            
            // Store in memory
            recordedTests.put(testCase.getId(), testCase);
            
            // Save to file
            saveTestToFile(testCase);
            
            return testCase;
        } catch (Exception e) {
            log.error("Error saving recorded test", e);
            throw new RuntimeException("Failed to save recorded test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Get a recorded test by ID
     * @param id Test ID
     * @return Test case or null if not found
     */
    public TestCase getRecordedTest(String id) {
        // Try to get from memory first
        TestCase testCase = recordedTests.get(id);
        
        // If not found, try to load from file
        if (testCase == null) {
            testCase = loadTestFromFile(id);
            if (testCase != null) {
                // Put in cache for future use
                recordedTests.put(id, testCase);
            }
        }
        
        return testCase;
    }
    
    /**
     * Get all recorded tests
     * @return List of all recorded tests
     */
    public List<TestCase> getAllRecordedTests() {
        // Load any tests from files that aren't already in memory
        loadAllTestsFromFiles();
        
        return new ArrayList<>(recordedTests.values());
    }
    
    /**
     * Delete a recorded test
     * @param id Test ID to delete
     * @return True if deleted successfully
     */
    public boolean deleteRecordedTest(String id) {
        try {
            // Remove from memory
            TestCase testCase = recordedTests.remove(id);
            
            // Remove from disk if found
            if (testCase != null) {
                File testFile = new File(RECORDED_TESTS_DIR, id + ".json");
                if (testFile.exists()) {
                    testFile.delete();
                }
                
                // Also delete any Java file if exists
                if (testCase.getClassName() != null) {
                    String packageDir = "src/main/java/com/cssmart/tests/generated";
                    File javaFile = new File(packageDir, testCase.getClassName() + ".java");
                    if (javaFile.exists()) {
                        javaFile.delete();
                    }
                }
                
                return true;
            }
            
            return false;
        } catch (Exception e) {
            log.error("Error deleting recorded test", e);
            return false;
        }
    }
    
    /**
     * Create a new test case with basic information
     * @param name Test name
     * @param description Test description
     * @return New test case
     */
    public TestCase createNewTestCase(String name, String description) {
        TestCase testCase = new TestCase();
        testCase.setId(UUID.randomUUID().toString());
        testCase.setName(name != null ? name : "New Test");
        testCase.setDescription(description != null ? description : "Test created with CS Smart Test Framework");
        testCase.setSteps(new ArrayList<>());
        testCase.setClassName(generateClassName(name));
        testCase.setMethodName(generateMethodName(name));
        
        return testCase;
    }
    
    /**
     * Save test to file
     * @param testCase Test case to save
     */
    private void saveTestToFile(TestCase testCase) {
        try {
            // Create directories if they don't exist
            File dir = new File(RECORDED_TESTS_DIR);
            if (!dir.exists()) {
                dir.mkdirs();
            }
            
            // Save test as JSON
            File testFile = new File(dir, testCase.getId() + ".json");
            
            // Use Jackson to serialize to JSON
            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
            objectMapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule());
            objectMapper.disable(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
            
            objectMapper.writeValue(testFile, testCase);
            
            log.info("Saved test case to file: {}", testFile.getAbsolutePath());
            
            // If code is present, also save it as a Java file
            if (testCase.getCode() != null && !testCase.getCode().isEmpty()) {
                String packageDir = "src/main/java/com/cssmart/tests/generated";
                File packagePath = new File(packageDir);
                if (!packagePath.exists()) {
                    packagePath.mkdirs();
                }
                
                File javaFile = new File(packageDir, testCase.getClassName() + ".java");
                Files.writeString(javaFile.toPath(), testCase.getCode());
                
                log.info("Saved test code to: {}", javaFile.getAbsolutePath());
            }
        } catch (Exception e) {
            log.error("Error saving test case to file", e);
            throw new RuntimeException("Failed to save test to file: " + e.getMessage(), e);
        }
    }
    
    /**
     * Load test from file
     * @param id Test ID
     * @return Loaded test case or null if not found
     */
    private TestCase loadTestFromFile(String id) {
        try {
            File testFile = new File(RECORDED_TESTS_DIR, id + ".json");
            if (!testFile.exists()) {
                return null;
            }
            
            // Use Jackson to deserialize from JSON
            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
            objectMapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule());
            
            // Check file type based on content
            // If it contains "pageObjects" property, load as POMTestCase
            String content = Files.readString(testFile.toPath());
            if (content.contains("\"pageObjects\"") || content.contains("\"usesPageObjectModel\"")) {
                return objectMapper.readValue(testFile, POMTestCase.class);
            } else {
                return objectMapper.readValue(testFile, TestCase.class);
            }
        } catch (Exception e) {
            log.error("Error loading test case from file", e);
            return null;
        }
    }
    
    /**
     * Load all tests from files
     */
    private void loadAllTestsFromFiles() {
        try {
            File dir = new File(RECORDED_TESTS_DIR);
            if (!dir.exists()) {
                return;
            }
            
            File[] files = dir.listFiles((d, name) -> name.endsWith(".json"));
            if (files == null) {
                return;
            }
            
            for (File file : files) {
                String id = file.getName().replace(".json", "");
                if (!recordedTests.containsKey(id)) {
                    TestCase testCase = loadTestFromFile(id);
                    if (testCase != null) {
                        recordedTests.put(id, testCase);
                    }
                }
            }
        } catch (Exception e) {
            log.error("Error loading all tests from files", e);
        }
    }
    
    /**
     * Generate a class name from test name
     * @param testName Test name
     * @return Class name
     */
    private String generateClassName(String testName) {
        if (testName == null || testName.isEmpty()) {
            return "RecordedTest";
        }
        
        // Remove "Test" suffix if present - we'll add it back
        if (testName.endsWith(" Test")) {
            testName = testName.substring(0, testName.length() - 5);
        }
        
        // Replace non-alphanumeric with spaces and split into words
        String[] words = testName.replaceAll("[^a-zA-Z0-9]", " ").trim().split("\\s+");
        
        StringBuilder className = new StringBuilder();
        for (String word : words) {
            if (!word.isEmpty()) {
                className.append(Character.toUpperCase(word.charAt(0)))
                       .append(word.substring(1).toLowerCase());
            }
        }
        
        return className.toString() + "Test";
    }
    
    /**
     * Generate a method name from test name
     * @param testName Test name
     * @return Method name
     */
    private String generateMethodName(String testName) {
        if (testName == null || testName.isEmpty()) {
            return "test";
        }
        
        // Remove "Test" suffix if present
        if (testName.endsWith(" Test")) {
            testName = testName.substring(0, testName.length() - 5);
        }
        
        // Replace non-alphanumeric with spaces and split into words
        String[] words = testName.replaceAll("[^a-zA-Z0-9]", " ").trim().split("\\s+");
        
        StringBuilder methodName = new StringBuilder("test");
        for (String word : words) {
            if (!word.isEmpty()) {
                methodName.append(Character.toUpperCase(word.charAt(0)))
                         .append(word.substring(1).toLowerCase());
            }
        }
        
        return methodName.toString();
    }
}


package com.cssmart.ui.config;

import com.cssmart.ui.service.PageObjectGenerator;
import com.cssmart.ui.service.TestRecordingService;
import com.cssmart.ai.engine.AIEngine;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Configuration for Page Object Model components
 */
@Configuration
public class POMConfiguration {
    
    /**
     * Create PageObjectGenerator bean
     * @param aiEngine AI engine
     * @return PageObjectGenerator
     */
    @Bean
    public PageObjectGenerator pageObjectGenerator(AIEngine aiEngine) {
        return new PageObjectGenerator(aiEngine);
    }
    
    /**
     * Create TestRecordingService bean
     * @param aiEngine AI engine
     * @return TestRecordingService
     */
    @Bean
    public TestRecordingService testRecordingService(AIEngine aiEngine) {
        return new TestRecordingService(aiEngine);
    }
}




// POMEnhancer.java
package com.cssmart.ai.engine;

import com.cssmart.ai.engine.model.Action;
import com.cssmart.ai.engine.model.ActionType;
import com.cssmart.ai.engine.model.ElementAnalysis;
import com.cssmart.ai.engine.model.Locator;
import com.cssmart.ai.patterns.PatternMatcher;
import com.cssmart.ai.patterns.model.Pattern;
import com.cssmart.core.pom.PageObjectModel;
import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.recorder.model.RecordedStep;

import lombok.extern.slf4j.Slf4j;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;

/**
 * Enhances the AI Engine with Page Object Model capabilities
 */
@Slf4j
public class POMEnhancer {
    
    private final AIEngine aiEngine;
    private final LocatorStrategy locatorStrategy;
    private final ElementAnalyzer elementAnalyzer;
    private final ElementPredictor elementPredictor;
    private final ActionGenerator actionGenerator;
    
    public POMEnhancer(AIEngine aiEngine) {
        this.aiEngine = aiEngine;
        this.locatorStrategy = new LocatorStrategy();
        this.elementAnalyzer = new ElementAnalyzer();
        this.elementPredictor = new ElementPredictor();
        this.actionGenerator = new ActionGenerator();
    }
    
    /**
     * Analyze a test case for Page Object Model structure
     * @param testCase Test case to analyze
     * @return Analysis result with page and element information
     */
    public POMAnalysisResult analyzeForPageObjects(TestCase testCase) {
        POMAnalysisResult result = new POMAnalysisResult();
        
        if (testCase.getSteps() == null || testCase.getSteps().isEmpty()) {
            return result;
        }
        
        try {
            // Identify pages in the test
            List<String> pages = identifyPages(testCase);
            result.setPages(pages);
            
            // Identify elements in each page
            Map<String, List<String>> elementsPerPage = identifyElements(testCase, pages);
            result.setElementsPerPage(elementsPerPage);
            
            // Identify actions in each page
            Map<String, List<String>> actionsPerPage = identifyActions(testCase, pages, elementsPerPage);
            result.setActionsPerPage(actionsPerPage);
            
            return result;
        } catch (Exception e) {
            log.error("Error analyzing test case for Page Object Model", e);
            return result;
        }
    }
    
    /**
     * Generate a Page Object Model from analysis
     * @param testCase Test case
     * @param analysisResult Analysis result
     * @param pageName Optional page name
     * @return Page Object Model
     */
    public PageObjectModel generatePageObjectModel(TestCase testCase, POMAnalysisResult analysisResult, String pageName) {
        try {
            // Extract page URL from navigation steps
            String pageUrl = extractPageUrl(testCase);
            
            // Determine page name if not provided
            String effectivePageName;
            if (pageName != null && !pageName.isEmpty()) {
                effectivePageName = pageName;
            } else if (analysisResult.getPages() != null && !analysisResult.getPages().isEmpty()) {
                effectivePageName = analysisResult.getPages().get(0);
            } else {
                // Extract from URL or test name
                effectivePageName = extractPageNameFromUrl(pageUrl);
                if (effectivePageName.isEmpty() && testCase.getName() != null) {
                    effectivePageName = testCase.getName() + " Page";
                }
            }
            
            // Generate class name
            String className = generateClassName(effectivePageName);
            
            // Create the Page Object Model
            PageObjectModel pageObject = PageObjectModel.builder()
                .id(java.util.UUID.randomUUID().toString())
                .name(effectivePageName)
                .description("Page Object Model for " + effectivePageName)
                .pageUrl(pageUrl)
                .packageName("com.cssmart.pom.pages")
                .className(className)
                .elements(new ArrayList<>())
                .actions(new ArrayList<>())
                .verifications(new ArrayList<>())
                .build();
            
            // Add elements and actions based on analysis
            populatePageObjectFromAnalysis(pageObject, testCase, analysisResult);
            
            return pageObject;
        } catch (Exception e) {
            log.error("Error generating Page Object Model", e);
            return null;
        }
    }
    
    /**
     * Identify pages in a test case
     * @param testCase Test case to analyze
     * @return List of page names
     */
    private List<String> identifyPages(TestCase testCase) {
        Set<String> pages = new HashSet<>();
        
        // Add a default page
        String defaultPage = "MainPage";
        pages.add(defaultPage);
        
        // Look for navigation steps to identify different pages
        for (RecordedStep step : testCase.getSteps()) {
            if ("NAVIGATE".equals(step.getAction()) && step.getValue() != null) {
                String url = step.getValue();
                String pageName = extractPageNameFromUrl(url);
                if (!pageName.isEmpty()) {
                    pages.add(pageName);
                }
            }
        }
        
        return new ArrayList<>(pages);
    }
    
    /**
     * Identify elements in each page
     * @param testCase Test case
     * @param pages List of pages
     * @return Map of page name to list of elements
     */
    private Map<String, List<String>> identifyElements(TestCase testCase, List<String> pages) {
        Map<String, List<String>> elementsPerPage = new HashMap<>();
        
        // Initialize lists for each page
        for (String page : pages) {
            elementsPerPage.put(page, new ArrayList<>());
        }
        
        // Default page for elements without explicit page assignment
        String currentPage = pages.get(0);
        
        // Track current page based on navigation steps
        for (RecordedStep step : testCase.getSteps()) {
            if ("NAVIGATE".equals(step.getAction()) && step.getValue() != null) {
                String url = step.getValue();
                String pageName = extractPageNameFromUrl(url);
                if (!pageName.isEmpty() && pages.contains(pageName)) {
                    currentPage = pageName;
                }
            }
            
            // Add element to current page if present
            if (step.getElement() != null && !step.getElement().isEmpty()) {
                List<String> elements = elementsPerPage.get(currentPage);
                if (!elements.contains(step.getElement())) {
                    elements.add(step.getElement());
                }
            }
        }
        
        return elementsPerPage;
    }
    
    /**
     * Identify actions in each page
     * @param testCase Test case
     * @param pages List of pages
     * @param elementsPerPage Map of page name to list of elements
     * @return Map of page name to list of actions
     */
    private Map<String, List<String>> identifyActions(TestCase testCase, List<String> pages, 
                                                   Map<String, List<String>> elementsPerPage) {
        Map<String, List<String>> actionsPerPage = new HashMap<>();
        
        // Initialize lists for each page
        for (String page : pages) {
            actionsPerPage.put(page, new ArrayList<>());
        }
        
        // Default page for elements without explicit page assignment
        String currentPage = pages.get(0);
        
        // Track current page based on navigation steps
        for (RecordedStep step : testCase.getSteps()) {
            if ("NAVIGATE".equals(step.getAction()) && step.getValue() != null) {
                String url = step.getValue();
                String pageName = extractPageNameFromUrl(url);
                if (!pageName.isEmpty() && pages.contains(pageName)) {
                    currentPage = pageName;
                }
                
                // Add navigate action to the page
                List<String> actions = actionsPerPage.get(currentPage);
                if (!actions.contains("navigate")) {
                    actions.add("navigate");
                }
                continue;
            }
            
            // Add action based on step
            if (step.getAction() != null && step.getElement() != null) {
                // Create an action identifier
                String actionId = step.getAction().toLowerCase() + "_" + step.getElement();
                
                List<String> actions = actionsPerPage.get(currentPage);
                if (!actions.contains(actionId)) {
                    actions.add(actionId);
                }
            }
        }
        
        return actionsPerPage;
    }
    
    /**
     * Populate a Page Object Model from analysis
     * @param pageObject Page Object Model to populate
     * @param testCase Test case
     * @param analysisResult Analysis result
     */
    private void populatePageObjectFromAnalysis(PageObjectModel pageObject, TestCase testCase, 
                                                POMAnalysisResult analysisResult) {
        // Determine which page in the analysis we're using
        String pageName = pageObject.getName();
        String usePage = analysisResult.getPages().stream()
            .filter(p -> p.equals(pageName))
            .findFirst()
            .orElse(analysisResult.getPages().get(0));
        
        // Get elements for this page
        List<String> pageElements = analysisResult.getElementsPerPage().get(usePage);
        
        // Create elements
        for (String elementDescription : pageElements) {
            // Generate a name for the element
            String elementName = generateElementName(elementDescription);
            
            // Use ElementPredictor to generate locators
            ElementAnalysis elementAnalysis = new ElementAnalysis();
            elementAnalysis.setElementType(determineElementType(elementDescription));
            
            Map<String, String> attributes = new HashMap<>();
            attributes.put("text", elementDescription);
            elementAnalysis.setAttributes(attributes);
            
            List<Locator> locators = locatorStrategy.generateLocators(elementAnalysis);
            
            // Pick the best locator type and value
            com.cssmart.core.pom.PageElement.LocatorType locatorType = determineLocatorType(elementDescription);
            String locatorValue = "";
            
            if (!locators.isEmpty()) {
                // Pick the locator with highest confidence
                locators.sort((l1, l2) -> Double.compare(l2.getConfidence(), l1.getConfidence()));
                Locator bestLocator = locators.get(0);
                
                locatorType = mapLocatorType(bestLocator.getType());
                locatorValue = bestLocator.getValue();
            } else {
                // Generate a simple locator based on the element description
                locatorValue = generateLocatorValue(elementDescription, locatorType);
            }
            
            // Create the element
            com.cssmart.core.pom.PageElement element = com.cssmart.core.pom.PageElement.builder()
                .name(elementName)
                .description(elementDescription)
                .locatorType(locatorType)
                .locatorValue(locatorValue)
                .isList(false) // For simplicity, assume elements are not lists
                .build();
            
            pageObject.addElement(element);
        }
        
        // Get actions for this page
        List<String> pageActions = analysisResult.getActionsPerPage().get(usePage);
        
        // Add a navigate action if page has a URL
        if (pageObject.getPageUrl() != null && !pageObject.getPageUrl().isEmpty()) {
            com.cssmart.core.pom.PageAction navigateAction = com.cssmart.core.pom.PageAction.builder()
                .name("navigateToPage")
                .description("Navigate to " + pageObject.getName())
                .type(com.cssmart.core.pom.PageAction.ActionType.NAVIGATE)
                .returnsPage(true)
                .build();
            
            pageObject.addAction(navigateAction);
        }
        
        // Create actions from test steps
        Map<String, com.cssmart.core.pom.PageAction> actionMap = new HashMap<>();
        
        for (RecordedStep step : testCase.getSteps()) {
            // Skip steps that don't have an element
            if (step.getElement() == null || step.getElement().isEmpty()) {
                continue;
            }
            
            // Check if this element belongs to this page
            if (!pageElements.contains(step.getElement())) {
                continue;
            }
            
            // Skip navigation steps (already handled)
            if ("NAVIGATE".equals(step.getAction())) {
                continue;
            }
            
            String elementName = generateElementName(step.getElement());
            String actionName = generateActionName(step);
            
            // Skip if we've already processed this action
            if (actionMap.containsKey(actionName)) {
                continue;
            }
            
            // Determine action type
            com.cssmart.core.pom.PageAction.ActionType actionType = mapActionType(step.getAction());
            
            // Create parameters map if needed
            Map<String, String> parameters = null;
            if ("TYPE".equals(step.getAction()) || "SELECT".equals(step.getAction())) {
                parameters = new HashMap<>();
                parameters.put("value", "Value to enter");
            }
            
            // Create the action
            com.cssmart.core.pom.PageAction action = com.cssmart.core.pom.PageAction.builder()
                .name(actionName)
                .description(step.getDescription() != null ? step.getDescription() : "Perform action on " + step.getElement())
                .type(actionType)
                .elementName(elementName)
                .parameters(parameters)
                .returnsPage(true) // For fluent API
                .build();
            
            pageObject.addAction(action);
            actionMap.put(actionName, action);
        }
        
        // Create verifications for each element
        for (com.cssmart.core.pom.PageElement element : pageObject.getElements()) {
            String verificationName = "verify" + capitalizeFirstLetter(element.getName()) + "IsPresent";
            
            com.cssmart.core.pom.PageVerification verification = com.cssmart.core.pom.PageVerification.builder()
                .name(verificationName)
                .description("Verify that " + element.getDescription() + " is present")
                .type(com.cssmart.core.pom.PageVerification.VerificationType.ELEMENT_PRESENT)
                .elementName(element.getName())
                .build();
            
            pageObject.addVerification(verification);
        }
    }
    
    /**
     * Extract page URL from test case steps
     * @param testCase Test case with steps
     * @return Page URL or empty string if not found
     */
    private String extractPageUrl(TestCase testCase) {
        if (testCase.getSteps() != null) {
            for (RecordedStep step : testCase.getSteps()) {
                if ("NAVIGATE".equals(step.getAction()) && step.getValue() != null) {
                    return step.getValue();
                }
            }
        }
        return "";
    }
    
    /**
     * Extract page name from URL
     * @param url URL to parse
     * @return Page name
     */
    private String extractPageNameFromUrl(String url) {
        if (url == null || url.isEmpty()) {
            return "";
        }
        
        try {
            // Remove protocol and domain
            String path = url.replaceAll("https?://[^/]+", "");
            
            // Split path into segments
            String[] segments = path.split("/");
            
            // Find the last non-empty segment
            for (int i = segments.length - 1; i >= 0; i--) {
                if (!segments[i].isEmpty()) {
                    // Remove any query parameters or fragments
                    String segment = segments[i].split("[?#]")[0];
                    
                    // Convert to proper case
                    if (!segment.isEmpty()) {
                        return toProperCase(segment) + "Page";
                    }
                }
            }
            
            // If we got here, use the domain
            String domain = url.replaceAll("https?://([^/]+).*", "$1");
            domain = domain.replaceAll("www\\.", "");
            
            return toProperCase(domain) + "Page";
        } catch (Exception e) {
            log.warn("Error extracting page name from URL: {}", url, e);
            return "Page";
        }
    }
    
    /**
     * Generate a class name from page name
     * @param pageName Page name
     * @return Class name
     */
    private String generateClassName(String pageName) {
        // Remove "Page" suffix if present - we'll add it back
        if (pageName.endsWith("Page")) {
            pageName = pageName.substring(0, pageName.length() - 4);
        }
        
        // Replace non-alphanumeric with spaces and split into words
        String[] words = pageName.replaceAll("[^a-zA-Z0-9]", " ").trim().split("\\s+");
        
        StringBuilder className = new StringBuilder();
        for (String word : words) {
            if (!word.isEmpty()) {
                className.append(Character.toUpperCase(word.charAt(0)))
                       .append(word.substring(1).toLowerCase());
            }
        }
        
        return className.toString() + "Page";
    }
    
    /**
     * Generate an element name from element description
     * @param elementDescription Element description
     * @return Element name
     */
    private String generateElementName(String elementDescription) {
        // Replace non-alphanumeric with spaces
        String clean = elementDescription.replaceAll("[^a-zA-Z0-9]", " ");
        
        // Split into words
        String[] words = clean.trim().split("\\s+");
        
        if (words.length == 0) {
            return "element";
        }
        
        // Use camel case with first word lowercase
        StringBuilder name = new StringBuilder(words[0].toLowerCase());
        
        for (int i = 1; i < words.length; i++) {
            if (words[i].length() > 0) {
                name.append(Character.toUpperCase(words[i].charAt(0)));
                if (words[i].length() > 1) {
                    name.append(words[i].substring(1).toLowerCase());
                }
            }
        }
        
        return name.toString();
    }
    
    /**
     * Determine element type based on description
     * @param description Element description
     * @return Element type
     */
    private String determineElementType(String description) {
        String lowerDesc = description.toLowerCase();
        
        if (lowerDesc.contains("button")) {
            return "button";
        } else if (lowerDesc.contains("link")) {
            return "a";
        } else if (lowerDesc.contains("field") || lowerDesc.contains("input") || lowerDesc.contains("text")) {
            return "input";
        } else if (lowerDesc.contains("select") || lowerDesc.contains("dropdown")) {
            return "select";
        } else if (lowerDesc.contains("checkbox")) {
            return "input";
        } else if (lowerDesc.contains("radio")) {
            return "input";
        } else {
            return "div";
        }
    }
    
    /**
     * Determine locator type based on element description
     * @param elementDescription Element description
     * @return Locator type
     */
    private com.cssmart.core.pom.PageElement.LocatorType determineLocatorType(String elementDescription) {
        String lowerDesc = elementDescription.toLowerCase();
        
        // Use heuristics to determine locator type
        if (lowerDesc.contains("button")) {
            return com.cssmart.core.pom.PageElement.LocatorType.XPATH;
        } else if (lowerDesc.contains("link")) {
            return com.cssmart.core.pom.PageElement.LocatorType.LINK_TEXT;
        } else if (lowerDesc.contains("field") || lowerDesc.contains("input") || lowerDesc.contains("text")) {
            return com.cssmart.core.pom.PageElement.LocatorType.NAME;
        } else {
            return com.cssmart.core.pom.PageElement.LocatorType.ID;
        }
    }
    
    /**
     * Map LocatorType to PageElement.LocatorType
     * @param locatorType LocatorType from AI engine
     * @return LocatorType for Page Element
     */
    private com.cssmart.core.pom.PageElement.LocatorType mapLocatorType(com.cssmart.ai.engine.model.LocatorType locatorType) {
        switch (locatorType) {
            case ID:
                return com.cssmart.core.pom.PageElement.LocatorType.ID;
            case NAME:
                return com.cssmart.core.pom.PageElement.LocatorType.NAME;
            case CLASS_NAME:
                return com.cssmart.core.pom.PageElement.LocatorType.CLASS_NAME;
            case TAG_NAME:
                return com.cssmart.core.pom.PageElement.LocatorType.TAG_NAME;
            case XPATH:
                return com.cssmart.core.pom.PageElement.LocatorType.XPATH;
            case CSS:
                return com.cssmart.core.pom.PageElement.LocatorType.CSS;
            case LINK_TEXT:
                return com.cssmart.core.pom.PageElement.LocatorType.LINK_TEXT;
            case PARTIAL_LINK_TEXT:
                return com.cssmart.core.pom.PageElement.LocatorType.PARTIAL_LINK_TEXT;
            default:
                return com.cssmart.core.pom.PageElement.LocatorType.ID;
        }
    }
    
    /**
     * Generate a locator value based on element description and type
     * @param elementDescription Element description
     * @param locatorType Locator type
     * @return Locator value
     */
    private String generateLocatorValue(String elementDescription, com.cssmart.core.pom.PageElement.LocatorType locatorType) {
        switch (locatorType) {
            case ID:
                return generateElementName(elementDescription);
                
            case NAME:
                return generateElementName(elementDescription);
                
            case CLASS_NAME:
                return elementDescription.toLowerCase().replaceAll("[^a-z0-9]", "-");
                
            case TAG_NAME:
                if (elementDescription.toLowerCase().contains("button")) {
                    return "button";
                } else if (elementDescription.toLowerCase().contains("link")) {
                    return "a";
                } else if (elementDescription.toLowerCase().contains("input") || 
                           elementDescription.toLowerCase().contains("field")) {
                    return "input";
                } else {
                    return "div";
                }
                
            case XPATH:
                // Generate a simple XPath based on text contains
                return "//*[contains(text(),'" + elementDescription + "')]";
                
            case CSS:
                return "#" + generateElementName(elementDescription);
                
            case LINK_TEXT:
                return elementDescription;
                
            case PARTIAL_LINK_TEXT:
                // Use the first few words
                String[] words = elementDescription.split("\\s+");
                if (words.length > 2) {
                    return words[0] + " " + words[1];
                }
                return elementDescription;
                
            default:
                return generateElementName(elementDescription);
        }
    }
    
    /**
     * Generate an action name from a step
     * @param step Recorded step
     * @return Action name
     */
    private String generateActionName(RecordedStep step) {
        if (step.getElement() == null || step.getElement().isEmpty()) {
            return "performAction";
        }
        
        String actionPrefix;
        switch (step.getAction()) {
            case "CLICK":
                actionPrefix = "click";
                break;
            case "TYPE":
                actionPrefix = "enter";
                break;
            case "SELECT":
                actionPrefix = "select";
                break;
            case "HOVER":
                actionPrefix = "hoverOver";
                break;
            case "VERIFY_PRESENCE":
                actionPrefix = "verify";
                return actionPrefix + toProperCase(generateElementName(step.getElement())) + "IsPresent";
            case "VERIFY_TEXT":
                actionPrefix = "verify";
                return actionPrefix + toProperCase(generateElementName(step.getElement())) + "Text";
            default:
                actionPrefix = "interact";
                break;
        }
        
        return actionPrefix + toProperCase(generateElementName(step.getElement()));
    }
    
    /**
     * Map a recorded step action to a page action type
     * @param stepAction Step action
     * @return Page action type
     */
    private com.cssmart.core.pom.PageAction.ActionType mapActionType(String stepAction) {
        switch (stepAction) {
            case "CLICK":
                return com.cssmart.core.pom.PageAction.ActionType.CLICK;
            case "TYPE":
                return com.cssmart.core.pom.PageAction.ActionType.TYPE;
            case "SELECT":
                return com.cssmart.core.pom.PageAction.ActionType.SELECT;
            case "HOVER":
                return com.cssmart.core.pom.PageAction.ActionType.HOVER;
            case "NAVIGATE":
                return com.cssmart.core.pom.PageAction.ActionType.NAVIGATE;
            case "WAIT":
                return com.cssmart.core.pom.PageAction.ActionType.WAIT;
            default:
                return com.cssmart.core.pom.PageAction.ActionType.CUSTOM;
        }
    }
    
    /**
     * Convert a string to proper case
     * @param input Input string
     * @return Proper case string
     */
    private String toProperCase(String input) {
        if (input == null || input.isEmpty()) {
            return "";
        }
        
        // Replace non-alphanumeric with spaces
        String clean = input.replaceAll("[^a-zA-Z0-9]", " ");
        
        // Split into words
        String[] words = clean.trim().split("\\s+");
        StringBuilder result = new StringBuilder();
        
        for (String word : words) {
            if (word.length() > 0) {
                // Capitalize first letter of each word
                result.append(Character.toUpperCase(word.charAt(0)));
                if (word.length() > 1) {
                    result.append(word.substring(1).toLowerCase());
                }
            }
        }
        
        return result.toString();
    }
    
    /**
     * Capitalize first letter of a string
     * @param input Input string
     * @return String with first letter capitalized
     */
    private String capitalizeFirstLetter(String input) {
        if (input == null || input.isEmpty()) {
            return input;
        }
        return Character.toUpperCase(input.charAt(0)) + input.substring(1);
    }
}

/**
 * Result of POM analysis
 */
class POMAnalysisResult {
    private List<String> pages = new ArrayList<>();
    private Map<String, List<String>> elementsPerPage = new HashMap<>();
    private Map<String, List<String>> actionsPerPage = new HashMap<>();
    
    // Getters and setters
    public List<String> getPages() {
        return pages;
    }
    
    public void setPages(List<String> pages) {
        this.pages = pages;
    }
    
    public Map<String, List<String>> getElementsPerPage() {
        return elementsPerPage;
    }
    
    public void setElementsPerPage(Map<String, List<String>> elementsPerPage) {
        this.elementsPerPage = elementsPerPage;
    }
    
    public Map<String, List<String>> getActionsPerPage() {
        return actionsPerPage;
    }
    
    public void setActionsPerPage(Map<String, List<String>> actionsPerPage) {
        this.actionsPerPage = actionsPerPage;
    }
}

// Add these methods to your AIEngine.java

/**
 * Analyze a test case for Page Object Model
 * @param testCase Test case to analyze
 * @return Analysis result with page structure information
 */
public POMAnalysisResult analyzeForPageObjects(TestCase testCase) {
    // Create a POM enhancer and delegate the analysis
    POMEnhancer pomEnhancer = new POMEnhancer(this);
    return pomEnhancer.analyzeForPageObjects(testCase);
}

/**
 * Generate a Page Object Model from a test case
 * @param testCase Test case to analyze
 * @param pageName Optional page name
 * @return Generated Page Object Model
 */
public PageObjectModel generatePageObjectModel(TestCase testCase, String pageName) {
    POMEnhancer pomEnhancer = new POMEnhancer(this);
    POMAnalysisResult analysisResult = pomEnhancer.analyzeForPageObjects(testCase);
    return pomEnhancer.generatePageObjectModel(testCase, analysisResult, pageName);
}

/**
 * Enhance a test case with Page Object support
 * @param testCase Test case to enhance
 * @return Enhanced POM test case
 */
public POMTestCase enhanceWithPOM(TestCase testCase) {
    if (testCase instanceof POMTestCase) {
        return (POMTestCase) testCase;
    }
    
    // Create a new POM test case from the regular one
    POMTestCase pomTestCase = new POMTestCase(testCase);
    
    // Generate a page object for the test
    PageObjectModel pageObject = generatePageObjectModel(testCase, null);
    
    // Add to POM test case
    if (pageObject != null) {
        pomTestCase.addPageObject(pageObject);
        pomTestCase.setCode(pomTestCase.generatePOMCode());
    }
    
    return pomTestCase;
}


// PageObjectGenerator.java - Updated to use AIEngine integration
package com.cssmart.ui.service;

import com.cssmart.ai.engine.AIEngine;
import com.cssmart.ai.engine.POMAnalysisResult;
import com.cssmart.core.pom.PageObjectModel;
import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.recorder.model.POMTestCase;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.ArrayList;

/**
 * Service for generating Page Object Models using AI
 */
@Slf4j
@Service
public class PageObjectGenerator {
    
    private final AIEngine aiEngine;
    private static final String POM_DIR = "src/main/java/com/cssmart/pom/pages";
    
    @Autowired
    public PageObjectGenerator(AIEngine aiEngine) {
        this.aiEngine = aiEngine;
        
        // Ensure directory exists
        File pomDir = new File(POM_DIR);
        if (!pomDir.exists()) {
            pomDir.mkdirs();
        }
    }
    
    /**
     * Generate a Page Object Model from a test case
     * @param testCase Test case to analyze
     * @return Generated Page Object Model
     */
    public PageObjectModel generatePageObject(TestCase testCase) {
        log.info("Generating Page Object Model for test case: {}", testCase.getName());
        
        try {
            // Use AIEngine to generate Page Object Model
            PageObjectModel pageObject = aiEngine.generatePageObjectModel(testCase, null);
            
            // Save generated code
            savePageObjectToFile(pageObject);
            
            return pageObject;
        } catch (Exception e) {
            log.error("Error generating Page Object Model", e);
            throw new RuntimeException("Failed to generate Page Object Model: " + e.getMessage(), e);
        }
    }
    
    /**
     * Convert a test case to a POM-based test case
     * @param testCase Original test case
     * @return POM-based test case
     */
    public POMTestCase convertToPOMTestCase(TestCase testCase) {
        log.info("Converting test case to POM-based test case: {}", testCase.getName());
        
        try {
            // Use AIEngine to enhance test case with POM
            POMTestCase pomTestCase = aiEngine.enhanceWithPOM(testCase);
            
            // Save the POM test code
            saveTestCode(pomTestCase);
            
            return pomTestCase;
        } catch (Exception e) {
            log.error("Error converting to POM test case", e);
            throw new RuntimeException("Failed to convert to POM test case: " + e.getMessage(), e);
        }
    }
    
    /**
     * Save page object Java code to file
     * @param pageObject Page object
     */
    private void savePageObjectToFile(PageObjectModel pageObject) {
        try {
            // Create package directories if they don't exist
            String packagePath = pageObject.getPackageName().replace('.', '/');
            File packageDir = new File("src/main/java", packagePath);
            if (!packageDir.exists()) {
                packageDir.mkdirs();
            }
            
            // Save Java file
            File javaFile = new File(packageDir, pageObject.getClassName() + ".java");
            Files.writeString(javaFile.toPath(), pageObject.generateCode());
            
            log.info("Saved page object to: {}", javaFile.getAbsolutePath());
        } catch (Exception e) {
            log.error("Error saving page object to file", e);
            throw new RuntimeException("Failed to save page object: " + e.getMessage(), e);
        }
    }
    
    /**
     * Save test code to file
     * @param pomTestCase POM test case
     */
    private void saveTestCode(POMTestCase pomTestCase) {
        try {
            // Create package directories if they don't exist
            String packagePath = "com/cssmart/tests/generated";
            File packageDir = new File("src/main/java", packagePath);
            if (!packageDir.exists()) {
                packageDir.mkdirs();
            }
            
            // Save Java file
            File javaFile = new File(packageDir, pomTestCase.getClassName() + ".java");
            Files.writeString(javaFile.toPath(), pomTestCase.getCode());
            
            log.info("Saved POM test code to: {}", javaFile.getAbsolutePath());
        } catch (Exception e) {
            log.error("Error saving POM test code", e);
            throw new RuntimeException("Failed to save POM test code: " + e.getMessage(), e);
        }
    }
}


// src/main/webapp/src/components/recorder/POMTestRecorder.jsx
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import RecordedSteps from './RecordedSteps';
import RecorderConfig from './RecorderConfig';
import PageObjectList from './PageObjectList';
import TestCodeViewer from './TestCodeViewer';
import Button from '../common/Button';
import Card from '../common/Card';
import Alert from '../common/Alert';
import Spinner from '../common/Spinner';
import { useNotification } from '../../context/NotificationContext';

// Import the tabs separately to avoid potential import issues
import Tabs from '../common/Tabs';
import { Tab } from '../common/Tabs';

const POMTestRecorder = () => {
  const navigate = useNavigate();
  const { addNotification } = useNotification();
  const [isRecording, setIsRecording] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [recordedSteps, setRecordedSteps] = useState([]);
  const [testCase, setTestCase] = useState(null);
  const [pomTestCase, setPOMTestCase] = useState(null);
  const [pageObjects, setPageObjects] = useState([]);
  const [activeTab, setActiveTab] = useState('steps');
  const [error, setError] = useState(null);
  const [successMessage, setSuccessMessage] = useState(null);
  const [config, setConfig] = useState({
    url: 'https://example.com',
    browser: 'chrome',
    headless: false,
    generatePageObjects: true
  });
  const websocket = useRef(null);
  
  // Handle WebSocket cleanup on component unmount
  useEffect(() => {
    return () => {
      if (websocket.current) {
        websocket.current.close();
      }
    };
  }, []);
  
  // Connect to WebSocket when starting recording
  const connectWebSocket = () => {
    try {
      setIsConnecting(true);
      setError(null);
      
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/recorder`;
      
      websocket.current = new WebSocket(wsUrl);
      
      websocket.current.onopen = () => {
        console.log('WebSocket connected');
        setIsConnecting(false);
        
        // Send recording configuration to the server
        websocket.current.send(JSON.stringify({ 
          type: 'START_RECORDING',
          data: config
        }));
      };
      
      websocket.current.onmessage = (event) => {
        const message = JSON.parse(event.data);
        
        if (message.type === 'RECORDING_STARTED') {
          console.log('Recording started, current state:', { isRecording, recordedSteps });
          try {
            // Use a function form to avoid closure issues
            setIsRecording(() => true);
            console.log('Recording state updated');
            // Add notification after state update
            setTimeout(() => {
              addNotification('Recording started successfully!', 'success');
            }, 0);
          } catch (e) {
            console.error('Error updating recording state:', e);
          }
        } else if (message.type === 'ACTION_RECORDED') {
          console.log('Action recorded');
        } else if (message.type === 'STEP_RECORDED') {
          console.log('Step recorded:', message.data);
          setRecordedSteps(prev => [...prev, message.data]);
        } else if (message.type === 'TEST_CASE') {
          console.log('Test case received:', message.data);
          setTestCase(message.data);
          setIsRecording(false);
          
          // If POM mode is enabled, generate page objects
          if (config.generatePageObjects) {
            convertToPOMTestCase(message.data.id);
          }
        } else if (message.type === 'ERROR') {
          console.error('WebSocket error:', message.data);
          setError(`Error: ${message.data}`);
          setIsRecording(false);
          setIsConnecting(false);
          addNotification(`Recording error: ${message.data}`, 'error');
        }
      };
      
      websocket.current.onerror = (error) => {
        console.error('WebSocket error:', error);
        setError('Failed to connect to the recording service. Please check if the server is running.');
        setIsRecording(false);
        setIsConnecting(false);
        addNotification('Failed to connect to recording service', 'error');
      };
      
      websocket.current.onclose = () => {
        console.log('WebSocket disconnected');
        if (isRecording) {
          setIsRecording(false);
          addNotification('Recording connection closed', 'warning');
        }
      };
      
      return true;
    } catch (error) {
      console.error('Error connecting to WebSocket:', error);
      setError(`Connection error: ${error.message}`);
      setIsRecording(false);
      setIsConnecting(false);
      addNotification(`Connection error: ${error.message}`, 'error');
      return false;
    }
  };
  
  // Start recording
  const startRecording = () => {
    setRecordedSteps([]);
    setTestCase(null);
    setPOMTestCase(null);
    setPageObjects([]);
    setError(null);
    setSuccessMessage(null);
    
    const connected = connectWebSocket();
    if (!connected) {
      setError('Failed to start recording. Could not connect to server.');
    }
  };
  
  // Stop recording
  const stopRecording = () => {
    if (websocket.current && websocket.current.readyState === WebSocket.OPEN) {
      websocket.current.send(JSON.stringify({ type: 'STOP_RECORDING' }));
      setIsGenerating(true);
    } else {
      setError('WebSocket is not connected. Cannot stop recording.');
      addNotification('Cannot stop recording: connection lost', 'error');
    }
  };
  
  // Convert a test case to POM test case
  const convertToPOMTestCase = async (testId) => {
    try {
      setIsGenerating(true);
      
      // Call the API to convert the test case
      const response = await fetch(`/api/pom/convert/${testId}`);
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      setPOMTestCase(data);
      setPageObjects(data.pageObjects || []);
      setActiveTab('pageObjects');
      
      setIsGenerating(false);
      addNotification('Page Objects generated successfully!', 'success');
      
    } catch (error) {
      console.error('Error generating Page Objects:', error);
      setError(`Failed to generate Page Objects: ${error.message}`);
      setIsGenerating(false);
      addNotification(`Error generating Page Objects: ${error.message}`, 'error');
    }
  };
  
  // Update configuration
  const updateConfig = (newConfig) => {
    setConfig(newConfig);
  };
  
  // Save test case
  const saveTestCase = async () => {
    if (!testCase) return;
    
    try {
      // Depending on whether we're in POM mode or not, save different things
      if (pomTestCase) {
        const response = await fetch('/api/pom/save', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(pomTestCase),
        });
        
        if (!response.ok) {
          throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }
        
        const savedPomTestCase = await response.json();
        setPOMTestCase(savedPomTestCase);
        setSuccessMessage('POM test case saved successfully!');
        addNotification('POM test case saved successfully!', 'success');
      } else {
        const response = await fetch('/api/recorder/save', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(testCase),
        });
        
        if (!response.ok) {
          throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }
        
        const savedTestCase = await response.json();
        setTestCase(savedTestCase);
        setSuccessMessage('Test case saved successfully!');
        addNotification('Test case saved successfully!', 'success');
      }
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (error) {
      console.error('Error saving test case:', error);
      setError(`Failed to save test case: ${error.message}`);
      addNotification(`Failed to save test case: ${error.message}`, 'error');
    }
  };
  
  // Run test
  const runTest = async () => {
    if (!testCase) {
      setError('Please record a test first');
      return;
    }
    
    try {
      // Determine which API to call based on whether we're in POM mode
      const apiPath = pomTestCase ? `/api/pom/${testCase.id}/run` : `/api/tests/${testCase.id}/run`;
      
      const response = await fetch(apiPath, {
        method: 'POST',
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      setSuccessMessage('Test execution started successfully!');
      addNotification('Test execution started. Check Reports for results.', 'success');
      
      // Redirect to reports page after a delay
      setTimeout(() => {
        navigate('/reports');
      }, 3000);
    } catch (error) {
      console.error('Error running test:', error);
      setError(`Failed to run test: ${error.message}`);
      addNotification(`Failed to run test: ${error.message}`, 'error');
    }
  };
  
  // Switch between standard mode and POM mode
  const togglePOMMode = () => {
    if (!testCase) {
      setError('Please record a test first');
      return;
    }
    
    if (!pomTestCase && testCase) {
      // If we don't have a POM test case yet, generate one
      convertToPOMTestCase(testCase.id);
    } else {
      // Toggle between regular and POM modes
      if (activeTab === 'pageObjects' || activeTab === 'pomCode') {
        setActiveTab('steps');
      } else {
        setActiveTab('pageObjects');
      }
    }
  };

  // Render content based on active tab without using Tabs component
  const renderTabContent = () => {
    switch (activeTab) {
      case 'steps':
        return (
          <RecordedSteps 
            steps={recordedSteps} 
            isRecording={isRecording}
          />
        );
      case 'pageObjects':
        return pageObjects.length > 0 ? (
          <PageObjectList 
            pageObjects={pageObjects} 
          />
        ) : null;
      case 'testCode':
        return testCase ? (
          <TestCodeViewer code={testCase.code} />
        ) : null;
      case 'pomCode':
        return pomTestCase ? (
          <TestCodeViewer code={pomTestCase.code} />
        ) : null;
      default:
        return (
          <RecordedSteps 
            steps={recordedSteps} 
            isRecording={isRecording}
          />
        );
    }
  };
  
  return (
    <div className="space-y-6">
      {/* Header with action buttons */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold">POM Test Recorder</h1>
        <div className="flex space-x-2">
          {!isRecording ? (
            <Button
              variant="primary"
              disabled={isConnecting}
              onClick={startRecording}
            >
              {isConnecting ? (
                <>
                  <Spinner size="sm" color="white" className="mr-2" />
                  Connecting...
                </>
              ) : (
                'Start Recording'
              )}
            </Button>
          ) : (
            <Button
              variant="danger"
              onClick={stopRecording}
            >
              Stop Recording
            </Button>
          )}
        </div>
      </div>
      
      {/* Error and success messages */}
      {error && (
        <Alert
          type="error"
          title="Error"
          onClose={() => setError(null)}
        >
          {error}
        </Alert>
      )}
      
      {successMessage && (
        <Alert
          type="success"
          title="Success"
          onClose={() => setSuccessMessage(null)}
        >
          {successMessage}
        </Alert>
      )}
      
      {/* Configuration */}
      <RecorderConfig 
        config={config} 
        updateConfig={updateConfig} 
        disabled={isRecording || isConnecting}
        showPOMOptions={true}
      />
      
      {/* Content with tabs - simplified to avoid Tabs component issue */}
      {(testCase || isRecording) && (
        <Card>
          {/* Custom tab navigation */}
          <div className="border-b mb-4">
            <div className="flex">
              <button
                className={`px-4 py-2 text-sm font-medium border-b-2 ${
                  activeTab === 'steps' 
                    ? 'text-indigo-600 border-indigo-600' 
                    : 'text-gray-500 border-transparent hover:text-gray-700 hover:border-gray-300'
                }`}
                onClick={() => setActiveTab('steps')}
              >
                Recorded Steps
              </button>
              
              {pageObjects.length > 0 && (
                <button
                  className={`px-4 py-2 text-sm font-medium border-b-2 ${
                    activeTab === 'pageObjects' 
                      ? 'text-indigo-600 border-indigo-600' 
                      : 'text-gray-500 border-transparent hover:text-gray-700 hover:border-gray-300'
                  }`}
                  onClick={() => setActiveTab('pageObjects')}
                >
                  Page Objects
                </button>
              )}
              
              {testCase && (
                <button
                  className={`px-4 py-2 text-sm font-medium border-b-2 ${
                    activeTab === 'testCode' 
                      ? 'text-indigo-600 border-indigo-600' 
                      : 'text-gray-500 border-transparent hover:text-gray-700 hover:border-gray-300'
                  }`}
                  onClick={() => setActiveTab('testCode')}
                >
                  Test Code
                </button>
              )}
              
              {pomTestCase && (
                <button
                  className={`px-4 py-2 text-sm font-medium border-b-2 ${
                    activeTab === 'pomCode' 
                      ? 'text-indigo-600 border-indigo-600' 
                      : 'text-gray-500 border-transparent hover:text-gray-700 hover:border-gray-300'
                  }`}
                  onClick={() => setActiveTab('pomCode')}
                >
                  POM Test Code
                </button>
              )}
            </div>
          </div>
          
          {/* Tab content */}
          <div className="py-2">
            {renderTabContent()}
          </div>
          
          {/* Action buttons */}
          <div className="mt-6 flex justify-end space-x-2">
            {testCase && (
              <>
                {config.generatePageObjects && !pomTestCase && isGenerating && (
                  <div className="flex items-center mr-auto">
                    <Spinner size="sm" className="mr-2" />
                    <span>Generating Page Objects...</span>
                  </div>
                )}
                
                <Button
                  variant={pomTestCase ? "success" : "outline"}
                  onClick={togglePOMMode}
                  disabled={isGenerating}
                >
                  {pomTestCase ? "View Regular Mode" : "Generate Page Objects"}
                </Button>
                
                <Button
                  variant="primary"
                  onClick={saveTestCase}
                  disabled={isGenerating}
                >
                  Save Test
                </Button>
                
                <Button
                  variant="secondary"
                  onClick={runTest}
                  disabled={isGenerating}
                >
                  Run Test
                </Button>
              </>
            )}
          </div>
        </Card>
      )}
      
      {/* Initial state message */}
      {!testCase && !isRecording && !isGenerating && (
        <Card>
          <div className="p-6 text-center">
            <p className="text-gray-600 mb-4">
              Click "Start Recording" to begin capturing your test steps. The recorder will create Page Object Models automatically when you stop recording.
            </p>
            <p className="text-sm text-gray-500">
              Page Object Models encapsulate page structure and behavior, making your tests more maintainable and easier to understand.
            </p>
          </div>
        </Card>
      )}
      
      {/* Processing state */}
      {isGenerating && !pomTestCase && !isRecording && (
        <Card>
          <div className="flex flex-col items-center justify-center py-8">
            <Spinner size="lg" className="mb-4" />
            <p className="text-lg text-gray-700">Generating Page Objects...</p>
            <p className="text-gray-500 text-sm mt-2">This may take a few moments as our AI analyzes your test.</p>
          </div>
        </Card>
      )}
      
      {/* Recording indicator - rendered safely */}
      {isRecording && (
        <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-red-600 text-white px-4 py-2 rounded-md shadow-lg animate-pulse">
          Recording in progress... Actions performed in the browser are being captured.
        </div>
      )}
    </div>
  );
};

export default POMTestRecorder;


// src/main/webapp/src/components/recorder/PageObjectList.jsx
import React from 'react';
import Card from '../common/Card';

const PageObjectList = ({ pageObjects }) => {
  if (!pageObjects || pageObjects.length === 0) {
    return (
      <div className="text-gray-500 text-center py-8">
        No page objects have been generated yet.
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {pageObjects.map((pageObject, index) => (
        <div key={index} className="border rounded-lg p-4">
          <div className="font-medium text-lg mb-2">{pageObject.name}</div>
          <div className="text-sm text-gray-600 mb-4">{pageObject.description || 'No description available'}</div>
          
          {/* Elements section */}
          <div className="mb-4">
            <h3 className="text-sm font-medium text-gray-700 mb-2">Elements</h3>
            {pageObject.elements && pageObject.elements.length > 0 ? (
              <ul className="space-y-1">
                {pageObject.elements.map((element, elemIndex) => (
                  <li key={elemIndex} className="text-sm">
                    <span className="font-mono bg-gray-100 px-1 rounded">{element.name}</span>
                    <span className="mx-1">-</span>
                    <span className="text-gray-600">{element.description}</span>
                  </li>
                ))}
              </ul>
            ) : (
              <p className="text-sm text-gray-500">No elements defined</p>
            )}
          </div>
          
          {/* Actions section */}
          <div>
            <h3 className="text-sm font-medium text-gray-700 mb-2">Actions</h3>
            {pageObject.actions && pageObject.actions.length > 0 ? (
              <ul className="space-y-1">
                {pageObject.actions.map((action, actionIndex) => (
                  <li key={actionIndex} className="text-sm">
                    <span className="font-mono bg-gray-100 px-1 rounded">{action.name}()</span>
                    <span className="mx-1">-</span>
                    <span className="text-gray-600">{action.description}</span>
                  </li>
                ))}
              </ul>
            ) : (
              <p className="text-sm text-gray-500">No actions defined</p>
            )}
          </div>
        </div>
      ))}
    </div>
  );
};

export default PageObjectList;


// src/main/webapp/src/components/recorder/RecorderConfig.jsx
import React from 'react';
import TextField from '../common/TextField';
import SelectField from '../common/SelectField';
import Checkbox from '../common/Checkbox';
import Card from '../common/Card';

const RecorderConfig = ({ config, updateConfig, disabled = false, showPOMOptions = false }) => {
  const browserOptions = [
    { value: 'chrome', label: 'Chrome' },
    { value: 'firefox', label: 'Firefox' },
    { value: 'edge', label: 'Edge' },
    { value: 'safari', label: 'Safari' }
  ];
  
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    updateConfig({
      ...config,
      [name]: type === 'checkbox' ? checked : value
    });
  };
  
  return (
    <Card title="Recording Configuration">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <TextField 
          label="URL to test"
          name="url"
          placeholder="https://example.com"
          value={config.url}
          onChange={handleChange}
          disabled={disabled}
          required
        />
        
        <SelectField
          label="Browser"
          name="browser"
          value={config.browser}
          onChange={handleChange}
          options={browserOptions}
          disabled={disabled}
          required
        />
        
        <Checkbox
          label="Run in headless mode"
          name="headless"
          checked={config.headless}
          onChange={handleChange}
          disabled={disabled}
        />
        
        {showPOMOptions && (
          <Checkbox
            label="Generate Page Object Models"
            name="generatePageObjects"
            checked={config.generatePageObjects}
            onChange={handleChange}
            disabled={disabled}
          />
        )}
      </div>
      
      <div className="text-sm text-gray-500 mt-4">
        <p>The test recorder will open a browser window and record your actions on the specified URL.</p>
        {showPOMOptions && config.generatePageObjects && (
          <p className="mt-2">Page Object Models will be automatically generated when recording stops.</p>
        )}
      </div>
    </Card>
  );
};

export default RecorderConfig;



package com.cssmart.ui.controller;

import com.cssmart.ui.service.PageObjectGenerator;
import com.cssmart.ui.service.TestRecordingService;
import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.recorder.model.POMTestCase;
import com.cssmart.core.pom.PageObjectModel;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.UUID;

/**
 * Controller for Page Object Model operations
 */
@Slf4j
@RestController
@RequestMapping("/api/pom")
public class POMController {
    
    private final PageObjectGenerator pageObjectGenerator;
    private final TestRecordingService testRecordingService;
    
    @Autowired
    public POMController(PageObjectGenerator pageObjectGenerator, TestRecordingService testRecordingService) {
        this.pageObjectGenerator = pageObjectGenerator;
        this.testRecordingService = testRecordingService;
    }
    
    /**
     * Convert a test case to a POM test case
     * @param id Test case ID
     * @return POM test case
     */
    @GetMapping("/convert/{id}")
    public ResponseEntity<POMTestCase> convertToPOM(@PathVariable("id") String id) {
        log.info("Converting test case {} to POM test case", id);
        
        try {
            // Get the test case from the recording service
            TestCase testCase = testRecordingService.getRecordedTest(id);
            
            if (testCase == null) {
                log.warn("Test case not found: {}", id);
                return ResponseEntity.notFound().build();
            }
            
            // Convert to POM test case
            POMTestCase pomTestCase = pageObjectGenerator.convertToPOMTestCase(testCase);
            
            return ResponseEntity.ok(pomTestCase);
        } catch (Exception e) {
            log.error("Error converting test case to POM", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Save a POM test case
     * @param pomTestCase POM test case to save
     * @return Saved POM test case
     */
    @PostMapping("/save")
    public ResponseEntity<POMTestCase> savePOMTestCase(@RequestBody POMTestCase pomTestCase) {
        log.info("Saving POM test case: {}", pomTestCase.getName());
        
        try {
            // Set ID if not present
            if (pomTestCase.getId() == null || pomTestCase.getId().isEmpty()) {
                pomTestCase.setId(UUID.randomUUID().toString());
            }
            
            // Save page objects if they exist
            if (pomTestCase.getPageObjects() != null && !pomTestCase.getPageObjects().isEmpty()) {
                for (PageObjectModel pageObject : pomTestCase.getPageObjects()) {
                    pageObjectGenerator.savePageObject(pageObject);
                }
            }
            
            // Save the test case
            POMTestCase savedPomTestCase = testRecordingService.savePOMTestCase(pomTestCase);
            
            return ResponseEntity.ok(savedPomTestCase);
        } catch (Exception e) {
            log.error("Error saving POM test case", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Run a POM test
     * @param id Test ID
     * @return Execution result
     */
    @PostMapping("/{id}/run")
    public ResponseEntity<Map<String, Object>> runPOMTest(@PathVariable("id") String id) {
        log.info("Running POM test: {}", id);
        
        try {
            // Get the POM test case
            POMTestCase pomTestCase = testRecordingService.getPOMTestCase(id);
            
            if (pomTestCase == null) {
                log.warn("POM test case not found: {}", id);
                return ResponseEntity.notFound().build();
            }
            
            // Execute the test - for now, just return a success message
            Map<String, Object> result = new HashMap<>();
            result.put("status", "success");
            result.put("message", "POM Test execution started");
            result.put("executionId", UUID.randomUUID().toString());
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("Error running POM test", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Get all page objects
     * @return List of page objects
     */
    @GetMapping("/page-objects")
    public ResponseEntity<List<PageObjectModel>> getAllPageObjects() {
        log.info("Fetching all page objects");
        
        try {
            List<PageObjectModel> pageObjects = pageObjectGenerator.getAllPageObjects();
            return ResponseEntity.ok(pageObjects);
        } catch (Exception e) {
            log.error("Error fetching page objects", e);
            return ResponseEntity.status(500).body(null);
        }
    }
}


package com.cssmart.ui.recorder.model;

import com.cssmart.core.pom.PageObjectModel;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

/**
 * Test case with Page Object Model support
 */
@Data
@EqualsAndHashCode(callSuper = true)
@NoArgsConstructor
public class POMTestCase extends TestCase {
    
    private List<PageObjectModel> pageObjects = new ArrayList<>();
    
    /**
     * Create a POM test case from a regular test case
     * @param testCase Regular test case
     */
    public POMTestCase(TestCase testCase) {
        setId(testCase.getId());
        setName(testCase.getName());
        setDescription(testCase.getDescription());
        setClassName(testCase.getClassName());
        setMethodName(testCase.getMethodName());
        setCode(testCase.getCode());
        setSteps(testCase.getSteps());
        setStartTime(testCase.getStartTime());
        setEndTime(testCase.getEndTime());
    }
    
    /**
     * Add a page object to this test case
     * @param pageObject Page object to add
     */
    public void addPageObject(PageObjectModel pageObject) {
        if (pageObjects == null) {
            pageObjects = new ArrayList<>();
        }
        pageObjects.add(pageObject);
    }
    
    /**
     * Generate POM-based test code
     * @return Generated code
     */
    public String generatePOMCode() {
        StringBuilder code = new StringBuilder();
        
        // Add imports and class declaration
        code.append("package com.cssmart.tests.generated;\n\n");
        code.append("import com.cssmart.core.base.POMTestBase;\n");
        code.append("import com.cssmart.core.annotations.CSSmartTest;\n");
        code.append("import org.testng.annotations.Test;\n");
        
        // Import page objects
        if (pageObjects != null && !pageObjects.isEmpty()) {
            for (PageObjectModel pageObject : pageObjects) {
                code.append("import ").append(pageObject.getPackageName()).append(".")
                    .append(pageObject.getClassName()).append(";\n");
            }
        }
        
        code.append("import lombok.extern.slf4j.Slf4j;\n\n");
        
        code.append("/**\n");
        code.append(" * ").append(getDescription()).append("\n");
        code.append(" * Generated with Page Object Models\n");
        code.append(" */\n");
        code.append("@Slf4j\n");
        code.append("public class ").append(getClassName()).append(" extends POMTestBase {\n\n");
        
        // Add test method
        code.append("    @Test\n");
        code.append("    @CSSmartTest(description = \"").append(getDescription()).append("\")\n");
        code.append("    public void ").append(getMethodName()).append("() {\n");
        code.append("        log.info(\"Starting test: ").append(getDescription()).append("\");\n\n");
        
        // Initialize page objects
        if (pageObjects != null && !pageObjects.isEmpty()) {
            for (PageObjectModel pageObject : pageObjects) {
                String instanceName = toLowerCamelCase(pageObject.getClassName().replace("Page", ""));
                code.append("        // Initialize ").append(pageObject.getName()).append("\n");
                code.append("        ").append(pageObject.getClassName()).append(" ")
                    .append(instanceName).append(" = new ").append(pageObject.getClassName())
                    .append("(driver);\n\n");
            }
        }
        
        // Add test steps using page objects
        if (getSteps() != null && !getSteps().isEmpty()) {
            // Try to generate POM-based steps
            generatePOMBasedSteps(code);
        } else {
            code.append("        // TODO: Implement test steps using page objects\n\n");
        }
        
        code.append("        log.info(\"Test completed successfully\");\n");
        code.append("    }\n");
        
        // Add helper methods if needed
        code.append("\n    /**\n");
        code.append("     * Helper method to get the appropriate page object for an element\n");
        code.append("     * @param elementName Element name\n");
        code.append("     * @return Page object instance name as String\n");
        code.append("     */\n");
        code.append("    private String getPageObjectForElement(String elementName) {\n");
        code.append("        // This would be more sophisticated in a real implementation\n");
        if (pageObjects != null && !pageObjects.isEmpty()) {
            code.append("        return \"").append(toLowerCamelCase(pageObjects.get(0).getClassName().replace("Page", ""))).append("\";\n");
        } else {
            code.append("        return \"page\";\n");
        }
        code.append("    }\n");
        
        code.append("}\n");
        
        return code.toString();
    }
    
    /**
     * Generate POM-based steps from the recorded steps
     * @param code StringBuilder to append to
     */
    private void generatePOMBasedSteps(StringBuilder code) {
        if (pageObjects == null || pageObjects.isEmpty() || getSteps() == null || getSteps().isEmpty()) {
            code.append("        // No steps or page objects available\n\n");
            return;
        }
        
        // Default to first page object if we have one
        PageObjectModel defaultPageObject = pageObjects.get(0);
        String defaultInstanceName = toLowerCamelCase(defaultPageObject.getClassName().replace("Page", ""));
        
        for (RecordedStep step : getSteps()) {
            if (step.getDescription() != null) {
                code.append("        // ").append(step.getDescription()).append("\n");
            }
            
            // Try to map the step to a page object action
            if ("NAVIGATE".equals(step.getAction()) && step.getValue() != null) {
                // Find the page object that matches this URL if possible
                PageObjectModel matchingPage = findPageObjectForUrl(step.getValue());
                String instanceName = matchingPage != null 
                    ? toLowerCamelCase(matchingPage.getClassName().replace("Page", ""))
                    : defaultInstanceName;
                
                code.append("        ").append(instanceName).append(".navigateToPage();\n");
            } else if (step.getElement() != null) {
                // Try to find which page object this element belongs to
                PageObjectModel pageObject = findPageObjectForElement(step.getElement());
                String instanceName = pageObject != null
                    ? toLowerCamelCase(pageObject.getClassName().replace("Page", ""))
                    : defaultInstanceName;
                
                // Generate action based on step type
                switch (step.getAction()) {
                    case "CLICK":
                        code.append("        ").append(instanceName).append(".click")
                            .append(toProperCase(step.getElement())).append("();\n");
                        break;
                    case "TYPE":
                        code.append("        ").append(instanceName).append(".enter")
                            .append(toProperCase(step.getElement())).append("(\"")
                            .append(step.getValue()).append("\");\n");
                        break;
                    case "SELECT":
                        code.append("        ").append(instanceName).append(".select")
                            .append(toProperCase(step.getElement())).append("(\"")
                            .append(step.getValue()).append("\");\n");
                        break;
                    case "VERIFY_PRESENCE":
                        code.append("        ").append(instanceName).append(".verify")
                            .append(toProperCase(step.getElement())).append("IsPresent();\n");
                        break;
                    default:
                        code.append("        // TODO: Implement ")
                            .append(step.getAction()).append(" for ")
                            .append(step.getElement()).append("\n");
                        break;
                }
            }
            
            code.append("\n");
        }
    }
    
    /**
     * Find the page object for a URL
     * @param url URL to match
     * @return Matching page object or null
     */
    private PageObjectModel findPageObjectForUrl(String url) {
        if (pageObjects == null || url == null) {
            return null;
        }
        
        return pageObjects.stream()
            .filter(po -> po.getPageUrl() != null && url.contains(po.getPageUrl()))
            .findFirst()
            .orElse(null);
    }
    
    /**
     * Find the page object containing a specific element
     * @param elementName Element name to find
     * @return Page object containing the element, or null
     */
    private PageObjectModel findPageObjectForElement(String elementName) {
        if (pageObjects == null || elementName == null) {
            return null;
        }
        
        return pageObjects.stream()
            .filter(po -> po.getElements() != null && po.getElements().stream()
                .anyMatch(e -> e.getDescription() != null && 
                         e.getDescription().contains(elementName)))
            .findFirst()
            .orElse(null);
    }
    
    /**
     * Convert a string to proper case (first letter of each word capitalized)
     * @param input Input string
     * @return Proper case string
     */
    private String toProperCase(String input) {
        if (input == null || input.isEmpty()) {
            return "";
        }
        
        // Replace non-alphanumeric with spaces
        String clean = input.replaceAll("[^a-zA-Z0-9]", " ");
        
        // Split into words
        String[] words = clean.trim().split("\\s+");
        StringBuilder result = new StringBuilder();
        
        for (String word : words) {
            if (word.length() > 0) {
                // Capitalize first letter of each word
                result.append(Character.toUpperCase(word.charAt(0)));
                if (word.length() > 1) {
                    result.append(word.substring(1).toLowerCase());
                }
            }
        }
        
        return result.toString();
    }
    
    /**
     * Convert a string to lower camel case
     * @param input Input string
     * @return Lower camel case string
     */
    private String toLowerCamelCase(String input) {
        if (input == null || input.isEmpty()) {
            return "";
        }
        
        String properCase = toProperCase(input);
        return Character.toLowerCase(properCase.charAt(0)) + properCase.substring(1);
    }
}


package com.cssmart.core.pom;

import lombok.Builder;
import lombok.Data;
import lombok.Singular;

import java.util.ArrayList;
import java.util.List;

/**
 * Page Object Model for a web page
 */
@Data
@Builder
public class PageObjectModel {
    
    private String id;
    private String name;
    private String description;
    private String pageUrl;
    private String packageName;
    private String className;
    
    @Singular
    private List<PageElement> elements;
    
    @Singular
    private List<PageAction> actions;
    
    @Singular
    private List<PageVerification> verifications;
    
    /**
     * Add an element to this page object
     * @param element Element to add
     */
    public void addElement(PageElement element) {
        if (elements == null) {
            elements = new ArrayList<>();
        }
        elements.add(element);
    }
    
    /**
     * Add an action to this page object
     * @param action Action to add
     */
    public void addAction(PageAction action) {
        if (actions == null) {
            actions = new ArrayList<>();
        }
        actions.add(action);
    }
    
    /**
     * Add a verification to this page object
     * @param verification Verification to add
     */
    public void addVerification(PageVerification verification) {
        if (verifications == null) {
            verifications = new ArrayList<>();
        }
        verifications.add(verification);
    }
    
    /**
     * Generate code for this page object
     * @return Generated Java code
     */
    public String generateCode() {
        StringBuilder code = new StringBuilder();
        
        // Add package declaration
        code.append("package ").append(packageName).append(";\n\n");
        
        // Add imports
        code.append("import org.openqa.selenium.WebDriver;\n");
        code.append("import org.openqa.selenium.WebElement;\n");
        code.append("import org.openqa.selenium.support.FindBy;\n");
        code.append("import org.openqa.selenium.support.PageFactory;\n");
        code.append("import com.cssmart.core.pom.BasePage;\n");
        code.append("import lombok.extern.slf4j.Slf4j;\n\n");
        
        // Add class javadoc
        code.append("/**\n");
        code.append(" * Page Object Model for ").append(name).append("\n");
        if (description != null && !description.isEmpty()) {
            code.append(" * ").append(description).append("\n");
        }
        code.append(" */\n");
        
        // Add class declaration
        code.append("@Slf4j\n");
        code.append("public class ").append(className).append(" extends BasePage {\n\n");
        
        // Add elements
        if (elements != null && !elements.isEmpty()) {
            for (PageElement element : elements) {
                // Add FindBy annotation
                code.append("    @FindBy(").append(element.getLocatorType().name().toLowerCase())
                    .append(" = \"").append(element.getLocatorValue()).append("\")\n");
                
                // Add field
                code.append("    private WebElement ").append(element.getName()).append(";\n\n");
            }
        }
        
        // Add constructor
        code.append("    /**\n");
        code.append("     * Constructor\n");
        code.append("     * @param driver WebDriver instance\n");
        code.append("     */\n");
        code.append("    public ").append(className).append("(WebDriver driver) {\n");
        code.append("        super(driver);\n");
        code.append("        PageFactory.initElements(driver, this);\n");
        code.append("    }\n\n");
        
        // Add navigate method if URL is specified
        if (pageUrl != null && !pageUrl.isEmpty()) {
            code.append("    /**\n");
            code.append("     * Navigate to this page\n");
            code.append("     * @return this page object\n");
            code.append("     */\n");
            code.append("    public ").append(className).append(" navigateToPage() {\n");
            code.append("        driver.get(\"").append(pageUrl).append("\");\n");
            code.append("        log.info(\"Navigated to ").append(name).append("\");\n");
            code.append("        return this;\n");
            code.append("    }\n\n");
        }
        
        // Add action methods
        if (actions != null && !actions.isEmpty()) {
            for (PageAction action : actions) {
                // Add method javadoc
                code.append("    /**\n");
                code.append("     * ").append(action.getDescription()).append("\n");
                
                // Add parameters javadoc if any
                if (action.getParameters() != null && !action.getParameters().isEmpty()) {
                    for (Map.Entry<String, String> param : action.getParameters().entrySet()) {
                        code.append("     * @param ").append(param.getKey())
                            .append(" ").append(param.getValue()).append("\n");
                    }
                }
                
                // Add return javadoc
                if (action.isReturnsPage()) {
                    code.append("     * @return this page object\n");
                }
                
                code.append("     */\n");
                
                // Add method signature
                code.append("    public ");
                
                // Return type
                if (action.isReturnsPage()) {
                    code.append(className);
                } else {
                    code.append("void");
                }
                
                // Method name and parameters
                code.append(" ").append(action.getName()).append("(");
                
                // Add parameters if any
                if (action.getParameters() != null && !action.getParameters().isEmpty()) {
                    int paramCount = 0;
                    for (String paramName : action.getParameters().keySet()) {
                        if (paramCount > 0) {
                            code.append(", ");
                        }
                        code.append("String ").append(paramName);
                        paramCount++;
                    }
                }
                
                code.append(") {\n");
                
                // Method body
                switch (action.getType()) {
                    case CLICK:
                        code.append("        waitForElementClickable(").append(action.getElementName()).append(");\n");
                        code.append("        ").append(action.getElementName()).append(".click();\n");
                        code.append("        log.info(\"Clicked on ").append(action.getElementName()).append("\");\n");
                        break;
                        
                    case TYPE:
                        code.append("        waitForElementVisible(").append(action.getElementName()).append(");\n");
                        code.append("        ").append(action.getElementName()).append(".clear();\n");
                        code.append("        ").append(action.getElementName()).append(".sendKeys(value);\n");
                        code.append("        log.info(\"Entered text in ").append(action.getElementName()).append("\");\n");
                        break;
                        
                    case SELECT:
                        code.append("        waitForElementVisible(").append(action.getElementName()).append(");\n");
                        code.append("        new org.openqa.selenium.support.ui.Select(")
                            .append(action.getElementName()).append(").selectByVisibleText(value);\n");
                        code.append("        log.info(\"Selected option in ").append(action.getElementName()).append("\");\n");
                        break;
                        
                    case NAVIGATE:
                        code.append("        driver.get(\"").append(pageUrl).append("\");\n");
                        code.append("        log.info(\"Navigated to ").append(name).append("\");\n");
                        break;
                        
                    case WAIT:
                        if (action.getElementName() != null) {
                            code.append("        waitForElementVisible(").append(action.getElementName()).append(");\n");
                            code.append("        log.info(\"Waited for ").append(action.getElementName()).append("\");\n");
                        } else {
                            code.append("        try { Thread.sleep(2000); } catch (InterruptedException e) {}\n");
                            code.append("        log.info(\"Waited for 2 seconds\");\n");
                        }
                        break;
                        
                    case HOVER:
                        code.append("        hover(").append(action.getElementName()).append(");\n");
                        code.append("        log.info(\"Hovered over ").append(action.getElementName()).append("\");\n");
                        break;
                        
                    case CUSTOM:
                    default:
                        code.append("        // TODO: Implement this action\n");
                        code.append("        log.info(\"Performed custom action\");\n");
                        break;
                }
                
                // Return statement if needed
                if (action.isReturnsPage()) {
                    code.append("        return this;\n");
                }
                
                code.append("    }\n\n");
            }
        }
        
        // Add verification methods
        if (verifications != null && !verifications.isEmpty()) {
            for (PageVerification verification : verifications) {
                // Add method javadoc
                code.append("    /**\n");
                code.append("     * ").append(verification.getDescription()).append("\n");
                code.append("     * @return true if verification passes\n");
                code.append("     */\n");
                
                // Add method signature
                code.append("    public boolean ").append(verification.getName()).append("() {\n");
                
                // Method body
                switch (verification.getType()) {
                    case ELEMENT_PRESENT:
                        code.append("        try {\n");
                        code.append("            return ").append(verification.getElementName()).append(".isDisplayed();\n");
                        code.append("        } catch (Exception e) {\n");
                        code.append("            log.warn(\"Element not present: ").append(verification.getElementName()).append("\");\n");
                        code.append("            return false;\n");
                        code.append("        }\n");
                        break;
                        
                    case ELEMENT_ENABLED:
                        code.append("        try {\n");
                        code.append("            return ").append(verification.getElementName()).append(".isEnabled();\n");
                        code.append("        } catch (Exception e) {\n");
                        code.append("            log.warn(\"Element not enabled: ").append(verification.getElementName()).append("\");\n");
                        code.append("            return false;\n");
                        code.append("        }\n");
                        break;
                        
                    case TEXT_EQUALS:
                        code.append("        try {\n");
                        code.append("            return ").append(verification.getElementName())
                            .append(".getText().equals(\"").append(verification.getExpectedValue()).append("\");\n");
                        code.append("        } catch (Exception e) {\n");
                        code.append("            log.warn(\"Text verification failed: ").append(verification.getElementName()).append("\");\n");
                        code.append("            return false;\n");
                        code.append("        }\n");
                        break;
                        
                    case TEXT_CONTAINS:
                        code.append("        try {\n");
                        code.append("            return ").append(verification.getElementName())
                            .append(".getText().contains(\"").append(verification.getExpectedValue()).append("\");\n");
                        code.append("        } catch (Exception e) {\n");
                        code.append("            log.warn(\"Text contains verification failed: ").append(verification.getElementName()).append("\");\n");
                        code.append("            return false;\n");
                        code.append("        }\n");
                        break;
                        
                    case CUSTOM:
                    default:
                        code.append("        // TODO: Implement this verification\n");
                        code.append("        return true;\n");
                        break;
                }
                
                code.append("    }\n\n");
            }
        }
        
        // Close class
        code.append("}\n");
        
        return code.toString();
    }
}


package com.cssmart.core.pom;

import lombok.Builder;
import lombok.Data;

import java.util.Map;

/**
 * Represents an element on a page
 */
@Data
@Builder
public class PageElement {
    
    /**
     * Locator types
     */
    public enum LocatorType {
        ID,
        NAME,
        CLASS_NAME,
        TAG_NAME,
        XPATH,
        CSS,
        LINK_TEXT,
        PARTIAL_LINK_TEXT
    }
    
    private String name;
    private String description;
    private LocatorType locatorType;
    private String locatorValue;
    private boolean isList;
}

package com.cssmart.core.pom;

import lombok.Builder;
import lombok.Data;

import java.util.Map;

/**
 * Represents an action that can be performed on a page
 */
@Data
@Builder
public class PageAction {
    
    /**
     * Action types
     */
    public enum ActionType {
        CLICK,
        TYPE,
        SELECT,
        NAVIGATE,
        WAIT,
        HOVER,
        CUSTOM
    }
    
    private String name;
    private String description;
    private ActionType type;
    private String elementName;
    private Map<String, String> parameters;
    private boolean returnsPage;
}

package com.cssmart.core.pom;

import lombok.Builder;
import lombok.Data;

/**
 * Represents a verification on a page
 */
@Data
@Builder
public class PageVerification {
    
    /**
     * Verification types
     */
    public enum VerificationType {
        ELEMENT_PRESENT,
        ELEMENT_ENABLED,
        TEXT_EQUALS,
        TEXT_CONTAINS,
        CUSTOM
    }
    
    private String name;
    private String description;
    private VerificationType type;
    private String elementName;
    private String expectedValue;
}


package com.cssmart.core.pom;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

/**
 * Base page class for Page Object Models
 */
public class BasePage {
    
    protected WebDriver driver;
    protected WebDriverWait wait;
    
    /**
     * Constructor
     * @param driver WebDriver instance
     */
    public BasePage(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, 10);
    }
    
    /**
     * Wait for an element to be visible
     * @param element WebElement to wait for
     * @return The element when it's visible
     */
    protected WebElement waitForElementVisible(WebElement element) {
        return wait.until(ExpectedConditions.visibilityOf(element));
    }
    
    /**
     * Wait for an element to be clickable
     * @param element WebElement to wait for
     * @return The element when it's clickable
     */
    protected WebElement waitForElementClickable(WebElement element) {
        return wait.until(ExpectedConditions.elementToBeClickable(element));
    }
    
    /**
     * Hover over an element
     * @param element WebElement to hover over
     */
    protected void hover(WebElement element) {
        Actions actions = new Actions(driver);
        actions.moveToElement(element).perform();
    }
}



package com.cssmart.core.base;

import org.openqa.selenium.WebDriver;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import lombok.extern.slf4j.Slf4j;

/**
 * Base class for Page Object Model-based tests
 */
@Slf4j
public class POMTestBase {
    
    protected WebDriver driver;
    
    /**
     * Set up before test method
     */
    @BeforeMethod
    public void setUp() {
        // Initialize WebDriver (in a real implementation, this would be more configurable)
        driver = new org.openqa.selenium.chrome.ChromeDriver();
        driver.manage().window().maximize();
        log.info("WebDriver initialized for POM test");
    }
    
    /**
     * Tear down after test method
     */
    @AfterMethod
    public void tearDown() {
        if (driver != null) {
            driver.quit();
            log.info("WebDriver closed");
        }
    }
}





