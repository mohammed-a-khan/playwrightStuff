// DashboardController.java
package com.cssmart.ui.controller;

import com.cssmart.reporting.ReportManager;
import com.cssmart.reporting.model.ExecutionMetrics;
import com.cssmart.reporting.model.Insight;
import com.cssmart.reporting.model.InsightType;
import com.cssmart.reporting.model.TestReport;
import com.cssmart.ui.model.DashboardMetrics;
import com.cssmart.ui.model.TrendData;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * REST controller for dashboard data
 */
@Slf4j
@RestController
@RequestMapping("/api/dashboard")
public class DashboardController {
    private final ReportManager reportManager;
    
    public DashboardController() {
        this.reportManager = ReportManager.getInstance();
        log.info("DashboardController initialized");
    }
    
    /**
     * Get dashboard metrics
     * 
     * @return Dashboard metrics
     */
    @GetMapping("/metrics")
    public ResponseEntity<DashboardMetrics> getMetrics() {
        try {
            log.debug("Fetching dashboard metrics");
            
            // Get current metrics
            ExecutionMetrics metrics = reportManager.getCurrentMetrics();
            
            // Generate AI insights
            List<Insight> insights = generateInsights(metrics);
            
            // Create dashboard metrics
            DashboardMetrics dashboardMetrics = new DashboardMetrics(metrics, insights);
            
            return ResponseEntity.ok(dashboardMetrics);
        } catch (Exception e) {
            log.error("Error fetching dashboard metrics", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Get execution trends
     * 
     * @return Execution trend data
     */
    @GetMapping("/trends")
    public ResponseEntity<List<TrendData>> getTrends() {
        try {
            log.debug("Fetching execution trends");
            
            // Get recent reports
            List<TestReport> reports = reportManager.getRecentReports();
            
            // Generate trend data
            List<TrendData> trends = analyzeTrends(reports);
            
            return ResponseEntity.ok(trends);
        } catch (Exception e) {
            log.error("Error fetching execution trends", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Get recent tests
     * 
     * @return List of recent test reports
     */
    @GetMapping("/tests")
    public ResponseEntity<List<TestReport>> getTests() {
        try {
            log.debug("Fetching recent tests");
            
            // Get recent reports
            List<TestReport> reports = reportManager.getRecentReports();
            
            return ResponseEntity.ok(reports);
        } catch (Exception e) {
            log.error("Error fetching recent tests", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Generate insights from metrics
     * 
     * @param metrics Execution metrics
     * @return List of insights
     */
    private List<Insight> generateInsights(ExecutionMetrics metrics) {
        List<Insight> insights = new ArrayList<>();
        
        // Generate performance insight
        if (metrics.getAvgDuration() > 10000) { // 10 seconds
            insights.add(Insight.builder()
                .title("Performance Concern")
                .description("Tests are taking longer than expected to execute. Consider optimizing waits and actions.")
                .type(InsightType.PERFORMANCE)
                .confidence(0.8)
                .build());
        }
        
        // Generate reliability insight
        if (metrics.getTotalTests() > 0 && metrics.getSuccessRate() < 80) {
            insights.add(Insight.builder()
                .title("Reliability Issues")
                .description("Test success rate is below 80%. Review failed tests for common patterns.")
                .type(InsightType.RELIABILITY)
                .confidence(0.9)
                .build());
        } else if (metrics.getTotalTests() > 0 && metrics.getSuccessRate() > 95) {
            insights.add(Insight.builder()
                .title("Excellent Reliability")
                .description("Test success rate is above 95%. Good job maintaining reliable tests!")
                .type(InsightType.RELIABILITY)
                .confidence(0.9)
                .build());
        }
        
        // Add more insights as needed
        
        return insights;
    }
    
    /**
     * Analyze trends from reports
     * 
     * @param reports List of test reports
     * @return List of trend data points
     */
    private List<TrendData> analyzeTrends(List<TestReport> reports) {
        // Group reports by day
        Map<LocalDateTime, List<TestReport>> reportsByDay = reports.stream()
                .collect(Collectors.groupingBy(report -> 
                    report.getEndTime().withHour(0).withMinute(0).withSecond(0).withNano(0)));
        
        // Create trend data for each day
        List<TrendData> trends = new ArrayList<>();
        
        reportsByDay.forEach((date, dayReports) -> {
            int total = dayReports.size();
            int passed = (int) dayReports.stream()
                    .filter(r -> r.getStatus() == TestStatus.PASSED)
                    .count();
            int failed = (int) dayReports.stream()
                    .filter(r -> r.getStatus() == TestStatus.FAILED)
                    .count();
            int skipped = (int) dayReports.stream()
                    .filter(r -> r.getStatus() == TestStatus.SKIPPED)
                    .count();
            
            double successRate = total == 0 ? 0 : (passed * 100.0) / total;
            long avgDuration = total == 0 ? 0 : 
                    dayReports.stream().mapToLong(TestReport::getDuration).sum() / total;
            
            TrendData trendData = TrendData.builder()
                    .date(date)
                    .total(total)
                    .passed(passed)
                    .failed(failed)
                    .skipped(skipped)
                    .successRate(successRate)
                    .avgDuration(avgDuration)
                    .build();
            
            trends.add(trendData);
        });
        
        // Sort by date
        trends.sort((a, b) -> a.getDate().compareTo(b.getDate()));
        
        return trends;
    }
}

// TestGeneratorController.java
package com.cssmart.ui.controller;

import com.cssmart.ai.codegen.TestGenerator;
import com.cssmart.ai.codegen.model.TestCase;
import com.cssmart.ui.service.TestGeneratorService;
import com.cssmart.ui.model.GenerateTestRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import lombok.extern.slf4j.Slf4j;

/**
 * REST controller for test generation
 */
@Slf4j
@RestController
@RequestMapping("/api/generator")
public class TestGeneratorController {
    
    private final TestGenerator testGenerator;
    private final TestGeneratorService testGeneratorService;
    
    /**
     * Create a new test generator controller
     * 
     * @param testGeneratorService Test generator service
     */
    @Autowired
    public TestGeneratorController(TestGeneratorService testGeneratorService) {
        this.testGenerator = new TestGenerator();
        this.testGeneratorService = testGeneratorService;
        log.info("TestGeneratorController initialized");
    }
    
    /**
     * Generate a test from a description
     * 
     * @param request Generate test request
     * @return Generated test case
     */
    @PostMapping("/generate")
    public ResponseEntity<com.cssmart.ui.recorder.model.TestCase> generateTest(
            @RequestBody GenerateTestRequest request) {
        
        try {
            log.info("Generating test from description: {}", request.getDescription());
            
            // Generate test using AI
            TestCase aiTestCase = testGenerator.generateTest(request.getDescription());
            
            // Convert to UI model
            com.cssmart.ui.recorder.model.TestCase uiTestCase = 
                    testGeneratorService.convertToUiTestCase(aiTestCase);
            
            log.info("Test generated successfully");
            return ResponseEntity.ok(uiTestCase);
            
        } catch (Exception e) {
            log.error("Error generating test", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Save a generated test
     * 
     * @param testCase Test case to save
     * @return Saved test case
     */
    @PostMapping("/save")
    public ResponseEntity<com.cssmart.ui.recorder.model.TestCase> saveTest(
            @RequestBody com.cssmart.ui.recorder.model.TestCase testCase) {
        
        try {
            log.info("Saving test: {}", testCase.getName());
            
            // Save the test
            com.cssmart.ui.recorder.model.TestCase savedTest = 
                    testGeneratorService.saveTest(testCase);
            
            log.info("Test saved successfully");
            return ResponseEntity.ok(savedTest);
            
        } catch (Exception e) {
            log.error("Error saving test", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Get all generated tests
     * 
     * @return List of generated tests
     */
    @GetMapping("/tests")
    public ResponseEntity<List<com.cssmart.ui.recorder.model.TestCase>> getTests() {
        try {
            log.debug("Fetching generated tests");
            
            // Get all tests
            List<com.cssmart.ui.recorder.model.TestCase> tests = 
                    testGeneratorService.getAllTests();
            
            return ResponseEntity.ok(tests);
        } catch (Exception e) {
            log.error("Error fetching generated tests", e);
            return ResponseEntity.status(500).body(new ArrayList<>());
        }
    }
    
    /**
     * Get a test by ID
     * 
     * @param id Test ID
     * @return Test case
     */
    @GetMapping("/test/{id}")
    public ResponseEntity<com.cssmart.ui.recorder.model.TestCase> getTest(@PathVariable String id) {
        try {
            log.debug("Fetching test with ID: {}", id);
            
            // Get test
            com.cssmart.ui.recorder.model.TestCase test = 
                    testGeneratorService.getTestById(id);
            
            if (test == null) {
                return ResponseEntity.notFound().build();
            }
            
            return ResponseEntity.ok(test);
        } catch (Exception e) {
            log.error("Error fetching test with ID: {}", id, e);
            return ResponseEntity.status(500).body(null);
        }
    }
}

// RecorderController.java
package com.cssmart.ui.controller;

import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.service.TestGeneratorService;
import com.cssmart.ui.model.BrowserConfig;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import lombok.extern.slf4j.Slf4j;

import java.util.UUID;

/**
 * REST controller for test recorder operations
 */
@Slf4j
@RestController
@RequestMapping("/api/recorder")
public class RecorderController {
    
    private final TestGeneratorService testGeneratorService;
    
    /**
     * Create a new recorder controller
     * 
     * @param testGeneratorService Test generator service
     */
    @Autowired
    public RecorderController(TestGeneratorService testGeneratorService) {
        this.testGeneratorService = testGeneratorService;
        log.info("RecorderController initialized");
    }
    
    /**
     * Save a recorded test case
     * 
     * @param testCase Recorded test case
     * @return Saved test case
     */
    @PostMapping("/save")
    public ResponseEntity<TestCase> saveTestCase(@RequestBody TestCase testCase) {
        log.info("Saving recorded test case: {}", testCase.getName());
        
        try {
            // Ensure the test case has an ID
            if (testCase.getId() == null || testCase.getId().isEmpty()) {
                testCase.setId(UUID.randomUUID().toString());
            }
            
            // Save the test
            TestCase savedTest = testGeneratorService.saveTest(testCase);
            
            return ResponseEntity.ok(savedTest);
        } catch (Exception e) {
            log.error("Error saving test case", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Get browser configuration options
     * 
     * @return Browser configuration
     */
    @GetMapping("/browser-config")
    public ResponseEntity<BrowserConfig> getBrowserConfig() {
        log.info("Fetching browser configuration options");
        
        try {
            BrowserConfig config = new BrowserConfig();
            config.addBrowserOption("chrome", "Chrome");
            config.addBrowserOption("firefox", "Firefox");
            config.addBrowserOption("edge", "Edge");
            config.addBrowserOption("safari", "Safari");
            
            return ResponseEntity.ok(config);
        } catch (Exception e) {
            log.error("Error fetching browser configuration", e);
            return ResponseEntity.status(500).body(null);
        }
    }
}


// TestGeneratorService.java
package com.cssmart.ui.service;

import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.recorder.model.RecordedStep;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.io.FileWriter;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Service for test generation and management
 */
@Slf4j
@Service
public class TestGeneratorService {
    
    private final Map<String, TestCase> testCache = new HashMap<>();
    private final String testOutputDir = "generated-tests";
    
    /**
     * Create a new test generator service
     */
    public TestGeneratorService() {
        // Create test output directory if it doesn't exist
        File outputDir = new File(testOutputDir);
        if (!outputDir.exists()) {
            outputDir.mkdirs();
        }
        
        log.info("TestGeneratorService initialized");
    }
    
    /**
     * Save a test case
     * 
     * @param testCase Test case to save
     * @return Saved test case
     */
    public TestCase saveTest(TestCase testCase) {
        try {
            log.info("Saving test case: {}", testCase.getName());
            
            // Store in cache
            testCache.put(testCase.getId(), testCase);
            
            // Save the test code to file
            String filePath = testOutputDir + "/" + testCase.getClassName() + ".java";
            try (FileWriter writer = new FileWriter(filePath)) {
                writer.write(testCase.getCode());
            }
            
            log.info("Test case saved: {}", filePath);
            return testCase;
        } catch (Exception e) {
            log.error("Failed to save test case", e);
            throw new RuntimeException("Failed to save test case", e);
        }
    }
    
    /**
     * Get a test case by ID
     * 
     * @param id Test case ID
     * @return Test case
     */
    public TestCase getTestById(String id) {
        return testCache.get(id);
    }
    
    /**
     * Get all test cases
     * 
     * @return List of test cases
     */
    public List<TestCase> getAllTests() {
        return new ArrayList<>(testCache.values());
    }
    
    /**
     * Convert an AI test case to a UI test case
     * 
     * @param aiTestCase AI-generated test case
     * @return UI test case
     */
    public TestCase convertToUiTestCase(com.cssmart.ai.codegen.model.TestCase aiTestCase) {
        TestCase uiTestCase = new TestCase();
        
        // Set basic properties
        uiTestCase.setId(java.util.UUID.randomUUID().toString());
        uiTestCase.setName(aiTestCase.getClassName().replace("Test", "") + " Test");
        uiTestCase.setDescription("AI-generated test case");
        uiTestCase.setClassName(aiTestCase.getClassName());
        uiTestCase.setMethodName("test" + aiTestCase.getClassName().replace("Test", ""));
        uiTestCase.setStartTime(LocalDateTime.now());
        uiTestCase.setEndTime(LocalDateTime.now());
        
        // Convert steps
        List<RecordedStep> steps = new ArrayList<>();
        
        // Simple parsing of the code to extract steps
        // This is a simplified approach and may need improvements
        String code = aiTestCase.getCompilationUnit().toString();
        String[] lines = code.split("\n");
        
        for (String line : lines) {
            // Look for click, type, navigate actions
            if (line.contains("click(")) {
                RecordedStep step = extractStep(line, "CLICK");
                if (step != null) {
                    steps.add(step);
                }
            } else if (line.contains("type(")) {
                RecordedStep step = extractStep(line, "TYPE");
                if (step != null) {
                    steps.add(step);
                }
            } else if (line.contains("driver.get(")) {
                RecordedStep step = extractNavigation(line);
                if (step != null) {
                    steps.add(step);
                }
            } else if (line.contains("verifyTextPresent(")) {
                RecordedStep step = extractStep(line, "VERIFY_TEXT");
                if (step != null) {
                    steps.add(step);
                }
            }
        }
        
        uiTestCase.setSteps(steps);
        
        // Set the code
        uiTestCase.setCode(code);
        
        return uiTestCase;
    }
    
    /**
     * Extract a step from a line of code
     * 
     * @param line Line of code
     * @param action Action type
     * @return Recorded step
     */
    private RecordedStep extractStep(String line, String action) {
        try {
            // Extract element description
            int startIndex = line.indexOf("(\"") + 2;
            int endIndex = line.indexOf("\"", startIndex);
            
            if (startIndex < 2 || endIndex < 0) {
                return null;
            }
            
            String element = line.substring(startIndex, endIndex);
            
            RecordedStep step = new RecordedStep();
            step.setAction(action);
            step.setElement(element);
            step.setTimestamp(LocalDateTime.now());
            
            // Extract value for TYPE and VERIFY_TEXT actions
            if ("TYPE".equals(action) || "VERIFY_TEXT".equals(action)) {
                int valueStartIndex = line.indexOf("\", \"") + 4;
                int valueEndIndex = line.indexOf("\"", valueStartIndex);
                
                if (valueStartIndex >= 4 && valueEndIndex > 0) {
                    String value = line.substring(valueStartIndex, valueEndIndex);
                    step.setValue(value);
                }
            }
            
            // Generate description
            step.setDescription(generateDescription(action, element, step.getValue()));
            
            return step;
        } catch (Exception e) {
            log.warn("Failed to extract step from line: {}", line, e);
            return null;
        }
    }
    
    /**
     * Extract a navigation step from a line of code
     * 
     * @param line Line of code
     * @return Recorded step
     */
    private RecordedStep extractNavigation(String line) {
        try {
            // Extract URL
            int startIndex = line.indexOf("(\"") + 2;
            int endIndex = line.indexOf("\"", startIndex);
            
            if (startIndex < 2 || endIndex < 0) {
                return null;
            }
            
            String url = line.substring(startIndex, endIndex);
            
            RecordedStep step = new RecordedStep();
            step.setAction("NAVIGATE");
            step.setValue(url);
            step.setTimestamp(LocalDateTime.now());
            step.setDescription("Navigate to " + url);
            
            return step;
        } catch (Exception e) {
            log.warn("Failed to extract navigation from line: {}", line, e);
            return null;
        }
    }
    
    /**
     * Generate a human-readable description for an action
     * 
     * @param action Action type
     * @param element Element description
     * @param value Value (if applicable)
     * @return Human-readable description
     */
    private String generateDescription(String action, String element, String value) {
        switch (action) {
            case "CLICK":
                return "Click on " + element;
            case "TYPE":
                return "Enter '" + value + "' in " + element;
            case "SELECT":
                return "Select '" + value + "' from " + element;
            case "VERIFY_PRESENCE":
                return "Verify " + element + " is present";
            case "VERIFY_TEXT":
                return "Verify '" + value + "' is present in " + element;
            case "VERIFY_VISIBILITY":
                return "Verify " + element + " is visible";
            case "WAIT":
                return "Wait for " + element;
            case "HOVER":
                return "Hover over " + element;
            default:
                return action + " on " + element;
        }
    }
}

// DashboardMetrics.java
package com.cssmart.ui.model;

import com.cssmart.reporting.model.ExecutionMetrics;
import com.cssmart.reporting.model.Insight;
import lombok.AllArgsConstructor;
import lombok.Data;
import java.util.List;

/**
 * Model for dashboard metrics
 */
@Data
@AllArgsConstructor
public class DashboardMetrics {
    private ExecutionMetrics metrics;
    private List<Insight> insights;
}

// TrendData.java
package com.cssmart.ui.model;

import lombok.Builder;
import lombok.Data;
import java.time.LocalDateTime;

/**
 * Model for trend data
 */
@Data
@Builder
public class TrendData {
    private LocalDateTime date;
    private int total;
    private int passed;
    private int failed;
    private int skipped;
    private double successRate;
    private long avgDuration;
}

// GenerateTestRequest.java
package com.cssmart.ui.model;

import lombok.Data;

/**
 * Request model for generating tests
 */
@Data
public class GenerateTestRequest {
    private String description;
    private String testType;
    private String browser;
}

// BrowserConfig.java
package com.cssmart.ui.model;

import lombok.Data;
import java.util.ArrayList;
import java.util.List;

/**
 * Model for browser configuration
 */
@Data
public class BrowserConfig {
    private List<BrowserOption> browsers = new ArrayList<>();
    
    /**
     * Add a browser option
     * 
     * @param value Browser value
     * @param label Browser label
     */
    public void addBrowserOption(String value, String label) {
        browsers.add(new BrowserOption(value, label));
    }
    
    /**
     * Model for browser option
     */
    @Data
    public static class BrowserOption {
        private String value;
        private String label;
        
        /**
         * Create a new browser option
         * 
         * @param value Browser value
         * @param label Browser label
         */
        public BrowserOption(String value, String label) {
            this.value = value;
            this.label = label;
        }
    }
}

// GeneratedTest.java
package com.cssmart.ui.model;

import lombok.Data;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Model for a generated test
 */
@Data
public class GeneratedTest {
    private String id;
    private String name;
    private String description;
    private String className;
    private String methodName;
    private String code;
    private LocalDateTime createdAt;
    private List<String> tags;
}

package com.cssmart.ui.controls;

import com.cssmart.ai.engine.AIEngine;
import com.cssmart.ai.engine.model.ElementAnalysis;
import com.cssmart.ai.engine.model.Locator;
import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.*;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.time.Duration;
import java.util.List;
import java.util.function.Function;

/**
 * Base class for all UI controls that provides common functionality
 */
@Slf4j
public abstract class UIControl {
    protected WebDriver driver;
    protected WebElement element;
    protected String description;
    protected AIEngine aiEngine;
    protected WebDriverWait wait;
    protected int defaultTimeoutSeconds = 10;

    public UIControl(WebDriver driver, WebElement element, String description) {
        this.driver = driver;
        this.element = element;
        this.description = description;
        this.aiEngine = AIEngine.getInstance();
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(defaultTimeoutSeconds));
    }

    public UIControl(WebDriver driver, String description) {
        this.driver = driver;
        this.description = description;
        this.aiEngine = AIEngine.getInstance();
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(defaultTimeoutSeconds));
        this.element = findElement();
    }

    /**
     * Find the element using AI-powered predictions
     * @return WebElement
     */
    protected WebElement findElement() {
        ElementAnalysis analysis = aiEngine.predictElement(description);
        List<Locator> locators = analysis.getLocators();
        
        for (Locator locator : locators) {
            try {
                By by = createBy(locator);
                return wait.until(ExpectedConditions.presenceOfElementLocated(by));
            } catch (Exception e) {
                log.debug("Could not find element with locator: {}", locator);
            }
        }
        
        throw new NoSuchElementException("Failed to find element: " + description);
    }

    /**
     * Create a By locator from a Locator object
     * @param locator the Locator object
     * @return By object
     */
    protected By createBy(Locator locator) {
        switch (locator.getType()) {
            case ID:
                return By.id(locator.getValue());
            case NAME:
                return By.name(locator.getValue());
            case XPATH:
                return By.xpath(locator.getValue());
            case CSS_SELECTOR:
                return By.cssSelector(locator.getValue());
            case CLASS_NAME:
                return By.className(locator.getValue());
            case LINK_TEXT:
                return By.linkText(locator.getValue());
            case PARTIAL_LINK_TEXT:
                return By.partialLinkText(locator.getValue());
            case TAG_NAME:
                return By.tagName(locator.getValue());
            default:
                throw new IllegalArgumentException("Unsupported locator type: " + locator.getType());
        }
    }

    /**
     * Waits for the element to be clickable and clicks it
     * @return this UIControl for chaining
     */
    public UIControl click() {
        refreshElement();
        wait.until(ExpectedConditions.elementToBeClickable(element)).click();
        log.debug("Clicked on element: {}", description);
        return this;
    }

    /**
     * Waits for the element to be clickable and clicks it with JavaScript
     * @return this UIControl for chaining
     */
    public UIControl jsClick() {
        refreshElement();
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript("arguments[0].click();", element);
        log.debug("JS clicked on element: {}", description);
        return this;
    }

    /**
     * Clears the element's content
     * @return this UIControl for chaining
     */
    public UIControl clear() {
        refreshElement();
        element.clear();
        log.debug("Cleared element: {}", description);
        return this;
    }

    /**
     * Types text into the element
     * @param text the text to type
     * @return this UIControl for chaining
     */
    public UIControl type(String text) {
        refreshElement();
        element.clear();
        element.sendKeys(text);
        log.debug("Typed '{}' into element: {}", text, description);
        return this;
    }

    /**
     * Moves the mouse to the element
     * @return this UIControl for chaining
     */
    public UIControl hover() {
        refreshElement();
        Actions actions = new Actions(driver);
        actions.moveToElement(element).perform();
        log.debug("Hovered over element: {}", description);
        return this;
    }

    /**
     * Gets the text of the element
     * @return the element's text
     */
    public String getText() {
        refreshElement();
        String text = element.getText();
        log.debug("Got text '{}' from element: {}", text, description);
        return text;
    }

    /**
     * Gets the value of an attribute
     * @param attributeName the attribute name
     * @return the attribute value
     */
    public String getAttribute(String attributeName) {
        refreshElement();
        String value = element.getAttribute(attributeName);
        log.debug("Got attribute '{}' with value '{}' from element: {}", attributeName, value, description);
        return value;
    }

    /**
     * Gets the value of a CSS property
     * @param propertyName the CSS property name
     * @return the CSS property value
     */
    public String getCssValue(String propertyName) {
        refreshElement();
        return element.getCssValue(propertyName);
    }

    /**
     * Checks if the element is displayed
     * @return true if displayed
     */
    public boolean isDisplayed() {
        try {
            refreshElement();
            return element.isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Checks if the element is enabled
     * @return true if enabled
     */
    public boolean isEnabled() {
        refreshElement();
        return element.isEnabled();
    }

    /**
     * Checks if the element is selected
     * @return true if selected
     */
    public boolean isSelected() {
        refreshElement();
        return element.isSelected();
    }

    /**
     * Waits for a specific condition
     * @param expectedCondition the condition to wait for
     * @param <T> the expected return type
     * @return the result of the condition
     */
    public <T> T waitFor(Function<WebDriver, T> expectedCondition) {
        return wait.until(expectedCondition);
    }

    /**
     * Waits for the element to be visible
     * @return this UIControl for chaining
     */
    public UIControl waitForVisible() {
        wait.until(ExpectedConditions.visibilityOf(element));
        return this;
    }

    /**
     * Waits for the element to be invisible
     * @return this UIControl for chaining
     */
    public UIControl waitForInvisible() {
        wait.until(ExpectedConditions.invisibilityOf(element));
        return this;
    }

    /**
     * Scrolls the element into view
     * @return this UIControl for chaining
     */
    public UIControl scrollIntoView() {
        refreshElement();
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript("arguments[0].scrollIntoView(true);", element);
        log.debug("Scrolled element into view: {}", description);
        return this;
    }

    /**
     * Highlights the element temporarily for debugging
     * @return this UIControl for chaining
     */
    public UIControl highlight() {
        refreshElement();
        JavascriptExecutor js = (JavascriptExecutor) driver;
        String originalStyle = element.getAttribute("style");
        js.executeScript(
                "arguments[0].setAttribute('style', 'border: 2px solid red; background: yellow;');",
                element);
        
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        js.executeScript(
                "arguments[0].setAttribute('style', arguments[1]);",
                element, originalStyle);
        
        return this;
    }

    /**
     * Executes JavaScript on the element
     * @param script the script to execute
     * @param args additional arguments
     * @return the result of the script execution
     */
    public Object executeScript(String script, Object... args) {
        refreshElement();
        JavascriptExecutor js = (JavascriptExecutor) driver;
        return js.executeScript(script, element, args);
    }

    /**
     * Refreshes the WebElement reference to avoid StaleElementReferenceException
     */
    protected void refreshElement() {
        try {
            // Test if element is still valid
            element.isEnabled();
        } catch (StaleElementReferenceException e) {
            log.debug("Refreshing stale element reference: {}", description);
            element = findElement();
        }
    }

    /**
     * Takes a screenshot of this element
     * @return byte array of the screenshot
     */
    public byte[] takeScreenshot() {
        refreshElement();
        scrollIntoView();
        
        if (element instanceof TakesScreenshot) {
            return ((TakesScreenshot) element).getScreenshotAs(OutputType.BYTES);
        }
        
        // Fallback to cropping from full page screenshot
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript("arguments[0].scrollIntoView(true);", element);
        
        // Wait a bit for scrolling to complete
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        return ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);
    }

    /**
     * Get the underlying WebElement
     * @return the WebElement
     */
    public WebElement getElement() {
        refreshElement();
        return element;
    }
    
    /**
     * Set the default timeout for waits
     * @param timeoutSeconds timeout in seconds
     * @return this UIControl for chaining
     */
    public UIControl setTimeout(int timeoutSeconds) {
        this.defaultTimeoutSeconds = timeoutSeconds;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        return this;
    }
}

package com.cssmart.ui.controls;

import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.Select;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Button control for interacting with button elements
 */
@Slf4j
public class Button extends UIControl {
    
    public Button(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public Button(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Checks if the button is active/primary
     * @return true if the button appears to be in active/primary state
     */
    public boolean isPrimary() {
        refreshElement();
        // This is a heuristic and may need to be customized based on the application
        String classes = element.getAttribute("class");
        return classes != null && (classes.contains("primary") || classes.contains("active"));
    }
    
    /**
     * Checks if the button is disabled
     * @return true if the button is disabled
     */
    @Override
    public boolean isEnabled() {
        refreshElement();
        return !element.getAttribute("disabled").equals("true") && element.isEnabled();
    }
}

/**
 * TextField control for interacting with text input elements
 */
@Slf4j
public class TextField extends UIControl {
    
    public TextField(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public TextField(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Types text with validation that the text was entered correctly
     * @param text the text to type
     * @return this TextField for chaining
     */
    @Override
    public TextField type(String text) {
        refreshElement();
        element.clear();
        element.sendKeys(text);
        
        // Verify the text was entered correctly
        String actualValue = getValue();
        if (!actualValue.equals(text)) {
            log.warn("Text verification failed for {}: expected '{}', got '{}'", description, text, actualValue);
            // Try one more time
            element.clear();
            element.sendKeys(text);
        }
        
        log.debug("Typed '{}' into {}", text, description);
        return this;
    }
    
    /**
     * Gets the current value of the text field
     * @return the current value
     */
    public String getValue() {
        refreshElement();
        String value = element.getAttribute("value");
        return value != null ? value : "";
    }
    
    /**
     * Checks if the field is required
     * @return true if the field is required
     */
    public boolean isRequired() {
        refreshElement();
        String required = element.getAttribute("required");
        return Boolean.parseBoolean(required) || "required".equals(required);
    }
    
    /**
     * Checks if the field has validation errors
     * @return true if the field has validation errors
     */
    public boolean hasError() {
        refreshElement();
        String ariaInvalid = element.getAttribute("aria-invalid");
        if ("true".equals(ariaInvalid)) {
            return true;
        }
        
        // Check for error classes (common convention)
        String classes = element.getAttribute("class");
        return classes != null && (classes.contains("error") || classes.contains("invalid"));
    }
    
    /**
     * Gets validation error message if available
     * @return the error message or null if none
     */
    public String getErrorMessage() {
        refreshElement();
        
        // Try to find the error message in common locations
        // 1. Check aria-describedby
        String describedBy = element.getAttribute("aria-describedby");
        if (describedBy != null && !describedBy.isEmpty()) {
            try {
                WebElement errorElement = driver.findElement(By.id(describedBy));
                return errorElement.getText();
            } catch (Exception e) {
                // Ignore and try next method
            }
        }
        
        // 2. Check for sibling or parent error elements
        try {
            // Look for sibling with error class
            WebElement errorElement = driver.findElement(
                By.xpath("./following-sibling::*[contains(@class, 'error') or contains(@class, 'invalid')]")
            );
            return errorElement.getText();
        } catch (Exception e) {
            // Ignore and try next method
        }
        
        // No error message found
        return null;
    }
    
    /**
     * Types text slowly, character by character
     * @param text the text to type slowly
     * @param delayMs delay in milliseconds between characters
     * @return this TextField for chaining
     */
    public TextField typeSlowly(String text, int delayMs) {
        refreshElement();
        element.clear();
        
        for (char c : text.toCharArray()) {
            element.sendKeys(String.valueOf(c));
            try {
                Thread.sleep(delayMs);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        log.debug("Typed '{}' slowly into {}", text, description);
        return this;
    }
}

/**
 * Checkbox control for interacting with checkbox elements
 */
@Slf4j
public class Checkbox extends UIControl {
    
    public Checkbox(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public Checkbox(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Checks if the checkbox is checked
     * @return true if checked
     */
    public boolean isChecked() {
        refreshElement();
        return element.isSelected();
    }
    
    /**
     * Sets the checkbox to the specified state
     * @param check true to check, false to uncheck
     * @return this Checkbox for chaining
     */
    public Checkbox setChecked(boolean check) {
        refreshElement();
        boolean currentState = isChecked();
        
        if (currentState != check) {
            element.click();
            log.debug("{} checkbox {}", check ? "Checked" : "Unchecked", description);
        }
        
        return this;
    }
    
    /**
     * Toggles the checkbox state
     * @return this Checkbox for chaining
     */
    public Checkbox toggle() {
        refreshElement();
        boolean currentState = isChecked();
        element.click();
        log.debug("Toggled checkbox {} from {} to {}", description, currentState, !currentState);
        return this;
    }
}

/**
 * Radio button control for interacting with radio elements
 */
@Slf4j
public class RadioButton extends UIControl {
    
    public RadioButton(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public RadioButton(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Checks if the radio button is selected
     * @return true if selected
     */
    public boolean isSelected() {
        refreshElement();
        return element.isSelected();
    }
    
    /**
     * Selects the radio button
     * @return this RadioButton for chaining
     */
    public RadioButton select() {
        refreshElement();
        if (!isSelected()) {
            element.click();
            log.debug("Selected radio button {}", description);
        }
        return this;
    }
    
    /**
     * Gets all radio buttons in the same group
     * @return list of radio buttons in the same group
     */
    public List<WebElement> getGroupButtons() {
        refreshElement();
        String name = element.getAttribute("name");
        
        if (name != null && !name.isEmpty()) {
            return driver.findElements(By.xpath("//input[@type='radio' and @name='" + name + "']"));
        }
        
        // Fallback if name attribute is not used
        return new ArrayList<>();
    }
}

/**
 * Dropdown control for interacting with select elements
 */
@Slf4j
public class Dropdown extends UIControl {
    private Select select;
    
    public Dropdown(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
        initSelect();
    }
    
    public Dropdown(WebDriver driver, String description) {
        super(driver, description);
        initSelect();
    }
    
    private void initSelect() {
        this.select = new Select(element);
    }
    
    @Override
    protected void refreshElement() {
        super.refreshElement();
        // Recreate Select object after refreshing the element
        this.select = new Select(element);
    }
    
    /**
     * Selects an option by visible text
     * @param text the visible text
     * @return this Dropdown for chaining
     */
    public Dropdown selectByText(String text) {
        refreshElement();
        select.selectByVisibleText(text);
        log.debug("Selected option '{}' in dropdown {}", text, description);
        return this;
    }
    
    /**
     * Selects an option by value attribute
     * @param value the value attribute
     * @return this Dropdown for chaining
     */
    public Dropdown selectByValue(String value) {
        refreshElement();
        select.selectByValue(value);
        log.debug("Selected option with value '{}' in dropdown {}", value, description);
        return this;
    }
    
    /**
     * Selects an option by index
     * @param index the index (0-based)
     * @return this Dropdown for chaining
     */
    public Dropdown selectByIndex(int index) {
        refreshElement();
        select.selectByIndex(index);
        log.debug("Selected option at index {} in dropdown {}", index, description);
        return this;
    }
    
    /**
     * Gets all options in the dropdown
     * @return list of option texts
     */
    public List<String> getOptions() {
        refreshElement();
        return select.getOptions().stream()
                .map(WebElement::getText)
                .collect(Collectors.toList());
    }
    
    /**
     * Gets all option values in the dropdown
     * @return list of option values
     */
    public List<String> getOptionValues() {
        refreshElement();
        return select.getOptions().stream()
                .map(e -> e.getAttribute("value"))
                .collect(Collectors.toList());
    }
    
    /**
     * Gets the selected option text
     * @return the selected option text
     */
    public String getSelectedText() {
        refreshElement();
        return select.getFirstSelectedOption().getText();
    }
    
    /**
     * Gets the selected option value
     * @return the selected option value
     */
    public String getSelectedValue() {
        refreshElement();
        return select.getFirstSelectedOption().getAttribute("value");
    }
    
    /**
     * Checks if this is a multi-select dropdown
     * @return true if multi-select
     */
    public boolean isMultiSelect() {
        refreshElement();
        return select.isMultiple();
    }
    
    /**
     * Gets all selected options in a multi-select dropdown
     * @return list of selected option texts
     */
    public List<String> getSelectedTexts() {
        refreshElement();
        return select.getAllSelectedOptions().stream()
                .map(WebElement::getText)
                .collect(Collectors.toList());
    }
    
    /**
     * Deselects all options in a multi-select dropdown
     * @return this Dropdown for chaining
     */
    public Dropdown deselectAll() {
        refreshElement();
        select.deselectAll();
        log.debug("Deselected all options in dropdown {}", description);
        return this;
    }
}

/**
 * Link control for interacting with anchor elements
 */
@Slf4j
public class Link extends UIControl {
    
    public Link(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public Link(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Gets the URL of the link
     * @return the href attribute
     */
    public String getUrl() {
        refreshElement();
        return element.getAttribute("href");
    }
    
    /**
     * Checks if the link opens in a new tab/window
     * @return true if the link opens in a new tab
     */
    public boolean opensInNewTab() {
        refreshElement();
        String target = element.getAttribute("target");
        return "_blank".equals(target);
    }
    
    /**
     * Follows the link and waits for the page to load
     * @return this Link for chaining
     */
    public Link follow() {
        refreshElement();
        String url = getUrl();
        click();
        
        // Wait for page load
        wait.until(driver -> ((JavascriptExecutor) driver).executeScript("return document.readyState").equals("complete"));
        
        log.debug("Followed link {} to {}", description, url);
        return this;
    }
}

/**
 * Label control for interacting with label elements
 */
@Slf4j
public class Label extends UIControl {
    
    public Label(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public Label(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Gets the for attribute of the label
     * @return the for attribute
     */
    public String getForId() {
        refreshElement();
        return element.getAttribute("for");
    }
    
    /**
     * Gets the associated input element if available
     * @return the associated input element or null
     */
    public WebElement getAssociatedElement() {
        refreshElement();
        String forId = getForId();
        
        if (forId != null && !forId.isEmpty()) {
            try {
                return driver.findElement(By.id(forId));
            } catch (NoSuchElementException e) {
                return null;
            }
        }
        
        // Check if there's a nested input
        try {
            return element.findElement(By.tagName("input"));
        } catch (NoSuchElementException e) {
            return null;
        }
    }
    
    /**
     * Clicks the associated input element
     * @return this Label for chaining
     */
    public Label clickAssociatedElement() {
        refreshElement();
        WebElement associatedElement = getAssociatedElement();
        
        if (associatedElement != null) {
            associatedElement.click();
            log.debug("Clicked associated element for label {}", description);
        } else {
            log.warn("No associated element found for label {}", description);
        }
        
        return this;
    }
}

/**
 * Image control for interacting with image elements
 */
@Slf4j
public class Image extends UIControl {
    
    public Image(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public Image(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Gets the image source URL
     * @return the src attribute
     */
    public String getSource() {
        refreshElement();
        return element.getAttribute("src");
    }
    
    /**
     * Gets the image alt text
     * @return the alt attribute
     */
    public String getAltText() {
        refreshElement();
        return element.getAttribute("alt");
    }
    
    /**
     * Checks if the image has loaded
     * @return true if loaded
     */
    public boolean isLoaded() {
        refreshElement();
        return (Boolean) executeScript("return arguments[0].complete && " +
                "typeof arguments[0].naturalWidth !== 'undefined' && " +
                "arguments[0].naturalWidth > 0");
    }
    
    /**
     * Gets the image dimensions
     * @return array with [width, height]
     */
    public int[] getDimensions() {
        refreshElement();
        int width = element.getSize().getWidth();
        int height = element.getSize().getHeight();
        return new int[] {width, height};
    }
}

/**
 * TextArea control for interacting with textarea elements
 */
@Slf4j
public class TextArea extends TextField {
    
    public TextArea(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public TextArea(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Gets the number of rows
     * @return the rows attribute as an integer
     */
    public int getRows() {
        refreshElement();
        String rows = element.getAttribute("rows");
        try {
            return Integer.parseInt(rows);
        } catch (NumberFormatException e) {
            return 2; // Default
        }
    }
    
    /**
     * Gets the number of columns
     * @return the cols attribute as an integer
     */
    public int getCols() {
        refreshElement();
        String cols = element.getAttribute("cols");
        try {
            return Integer.parseInt(cols);
        } catch (NumberFormatException e) {
            return 20; // Default
        }
    }
    
    /**
     * Appends text to existing content
     * @param text the text to append
     * @return this TextArea for chaining
     */
    public TextArea append(String text) {
        refreshElement();
        element.sendKeys(text);
        log.debug("Appended '{}' to {}", text, description);
        return this;
    }
}

package com.cssmart.ui.controls;

import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.ExpectedConditions;

import java.text.SimpleDateFormat;
import java.time.Duration;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Table control for interacting with data tables
 */
@Slf4j
public class Table extends UIControl {
    private Map<String, Integer> columnIndexMap = new HashMap<>();
    
    public Table(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
        initColumnMap();
    }
    
    public Table(WebDriver driver, String description) {
        super(driver, description);
        initColumnMap();
    }
    
    /**
     * Initialize the column index map for easy access to columns by name
     */
    private void initColumnMap() {
        List<WebElement> headerCells = findHeaderCells();
        for (int i = 0; i < headerCells.size(); i++) {
            String columnName = headerCells.get(i).getText().trim();
            columnIndexMap.put(columnName, i);
        }
        log.debug("Initialized table with columns: {}", columnIndexMap.keySet());
    }
    
    @Override
    protected void refreshElement() {
        super.refreshElement();
        initColumnMap();
    }
    
    /**
     * Find header cells of the table
     * @return list of header cell elements
     */
    public List<WebElement> findHeaderCells() {
        try {
            // Try to find header cells in thead
            List<WebElement> headerCells = element.findElements(By.xpath(".//thead//th"));
            if (!headerCells.isEmpty()) {
                return headerCells;
            }
            
            // Try to find header cells in tbody first row that are th
            headerCells = element.findElements(By.xpath(".//tbody//tr[1]//th"));
            if (!headerCells.isEmpty()) {
                return headerCells;
            }
            
            // Fallback to first row td if no th found
            return element.findElements(By.xpath(".//tr[1]//td"));
        } catch (Exception e) {
            log.warn("Error finding header cells: {}", e.getMessage());
            return new ArrayList<>();
        }
    }
    
    /**
     * Get number of rows in the table body
     * @return row count
     */
    public int getRowCount() {
        try {
            List<WebElement> rows = element.findElements(By.xpath(".//tbody//tr"));
            return rows.size();
        } catch (Exception e) {
            // Fallback to all tr except first (header) row
            List<WebElement> allRows = element.findElements(By.tagName("tr"));
            return Math.max(0, allRows.size() - 1);
        }
    }
    
    /**
     * Get number of columns in the table
     * @return column count
     */
    public int getColumnCount() {
        return columnIndexMap.size();
    }
    
    /**
     * Get a list of all column names
     * @return list of column names
     */
    public List<String> getColumnNames() {
        return new ArrayList<>(columnIndexMap.keySet());
    }
    
    /**
     * Get a specific cell's text by row and column index
     * @param rowIndex row index (0-based)
     * @param columnIndex column index (0-based)
     * @return cell text
     */
    public String getCellText(int rowIndex, int columnIndex) {
        try {
            WebElement cell = getCell(rowIndex, columnIndex);
            return cell.getText();
        } catch (Exception e) {
            log.warn("Error getting cell text at [{}, {}]: {}", rowIndex, columnIndex, e.getMessage());
            return "";
        }
    }
    
    /**
     * Get a specific cell's text by row index and column name
     * @param rowIndex row index (0-based)
     * @param columnName column name
     * @return cell text
     */
    public String getCellText(int rowIndex, String columnName) {
        Integer columnIndex = columnIndexMap.get(columnName);
        if (columnIndex == null) {
            log.warn("Column not found: {}", columnName);
            return "";
        }
        return getCellText(rowIndex, columnIndex);
    }
    
    /**
     * Get a specific cell by row and column index
     * @param rowIndex row index (0-based)
     * @param columnIndex column index (0-based)
     * @return WebElement representing the cell
     */
    public WebElement getCell(int rowIndex, int columnIndex) {
        // Get all rows, add 1 to rowIndex because of 0-based index and XPath starts at 1
        // Also need to account for header row in tbody or thead
        WebElement row;
        try {
            row = element.findElement(By.xpath(".//tbody//tr[" + (rowIndex + 1) + "]"));
        } catch (Exception e) {
            // Fallback to any tr, but account for header row
            row = element.findElement(By.xpath(".//tr[" + (rowIndex + 2) + "]"));
        }
        
        // Get all cells in the row
        List<WebElement> cells = row.findElements(By.xpath(".//td"));
        if (cells.isEmpty()) {
            cells = row.findElements(By.xpath(".//th"));
        }
        
        if (columnIndex >= 0 && columnIndex < cells.size()) {
            return cells.get(columnIndex);
        } else {
            throw new IndexOutOfBoundsException("Column index out of bounds: " + columnIndex);
        }
    }
    
    /**
     * Get a specific cell by row index and column name
     * @param rowIndex row index (0-based)
     * @param columnName column name
     * @return WebElement representing the cell
     */
    public WebElement getCell(int rowIndex, String columnName) {
        Integer columnIndex = columnIndexMap.get(columnName);
        if (columnIndex == null) {
            throw new NoSuchElementException("Column not found: " + columnName);
        }
        return getCell(rowIndex, columnIndex);
    }
    
    /**
     * Click a cell by row and column indices
     * @param rowIndex row index (0-based)
     * @param columnIndex column index (0-based)
     * @return this Table for chaining
     */
    public Table clickCell(int rowIndex, int columnIndex) {
        WebElement cell = getCell(rowIndex, columnIndex);
        cell.click();
        log.debug("Clicked cell at [{}, {}] in table {}", rowIndex, columnIndex, description);
        return this;
    }
    
    /**
     * Click a cell by row index and column name
     * @param rowIndex row index (0-based)
     * @param columnName column name
     * @return this Table for chaining
     */
    public Table clickCell(int rowIndex, String columnName) {
        WebElement cell = getCell(rowIndex, columnName);
        cell.click();
        log.debug("Clicked cell at [row {}, column '{}'] in table {}", rowIndex, columnName, description);
        return this;
    }
    
    /**
     * Get all data from the table as a list of maps
     * @return list of maps where each map represents a row with column name as key
     */
    public List<Map<String, String>> getAllData() {
        List<Map<String, String>> allData = new ArrayList<>();
        int rowCount = getRowCount();
        
        for (int i = 0; i < rowCount; i++) {
            Map<String, String> rowData = new HashMap<>();
            for (String columnName : columnIndexMap.keySet()) {
                rowData.put(columnName, getCellText(i, columnName));
            }
            allData.add(rowData);
        }
        
        return allData;
    }
    
    /**
     * Find row index by text in a specific column
     * @param columnName column name to search in
     * @param text text to search for
     * @return row index or -1 if not found
     */
    public int findRowByColumnText(String columnName, String text) {
        Integer columnIndex = columnIndexMap.get(columnName);
        if (columnIndex == null) {
            log.warn("Column not found: {}", columnName);
            return -1;
        }
        
        int rowCount = getRowCount();
        for (int i = 0; i < rowCount; i++) {
            String cellText = getCellText(i, columnIndex);
            if (text.equals(cellText)) {
                return i;
            }
        }
        
        return -1;
    }
    
    /**
     * Sort the table by clicking on a column header
     * @param columnName name of the column to sort by
     * @return this Table for chaining
     */
    public Table sortBy(String columnName) {
        Integer columnIndex = columnIndexMap.get(columnName);
        if (columnIndex == null) {
            log.warn("Column not found: {}", columnName);
            return this;
        }
        
        List<WebElement> headers = findHeaderCells();
        if (columnIndex < headers.size()) {
            headers.get(columnIndex).click();
            log.debug("Sorted table {} by column '{}'", description, columnName);
            
            // Wait a moment for sort to complete
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        return this;
    }
    
    /**
     * Get row data as a map
     * @param rowIndex row index (0-based)
     * @return map of column name to cell text
     */
    public Map<String, String> getRowData(int rowIndex) {
        Map<String, String> rowData = new HashMap<>();
        for (String columnName : columnIndexMap.keySet()) {
            rowData.put(columnName, getCellText(rowIndex, columnName));
        }
        return rowData;
    }
    
    /**
     * Get column data as a list
     * @param columnName column name
     * @return list of cell texts in the column
     */
    public List<String> getColumnData(String columnName) {
        Integer columnIndex = columnIndexMap.get(columnName);
        if (columnIndex == null) {
            log.warn("Column not found: {}", columnName);
            return new ArrayList<>();
        }
        
        List<String> columnData = new ArrayList<>();
        int rowCount = getRowCount();
        for (int i = 0; i < rowCount; i++) {
            columnData.add(getCellText(i, columnIndex));
        }
        
        return columnData;
    }
    
    /**
     * Check if a value exists in a specific column
     * @param columnName column name
     * @param value value to check
     * @return true if exists
     */
    public boolean columnContains(String columnName, String value) {
        return getColumnData(columnName).contains(value);
    }
}

/**
 * DatePicker control for interacting with date picker components
 */
@Slf4j
public class DatePicker extends UIControl {
    // Common date picker formats
    private static final String[] DATE_FORMATS = {
            "MM/dd/yyyy", "yyyy-MM-dd", "dd/MM/yyyy", "MM-dd-yyyy"
    };
    
    public DatePicker(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public DatePicker(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Sets the date using direct input when possible
     * @param date Date string in format MM/dd/yyyy
     * @return this DatePicker for chaining
     */
    public DatePicker setDate(String date) {
        refreshElement();
        
        // First try direct input if it's a text field
        try {
            element.clear();
            element.sendKeys(date);
            element.sendKeys(Keys.TAB); // To trigger date change event
            log.debug("Set date '{}' in date picker {}", date, description);
            return this;
        } catch (Exception e) {
            log.debug("Could not set date via direct input, trying UI interaction");
        }
        
        // If direct input fails, try to open the date picker and interact with it
        return setDateViaUI(date);
    }
    
    /**
     * Sets the date via UI interaction when direct input doesn't work
     * @param dateStr Date string in format MM/dd/yyyy
     * @return this DatePicker for chaining
     */
    private DatePicker setDateViaUI(String dateStr) {
        try {
            // Try to parse the date
            Date date = parseDate(dateStr);
            if (date == null) {
                throw new IllegalArgumentException("Invalid date format: " + dateStr);
            }
            
            // Open the date picker
            element.click();
            
            // Wait for the date picker popup
            wait.until(driver -> driver.findElements(By.cssSelector(".ui-datepicker, .datepicker, .calendar")).size() > 0
                    || driver.findElements(By.xpath("//*[contains(@class, 'datepicker') or contains(@class, 'calendar')]")).size() > 0);
            
            // Navigate to the correct month and year
            navigateToMonthAndYear(date);
            
            // Select the day
            selectDay(date);
            
            log.debug("Set date '{}' in date picker {} via UI", dateStr, description);
            return this;
        } catch (Exception e) {
            log.error("Failed to set date via UI: {}", e.getMessage());
            throw new RuntimeException("Failed to set date in date picker", e);
        }
    }
    
    /**
     * Parses a date string using multiple common formats
     * @param dateStr date string
     * @return Date object or null if parsing fails
     */
    private Date parseDate(String dateStr) {
        for (String format : DATE_FORMATS) {
            try {
                SimpleDateFormat sdf = new SimpleDateFormat(format);
                sdf.setLenient(false);
                return sdf.parse(dateStr);
            } catch (Exception e) {
                // Try next format
            }
        }
        return null;
    }
    
    /**
     * Navigate to the correct month and year in the date picker
     * @param date target date
     */
    private void navigateToMonthAndYear(Date date) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        int targetMonth = cal.get(Calendar.MONTH);
        int targetYear = cal.get(Calendar.YEAR);
        
        // This is a generic approach and might need customization based on the actual date picker
        // Try to find month/year display
        WebElement monthYearDisplay = null;
        try {
            monthYearDisplay = driver.findElement(By.cssSelector(".ui-datepicker-title, .datepicker-title, .calendar-title"));
        } catch (Exception e) {
            monthYearDisplay = driver.findElement(By.xpath("//*[contains(@class, 'datepicker-title') or contains(@class, 'calendar-title') or contains(@class, 'month-year')]"));
        }
        
        // Extract current month and year
        String displayText = monthYearDisplay.getText();
        log.debug("Date picker display text: {}", displayText);
        
        // This is simplified and might need adjustment based on the actual format
        // For now, just click prev/next until we reach the target month
        // Max iterations to prevent infinite loop
        int maxIterations = 24; // 2 years in either direction
        int iterations = 0;
        
        while (iterations < maxIterations) {
            iterations++;
            
            // Check if we're at the target month and year
            displayText = monthYearDisplay.getText();
            
            // Very simplified check - in real use would need proper parsing
            boolean atTargetMonth = displayText.contains(String.valueOf(targetMonth + 1)) &&
                    displayText.contains(String.valueOf(targetYear));
            
            if (atTargetMonth) {
                break;
            }
            
            // Determine if we need to go forward or backward
            // This is a simplification and would need adjustment
            WebElement navButton;
            if (displayText.contains(String.valueOf(targetYear)) && !displayText.contains(String.valueOf(targetMonth + 1))) {
                // Same year, different month
                int currentMonth = -1;
                for (int i = 0; i < 12; i++) {
                    Calendar tempCal = Calendar.getInstance();
                    tempCal.set(Calendar.MONTH, i);
                    String monthName = tempCal.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.getDefault());
                    if (displayText.contains(monthName)) {
                        currentMonth = i;
                        break;
                    }
                }
                
                if (currentMonth < targetMonth) {
                    navButton = driver.findElement(By.cssSelector(".ui-datepicker-next, .datepicker-next, .calendar-next"));
                } else {
                    navButton = driver.findElement(By.cssSelector(".ui-datepicker-prev, .datepicker-prev, .calendar-prev"));
                }
            } else {
                // Different year
                try {
                    int currentYear = Integer.parseInt(displayText.replaceAll("[^0-9]", ""));
                    if (currentYear < targetYear) {
                        navButton = driver.findElement(By.cssSelector(".ui-datepicker-next, .datepicker-next, .calendar-next"));
                    } else {
                        navButton = driver.findElement(By.cssSelector(".ui-datepicker-prev, .datepicker-prev, .calendar-prev"));
                    }
                } catch (Exception e) {
                    // If parsing fails, just try going forward
                    navButton = driver.findElement(By.cssSelector(".ui-datepicker-next, .datepicker-next, .calendar-next"));
                }
            }
            
            navButton.click();
            
            // Wait for the UI to update
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    /**
     * Select the specific day in the current month view
     * @param date target date
     */
    private void selectDay(Date date) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(date);
        int targetDay = cal.get(Calendar.DAY_OF_MONTH);
        
        // Find the day element and click it
        List<WebElement> dayElements = driver.findElements(By.cssSelector(".ui-datepicker-calendar td, .datepicker-days td, .calendar-days td"));
        for (WebElement dayElement : dayElements) {
            String dayText = dayElement.getText().trim();
            if (dayText.equals(String.valueOf(targetDay))) {
                dayElement.click();
                return;
            }
        }
        
        throw new NoSuchElementException("Could not find day " + targetDay + " in date picker");
    }
    
    /**
     * Gets the current value of the date picker
     * @return the current date string
     */
    public String getDate() {
        refreshElement();
        return element.getAttribute("value");
    }
}

/**
 * FileUpload control for interacting with file input elements
 */
@Slf4j
public class FileUpload extends UIControl {
    
    public FileUpload(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public FileUpload(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Uploads a file by setting the file path
     * @param filePath absolute path to the file
     * @return this FileUpload for chaining
     */
    public FileUpload uploadFile(String filePath) {
        refreshElement();
        element.sendKeys(filePath);
        log.debug("Uploaded file '{}' via {}", filePath, description);
        return this;
    }
    
    /**
     * Gets the file name from the input
     * @return file name or empty string
     */
    public String getFileName() {
        refreshElement();
        String value = element.getAttribute("value");
        if (value == null || value.isEmpty()) {
            return "";
        }
        
        // Extract filename from path
        int lastSep = Math.max(value.lastIndexOf('\\'), value.lastIndexOf('/'));
        if (lastSep >= 0 && lastSep < value.length() - 1) {
            return value.substring(lastSep + 1);
        }
        
        return value;
    }
    
    /**
     * Gets a list of allowed file extensions
     * @return list of allowed extensions or empty list
     */
    public List<String> getAllowedExtensions() {
        refreshElement();
        String accept = element.getAttribute("accept");
        if (accept == null || accept.isEmpty()) {
            return new ArrayList<>();
        }
        
        // Parse accept attribute
        return Arrays.stream(accept.split(","))
                .map(String::trim)
                .collect(Collectors.toList());
    }
    
    /**
     * Checks if a specific file type is allowed
     * @param fileExtension file extension to check (e.g., ".pdf")
     * @return true if allowed
     */
    public boolean isFileTypeAllowed(String fileExtension) {
        List<String> allowedExtensions = getAllowedExtensions();
        if (allowedExtensions.isEmpty()) {
            return true; // If no restrictions specified, all types are allowed
        }
        
        String normalizedExtension = fileExtension.startsWith(".") ? fileExtension : "." + fileExtension;
        
        return allowedExtensions.stream().anyMatch(ext -> 
                ext.equalsIgnoreCase(normalizedExtension) || 
                ext.equals("*.*") ||
                ext.equals("*") ||
                (ext.startsWith("*.") && ext.substring(1).equalsIgnoreCase(normalizedExtension)) ||
                // Check MIME types like image/*
                (ext.endsWith("/*") && normalizedExtension.matches("\\.(jpe?g|png|gif|bmp|webp)$") && ext.startsWith("image/")) ||
                (ext.endsWith("/*") && normalizedExtension.matches("\\.(pdf|doc|docx|xls|xlsx|ppt|pptx)$") && ext.startsWith("application/"))
        );
    }
}

/**
 * Modal control for interacting with modal dialogs
 */
@Slf4j
public class Modal extends UIControl {
    
    public Modal(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public Modal(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Gets the title of the modal
     * @return modal title text
     */
    public String getTitle() {
        refreshElement();
        try {
            WebElement titleElement = element.findElement(By.cssSelector(".modal-title, .dialog-title, header, h1, h2, h3"));
            return titleElement.getText();
        } catch (Exception e) {
            log.debug("Could not find modal title element");
            return "";
        }
    }
    
    /**
     * Gets the body text of the modal
     * @return modal body text
     */
    public String getBodyText() {
        refreshElement();
        try {
            WebElement bodyElement = element.findElement(By.cssSelector(".modal-body, .dialog-body, .body, main"));
            return bodyElement.getText();
        } catch (Exception e) {
            log.debug("Could not find modal body element");
            return "";
        }
    }
    
    /**
     * Closes the modal by clicking close button
     * @return this Modal for chaining
     */
    public Modal close() {
        refreshElement();
        try {
            WebElement closeButton = element.findElement(By.cssSelector(".close, .modal-close, [aria-label='Close'], button[title='Close']"));
            closeButton.click();
            log.debug("Closed modal {}", description);
            
            // Wait for modal to be gone
            wait.until(ExpectedConditions.invisibilityOf(element));
            return this;
        } catch (Exception e) {
            log.warn("Could not find close button for modal {}", description);
            throw new NoSuchElementException("Close button not found for modal");
        }
    }
    
    /**
     * Clicks a button in the modal by text
     * @param buttonText text of the button
     * @return this Modal for chaining
     */
    public Modal clickButton(String buttonText) {
        refreshElement();
        try {
            // Try to find by text
            WebElement button = element.findElement(By.xpath(
                    ".//button[contains(text(), '" + buttonText + "')] | " +
                    ".//a[contains(text(), '" + buttonText + "')] | " +
                    ".//*[contains(@class, 'btn') and contains(text(), '" + buttonText + "')]"
            ));
            button.click();
            log.debug("Clicked button '{}' in modal {}", buttonText, description);
            return this;
        } catch (Exception e) {
            log.warn("Could not find button with text '{}' in modal {}", buttonText, description);
            throw new NoSuchElementException("Button not found: " + buttonText);
        }
    }
    
    /**
     * Waits for the modal to be fully visible
     * @return this Modal for chaining
     */
    public Modal waitForVisible() {
        wait.until(ExpectedConditions.visibilityOf(element));
        
        // Also wait for any animation to complete
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        log.debug("Modal {} is now visible", description);
        return this;
    }
    
    /**
     * Gets all available button texts
     * @return list of button texts
     */
    public List<String> getButtonTexts() {
        refreshElement();
        List<WebElement> buttons = element.findElements(By.tagName("button"));
        buttons.addAll(element.findElements(By.cssSelector("a.btn, input[type='button'], input[type='submit']")));
        
        return buttons.stream()
                .map(WebElement::getText)
                .filter(text -> !text.isEmpty())
                .collect(Collectors.toList());
    }
}

/**
 * IFrame control for interacting with iframe elements
 */
@Slf4j
public class IFrame extends UIControl {
    
    public IFrame(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public IFrame(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Switches focus to this iframe
     * @return this IFrame for chaining
     */
    public IFrame switchTo() {
        refreshElement();
        driver.switchTo().frame(element);
        log.debug("Switched to iframe {}", description);
        return this;
    }
    
    /**
     * Switches focus back to the parent frame
     * @return this IFrame for chaining
     */
    public IFrame switchToParent() {
        driver.switchTo().parentFrame();
        log.debug("Switched back from iframe {} to parent frame", description);
        return this;
    }
    
    /**
     * Executes an action inside the iframe and switches back
     * @param action the action to perform
     * @param <T> return type of the action
     * @return result of the action
     */
    public <T> T withFrameAndBack(FrameAction<T> action) {
        switchTo();
        try {
            return action.perform();
        } finally {
            switchToParent();
        }
    }
    
    /**
     * Interface for actions to perform inside an iframe
     * @param <T> return type
     */
    @FunctionalInterface
    public interface FrameAction<T> {
        T perform();
    }
    
    /**
     * Gets the source URL of the iframe
     * @return src attribute
     */
    public String getSource() {
        refreshElement();
        return element.getAttribute("src");
    }
    
    /**
     * Gets the name of the iframe
     * @return name attribute
     */
    public String getName() {
        refreshElement();
        return element.getAttribute("name");
    }
}

/**
 * Slider control for interacting with range input elements
 */
@Slf4j
public class Slider extends UIControl {
    
    public Slider(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public Slider(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Gets the current value of the slider
     * @return current value as a string
     */
    public String getValue() {
        refreshElement();
        return element.getAttribute("value");
    }
    
    /**
     * Gets the min value of the slider
     * @return min value
     */
    public String getMin() {
        refreshElement();
        return element.getAttribute("min");
    }
    
    /**
     * Gets the max value of the slider
     * @return max value
     */
    public String getMax() {
        refreshElement();
        return element.getAttribute("max");
    }
    
    /**
     * Gets the step size of the slider
     * @return step size
     */
    public String getStep() {
        refreshElement();
        String step = element.getAttribute("step");
        return step != null && !step.isEmpty() ? step : "1";
    }
    
    /**
     * Sets the slider to a specific value
     * @param value target value
     * @return this Slider for chaining
     */
    public Slider setValue(double value) {
        refreshElement();
        
        // Try using JavaScript to set the value directly
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript("arguments[0].value = arguments[1]; " +
                "arguments[0].dispatchEvent(new Event('input', { bubbles: true })); " +
                "arguments[0].dispatchEvent(new Event('change', { bubbles: true }));", 
                element, String.valueOf(value));
        
        log.debug("Set slider {} to value {}", description, value);
        return this;
    }
    
    /**
     * Moves the slider by a relative amount
     * @param offset offset amount (positive or negative)
     * @return this Slider for chaining
     */
    public Slider moveBy(double offset) {
        refreshElement();
        double currentValue = Double.parseDouble(getValue());
        return setValue(currentValue + offset);
    }
    
    /**
     * Moves the slider to a percentage of its range
     * @param percent percentage (0-100)
     * @return this Slider for chaining
     */
    public Slider setPercent(double percent) {
        refreshElement();
        
        if (percent < 0 || percent > 100) {
            throw new IllegalArgumentException("Percentage must be between 0 and 100");
        }
        
        double min = Double.parseDouble(getMin());
        double max = Double.parseDouble(getMax());
        double range = max - min;
        double value = min + (range * percent / 100);
        
        return setValue(value);
    }
}

/**
 * DragAndDrop utility for drag and drop operations
 */
@Slf4j
public class DragAndDrop {
    private final WebDriver driver;
    
    public DragAndDrop(WebDriver driver) {
        this.driver = driver;
    }
    
    /**
     * Drags and drops an element to another element
     * @param source source element
     * @param target target element
     */
    public void dragAndDrop(WebElement source, WebElement target) {
        new org.openqa.selenium.interactions.Actions(driver)
                .dragAndDrop(source, target)
                .perform();
        log.debug("Dragged and dropped element to target");
    }
    
    /**
     * Drags and drops by offset
     * @param source source element
     * @param xOffset x offset
     * @param yOffset y offset
     */
    public void dragAndDropByOffset(WebElement source, int xOffset, int yOffset) {
        new org.openqa.selenium.interactions.Actions(driver)
                .dragAndDropBy(source, xOffset, yOffset)
                .perform();
        log.debug("Dragged and dropped element by offset ({}, {})", xOffset, yOffset);
    }
    
    /**
     * Drags and drops using JavaScript (more reliable in some browsers)
     * @param source source element
     * @param target target element
     */
    public void dragAndDropJS(WebElement source, WebElement target) {
        String jsScript = 
                "function createEvent(typeOfEvent) {\n" +
                "  var event = document.createEvent(\"CustomEvent\");\n" +
                "  event.initCustomEvent(typeOfEvent, true, true, null);\n" +
                "  event.dataTransfer = { data: {}, };\n" +
                "  event.dataTransfer.setData = function(key, value) { this.data[key] = value; };\n" +
                "  event.dataTransfer.getData = function(key) { return this.data[key]; };\n" +
                "  return event;\n" +
                "}\n" +
                "\n" +
                "function dispatchEvent(element, event, transferData) {\n" +
                "  if (transferData !== undefined) {\n" +
                "    event.dataTransfer = transferData;\n" +
                "  }\n" +
                "  if (element.dispatchEvent) {\n" +
                "    element.dispatchEvent(event);\n" +
                "  } else if (element.fireEvent) {\n" +
                "    element.fireEvent('on' + event.type, event);\n" +
                "  }\n" +
                "}\n" +
                "\n" +
                "function simulateHTML5DragAndDrop(element, target) {\n" +
                "  var dragStartEvent = createEvent('dragstart');\n" +
                "  dispatchEvent(element, dragStartEvent);\n" +
                "  var dropEvent = createEvent('drop');\n" +
                "  dispatchEvent(target, dropEvent, dragStartEvent.dataTransfer);\n" +
                "  var dragEndEvent = createEvent('dragend');\n" +
                "  dispatchEvent(element, dragEndEvent, dropEvent.dataTransfer);\n" +
                "}\n" +
                "\n" +
                "simulateHTML5DragAndDrop(arguments[0], arguments[1]);";
        
        JavascriptExecutor js = (JavascriptExecutor) driver;
        js.executeScript(jsScript, source, target);
        log.debug("Dragged and dropped element using JavaScript");
    }
}

/**
 * Tooltip control for interacting with tooltip elements
 */
@Slf4j
public class Tooltip extends UIControl {
    
    public Tooltip(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public Tooltip(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Hovers over the element to display the tooltip
     * @return this Tooltip for chaining
     */
    public Tooltip show() {
        refreshElement();
        hover();
        
        // Wait a moment for the tooltip to appear
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        log.debug("Showed tooltip for {}", description);
        return this;
    }
    
    /**
     * Gets the text of the tooltip
     * @return tooltip text
     */
    public String getTooltipText() {
        show();
        
        // Try different ways to find the tooltip
        try {
            // Try aria-describedby
            String describedBy = element.getAttribute("aria-describedby");
            if (describedBy != null && !describedBy.isEmpty()) {
                WebElement tooltip = driver.findElement(By.id(describedBy));
                return tooltip.getText();
            }
            
            // Try title attribute
            String title = element.getAttribute("title");
            if (title != null && !title.isEmpty()) {
                return title;
            }
            
            // Try data-tooltip attribute
            String dataTooltip = element.getAttribute("data-tooltip");
            if (dataTooltip != null && !dataTooltip.isEmpty()) {
                return dataTooltip;
            }
            
            // Try to find tooltip element in the DOM
            WebElement tooltipElement = driver.findElement(By.cssSelector(".tooltip, .tooltiptext, [role='tooltip']"));
            return tooltipElement.getText();
        } catch (Exception e) {
            log.warn("Could not get tooltip text: {}", e.getMessage());
            return "";
        }
    }
}

/**
 * Represents a cell in a data table with enhanced interaction capabilities
 */
@Data
public class TableCell {
    private final WebElement element;
    private final int rowIndex;
    private final int columnIndex;
    private final String columnName;
    
    /**
     * Gets the text of the cell
     * @return cell text
     */
    public String getText() {
        return element.getText();
    }
    
    /**
     * Clicks the cell
     */
    public void click() {
        element.click();
    }
    
    /**
     * Gets the value of an attribute
     * @param attributeName attribute name
     * @return attribute value
     */
    public String getAttribute(String attributeName) {
        return element.getAttribute(attributeName);
    }
}

/**
 * AutoComplete control for interacting with autocomplete/combobox elements
 */
@Slf4j
public class AutoComplete extends UIControl {
    
    public AutoComplete(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public AutoComplete(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Types text and selects an option from the dropdown
     * @param text text to type
     * @param optionText text of the option to select
     * @return this AutoComplete for chaining
     */
    public AutoComplete typeAndSelect(String text, String optionText) {
        refreshElement();
        element.clear();
        element.sendKeys(text);
        
        // Wait for dropdown to appear
        waitForSuggestions();
        
        // Find and click the option
        WebElement option = findOptionWithText(optionText);
        option.click();
        
        log.debug("Typed '{}' and selected '{}' in autocomplete {}", text, optionText, description);
        return this;
    }
    
    /**
     * Types text without selecting an option
     * @param text text to type
     * @return this AutoComplete for chaining
     */
    public AutoComplete typeOnly(String text) {
        refreshElement();
        element.clear();
        element.sendKeys(text);
        log.debug("Typed '{}' in autocomplete {}", text, description);
        return this;
    }
    
    /**
     * Waits for suggestions to appear
     * @return this AutoComplete for chaining
     */
    public AutoComplete waitForSuggestions() {
        try {
            wait.until(driver -> {
                // Try common selectors for autocomplete dropdowns
                return !driver.findElements(By.cssSelector(
                        ".autocomplete-suggestions, .dropdown-menu, .ui-autocomplete, " +
                        ".ui-menu, .suggestion-list, .combobox-options")).isEmpty();
            });
        } catch (Exception e) {
            log.warn("No suggestions appeared for autocomplete {}", description);
        }
        return this;
    }
    
    /**
     * Gets all suggestion texts
     * @return list of suggestion texts
     */
    public List<String> getSuggestions() {
        waitForSuggestions();
        
        List<WebElement> suggestions = findSuggestionElements();
        return suggestions.stream()
                .map(WebElement::getText)
                .collect(Collectors.toList());
    }
    
    /**
     * Finds an option element with the specified text
     * @param optionText the text to find
     * @return the option WebElement
     */
    private WebElement findOptionWithText(String optionText) {
        List<WebElement> suggestions = findSuggestionElements();
        
        for (WebElement suggestion : suggestions) {
            if (suggestion.getText().equals(optionText)) {
                return suggestion;
            }
        }
        
        throw new NoSuchElementException("Could not find suggestion with text: " + optionText);
    }
    
    /**
     * Finds all suggestion elements
     * @return list of suggestion elements
     */
    private List<WebElement> findSuggestionElements() {
        // Try multiple selectors for different autocomplete implementations
        List<WebElement> suggestions = driver.findElements(By.cssSelector(
                ".autocomplete-suggestion, .dropdown-item, .ui-menu-item, " +
                ".ui-autocomplete li, .suggestion-item, .combobox-option"));
        
        if (suggestions.isEmpty()) {
            // Try XPath as fallback
            suggestions = driver.findElements(By.xpath(
                    "//*[contains(@class, 'autocomplete') or contains(@class, 'suggestion') or " +
                    "contains(@class, 'dropdown')]//li"));
        }
        
        return suggestions;
    }
}

/**
 * Tab control for interacting with tab interfaces
 */
@Slf4j
public class TabPanel extends UIControl {
    
    public TabPanel(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public TabPanel(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Selects a tab by its text
     * @param tabText the tab text
     * @return this TabPanel for chaining
     */
    public TabPanel selectTab(String tabText) {
        refreshElement();
        
        // Find all tab headers
        List<WebElement> tabs = findTabHeaders();
        
        // Click the tab with matching text
        for (WebElement tab : tabs) {
            if (tab.getText().trim().equals(tabText)) {
                tab.click();
                log.debug("Selected tab '{}' in tab panel {}", tabText, description);
                
                // Wait for tab content to be visible
                try {
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                
                return this;
            }
        }
        
        throw new NoSuchElementException("Could not find tab with text: " + tabText);
    }
    
    /**
     * Gets the currently active tab text
     * @return active tab text
     */
    public String getActiveTabText() {
        refreshElement();
        List<WebElement> tabs = findTabHeaders();
        
        for (WebElement tab : tabs) {
            String classes = tab.getAttribute("class");
            if (classes != null && (classes.contains("active") || classes.contains("selected") || classes.contains("current"))) {
                return tab.getText().trim();
            }
        }
        
        return null;
    }
    
    /**
     * Gets all tab texts
     * @return list of tab texts
     */
    public List<String> getAllTabTexts() {
        refreshElement();
        List<WebElement> tabs = findTabHeaders();
        
        return tabs.stream()
                .map(tab -> tab.getText().trim())
                .collect(Collectors.toList());
    }
    
    /**
     * Finds all tab header elements
     * @return list of tab header elements
     */
    private List<WebElement> findTabHeaders() {
        // Try different selectors for tab headers
        List<WebElement> tabs = element.findElements(By.cssSelector(
                ".nav-tab, .tab-header, .ui-tab, .tab-button, li[role='tab']"));
        
        if (tabs.isEmpty()) {
            // Try alternative selectors
            tabs = element.findElements(By.cssSelector(".nav-item a, .tab a, ul.tabs li"));
        }
        
        if (tabs.isEmpty()) {
            // Try generic approach
            tabs = element.findElements(By.xpath(".//*[contains(@class, 'tab') and not(contains(@class, 'content'))]"));
        }
        
        return tabs;
    }
    
    /**
     * Gets the current active tab content element
     * @return the active content WebElement
     */
    public WebElement getActiveContent() {
        refreshElement();
        
        // Try different selectors for active content
        try {
            return element.findElement(By.cssSelector(
                    ".tab-content.active, .tab-panel.active, .tab-pane.active, .ui-tabs-panel:not(.ui-tabs-hide), [role='tabpanel']:not([hidden])"));
        } catch (NoSuchElementException e) {
            log.warn("Could not find active tab content in tab panel {}", description);
            throw new NoSuchElementException("No active tab content found");
        }
    }
}

/**
 * Notification control for interacting with notifications/toasts
 */
@Slf4j
public class Notification extends UIControl {
    
    public Notification(WebDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }
    
    public Notification(WebDriver driver, String description) {
        super(driver, description);
    }
    
    /**
     * Gets the notification message
     * @return notification message text
     */
    public String getMessage() {
        refreshElement();
        return element.getText();
    }
    
    /**
     * Determines the notification type (success, error, warning, etc.)
     * @return notification type or "unknown"
     */
    public String getType() {
        refreshElement();
        String classes = element.getAttribute("class");
        
        if (classes.contains("success")) return "success";
        if (classes.contains("error") || classes.contains("danger")) return "error";
        if (classes.contains("warning")) return "warning";
        if (classes.contains("info")) return "info";
        
        return "unknown";
    }
    
    /**
     * Dismisses the notification if possible
     * @return this Notification for chaining
     */
    public Notification dismiss() {
        refreshElement();
        
        try {
            // Try to find close button
            WebElement closeButton = element.findElement(By.cssSelector(
                    ".close, .dismiss, .notification-close, button[aria-label='Close']"));
            closeButton.click();
            log.debug("Dismissed notification {}", description);
            
            // Wait for notification to disappear
            wait.until(ExpectedConditions.invisibilityOf(element));
        } catch (Exception e) {
            log.warn("Could not find close button for notification {}", description);
            
            // Try clicking the notification itself as fallback
            element.click();
            log.debug("Clicked notification to dismiss it");
        }
        
        return this;
    }
    
    /**
     * Waits for the notification to auto-dismiss
     * @param timeoutSeconds max time to wait
     * @return true if notification disappeared
     */
    public boolean waitForAutoDismiss(int timeoutSeconds) {
        try {
            WebDriverWait longWait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
            longWait.until(ExpectedConditions.invisibilityOf(element));
            log.debug("Notification was auto-dismissed");
            return true;
        } catch (Exception e) {
            log.debug("Notification did not auto-dismiss within {} seconds", timeoutSeconds);
            return false;
        }
    }
}

package com.cssmart.ui.controls;

import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.By;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

/**
 * Factory for creating UI control objects based on element type or description
 */
@Slf4j
public class UIControlFactory {
    private final WebDriver driver;
    
    public UIControlFactory(WebDriver driver) {
        this.driver = driver;
    }
    
    /**
     * Create a control by element description using AI to find the element
     * @param description element description
     * @return appropriate UI control instance
     */
    public UIControl createControl(String description) {
        // Use heuristics from the description to determine control type
        if (description.toLowerCase().contains("button") || description.toLowerCase().contains("submit")) {
            return new Button(driver, description);
        } else if (description.toLowerCase().contains("checkbox")) {
            return new Checkbox(driver, description);
        } else if (description.toLowerCase().contains("radio")) {
            return new RadioButton(driver, description);
        } else if (description.toLowerCase().contains("dropdown") || description.toLowerCase().contains("select")) {
            return new Dropdown(driver, description);
        } else if (description.toLowerCase().contains("link")) {
            return new Link(driver, description);
        } else if (description.toLowerCase().contains("image") || description.toLowerCase().contains("img")) {
            return new Image(driver, description);
        } else if (description.toLowerCase().contains("date") || description.toLowerCase().contains("calendar")) {
            return new DatePicker(driver, description);
        } else if (description.toLowerCase().contains("file") || description.toLowerCase().contains("upload")) {
            return new FileUpload(driver, description);
        } else if (description.toLowerCase().contains("textarea")) {
            return new TextArea(driver, description);
        } else if (description.toLowerCase().contains("table")) {
            return new Table(driver, description);
        } else if (description.toLowerCase().contains("iframe") || description.toLowerCase().contains("frame")) {
            return new IFrame(driver, description);
        } else if (description.toLowerCase().contains("slider") || description.toLowerCase().contains("range")) {
            return new Slider(driver, description);
        } else if (description.toLowerCase().contains("tab")) {
            return new TabPanel(driver, description);
        } else if (description.toLowerCase().contains("modal") || description.toLowerCase().contains("dialog")) {
            return new Modal(driver, description);
        } else if (description.toLowerCase().contains("autocomplete") || description.toLowerCase().contains("combobox")) {
            return new AutoComplete(driver, description);
        } else if (description.toLowerCase().contains("notification") || description.toLowerCase().contains("toast")) {
            return new Notification(driver, description);
        } else if (description.toLowerCase().contains("tooltip")) {
            return new Tooltip(driver, description);
        } else if (description.toLowerCase().contains("label")) {
            return new Label(driver, description);
        } else {
            // Default to TextField for input or generic UIControl for others
            if (description.toLowerCase().contains("input") || description.toLowerCase().contains("field") || 
                description.toLowerCase().contains("text")) {
                return new TextField(driver, description);
            } else {
                return new UIControl(driver, description);
            }
        }
    }
    
    /**
     * Create a control from an existing WebElement by detecting its type
     * @param element the WebElement
     * @param description element description for logging
     * @return appropriate UI control instance
     */
    public UIControl createControl(WebElement element, String description) {
        String tagName = element.getTagName().toLowerCase();
        String type = element.getAttribute("type");
        
        if (type != null) {
            type = type.toLowerCase();
        }
        
        // Check for button
        if (tagName.equals("button") || 
            (tagName.equals("input") && (type == null || type.equals("button") || type.equals("submit") || type.equals("reset"))) ||
            element.getAttribute("role") != null && element.getAttribute("role").equals("button")) {
            return new Button(driver, element, description);
        }
        
        // Check for checkbox
        if ((tagName.equals("input") && type != null && type.equals("checkbox")) ||
            element.getAttribute("role") != null && element.getAttribute("role").equals("checkbox")) {
            return new Checkbox(driver, element, description);
        }
        
        // Check for radio button
        if ((tagName.equals("input") && type != null && type.equals("radio")) ||
            element.getAttribute("role") != null && element.getAttribute("role").equals("radio")) {
            return new RadioButton(driver, element, description);
        }
        
        // Check for select/dropdown
        if (tagName.equals("select") || 
            element.getAttribute("role") != null && element.getAttribute("role").equals("listbox")) {
            return new Dropdown(driver, element, description);
        }
        
        // Check for link
        if (tagName.equals("a") || 
            element.getAttribute("role") != null && element.getAttribute("role").equals("link")) {
            return new Link(driver, element, description);
        }
        
        // Check for image
        if (tagName.equals("img")) {
            return new Image(driver, element, description);
        }
        
        // Check for date picker
        if ((tagName.equals("input") && type != null && (type.equals("date") || type.equals("datetime-local"))) ||
            element.getAttribute("role") != null && element.getAttribute("role").equals("date")) {
            return new DatePicker(driver, element, description);
        }
        
        // Check for file upload
        if ((tagName.equals("input") && type != null && type.equals("file"))) {
            return new FileUpload(driver, element, description);
        }
        
        // Check for textarea
        if (tagName.equals("textarea")) {
            return new TextArea(driver, element, description);
        }
        
        // Check for table
        if (tagName.equals("table") || 
            element.getAttribute("role") != null && element.getAttribute("role").equals("grid")) {
            return new Table(driver, element, description);
        }
        
        // Check for iframe
        if (tagName.equals("iframe") || tagName.equals("frame")) {
            return new IFrame(driver, element, description);
        }
        
        // Check for slider/range
        if ((tagName.equals("input") && type != null && type.equals("range")) ||
            element.getAttribute("role") != null && element.getAttribute("role").equals("slider")) {
            return new Slider(driver, element, description);
        }
        
        // Check for tabs
        if (element.getAttribute("role") != null && 
            (element.getAttribute("role").equals("tablist") || element.getAttribute("role").equals("tab"))) {
            return new TabPanel(driver, element, description);
        }
        
        // Check for modal/dialog
        if (element.getAttribute("role") != null && 
            (element.getAttribute("role").equals("dialog") || element.getAttribute("role").equals("modal"))) {
            return new Modal(driver, element, description);
        }
        
        // Check for autocomplete
        if (element.getAttribute("role") != null && 
            (element.getAttribute("role").equals("combobox") || element.getAttribute("role").equals("autocomplete"))) {
            return new AutoComplete(driver, element, description);
        }
        
        // Check for tooltip
        if (element.getAttribute("role") != null && element.getAttribute("role").equals("tooltip")) {
            return new Tooltip(driver, element, description);
        }
        
        // Check for label
        if (tagName.equals("label")) {
            return new Label(driver, element, description);
        }
        
        // Default to TextField for input or generic UIControl for others
        if (tagName.equals("input") && (type == null || type.equals("text") || type.equals("email") || 
                                        type.equals("password") || type.equals("number") || type.equals("tel"))) {
            return new TextField(driver, element, description);
        } else {
            return new UIControl(driver, element, description);
        }
    }
    
    /**
     * Creates a Button control
     * @param description element description
     * @return Button control
     */
    public Button button(String description) {
        return new Button(driver, description);
    }
    
    /**
     * Creates a TextField control
     * @param description element description
     * @return TextField control
     */
    public TextField textField(String description) {
        return new TextField(driver, description);
    }
    
    /**
     * Creates a Checkbox control
     * @param description element description
     * @return Checkbox control
     */
    public Checkbox checkbox(String description) {
        return new Checkbox(driver, description);
    }
    
    /**
     * Creates a RadioButton control
     * @param description element description
     * @return RadioButton control
     */
    public RadioButton radioButton(String description) {
        return new RadioButton(driver, description);
    }
    
    /**
     * Creates a Dropdown control
     * @param description element description
     * @return Dropdown control
     */
    public Dropdown dropdown(String description) {
        return new Dropdown(driver, description);
    }
    
    /**
     * Creates a Link control
     * @param description element description
     * @return Link control
     */
    public Link link(String description) {
        return new Link(driver, description);
    }
    
    /**
     * Creates a Table control
     * @param description element description
     * @return Table control
     */
    public Table table(String description) {
        return new Table(driver, description);
    }
    
    /**
     * Creates a DatePicker control
     * @param description element description
     * @return DatePicker control
     */
    public DatePicker datePicker(String description) {
        return new DatePicker(driver, description);
    }
    
    /**
     * Creates a FileUpload control
     * @param description element description
     * @return FileUpload control
     */
    public FileUpload fileUpload(String description) {
        return new FileUpload(driver, description);
    }
    
    /**
     * Creates a Modal control
     * @param description element description
     * @return Modal control
     */
    public Modal modal(String description) {
        return new Modal(driver, description);
    }
    
    /**
     * Creates an IFrame control
     * @param description element description
     * @return IFrame control
     */
    public IFrame iframe(String description) {
        return new IFrame(driver, description);
    }
    
    /**
     * Creates a TabPanel control
     * @param description element description
     * @return TabPanel control
     */
    public TabPanel tabPanel(String description) {
        return new TabPanel(driver, description);
    }
    
    /**
     * Creates a Notification control
     * @param description element description
     * @return Notification control
     */
    public Notification notification(String description) {
        return new Notification(driver, description);
    }
    
    /**
     * Find active notifications/toasts on the page
     * @return array of Notification controls
     */
    public Notification[] findActiveNotifications() {
        try {
            // Try common selectors for notifications/toasts
            String notificationSelectors = ".toast, .notification, .alert, .message, [role='alert']";
            return driver.findElements(By.cssSelector(notificationSelectors)).stream()
                    .map(element -> new Notification(driver, element, "Notification"))
                    .toArray(Notification[]::new);
        } catch (Exception e) {
            log.debug("No active notifications found");
            return new Notification[0];
        }
    }
    
    /**
     * Creates a DragAndDrop utility
     * @return DragAndDrop utility
     */
    public DragAndDrop dragAndDrop() {
        return new DragAndDrop(driver);
    }
    
    /**
     * Find an active modal dialog
     * @return Modal control or null if not found
     */
    public Modal findActiveModal() {
        try {
            // Try common selectors for modal dialogs
            String modalSelectors = ".modal, .dialog, [role='dialog'], [role='modal']";
            WebElement modalElement = driver.findElement(By.cssSelector(modalSelectors));
            return new Modal(driver, modalElement, "Active Modal");
        } catch (NoSuchElementException e) {
            log.debug("No active modal found");
            return null;
        }
    }
}


package com.cssmart.core;

import com.cssmart.ai.engine.AIEngine;
import com.cssmart.ai.engine.model.ElementAnalysis;
import com.cssmart.ai.engine.model.Locator;
import com.cssmart.ai.engine.model.Action;
import com.cssmart.config.ConfigurationManager;
import com.cssmart.config.EnvironmentManager;
import com.cssmart.driver.BrowserManager;
import com.cssmart.driver.DriverManager;
import com.cssmart.reporting.ReportManager;
import com.cssmart.reporting.ScreenshotManager;
import com.cssmart.ui.controls.*;

import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;
import org.testng.ITestResult;
import org.testng.annotations.*;

import java.io.File;
import java.lang.reflect.Method;
import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * Base class for all test classes that provides common functionality and lifecycle management
 */
@Slf4j
public class CSSmartTestBase {
    protected WebDriver driver;
    protected AIEngine aiEngine;
    protected ConfigurationManager config;
    protected TestContext testContext;
    protected ReportManager reportManager;
    protected UIControlFactory controlFactory;
    
    private String testName;
    private String testDescription;
    private String[] testTags;
    
    @BeforeSuite(alwaysRun = true)
    public void beforeSuite() {
        log.info("Starting test suite execution");
        config = ConfigurationManager.getInstance();
        EnvironmentManager.initialize(config.getEnvironment());
        reportManager = ReportManager.getInstance();
        reportManager.startSuite();
        
        // Initialize AI Engine
        aiEngine = AIEngine.getInstance();
        aiEngine.initialize();
    }
    
    @BeforeClass(alwaysRun = true)
    public void beforeClass() {
        log.info("Starting test class: {}", getClass().getSimpleName());
        testContext = new TestContext();
    }
    
    @BeforeMethod(alwaysRun = true)
    public void beforeMethod(Method method, Object[] params, ITestResult testResult) {
        // Get test metadata from annotation
        CSSmartTest testAnnotation = method.getAnnotation(CSSmartTest.class);
        if (testAnnotation != null) {
            testName = testAnnotation.name().isEmpty() ? method.getName() : testAnnotation.name();
            testDescription = testAnnotation.description();
            testTags = testAnnotation.tags();
            
            String browser = testAnnotation.browser().isEmpty() ? 
                    config.getDefaultBrowser() : testAnnotation.browser();
            
            // Initialize driver with configuration from annotation
            initializeDriver(browser);
        } else {
            testName = method.getName();
            testDescription = "";
            testTags = new String[0];
            
            // Initialize driver with default configuration
            initializeDriver(config.getDefaultBrowser());
        }
        
        log.info("Starting test: {}", testName);
        reportManager.startTest(testName, testDescription, testTags);
        
        // Initialize UI Control Factory
        controlFactory = new UIControlFactory(driver);
    }
    
    @AfterMethod(alwaysRun = true)
    public void afterMethod(ITestResult result) {
        if (result.getStatus() == ITestResult.FAILURE) {
            log.error("Test failed: {}", result.getName());
            reportManager.testFailed(result.getThrowable());
            
            // Capture screenshot on failure
            if (driver != null) {
                byte[] screenshot = ScreenshotManager.takeScreenshot(driver);
                reportManager.addScreenshot("Failure Screenshot", screenshot);
            }
        } else if (result.getStatus() == ITestResult.SUCCESS) {
            log.info("Test passed: {}", result.getName());
            reportManager.testPassed();
        } else {
            log.warn("Test skipped: {}", result.getName());
            reportManager.testSkipped();
        }
        
        // Clean up driver if needed
        if (driver != null && !config.isKeepBrowserOpenBetweenTests()) {
            quitDriver();
        }
    }
    
    @AfterClass(alwaysRun = true)
    public void afterClass() {
        log.info("Finished test class: {}", getClass().getSimpleName());
        testContext.clear();
    }
    
    @AfterSuite(alwaysRun = true)
    public void afterSuite() {
        log.info("Finished test suite execution");
        reportManager.endSuite();
        
        // Clean up resources
        if (driver != null) {
            quitDriver();
        }
    }
    
    /**
     * Initializes the WebDriver with the specified browser
     * @param browser the browser to use
     */
    protected void initializeDriver(String browser) {
        log.info("Initializing WebDriver for browser: {}", browser);
        
        // Get driver configuration
        int implicitWaitSeconds = config.getImplicitWaitSeconds();
        int pageLoadTimeoutSeconds = config.getPageLoadTimeoutSeconds();
        int scriptTimeoutSeconds = config.getScriptTimeoutSeconds();
        boolean maximizeBrowser = config.isMaximizeBrowser();
        Map<String, Object> capabilities = config.getBrowserCapabilities(browser);
        
        // Create driver
        driver = DriverManager.createDriver(browser, capabilities);
        
        // Configure timeouts
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(implicitWaitSeconds));
        driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(pageLoadTimeoutSeconds));
        driver.manage().timeouts().scriptTimeout(Duration.ofSeconds(scriptTimeoutSeconds));
        
        // Maximize if configured
        if (maximizeBrowser) {
            driver.manage().window().maximize();
        }
        
        // Set window size if not maximized
        if (!maximizeBrowser && config.getBrowserWidth() > 0 && config.getBrowserHeight() > 0) {
            driver.manage().window().setSize(
                    new Dimension(config.getBrowserWidth(), config.getBrowserHeight()));
        }
        
        // Add driver to test context
        testContext.set("driver", driver);
    }
    
    /**
     * Quits the WebDriver and cleans up resources
     */
    protected void quitDriver() {
        if (driver != null) {
            try {
                log.info("Quitting WebDriver");
                driver.quit();
            } catch (Exception e) {
                log.error("Error quitting WebDriver", e);
            } finally {
                driver = null;
                DriverManager.removeDriver();
            }
        }
    }
    
    /**
     * Navigates to the specified URL
     * @param url the URL to navigate to
     */
    protected void navigateTo(String url) {
        log.info("Navigating to URL: {}", url);
        driver.get(url);
        reportManager.logStep("Navigated to " + url);
    }
    
    /**
     * Finds a WebElement using the AI engine
     * @param description natural language description of the element
     * @return the WebElement
     */
    protected WebElement findElement(String description) {
        log.debug("Finding element: {}", description);
        ElementAnalysis analysis = aiEngine.predictElement(description);
        List<Locator> locators = analysis.getLocators();
        
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(config.getExplicitWaitSeconds()));
        
        for (Locator locator : locators) {
            try {
                By by = createBy(locator);
                WebElement element = wait.until(ExpectedConditions.presenceOfElementLocated(by));
                log.debug("Found element '{}' using locator: {}", description, locator);
                return element;
            } catch (Exception e) {
                log.trace("Could not find element with locator: {}", locator);
            }
        }
        
        throw new NoSuchElementException("Could not find element: " + description);
    }
    
    /**
     * Creates a By locator from a Locator object
     * @param locator the Locator object
     * @return By object
     */
    protected By createBy(Locator locator) {
        switch (locator.getType()) {
            case ID:
                return By.id(locator.getValue());
            case NAME:
                return By.name(locator.getValue());
            case XPATH:
                return By.xpath(locator.getValue());
            case CSS_SELECTOR:
                return By.cssSelector(locator.getValue());
            case CLASS_NAME:
                return By.className(locator.getValue());
            case LINK_TEXT:
                return By.linkText(locator.getValue());
            case PARTIAL_LINK_TEXT:
                return By.partialLinkText(locator.getValue());
            case TAG_NAME:
                return By.tagName(locator.getValue());
            default:
                throw new IllegalArgumentException("Unsupported locator type: " + locator.getType());
        }
    }
    
    /**
     * Types text into an element
     * @param description natural language description of the element
     * @param text the text to type
     */
    protected void type(String description, String text) {
        log.info("Typing '{}' into {}", text, description);
        TextField textField = controlFactory.textField(description);
        textField.type(text);
        reportManager.logStep("Typed '" + text + "' into " + description);
    }
    
    /**
     * Clears an element
     * @param description natural language description of the element
     */
    protected void clear(String description) {
        log.info("Clearing {}", description);
        TextField textField = controlFactory.textField(description);
        textField.clear();
        reportManager.logStep("Cleared " + description);
    }
    
    /**
     * Clicks on an element
     * @param description natural language description of the element
     */
    protected void click(String description) {
        log.info("Clicking on {}", description);
        UIControl control = controlFactory.createControl(description);
        control.click();
        reportManager.logStep("Clicked on " + description);
    }
    
    /**
     * Clicks on an element using JavaScript
     * @param description natural language description of the element
     */
    protected void jsClick(String description) {
        log.info("JavaScript clicking on {}", description);
        UIControl control = controlFactory.createControl(description);
        control.jsClick();
        reportManager.logStep("JavaScript clicked on " + description);
    }
    
    /**
     * Checks a checkbox
     * @param description natural language description of the checkbox
     * @param check true to check, false to uncheck
     */
    protected void setChecked(String description, boolean check) {
        log.info("{} checkbox {}", check ? "Checking" : "Unchecking", description);
        Checkbox checkbox = controlFactory.checkbox(description);
        checkbox.setChecked(check);
        reportManager.logStep((check ? "Checked " : "Unchecked ") + description);
    }
    
    /**
     * Selects an option from a dropdown by visible text
     * @param description natural language description of the dropdown
     * @param optionText the visible text of the option to select
     */
    protected void selectByText(String description, String optionText) {
        log.info("Selecting option '{}' from dropdown {}", optionText, description);
        Dropdown dropdown = controlFactory.dropdown(description);
        dropdown.selectByText(optionText);
        reportManager.logStep("Selected option '" + optionText + "' from " + description);
    }
    
    /**
     * Gets the text of an element
     * @param description natural language description of the element
     * @return the element's text
     */
    protected String getText(String description) {
        UIControl control = controlFactory.createControl(description);
        String text = control.getText();
        log.info("Got text '{}' from {}", text, description);
        return text;
    }
    
    /**
     * Gets the value of an input element
     * @param description natural language description of the element
     * @return the element's value
     */
    protected String getValue(String description) {
        TextField textField = controlFactory.textField(description);
        String value = textField.getValue();
        log.info("Got value '{}' from {}", value, description);
        return value;
    }
    
    /**
     * Hovers over an element
     * @param description natural language description of the element
     */
    protected void hover(String description) {
        log.info("Hovering over {}", description);
        UIControl control = controlFactory.createControl(description);
        control.hover();
        reportManager.logStep("Hovered over " + description);
    }
    
    /**
     * Verifies that an element is present
     * @param description natural language description of the element
     * @return true if present
     */
    protected boolean verifyElementPresent(String description) {
        try {
            findElement(description);
            log.info("Verified element is present: {}", description);
            reportManager.logStep("Verified element is present: " + description);
            return true;
        } catch (NoSuchElementException e) {
            log.info("Element not present: {}", description);
            reportManager.logStep("Element not present: " + description);
            return false;
        }
    }
    
    /**
     * Verifies that text is present on the page
     * @param text the text to verify
     * @return true if present
     */
    protected boolean verifyTextPresent(String text) {
        try {
            WebElement element = driver.findElement(By.xpath("//*[contains(text(),'" + text + "')]"));
            boolean isDisplayed = element.isDisplayed();
            log.info("Verified text is {}: {}", isDisplayed ? "present" : "not present", text);
            reportManager.logStep("Verified text is " + (isDisplayed ? "present" : "not present") + ": " + text);
            return isDisplayed;
        } catch (NoSuchElementException e) {
            log.info("Text not present: {}", text);
            reportManager.logStep("Text not present: " + text);
            return false;
        }
    }
    
    /**
     * Gets a table control by description
     * @param description natural language description of the table
     * @return Table control
     */
    protected Table table(String description) {
        return controlFactory.table(description);
    }
    
    /**
     * Gets a button control by description
     * @param description natural language description of the button
     * @return Button control
     */
    protected Button button(String description) {
        return controlFactory.button(description);
    }
    
    /**
     * Gets a checkbox control by description
     * @param description natural language description of the checkbox
     * @return Checkbox control
     */
    protected Checkbox checkbox(String description) {
        return controlFactory.checkbox(description);
    }
    
    /**
     * Gets a radio button control by description
     * @param description natural language description of the radio button
     * @return RadioButton control
     */
    protected RadioButton radioButton(String description) {
        return controlFactory.radioButton(description);
    }
    
    /**
     * Gets a link control by description
     * @param description natural language description of the link
     * @return Link control
     */
    protected Link link(String description) {
        return controlFactory.link(description);
    }
    
    /**
     * Gets a dropdown control by description
     * @param description natural language description of the dropdown
     * @return Dropdown control
     */
    protected Dropdown dropdown(String description) {
        return controlFactory.dropdown(description);
    }
    
    /**
     * Gets a date picker control by description
     * @param description natural language description of the date picker
     * @return DatePicker control
     */
    protected DatePicker datePicker(String description) {
        return controlFactory.datePicker(description);
    }
    
    /**
     * Gets a file upload control by description
     * @param description natural language description of the file upload
     * @return FileUpload control
     */
    protected FileUpload fileUpload(String description) {
        return controlFactory.fileUpload(description);
    }
    
    /**
     * Gets an iframe control by description
     * @param description natural language description of the iframe
     * @return IFrame control
     */
    protected IFrame iframe(String description) {
        return controlFactory.iframe(description);
    }
    
    /**
     * Uploads a file
     * @param description natural language description of the file input
     * @param filePath absolute path to the file
     */
    protected void uploadFile(String description, String filePath) {
        log.info("Uploading file '{}' to {}", filePath, description);
        FileUpload fileUpload = controlFactory.fileUpload(description);
        fileUpload.uploadFile(filePath);
        reportManager.logStep("Uploaded file '" + filePath + "' to " + description);
    }
    
    /**
     * Sets a date in a date picker
     * @param description natural language description of the date picker
     * @param date the date string in format MM/dd/yyyy
     */
    protected void setDate(String description, String date) {
        log.info("Setting date '{}' in {}", date, description);
        DatePicker datePicker = controlFactory.datePicker(description);
        datePicker.setDate(date);
        reportManager.logStep("Set date '" + date + "' in " + description);
    }
    
    /**
     * Takes a screenshot and adds it to the report
     * @param description screenshot description
     * @return path to the screenshot file
     */
    protected String takeScreenshot(String description) {
        log.info("Taking screenshot: {}", description);
        byte[] screenshot = ScreenshotManager.takeScreenshot(driver);
        reportManager.addScreenshot(description, screenshot);
        return "Screenshot captured: " + description;
    }
    
    /**
     * Executes JavaScript
     * @param script the script to execute
     * @param args the script arguments
     * @return the result of script execution
     */
    protected Object executeScript(String script, Object... args) {
        log.debug("Executing JavaScript: {}", script);
        JavascriptExecutor js = (JavascriptExecutor) driver;
        return js.executeScript(script, args);
    }
    
    /**
     * Waits for an element to be present
     * @param description natural language description of the element
     * @param timeoutSeconds timeout in seconds
     * @return the WebElement
     */
    protected WebElement waitForElement(String description, int timeoutSeconds) {
        log.info("Waiting for element: {} (timeout: {} seconds)", description, timeoutSeconds);
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        
        ElementAnalysis analysis = aiEngine.predictElement(description);
        List<Locator> locators = analysis.getLocators();
        
        for (Locator locator : locators) {
            try {
                By by = createBy(locator);
                WebElement element = wait.until(ExpectedConditions.presenceOfElementLocated(by));
                log.debug("Element found: {}", description);
                return element;
            } catch (Exception e) {
                log.trace("Could not find element with locator: {}", locator);
            }
        }
        
        throw new TimeoutException("Timed out waiting for element: " + description);
    }
    
    /**
     * Waits for an element to be visible
     * @param description natural language description of the element
     * @param timeoutSeconds timeout in seconds
     * @return the WebElement
     */
    protected WebElement waitForElementVisible(String description, int timeoutSeconds) {
        log.info("Waiting for element to be visible: {} (timeout: {} seconds)", description, timeoutSeconds);
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        
        ElementAnalysis analysis = aiEngine.predictElement(description);
        List<Locator> locators = analysis.getLocators();
        
        for (Locator locator : locators) {
            try {
                By by = createBy(locator);
                WebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(by));
                log.debug("Element visible: {}", description);
                return element;
            } catch (Exception e) {
                log.trace("Could not find visible element with locator: {}", locator);
            }
        }
        
        throw new TimeoutException("Timed out waiting for element to be visible: " + description);
    }
    
    /**
     * Waits for an element to be clickable
     * @param description natural language description of the element
     * @param timeoutSeconds timeout in seconds
     * @return the WebElement
     */
    protected WebElement waitForElementClickable(String description, int timeoutSeconds) {
        log.info("Waiting for element to be clickable: {} (timeout: {} seconds)", description, timeoutSeconds);
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        
        ElementAnalysis analysis = aiEngine.predictElement(description);
        List<Locator> locators = analysis.getLocators();
        
        for (Locator locator : locators) {
            try {
                By by = createBy(locator);
                WebElement element = wait.until(ExpectedConditions.elementToBeClickable(by));
                log.debug("Element clickable: {}", description);
                return element;
            } catch (Exception e) {
                log.trace("Could not find clickable element with locator: {}", locator);
            }
        }
        
        throw new TimeoutException("Timed out waiting for element to be clickable: " + description);
    }
    
    /**
     * Waits for text to be present in an element
     * @param description natural language description of the element
     * @param text the text to wait for
     * @param timeoutSeconds timeout in seconds
     * @return true if the text is present
     */
    protected boolean waitForTextPresent(String description, String text, int timeoutSeconds) {
        log.info("Waiting for text '{}' in element: {} (timeout: {} seconds)", text, description, timeoutSeconds);
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        
        ElementAnalysis analysis = aiEngine.predictElement(description);
        List<Locator> locators = analysis.getLocators();
        
        for (Locator locator : locators) {
            try {
                By by = createBy(locator);
                boolean isPresent = wait.until(ExpectedConditions.textToBePresentInElementLocated(by, text));
                log.debug("Text '{}' is present in element: {}", text, description);
                return isPresent;
            } catch (Exception e) {
                log.trace("Text not present in element with locator: {}", locator);
            }
        }
        
        log.warn("Timed out waiting for text '{}' in element: {}", text, description);
        return false;
    }
    
    /**
     * Performs drag and drop operation
     * @param sourceDescription natural language description of the source element
     * @param targetDescription natural language description of the target element
     */
    protected void dragAndDrop(String sourceDescription, String targetDescription) {
        log.info("Performing drag and drop from {} to {}", sourceDescription, targetDescription);
        WebElement sourceElement = findElement(sourceDescription);
        WebElement targetElement = findElement(targetDescription);
        
        DragAndDrop dragAndDrop = controlFactory.dragAndDrop();
        dragAndDrop.dragAndDrop(sourceElement, targetElement);
        
        reportManager.logStep("Dragged from " + sourceDescription + " to " + targetDescription);
    }
    
    /**
     * Finds an active modal dialog
     * @return Modal control or null if not found
     */
    protected Modal findActiveModal() {
        log.info("Finding active modal dialog");
        return controlFactory.findActiveModal();
    }
    
    /**
     * Finds active notifications on the page
     * @return array of Notification controls
     */
    protected Notification[] findActiveNotifications() {
        log.info("Finding active notifications");
        return controlFactory.findActiveNotifications();
    }
    
    /**
     * Performs an action suggested by the AI engine
     * @param description natural language description of what to do
     */
    protected void performAction(String description) {
        log.info("Performing AI-suggested action: {}", description);
        Action action = aiEngine.suggestAction(description);
        
        switch (action.getType()) {
            case CLICK:
                click(action.getElementDescription());
                break;
            case TYPE:
                type(action.getElementDescription(), action.getValue());
                break;
            case SELECT:
                selectByText(action.getElementDescription(), action.getValue());
                break;
            case CHECK:
                setChecked(action.getElementDescription(), true);
                break;
            case UNCHECK:
                setChecked(action.getElementDescription(), false);
                break;
            case NAVIGATE:
                navigateTo(action.getValue());
                break;
            default:
                log.warn("Unsupported action type: {}", action.getType());
                throw new UnsupportedOperationException("Unsupported action type: " + action.getType());
        }
        
        reportManager.logStep("Performed AI-suggested action: " + description);
    }
}


package com.cssmart.examples;

import com.cssmart.core.CSSmartTestBase;
import com.cssmart.core.CSSmartTest;
import com.cssmart.ui.controls.*;

import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.WebElement;
import org.testng.Assert;
import org.testng.annotations.Test;

import java.util.List;
import java.util.Map;

/**
 * Example test class demonstrating the usage of CS Smart Test Framework
 */
@Slf4j
public class OnlineShoppingTest extends CSSmartTestBase {

    @Test
    @CSSmartTest(
        name = "Login Test",
        description = "Tests the login functionality with valid credentials",
        tags = {"smoke", "login"}
    )
    public void testLogin() {
        // Navigate to login page
        navigateTo("https://www.saucedemo.com/");
        
        // Type credentials using TextField control
        TextField usernameField = controlFactory.textField("username field");
        usernameField
            .highlight()  // Highlight for visual debugging
            .type("standard_user");
        
        TextField passwordField = controlFactory.textField("password field");
        passwordField
            .highlight()
            .type("secret_sauce");
        
        // Click login button
        Button loginButton = controlFactory.button("login button");
        loginButton.click();
        
        // Verify successful login
        boolean isLoggedIn = verifyTextPresent("Products");
        Assert.assertTrue(isLoggedIn, "Failed to login - Products page not displayed");
        
        takeScreenshot("Successful Login");
    }
    
    @Test
    @CSSmartTest(
        name = "Product Selection Test",
        description = "Tests adding products to cart and checkout process",
        tags = {"regression", "checkout"},
        browser = "chrome"
    )
    public void testProductSelection() {
        // First login
        navigateTo("https://www.saucedemo.com/");
        type("username field", "standard_user");
        type("password field", "secret_sauce");
        click("login button");
        
        // Sort products by price high to low
        dropdown("product sort dropdown").selectByValue("hilo");
        
        // Get the most expensive product
        String productName = getText("first product name");
        String productPrice = getText("first product price");
        log.info("Selected product: {} with price {}", productName, productPrice);
        
        // Add to cart
        button("first add to cart button").click();
        
        // Verify cart updated
        String cartBadge = getText("shopping cart badge");
        Assert.assertEquals(cartBadge, "1", "Cart badge should show 1 item");
        
        // Go to cart
        click("shopping cart link");
        
        // Verify product in cart
        boolean productInCart = verifyTextPresent(productName);
        Assert.assertTrue(productInCart, "Product not found in cart");
        
        // Proceed to checkout
        click("checkout button");
        
        // Fill checkout information
        textField("first name field").type("John");
        textField("last name field").type("Doe");
        textField("postal code field").type("12345");
        
        // Continue to next step
        click("continue button");
        
        // Verify checkout summary
        boolean summaryDisplayed = verifyTextPresent("Checkout: Overview");
        Assert.assertTrue(summaryDisplayed, "Checkout summary not displayed");
        
        // Verify product details
        boolean productInSummary = verifyTextPresent(productName);
        Assert.assertTrue(productInSummary, "Product not found in summary");
        
        // Complete purchase
        click("finish button");
        
        // Verify order confirmation
        boolean orderConfirmed = verifyTextPresent("Thank you for your order");
        Assert.assertTrue(orderConfirmed, "Order confirmation not displayed");
        
        takeScreenshot("Order Confirmation");
    }
    
    @Test
    @CSSmartTest(
        name = "Form Controls Test",
        description = "Demonstrates usage of various form controls",
        tags = {"demo", "controls"}
    )
    public void testFormControls() {
        // Navigate to a demo page with form controls
        navigateTo("https://demoqa.com/automation-practice-form");
        
        // Text fields
        TextField firstNameField = textField("first name field");
        firstNameField.type("John");
        
        TextField lastNameField = textField("last name field");
        lastNameField.type("Doe");
        
        TextField emailField = textField("email field");
        emailField.type("john.doe@example.com");
        
        // Radio buttons
        RadioButton maleRadio = radioButton("gender male radio");
        maleRadio.select();
        Assert.assertTrue(maleRadio.isSelected(), "Male radio should be selected");
        
        // Another way to select radio using the base method
        click("gender female radio");
        
        // Phone number
        textField("mobile number field").type("1234567890");
        
        // Date picker
        DatePicker datePicker = datePicker("date of birth field");
        datePicker.setDate("01/15/1990");
        
        // Subjects autocomplete
        AutoComplete subjects = new AutoComplete(driver, "subjects input");
        subjects.typeAndSelect("Math", "Maths");
        
        // Checkboxes
        Checkbox sportsCheckbox = checkbox("sports checkbox");
        sportsCheckbox.setChecked(true);
        Assert.assertTrue(sportsCheckbox.isChecked(), "Sports checkbox should be checked");
        
        Checkbox readingCheckbox = checkbox("reading checkbox");
        readingCheckbox.setChecked(true);
        
        // File upload
        String filePath = System.getProperty("user.dir") + "/src/test/resources/sample.jpg";
        fileUpload("upload picture").uploadFile(filePath);
        
        // Text area
        TextArea addressArea = new TextArea(driver, "current address field");
        addressArea.type("123 Test Street, Test City, 12345");
        
        // Dropdown with select
        dropdown("state dropdown").click();
        click("NCR option");
        
        dropdown("city dropdown").click();
        click("Delhi option");
        
        // Submit form
        jsClick("submit button");
        
        // Verify submission
        Modal confirmationModal = findActiveModal();
        Assert.assertNotNull(confirmationModal, "Confirmation modal should be displayed");
        
        String modalTitle = confirmationModal.getTitle();
        Assert.assertEquals(modalTitle, "Thanks for submitting the form", "Incorrect modal title");
        
        confirmationModal.close();
    }
    
    @Test
    @CSSmartTest(
        name = "Table Test",
        description = "Demonstrates usage of the Table control",
        tags = {"demo", "table"}
    )
    public void testTableInteractions() {
        // Navigate to a page with tables
        navigateTo("https://demoqa.com/webtables");
        
        // Get the table control
        Table usersTable = table("registration table");
        
        // Get row count
        int initialRowCount = usersTable.getRowCount();
        log.info("Initial row count: {}", initialRowCount);
        
        // Get column names
        List<String> columns = usersTable.getColumnNames();
        log.info("Table columns: {}", columns);
        
        // Add a new record
        click("add new record button");
        
        // Fill the form
        type("first name field", "Alice");
        type("last name field", "Johnson");
        type("email field", "alice.johnson@example.com");
        type("age field", "28");
        type("salary field", "85000");
        type("department field", "Legal");
        
        click("submit button");
        
        // Verify new record was added
        int newRowCount = usersTable.getRowCount();
        Assert.assertEquals(newRowCount, initialRowCount + 1, "Row count should increase by 1");
        
        // Find the new row
        int rowIndex = usersTable.findRowByColumnText("First Name", "Alice");
        Assert.assertTrue(rowIndex >= 0, "Could not find the newly added row");
        
        // Get cell text
        String firstName = usersTable.getCellText(rowIndex, "First Name");
        String lastName = usersTable.getCellText(rowIndex, "Last Name");
        String email = usersTable.getCellText(rowIndex, "Email");
        
        Assert.assertEquals(firstName, "Alice", "First name in table doesn't match");
        Assert.assertEquals(lastName, "Johnson", "Last name in table doesn't match");
        Assert.assertEquals(email, "alice.johnson@example.com", "Email in table doesn't match");
        
        // Edit the row
        WebElement editButton = usersTable.getCell(rowIndex, "Action").findElement(By.cssSelector("[title='Edit']"));
        editButton.click();
        
        // Update data
        textField("department field").clear().type("HR");
        textField("salary field").clear().type("90000");
        
        click("submit button");
        
        // Verify updated data
        String updatedDepartment = usersTable.getCellText(rowIndex, "Department");
        String updatedSalary = usersTable.getCellText(rowIndex, "Salary");
        
        Assert.assertEquals(updatedDepartment, "HR", "Department was not updated");
        Assert.assertEquals(updatedSalary, "90000", "Salary was not updated");
        
        // Delete the row
        WebElement deleteButton = usersTable.getCell(rowIndex, "Action").findElement(By.cssSelector("[title='Delete']"));
        deleteButton.click();
        
        // Verify row was deleted
        int finalRowCount = usersTable.getRowCount();
        Assert.assertEquals(finalRowCount, initialRowCount, "Row count should return to initial value");
    }
    
    @Test
    @CSSmartTest(
        name = "Modal Dialog Test",
        description = "Demonstrates usage of the Modal control",
        tags = {"demo", "modal"}
    )
    public void testModalDialogs() {
        // Navigate to a page with modals
        navigateTo("https://demoqa.com/modal-dialogs");
        
        // Small modal
        click("small modal button");
        
        // Get the modal
        Modal smallModal = findActiveModal();
        Assert.assertNotNull(smallModal, "Small modal should be displayed");
        
        // Verify modal title and body
        String smallModalTitle = smallModal.getTitle();
        Assert.assertEquals(smallModalTitle, "Small Modal", "Incorrect small modal title");
        
        String smallModalBody = smallModal.getBodyText();
        Assert.assertTrue(smallModalBody.contains("small modal"), "Incorrect small modal body text");
        
        // Close the modal
        smallModal.close();
        
        // Wait a moment for modal to close
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        // Large modal
        click("large modal button");
        
        // Get the modal
        Modal largeModal = findActiveModal();
        Assert.assertNotNull(largeModal, "Large modal should be displayed");
        
        // Verify modal title and body
        String largeModalTitle = largeModal.getTitle();
        Assert.assertEquals(largeModalTitle, "Large Modal", "Incorrect large modal title");
        
        String largeModalBody = largeModal.getBodyText();
        Assert.assertTrue(largeModalBody.length() > smallModalBody.length(), "Large modal should have more text than small modal");
        
        // Check available buttons
        List<String> buttonTexts = largeModal.getButtonTexts();
        log.info("Modal buttons: {}", buttonTexts);
        
        // Close using button text
        largeModal.clickButton("Close");
    }
    
    @Test
    @CSSmartTest(
        name = "Tabs Test",
        description = "Demonstrates usage of the TabPanel control",
        tags = {"demo", "tabs"}
    )
    public void testTabs() {
        // Navigate to a page with tabs
        navigateTo("https://demoqa.com/tabs");
        
        // Get the tab panel
        TabPanel tabPanel = tabPanel("demo tabs");
        
        // Get initial active tab
        String initialActiveTab = tabPanel.getActiveTabText();
        log.info("Initial active tab: {}", initialActiveTab);
        
        // Get all tab texts
        List<String> allTabs = tabPanel.getAllTabTexts();
        log.info("All tabs: {}", allTabs);
        
        // Select different tabs
        tabPanel.selectTab("Origin");
        
        // Verify tab content
        WebElement activeContent = tabPanel.getActiveContent();
        String contentText = activeContent.getText();
        Assert.assertTrue(contentText.contains("philosophy"), "Origin tab content is incorrect");
        
        tabPanel.selectTab("Use");
        activeContent = tabPanel.getActiveContent();
        contentText = activeContent.getText();
        Assert.assertTrue(contentText.contains("contrary"), "Use tab content is incorrect");
        
        tabPanel.selectTab("What");
        activeContent = tabPanel.getActiveContent();
        contentText = activeContent.getText();
        Assert.assertTrue(contentText.contains("Lorem Ipsum"), "What tab content is incorrect");
    }
    
    @Test
    @CSSmartTest(
        name = "IFrame Test",
        description = "Demonstrates usage of the IFrame control",
        tags = {"demo", "iframe"}
    )
    public void testIFrames() {
        // Navigate to a page with iframes
        navigateTo("https://demoqa.com/frames");
        
        // Get iframe control
        IFrame firstFrame = iframe("frame1");
        
        // Get iframe source
        String frameSource = firstFrame.getSource();
        log.info("Frame source: {}", frameSource);
        
        // Switch to iframe
        firstFrame.switchTo();
        
        // Interact with elements inside the iframe
        String headingText = getText("iframe heading");
        Assert.assertEquals(headingText, "This is a sample page", "Incorrect iframe heading");
        
        // Switch back to main frame
        firstFrame.switchToParent();
        
        // Use the withFrameAndBack method for better control
        String result = firstFrame.withFrameAndBack(() -> {
            // This code runs inside the iframe
            return getText("iframe heading");
        });
        
        Assert.assertEquals(result, "This is a sample page", "Incorrect iframe heading with withFrameAndBack");
        
        // Try the second iframe
        IFrame secondFrame = iframe("frame2");
        secondFrame.withFrameAndBack(() -> {
            String text = getText("iframe heading");
            Assert.assertEquals(text, "This is a sample page", "Incorrect heading in second iframe");
            return null;
        });
    }
    
    @Test
    @CSSmartTest(
        name = "Advanced UI Controls Test",
        description = "Demonstrates usage of advanced UI controls",
        tags = {"demo", "advanced"}
    )
    public void testAdvancedControls() {
        // Navigate to a page with sliders
        navigateTo("https://demoqa.com/slider");
        
        // Use the slider control
        Slider slider = new Slider(driver, "demo slider");
        
        // Get initial value
        String initialValue = slider.getValue();
        log.info("Initial slider value: {}", initialValue);
        
        // Set to 75%
        slider.setPercent(75);
        
        // Verify value changed
        String newValue = slider.getValue();
        log.info("New slider value: {}", newValue);
        Assert.assertNotEquals(newValue, initialValue, "Slider value should change");
        
        // Navigate to a page with tooltips
        navigateTo("https://demoqa.com/tool-tips");
        
        // Use tooltip control
        Tooltip buttonTooltip = new Tooltip(driver, "hover me button");
        
        // Get tooltip text
        String tooltipText = buttonTooltip.getTooltipText();
        Assert.assertEquals(tooltipText, "You hovered over the Button", "Incorrect tooltip text");
        
        // Navigate to a page with drag and drop
        navigateTo("https://demoqa.com/droppable");
        
        // Create drag and drop utility
        DragAndDrop dragAndDrop = controlFactory.dragAndDrop();
        
        // Find elements
        WebElement draggable = findElement("draggable element");
        WebElement droppable = findElement("droppable element");
        
        // Perform drag and drop
        dragAndDrop.dragAndDrop(draggable, droppable);
        
        // Verify drop was successful
        String droppableText = droppable.getText();
        Assert.assertTrue(droppableText.contains("Dropped"), "Drop was not successful");
    }
    
    @Test
    @CSSmartTest(
        name = "AI-Powered Test",
        description = "Demonstrates usage of AI-powered actions",
        tags = {"demo", "ai"}
    )
    public void testAIPoweredInteractions() {
        // Navigate to login page
        navigateTo("https://www.saucedemo.com/");
        
        // Use AI-suggested actions
        performAction("log in as standard_user with password secret_sauce");
        
        // Verify login successful
        boolean isLoggedIn = verifyTextPresent("Products");
        Assert.assertTrue(isLoggedIn, "Login failed");
        
        // More AI actions
        performAction("sort products by price low to high");
        performAction("add the cheapest product to cart");
        
        // Verify cart updated
        String cartBadge = getText("shopping cart badge");
        Assert.assertEquals(cartBadge, "1", "Cart badge should show 1 item");
        
        // Continue with more AI actions
        performAction("go to the shopping cart");
        performAction("proceed to checkout");
        
        // Fill checkout information using AI
        performAction("fill checkout form with first name John, last name Doe, and zip code 12345");
        performAction("continue to the next step");
        
        // Complete order
        performAction("finish the purchase");
        
        // Verify order confirmation
        boolean orderConfirmed = verifyTextPresent("Thank you for your order");
        Assert.assertTrue(orderConfirmed, "Order not confirmed");
    }
}


# CS Smart Test Framework

CS Smart Test Framework is an AI-enhanced Selenium automation framework that makes writing, maintaining, and executing UI tests simpler and more efficient. It combines artificial intelligence with traditional test automation to create a powerful, self-healing test solution.

## Key Features

- **AI-Powered Element Detection**: Smart element finder that can locate elements based on natural language descriptions, with self-healing capabilities to handle dynamic or changing elements
- **Intelligent Test Recording**: Record user actions in real-time, automatically generate test cases with proper assertions, and recognize patterns to optimize related actions
- **Comprehensive UI Controls Library**: Built-in support for common UI components like buttons, text fields, checkboxes, tables, modals, and more
- **Comprehensive Reporting**: Detailed HTML reports with execution metrics, charts, graphs, and AI-enhanced insights
- **Flexible Configuration**: YAML-based configuration with environment-specific settings and support for multiple browsers and platforms

## Project Structure

```
cs-smart-test-framework/
 pom.xml                          # Maven configuration
 src/
    main/
       java/
          com/
              cssmart/
                  ai/          # AI components
                     engine/  # AI core functionality
                     model/   # AI data models
                     ...
                  core/        # Core framework
                  config/      # Configuration
                  driver/      # WebDriver management
                  reporting/   # Reporting
                  ui/          # UI components
                     controls/# UI control libraries
                     recorder/# Test recorder
                     ...
                  ...
       resources/               # Configuration files
       webapp/                  # Web UI (React)
    test/
        java/                    # Test examples
        resources/               # Test resources
```

## Getting Started

### Prerequisites

- Java 17 or higher
- Maven 3.8 or higher
- Chrome/Firefox/Edge browser
- Node.js and npm (for UI development)

### Installation

1. Clone the repository
   ```bash
   git clone https://github.com/yourusername/cs-smart-test-framework.git
   cd cs-smart-test-framework
   ```

2. Build the project
   ```bash
   mvn clean install
   ```

3. Launch the UI server (optional)
   ```bash
   mvn spring-boot:run
   ```

### Writing Your First Test

Create a new test class that extends `CSSmartTestBase`:

```java
package com.example.tests;

import com.cssmart.core.CSSmartTestBase;
import com.cssmart.core.CSSmartTest;
import org.testng.Assert;
import org.testng.annotations.Test;

public class LoginTest extends CSSmartTestBase {
    
    @Test
    @CSSmartTest(
        name = "Login Test",
        description = "Tests the login functionality with valid credentials",
        tags = {"smoke", "login"},
        browser = "chrome"
    )
    public void testLogin() {
        // Navigate to login page
        navigateTo("https://example.com/login");
        
        // Enter credentials using AI element finder
        type("username field", "testuser");
        type("password field", "password123");
        
        // Click login button
        click("login button");
        
        // Verify successful login
        verifyTextPresent("Welcome, Test User");
    }
}
```

### Running Tests

You can run tests using Maven:

```bash
mvn test
```

Or specify a specific test class:

```bash
mvn test -Dtest=LoginTest
```

## UI Controls

CS Smart Test Framework provides a rich set of UI controls for interacting with web elements.

### Basic Controls

- **Button**: For button interactions
- **TextField**: For text input fields
- **Checkbox**: For checkbox elements
- **RadioButton**: For radio button elements
- **Dropdown**: For select elements
- **Link**: For anchor elements
- **Image**: For image elements
- **Label**: For label elements

### Advanced Controls

- **Table**: For data table interactions
- **DatePicker**: For date picker elements
- **FileUpload**: For file upload elements
- **Modal**: For modal dialog interactions
- **IFrame**: For iframe interactions
- **TabPanel**: For tab interface interactions
- **Slider**: For range inputs
- **AutoComplete**: For autocomplete fields
- **Tooltip**: For tooltip elements
- **Notification**: For notifications/toasts

### Example Usage

```java
// Create controls directly
Button loginButton = controlFactory.button("login button");
loginButton.click();

TextField usernameField = controlFactory.textField("username field");
usernameField.type("testuser");

// Or use helper methods from CSSmartTestBase
click("login button");
type("username field", "testuser");

// Advanced controls
Table usersTable = table("users table");
int rowCount = usersTable.getRowCount();
String cellText = usersTable.getCellText(0, "Username");

// Date picker
datePicker("birth date").setDate("01/15/1990");

// File upload
uploadFile("profile picture", "/path/to/image.jpg");
```

## AI-Powered Features

### Element Detection

The framework uses AI to find elements based on natural language descriptions:

```java
// Instead of writing:
driver.findElement(By.id("username")).sendKeys("testuser");

// You can write:
type("username field", "testuser");
```

### Action Suggestions

The framework can suggest appropriate actions:

```java
// Let AI decide what action to take
performAction("log in as admin user");
```

### Self-Healing Tests

Elements are located dynamically, allowing tests to adapt to changes in the application.

## Recording Tests

1. Launch the Web UI at http://localhost:8080
2. Click "Record Test" and configure the target URL
3. Perform actions on the target application
4. Stop recording to generate the test
5. Review and save the generated test

## Configuration

Create a `cssmart.yml` file in your resources directory:

```yaml
environment: dev
browser:
  default: chrome
  width: 1920
  height: 1080
  maximize: true
timeouts:
  implicit: 5
  explicit: 10
  pageLoad: 30
  script: 30
reporting:
  screenshots:
    onFailure: true
    onStep: false
  outputDir: target/cssmart-reports
```

## Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgments

- Selenium WebDriver
- TestNG
- Spring Boot
- React


package com.cssmart.ui.recorder;

import com.cssmart.ai.engine.AIEngine;
import com.cssmart.ai.engine.model.Action;
import com.cssmart.ai.engine.model.ElementAnalysis;
import com.cssmart.ai.engine.model.RecordingSession;
import com.cssmart.ai.engine.model.TestScript;
import com.cssmart.core.CSSmartTest;
import com.cssmart.ui.recorder.model.*;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.UUID;

/**
 * REST controller for the UI Recorder
 */
@RestController
@RequestMapping("/api/recorder")
@Slf4j
public class RecorderController {

    private final RecorderService recorderService;
    private final AIEngine aiEngine;

    @Autowired
    public RecorderController(RecorderService recorderService) {
        this.recorderService = recorderService;
        this.aiEngine = AIEngine.getInstance();
    }

    /**
     * Start a new recording session
     * 
     * @param request Recording configuration
     * @return Session ID
     */
    @PostMapping("/start")
    public ResponseEntity<RecordingResponse> startRecording(@RequestBody RecordingRequest request) {
        log.info("Starting recording session with config: {}", request);
        
        String sessionId = recorderService.startRecording(request);
        
        RecordingResponse response = RecordingResponse.builder()
                .sessionId(sessionId)
                .status("started")
                .url(request.getUrl())
                .build();
                
        return ResponseEntity.ok(response);
    }

    /**
     * Stop a recording session
     * 
     * @param sessionId Session ID
     * @return Recording session data
     */
    @PostMapping("/stop/{sessionId}")
    public ResponseEntity<RecordingSession> stopRecording(@PathVariable String sessionId) {
        log.info("Stopping recording session: {}", sessionId);
        
        RecordingSession session = recorderService.stopRecording(sessionId);
        return ResponseEntity.ok(session);
    }

    /**
     * Record a user action
     * 
     * @param sessionId Session ID
     * @param action Action to record
     * @return Recorded action with analysis
     */
    @PostMapping("/action/{sessionId}")
    public ResponseEntity<RecordedAction> recordAction(
            @PathVariable String sessionId,
            @RequestBody UserAction action) {
        log.info("Recording action for session {}: {}", sessionId, action);
        
        RecordedAction recordedAction = recorderService.recordAction(sessionId, action);
        return ResponseEntity.ok(recordedAction);
    }

    /**
     * Generate a test script from recorded actions
     * 
     * @param sessionId Session ID
     * @return Generated test script
     */
    @GetMapping("/generate/{sessionId}")
    public ResponseEntity<TestScript> generateTest(@PathVariable String sessionId) {
        log.info("Generating test script for session: {}", sessionId);
        
        TestScript testScript = recorderService.generateTestScript(sessionId);
        return ResponseEntity.ok(testScript);
    }

    /**
     * Get all actions for a recording session
     * 
     * @param sessionId Session ID
     * @return List of recorded actions
     */
    @GetMapping("/actions/{sessionId}")
    public ResponseEntity<List<RecordedAction>> getActions(@PathVariable String sessionId) {
        log.info("Getting actions for session: {}", sessionId);
        
        List<RecordedAction> actions = recorderService.getActions(sessionId);
        return ResponseEntity.ok(actions);
    }

    /**
     * Save a test script
     * 
     * @param request Save request with test data
     * @return Result message
     */
    @PostMapping("/save")
    public ResponseEntity<SaveResponse> saveTest(@RequestBody SaveRequest request) {
        log.info("Saving test script: {}", request.getTestName());
        
        String testId = recorderService.saveTest(request);
        
        SaveResponse response = SaveResponse.builder()
                .testId(testId)
                .status("saved")
                .message("Test script saved successfully")
                .build();
                
        return ResponseEntity.ok(response);
    }

    /**
     * Get all saved tests
     * 
     * @return List of saved tests
     */
    @GetMapping("/tests")
    public ResponseEntity<List<TestInfo>> getSavedTests() {
        log.info("Getting all saved tests");
        
        List<TestInfo> tests = recorderService.getSavedTests();
        return ResponseEntity.ok(tests);
    }
}

/**
 * Service for recorder functionality
 */
@Service
@Slf4j
public class RecorderService {

    private final AIEngine aiEngine;
    private final Map<String, RecordingSession> activeSessions = new ConcurrentHashMap<>();
    private final TestScriptGenerator scriptGenerator;
    private final TestScriptRepository scriptRepository;

    @Autowired
    public RecorderService(TestScriptGenerator scriptGenerator, TestScriptRepository scriptRepository) {
        this.aiEngine = AIEngine.getInstance();
        this.scriptGenerator = scriptGenerator;
        this.scriptRepository = scriptRepository;
    }

    /**
     * Start a new recording session
     * 
     * @param request Recording configuration
     * @return Session ID
     */
    public String startRecording(RecordingRequest request) {
        // Create a new session
        String sessionId = UUID.randomUUID().toString();
        
        RecordingSession session = RecordingSession.builder()
                .id(sessionId)
                .startTime(LocalDateTime.now())
                .url(request.getUrl())
                .browser(request.getBrowser())
                .viewport(request.getViewport())
                .actions(new ArrayList<>())
                .status("recording")
                .build();
                
        activeSessions.put(sessionId, session);
        
        log.info("Created recording session: {}", sessionId);
        return sessionId;
    }

    /**
     * Stop a recording session
     * 
     * @param sessionId Session ID
     * @return Recording session data
     */
    public RecordingSession stopRecording(String sessionId) {
        RecordingSession session = getSession(sessionId);
        session.setEndTime(LocalDateTime.now());
        session.setStatus("completed");
        
        log.info("Stopped recording session: {} with {} actions", 
                sessionId, session.getActions().size());
                
        return session;
    }

    /**
     * Record a user action
     * 
     * @param sessionId Session ID
     * @param action Action to record
     * @return Recorded action with analysis
     */
    public RecordedAction recordAction(String sessionId, UserAction action) {
        RecordingSession session = getSession(sessionId);
        
        // Analyze the element
        ElementAnalysis elementAnalysis = null;
        if (action.getElement() != null) {
            elementAnalysis = aiEngine.analyzeElement(action.getElement());
        }
        
        // Create recorded action
        RecordedAction recordedAction = RecordedAction.builder()
                .id(UUID.randomUUID().toString())
                .timestamp(LocalDateTime.now())
                .actionType(action.getType())
                .element(action.getElement())
                .value(action.getValue())
                .elementAnalysis(elementAnalysis)
                .build();
                
        // Add to session
        session.getActions().add(recordedAction);
        
        log.info("Recorded action {} for session {}", 
                recordedAction.getActionType(), sessionId);
                
        return recordedAction;
    }

    /**
     * Generate a test script from recorded actions
     * 
     * @param sessionId Session ID
     * @return Generated test script
     */
    public TestScript generateTestScript(String sessionId) {
        RecordingSession session = getSession(sessionId);
        
        TestScript script = scriptGenerator.generateScript(session);
        
        log.info("Generated test script for session {}: {}", 
                sessionId, script.getName());
                
        return script;
    }

    /**
     * Get all actions for a recording session
     * 
     * @param sessionId Session ID
     * @return List of recorded actions
     */
    public List<RecordedAction> getActions(String sessionId) {
        RecordingSession session = getSession(sessionId);
        return session.getActions();
    }

    /**
     * Save a test script
     * 
     * @param request Save request with test data
     * @return Test ID
     */
    public String saveTest(SaveRequest request) {
        TestScript script = TestScript.builder()
                .id(UUID.randomUUID().toString())
                .name(request.getTestName())
                .description(request.getDescription())
                .packageName(request.getPackageName())
                .className(request.getClassName())
                .testMethod(request.getTestMethod())
                .tags(request.getTags())
                .browser(request.getBrowser())
                .code(request.getCode())
                .createdAt(LocalDateTime.now())
                .build();
                
        String id = scriptRepository.save(script);
        
        log.info("Saved test script: {} with ID {}", script.getName(), id);
        return id;
    }

    /**
     * Get all saved tests
     * 
     * @return List of saved tests
     */
    public List<TestInfo> getSavedTests() {
        List<TestScript> scripts = scriptRepository.findAll();
        
        return scripts.stream()
                .map(script -> TestInfo.builder()
                        .id(script.getId())
                        .name(script.getName())
                        .description(script.getDescription())
                        .className(script.getClassName())
                        .tags(script.getTags())
                        .createdAt(script.getCreatedAt())
                        .build())
                .collect(Collectors.toList());
    }

    /**
     * Get a recording session
     * 
     * @param sessionId Session ID
     * @return Recording session
     * @throws NotFoundException if session not found
     */
    private RecordingSession getSession(String sessionId) {
        RecordingSession session = activeSessions.get(sessionId);
        if (session == null) {
            log.error("Recording session not found: {}", sessionId);
            throw new NotFoundException("Recording session not found: " + sessionId);
        }
        return session;
    }
}

/**
 * Generator for test scripts from recorded actions
 */
@Service
@Slf4j
public class TestScriptGenerator {

    private final AIEngine aiEngine;
    private final TemplateEngine templateEngine;

    @Autowired
    public TestScriptGenerator(TemplateEngine templateEngine) {
        this.aiEngine = AIEngine.getInstance();
        this.templateEngine = templateEngine;
    }

    /**
     * Generate a test script from a recording session
     * 
     * @param session Recording session
     * @return Generated test script
     */
    public TestScript generateScript(RecordingSession session) {
        log.info("Generating test script for session: {}", session.getId());
        
        // Process actions - combine and optimize
        List<ProcessedAction> processedActions = processActions(session.getActions());
        
        // Generate assertions based on final state
        List<ProcessedAction> assertions = generateAssertions(processedActions);
        
        // Create a context for template
        Map<String, Object> context = new HashMap<>();
        context.put("className", generateClassName(session));
        context.put("testName", generateTestName(session));
        context.put("description", "Test generated from recording on " + 
                session.getStartTime().format(DateTimeFormatter.ISO_LOCAL_DATE));
        context.put("browser", session.getBrowser());
        context.put("url", session.getUrl());
        context.put("actions", processedActions);
        context.put("assertions", assertions);
        
        // Generate code from template
        String code = templateEngine.process("test-template", context);
        
        // Build test script
        return TestScript.builder()
                .id(UUID.randomUUID().toString())
                .name(generateTestName(session))
                .description("Test generated from recording")
                .packageName("com.cssmart.generated")
                .className(generateClassName(session))
                .testMethod("test" + StringUtils.capitalize(generateTestName(session).replaceAll("\\s+", "")))
                .tags(Arrays.asList("generated", "recording"))
                .browser(session.getBrowser())
                .code(code)
                .build();
    }

    /**
     * Process and optimize recorded actions
     * 
     * @param actions Recorded actions
     * @return Processed actions
     */
    private List<ProcessedAction> processActions(List<RecordedAction> actions) {
        List<ProcessedAction> processed = new ArrayList<>();
        
        // First convert each action to a processed action
        for (RecordedAction action : actions) {
            ProcessedAction processedAction = convertAction(action);
            if (processedAction != null) {
                processed.add(processedAction);
            }
        }
        
        // Apply optimizations
        optimizeActions(processed);
        
        return processed;
    }

    /**
     * Convert a recorded action to a processed action
     * 
     * @param action Recorded action
     * @return Processed action
     */
    private ProcessedAction convertAction(RecordedAction action) {
        // Skip navigation if there's no URL
        if (action.getActionType() == ActionType.NAVIGATE && 
            (action.getValue() == null || action.getValue().isEmpty())) {
            return null;
        }
        
        // Create a builder
        ProcessedAction.ProcessedActionBuilder builder = ProcessedAction.builder()
                .actionType(action.getActionType())
                .value(action.getValue());
                
        // Add element description if available
        if (action.getElementAnalysis() != null) {
            String description = action.getElementAnalysis().getDescription();
            builder.elementDescription(description);
        } else if (action.getElement() != null) {
            // Generate a description from element attributes
            String description = generateElementDescription(action.getElement());
            builder.elementDescription(description);
        }
        
        return builder.build();
    }

    /**
     * Generate a description for an element
     * 
     * @param element Element details
     * @return Element description
     */
    private String generateElementDescription(ElementInfo element) {
        // Use AI to generate a human-readable description
        return aiEngine.generateElementDescription(element);
    }

    /**
     * Optimize actions by combining related ones
     * 
     * @param actions List of actions to optimize
     */
    private void optimizeActions(List<ProcessedAction> actions) {
        // Apply patterns to combine related actions
        aiEngine.applyActionPatterns(actions);
    }

    /**
     * Generate assertions based on the final state
     * 
     * @param actions Processed actions
     * @return List of assertions
     */
    private List<ProcessedAction> generateAssertions(List<ProcessedAction> actions) {
        // Use AI to generate appropriate assertions
        return aiEngine.generateAssertions(actions);
    }

    /**
     * Generate a class name from the session
     * 
     * @param session Recording session
     * @return Class name
     */
    private String generateClassName(RecordingSession session) {
        // Extract domain from URL
        String domain = extractDomain(session.getUrl());
        
        // Generate a class name based on domain
        return StringUtils.capitalize(domain) + "Test";
    }

    /**
     * Generate a test name from the session
     * 
     * @param session Recording session
     * @return Test name
     */
    private String generateTestName(RecordingSession session) {
        // Extract key actions for naming
        List<String> keyActions = session.getActions().stream()
                .filter(a -> a.getActionType() == ActionType.CLICK || 
                             a.getActionType() == ActionType.SUBMIT)
                .map(a -> {
                    if (a.getElementAnalysis() != null) {
                        return a.getElementAnalysis().getDescription();
                    }
                    return null;
                })
                .filter(Objects::nonNull)
                .limit(2)
                .collect(Collectors.toList());
                
        // Generate name based on domain and key actions
        String domain = extractDomain(session.getUrl());
        
        if (keyActions.isEmpty()) {
            return domain + " Workflow";
        }
        
        return domain + " " + String.join(" and ", keyActions);
    }

    /**
     * Extract domain from URL
     * 
     * @param url URL
     * @return Domain name
     */
    private String extractDomain(String url) {
        try {
            URI uri = new URI(url);
            String domain = uri.getHost();
            
            if (domain.startsWith("www.")) {
                domain = domain.substring(4);
            }
            
            // Get first part of domain
            int dotIndex = domain.indexOf('.');
            if (dotIndex > 0) {
                domain = domain.substring(0, dotIndex);
            }
            
            return domain;
        } catch (Exception e) {
            log.warn("Failed to extract domain from URL: {}", url);
            return "site";
        }
    }
}

/**
 * Repository for storing and retrieving test scripts
 */
@Repository
@Slf4j
public class TestScriptRepository {

    // In a real implementation, this would be stored in a database
    private final Map<String, TestScript> scripts = new ConcurrentHashMap<>();

    /**
     * Save a test script
     * 
     * @param script Test script to save
     * @return ID of the saved script
     */
    public String save(TestScript script) {
        scripts.put(script.getId(), script);
        log.info("Saved test script: {}", script.getId());
        return script.getId();
    }

    /**
     * Find a test script by ID
     * 
     * @param id Script ID
     * @return Test script
     */
    public TestScript findById(String id) {
        TestScript script = scripts.get(id);
        if (script == null) {
            throw new NotFoundException("Test script not found: " + id);
        }
        return script;
    }

    /**
     * Find all test scripts
     * 
     * @return List of test scripts
     */
    public List<TestScript> findAll() {
        return new ArrayList<>(scripts.values());
    }

    /**
     * Delete a test script
     * 
     * @param id Script ID
     */
    public void delete(String id) {
        scripts.remove(id);
        log.info("Deleted test script: {}", id);
    }
}


package com.cssmart.ui.recorder.model;

import com.cssmart.ai.engine.model.ElementAnalysis;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * Request to start a recording session
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RecordingRequest {
    private String url;
    private String browser;
    private Viewport viewport;
    private Map<String, Object> capabilities;
}

/**
 * Response from starting a recording session
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RecordingResponse {
    private String sessionId;
    private String status;
    private String url;
    private String message;
}

/**
 * Details about an element from the browser
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ElementInfo {
    private String tagName;
    private String id;
    private String name;
    private String className;
    private String type;
    private String value;
    private String innerText;
    private String placeholder;
    private String href;
    private String src;
    private String alt;
    private Map<String, String> attributes;
    private String xpath;
    private String cssSelector;
    private Rect rect;
}

/**
 * Rectangle coordinates and dimensions
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Rect {
    private int x;
    private int y;
    private int width;
    private int height;
}

/**
 * Browser viewport dimensions
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Viewport {
    private int width;
    private int height;
}

/**
 * Action recorded from the user
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserAction {
    private ActionType type;
    private ElementInfo element;
    private String value;
}

/**
 * Action after recording with analysis
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RecordedAction {
    private String id;
    private LocalDateTime timestamp;
    private ActionType actionType;
    private ElementInfo element;
    private String value;
    private ElementAnalysis elementAnalysis;
}

/**
 * Action after processing and optimization
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProcessedAction {
    private ActionType actionType;
    private String elementDescription;
    private String value;
    private String comment;
}

/**
 * Types of actions that can be recorded
 */
public enum ActionType {
    NAVIGATE,
    CLICK,
    TYPE,
    CLEAR,
    SELECT,
    CHECK,
    UNCHECK,
    SUBMIT,
    HOVER,
    DRAG_AND_DROP,
    WAIT,
    ASSERT,
    VERIFY
}

/**
 * Request to save a test script
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SaveRequest {
    private String sessionId;
    private String testName;
    private String description;
    private String packageName;
    private String className;
    private String testMethod;
    private List<String> tags;
    private String browser;
    private String code;
}

/**
 * Response after saving a test script
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SaveResponse {
    private String testId;
    private String status;
    private String message;
}

/**
 * Information about a saved test
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TestInfo {
    private String id;
    private String name;
    private String description;
    private String className;
    private List<String> tags;
    private LocalDateTime createdAt;
}

/**
 * Exception for when a resource is not found
 */
public class NotFoundException extends RuntimeException {
    public NotFoundException(String message) {
        super(message);
    }
}

package com.cssmart.ui.recorder;

import com.cssmart.ui.recorder.model.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * WebSocket handler for real-time communication with the browser recorder extension
 */
@Component
@Slf4j
public class RecorderWebSocketHandler extends TextWebSocketHandler {

    private final RecorderService recorderService;
    private final ObjectMapper objectMapper;
    private final Map<String, WebSocketSession> sessions = new ConcurrentHashMap<>();
    private final Map<String, String> sessionToRecordingMap = new ConcurrentHashMap<>();

    @Autowired
    public RecorderWebSocketHandler(RecorderService recorderService, ObjectMapper objectMapper) {
        this.recorderService = recorderService;
        this.objectMapper = objectMapper;
    }

    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        log.info("WebSocket connection established: {}", session.getId());
        sessions.put(session.getId(), session);
    }

    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        log.debug("Received message: {}", message.getPayload());
        
        // Parse message
        WebSocketMessage wsMessage = objectMapper.readValue(message.getPayload(), WebSocketMessage.class);
        
        // Handle message based on type
        switch (wsMessage.getType()) {
            case "START_RECORDING":
                handleStartRecording(session, wsMessage);
                break;
            case "STOP_RECORDING":
                handleStopRecording(session, wsMessage);
                break;
            case "ACTION":
                handleAction(session, wsMessage);
                break;
            case "HEARTBEAT":
                handleHeartbeat(session);
                break;
            default:
                log.warn("Unknown message type: {}", wsMessage.getType());
        }
    }

    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
        log.info("WebSocket connection closed: {}", session.getId());
        
        // Clean up recording session if active
        String recordingId = sessionToRecordingMap.get(session.getId());
        if (recordingId != null) {
            try {
                recorderService.stopRecording(recordingId);
                log.info("Automatically stopped recording {} after connection closed", recordingId);
            } catch (Exception e) {
                log.error("Error stopping recording after connection closed", e);
            }
        }
        
        // Remove session
        sessions.remove(session.getId());
        sessionToRecordingMap.remove(session.getId());
    }

    /**
     * Handle a start recording message
     * 
     * @param session WebSocket session
     * @param message Start recording message
     * @throws IOException if sending response fails
     */
    private void handleStartRecording(WebSocketSession session, WebSocketMessage message) throws IOException {
        log.info("Handling start recording request");
        
        try {
            // Parse configuration
            RecordingRequest request = objectMapper.convertValue(message.getPayload(), RecordingRequest.class);
            
            // Start recording
            String recordingId = recorderService.startRecording(request);
            
            // Associate session with recording
            sessionToRecordingMap.put(session.getId(), recordingId);
            
            // Send response
            WebSocketMessage response = WebSocketMessage.builder()
                    .type("RECORDING_STARTED")
                    .payload(Map.of(
                        "recordingId", recordingId,
                        "status", "recording",
                        "url", request.getUrl()
                    ))
                    .build();
                    
            sendMessage(session, response);
            
            log.info("Started recording session: {}", recordingId);
        } catch (Exception e) {
            log.error("Error starting recording", e);
            sendErrorMessage(session, "Failed to start recording: " + e.getMessage());
        }
    }

    /**
     * Handle a stop recording message
     * 
     * @param session WebSocket session
     * @param message Stop recording message
     * @throws IOException if sending response fails
     */
    private void handleStopRecording(WebSocketSession session, WebSocketMessage message) throws IOException {
        log.info("Handling stop recording request");
        
        try {
            // Get recording ID
            String recordingId = sessionToRecordingMap.get(session.getId());
            if (recordingId == null) {
                sendErrorMessage(session, "No active recording session");
                return;
            }
            
            // Stop recording
            recorderService.stopRecording(recordingId);
            
            // Generate test script
            TestScript testScript = recorderService.generateTestScript(recordingId);
            
            // Send response
            WebSocketMessage response = WebSocketMessage.builder()
                    .type("RECORDING_STOPPED")
                    .payload(Map.of(
                        "recordingId", recordingId,
                        "status", "completed",
                        "testScript", testScript
                    ))
                    .build();
                    
            sendMessage(session, response);
            
            log.info("Stopped recording session: {}", recordingId);
        } catch (Exception e) {
            log.error("Error stopping recording", e);
            sendErrorMessage(session, "Failed to stop recording: " + e.getMessage());
        }
    }

    /**
     * Handle an action message
     * 
     * @param session WebSocket session
     * @param message Action message
     * @throws IOException if sending response fails
     */
    private void handleAction(WebSocketSession session, WebSocketMessage message) throws IOException {
        try {
            // Get recording ID
            String recordingId = sessionToRecordingMap.get(session.getId());
            if (recordingId == null) {
                sendErrorMessage(session, "No active recording session");
                return;
            }
            
            // Parse action
            UserAction action = objectMapper.convertValue(message.getPayload(), UserAction.class);
            
            // Record action
            RecordedAction recordedAction = recorderService.recordAction(recordingId, action);
            
            // Send response
            WebSocketMessage response = WebSocketMessage.builder()
                    .type("ACTION_RECORDED")
                    .payload(Map.of(
                        "recordingId", recordingId,
                        "actionId", recordedAction.getId(),
                        "status", "recorded"
                    ))
                    .build();
                    
            sendMessage(session, response);
        } catch (Exception e) {
            log.error("Error recording action", e);
            sendErrorMessage(session, "Failed to record action: " + e.getMessage());
        }
    }

    /**
     * Handle a heartbeat message
     * 
     * @param session WebSocket session
     * @throws IOException if sending response fails
     */
    private void handleHeartbeat(WebSocketSession session) throws IOException {
        // Send heartbeat response
        WebSocketMessage response = WebSocketMessage.builder()
                .type("HEARTBEAT_ACK")
                .payload(Map.of("timestamp", System.currentTimeMillis()))
                .build();
                
        sendMessage(session, response);
    }

    /**
     * Send a message to a WebSocket session
     * 
     * @param session WebSocket session
     * @param message Message to send
     * @throws IOException if sending fails
     */
    private void sendMessage(WebSocketSession session, WebSocketMessage message) throws IOException {
        if (session.isOpen()) {
            String payload = objectMapper.writeValueAsString(message);
            session.sendMessage(new TextMessage(payload));
        } else {
            log.warn("Tried to send message to closed session: {}", session.getId());
        }
    }

    /**
     * Send an error message to a WebSocket session
     * 
     * @param session WebSocket session
     * @param errorMessage Error message text
     * @throws IOException if sending fails
     */
    private void sendErrorMessage(WebSocketSession session, String errorMessage) throws IOException {
        WebSocketMessage response = WebSocketMessage.builder()
                .type("ERROR")
                .payload(Map.of("message", errorMessage))
                .build();
                
        sendMessage(session, response);
    }
}

/**
 * WebSocket message for communication with the client
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
class WebSocketMessage {
    private String type;
    private Map<String, Object> payload;
}


package com.cssmart.ui.recorder.config;

import com.cssmart.ui.recorder.RecorderWebSocketHandler;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;
import org.springframework.web.socket.server.standard.ServletServerContainerFactoryBean;

/**
 * WebSocket configuration for the recorder
 */
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

    private final RecorderWebSocketHandler webSocketHandler;

    @Autowired
    public WebSocketConfig(RecorderWebSocketHandler webSocketHandler) {
        this.webSocketHandler = webSocketHandler;
    }

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(webSocketHandler, "/ws/recorder")
                .setAllowedOrigins("*"); // In production, restrict origins
    }

    /**
     * Configure WebSocket parameters
     * 
     * @return ServletServerContainerFactoryBean
     */
    @Bean
    public ServletServerContainerFactoryBean createWebSocketContainer() {
        ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();
        // Maximum message size (10MB)
        container.setMaxTextMessageBufferSize(10 * 1024 * 1024);
        container.setMaxBinaryMessageBufferSize(10 * 1024 * 1024);
        // Session idle timeout (5 minutes)
        container.setMaxSessionIdleTimeout(5 * 60 * 1000L);
        return container;
    }
}


// src/main/webapp/src/App.js
import React, { useState } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

import Dashboard from './components/Dashboard';
import Navbar from './components/Navbar';
import Recorder from './components/Recorder';
import TestEditor from './components/TestEditor';
import TestList from './components/TestList';
import Settings from './components/Settings';

/**
 * Main App component
 */
const App = () => {
  const [darkMode, setDarkMode] = useState(localStorage.getItem('darkMode') === 'true');

  // Toggle dark mode
  const toggleDarkMode = () => {
    const newDarkMode = !darkMode;
    setDarkMode(newDarkMode);
    localStorage.setItem('darkMode', newDarkMode);
  };

  return (
    <Router>
      <div className={`app ${darkMode ? 'dark' : 'light'}`}>
        <Navbar darkMode={darkMode} toggleDarkMode={toggleDarkMode} />
        <div className="main-content">
          <Routes>
            <Route path="/dashboard" element={<Dashboard />} />
            <Route path="/recorder" element={<Recorder />} />
            <Route path="/tests" element={<TestList />} />
            <Route path="/test/:id" element={<TestEditor />} />
            <Route path="/settings" element={<Settings />} />
            <Route path="/" element={<Navigate to="/dashboard" replace />} />
          </Routes>
        </div>
        <ToastContainer position="bottom-right" />
      </div>
    </Router>
  );
};

export default App;

// src/main/webapp/src/components/Navbar.js
import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import { 
  FaHome, 
  FaVideo, 
  FaList, 
  FaCog, 
  FaMoon, 
  FaSun 
} from 'react-icons/fa';

/**
 * Navigation bar component
 */
const Navbar = ({ darkMode, toggleDarkMode }) => {
  const location = useLocation();

  // Check if a link is active
  const isActive = (path) => {
    return location.pathname.startsWith(path);
  };

  return (
    <nav className="navbar">
      <div className="navbar-brand">
        <Link to="/">
          <img 
            src="/logo.svg" 
            alt="CS Smart Test" 
            className="logo" 
          />
          <span className="brand-text">CS Smart Test</span>
        </Link>
      </div>
      
      <ul className="nav-links">
        <li className={isActive('/dashboard') ? 'active' : ''}>
          <Link to="/dashboard">
            <FaHome />
            <span>Dashboard</span>
          </Link>
        </li>
        <li className={isActive('/recorder') ? 'active' : ''}>
          <Link to="/recorder">
            <FaVideo />
            <span>Recorder</span>
          </Link>
        </li>
        <li className={isActive('/tests') ? 'active' : ''}>
          <Link to="/tests">
            <FaList />
            <span>Tests</span>
          </Link>
        </li>
        <li className={isActive('/settings') ? 'active' : ''}>
          <Link to="/settings">
            <FaCog />
            <span>Settings</span>
          </Link>
        </li>
      </ul>
      
      <div className="nav-actions">
        <button 
          className="theme-toggle" 
          onClick={toggleDarkMode}
          aria-label={darkMode ? 'Switch to light mode' : 'Switch to dark mode'}
        >
          {darkMode ? <FaSun /> : <FaMoon />}
        </button>
      </div>
    </nav>
  );
};

export default Navbar;

// src/main/webapp/src/components/Dashboard.js
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { FaPlay, FaEdit, FaChartLine, FaClock } from 'react-icons/fa';
import { fetchDashboardData } from '../services/dashboardService';
import { LineChart, XAxis, YAxis, Tooltip, Legend, Line, ResponsiveContainer, PieChart, Pie, Cell } from 'recharts';

/**
 * Dashboard component showing test metrics and recent tests
 */
const Dashboard = () => {
  const [dashboardData, setDashboardData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Load dashboard data
  useEffect(() => {
    const loadDashboardData = async () => {
      try {
        setLoading(true);
        const data = await fetchDashboardData();
        setDashboardData(data);
        setError(null);
      } catch (err) {
        setError('Failed to load dashboard data');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    loadDashboardData();
  }, []);

  if (loading) {
    return <div className="loading">Loading dashboard data...</div>;
  }

  if (error) {
    return <div className="error-message">{error}</div>;
  }

  // Colors for the pie chart
  const COLORS = ['#00C49F', '#FF8042', '#FFBB28'];

  return (
    <div className="dashboard">
      <h1>Dashboard</h1>

      <div className="metric-cards">
        <div className="metric-card">
          <div className="metric-icon">
            <FaPlay />
          </div>
          <div className="metric-content">
            <h3>Total Tests</h3>
            <div className="metric-value">{dashboardData.testCount}</div>
          </div>
        </div>

        <div className="metric-card">
          <div className="metric-icon">
            <FaChartLine />
          </div>
          <div className="metric-content">
            <h3>Success Rate</h3>
            <div className="metric-value">
              {dashboardData.successRate}%
            </div>
          </div>
        </div>

        <div className="metric-card">
          <div className="metric-icon">
            <FaClock />
          </div>
          <div className="metric-content">
            <h3>Avg. Duration</h3>
            <div className="metric-value">
              {dashboardData.avgDuration}s
            </div>
          </div>
        </div>
      </div>

      <div className="dashboard-charts">
        <div className="chart-container">
          <h2>Test Execution History</h2>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={dashboardData.executionHistory}>
              <XAxis dataKey="date" />
              <YAxis />
              <Tooltip />
              <Legend />
              <Line 
                type="monotone" 
                dataKey="passed" 
                name="Passed" 
                stroke="#00C49F" 
              />
              <Line 
                type="monotone" 
                dataKey="failed" 
                name="Failed" 
                stroke="#FF8042" 
              />
              <Line 
                type="monotone" 
                dataKey="skipped" 
                name="Skipped" 
                stroke="#FFBB28" 
              />
            </LineChart>
          </ResponsiveContainer>
        </div>

        <div className="chart-container">
          <h2>Test Status Distribution</h2>
          <ResponsiveContainer width="100%" height={300}>
            <PieChart>
              <Pie
                data={[
                  { name: 'Passed', value: dashboardData.testStatus.passed },
                  { name: 'Failed', value: dashboardData.testStatus.failed },
                  { name: 'Skipped', value: dashboardData.testStatus.skipped }
                ]}
                cx="50%"
                cy="50%"
                labelLine={false}
                label={({name, percent}) => `${name}: ${(percent * 100).toFixed(0)}%`}
                outerRadius={80}
                fill="#8884d8"
                dataKey="value"
              >
                {dashboardData.testStatus.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                ))}
              </Pie>
              <Tooltip />
            </PieChart>
          </ResponsiveContainer>
        </div>
      </div>

      <div className="recent-tests">
        <h2>Recent Tests</h2>
        <table className="tests-table">
          <thead>
            <tr>
              <th>Test Name</th>
              <th>Status</th>
              <th>Duration</th>
              <th>Last Run</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {dashboardData.recentTests.map(test => (
              <tr key={test.id}>
                <td>{test.name}</td>
                <td>
                  <span className={`status-badge ${test.status.toLowerCase()}`}>
                    {test.status}
                  </span>
                </td>
                <td>{test.duration}s</td>
                <td>{new Date(test.lastRun).toLocaleString()}</td>
                <td className="actions">
                  <Link to={`/test/${test.id}`} className="action-btn edit">
                    <FaEdit />
                  </Link>
                  <button className="action-btn run">
                    <FaPlay />
                  </button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default Dashboard;

// src/main/webapp/src/components/Recorder.js
import React, { useState, useEffect, useRef } from 'react';
import { toast } from 'react-toastify';
import { FaPlay, FaStop, FaCode, FaSave, FaCog } from 'react-icons/fa';
import RecorderSettings from './RecorderSettings';
import { startRecording, stopRecording, saveRecording } from '../services/recorderService';

/**
 * Test Recorder component for recording browser interactions
 */
const Recorder = () => {
  const [isRecording, setIsRecording] = useState(false);
  const [recordingSessionId, setRecordingSessionId] = useState(null);
  const [recordedActions, setRecordedActions] = useState([]);
  const [generatedCode, setGeneratedCode] = useState('');
  const [showSettings, setShowSettings] = useState(false);
  const [settings, setSettings] = useState({
    url: 'https://www.example.com',
    browser: 'chrome',
    viewport: { width: 1366, height: 768 }
  });
  const [websocket, setWebsocket] = useState(null);
  const webSocketRef = useRef(null);

  // Initialize websocket connection
  useEffect(() => {
    const setupWebSocket = () => {
      const wsUrl = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws/recorder`;
      const ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        console.log('WebSocket connection established');
      };
      
      ws.onmessage = (event) => {
        const message = JSON.parse(event.data);
        handleWebSocketMessage(message);
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        toast.error('WebSocket connection error');
      };
      
      ws.onclose = () => {
        console.log('WebSocket connection closed');
        if (isRecording) {
          toast.warning('Recording connection lost. Recording stopped.');
          setIsRecording(false);
        }
        
        // Try to reconnect after a delay
        setTimeout(setupWebSocket, 3000);
      };
      
      webSocketRef.current = ws;
      setWebsocket(ws);
    };
    
    setupWebSocket();
    
    // Clean up WebSocket on unmount
    return () => {
      if (webSocketRef.current) {
        webSocketRef.current.close();
      }
    };
  }, [isRecording]);
  
  // Handle WebSocket messages
  const handleWebSocketMessage = (message) => {
    console.log('Received message:', message);
    
    switch (message.type) {
      case 'RECORDING_STARTED':
        toast.success('Recording started');
        setRecordingSessionId(message.payload.recordingId);
        break;
        
      case 'RECORDING_STOPPED':
        toast.success('Recording stopped');
        setIsRecording(false);
        setGeneratedCode(message.payload.testScript.code);
        break;
        
      case 'ACTION_RECORDED':
        toast.info('Action recorded');
        // Refresh actions list
        fetchRecordedActions(message.payload.recordingId);
        break;
        
      case 'ERROR':
        toast.error(message.payload.message);
        break;
        
      default:
        console.log('Unhandled message type:', message.type);
    }
  };
  
  // Fetch recorded actions for a session
  const fetchRecordedActions = async (sessionId) => {
    try {
      const response = await fetch(`/api/recorder/actions/${sessionId}`);
      if (response.ok) {
        const actions = await response.json();
        setRecordedActions(actions);
      }
    } catch (error) {
      console.error('Error fetching actions:', error);
    }
  };
  
  // Start recording
  const handleStartRecording = async () => {
    try {
      if (webSocketRef.current?.readyState === WebSocket.OPEN) {
        webSocketRef.current.send(JSON.stringify({
          type: 'START_RECORDING',
          payload: settings
        }));
        
        setIsRecording(true);
        setRecordedActions([]);
        setGeneratedCode('');
      } else {
        toast.error('WebSocket connection not open');
      }
    } catch (error) {
      console.error('Error starting recording:', error);
      toast.error('Failed to start recording');
    }
  };
  
  // Stop recording
  const handleStopRecording = async () => {
    try {
      if (webSocketRef.current?.readyState === WebSocket.OPEN) {
        webSocketRef.current.send(JSON.stringify({
          type: 'STOP_RECORDING',
          payload: { sessionId: recordingSessionId }
        }));
      } else {
        toast.error('WebSocket connection not open');
      }
    } catch (error) {
      console.error('Error stopping recording:', error);
      toast.error('Failed to stop recording');
      setIsRecording(false);
    }
  };
  
  // Save the recorded test
  const handleSaveTest = async () => {
    try {
      const testName = prompt('Enter a name for this test:');
      if (!testName) return;
      
      const saveRequest = {
        sessionId: recordingSessionId,
        testName: testName,
        description: `Test recorded on ${new Date().toLocaleDateString()}`,
        packageName: 'com.cssmart.generated',
        className: testName.replace(/[^a-zA-Z0-9]/g, '') + 'Test',
        testMethod: 'test' + testName.replace(/[^a-zA-Z0-9]/g, ''),
        tags: ['generated', 'recorder'],
        browser: settings.browser,
        code: generatedCode
      };
      
      const response = await saveRecording(saveRequest);
      toast.success('Test saved successfully');
    } catch (error) {
      console.error('Error saving test:', error);
      toast.error('Failed to save test');
    }
  };
  
  // Toggle settings panel
  const toggleSettings = () => {
    setShowSettings(!showSettings);
  };
  
  // Update settings
  const updateSettings = (newSettings) => {
    setSettings(newSettings);
    setShowSettings(false);
  };

  return (
    <div className="recorder-container">
      <div className="recorder-header">
        <h1>Test Recorder</h1>
        <div className="recorder-controls">
          <button 
            className="control-button settings"
            onClick={toggleSettings}
          >
            <FaCog />
            <span>Settings</span>
          </button>
          
          {!isRecording ? (
            <button 
              className="control-button start"
              onClick={handleStartRecording}
            >
              <FaPlay />
              <span>Start Recording</span>
            </button>
          ) : (
            <button 
              className="control-button stop"
              onClick={handleStopRecording}
            >
              <FaStop />
              <span>Stop Recording</span>
            </button>
          )}
          
          {generatedCode && (
            <button 
              className="control-button save"
              onClick={handleSaveTest}
            >
              <FaSave />
              <span>Save Test</span>
            </button>
          )}
        </div>
      </div>
      
      {showSettings && (
        <RecorderSettings 
          settings={settings} 
          onSave={updateSettings} 
          onCancel={() => setShowSettings(false)} 
        />
      )}
      
      <div className="recorder-content">
        <div className="recorded-actions-panel">
          <h2>Recorded Actions</h2>
          {recordedActions.length === 0 ? (
            <div className="no-actions">
              {isRecording ? 'Waiting for actions...' : 'No actions recorded yet'}
            </div>
          ) : (
            <ul className="actions-list">
              {recordedActions.map((action, index) => (
                <li key={action.id || index} className="action-item">
                  <div className="action-type">{action.actionType}</div>
                  <div className="action-details">
                    {action.elementAnalysis?.description || 'Unknown element'}
                    {action.value && <span className="action-value">{action.value}</span>}
                  </div>
                </li>
              ))}
            </ul>
          )}
        </div>
        
        <div className="generated-code-panel">
          <h2>Generated Test Code</h2>
          {generatedCode ? (
            <pre className="code-preview">
              <code>{generatedCode}</code>
            </pre>
          ) : (
            <div className="no-code">
              {isRecording ? 'Recording in progress...' : 'Start recording to generate code'}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default Recorder;

// src/main/webapp/src/components/RecorderSettings.js
import React, { useState } from 'react';
import { FaSave, FaTimes } from 'react-icons/fa';

/**
 * Recorder settings component
 */
const RecorderSettings = ({ settings, onSave, onCancel }) => {
  const [formData, setFormData] = useState({
    url: settings.url || 'https://www.example.com',
    browser: settings.browser || 'chrome',
    viewportWidth: settings.viewport?.width || 1366,
    viewportHeight: settings.viewport?.height || 768
  });

  // Handle input changes
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value
    });
  };

  // Handle form submission
  const handleSubmit = (e) => {
    e.preventDefault();
    onSave({
      url: formData.url,
      browser: formData.browser,
      viewport: {
        width: parseInt(formData.viewportWidth),
        height: parseInt(formData.viewportHeight)
      }
    });
  };

  return (
    <div className="settings-panel">
      <div className="settings-header">
        <h2>Recorder Settings</h2>
        <button className="close-button" onClick={onCancel}>
          <FaTimes />
        </button>
      </div>
      
      <form onSubmit={handleSubmit}>
        <div className="form-group">
          <label htmlFor="url">Target URL</label>
          <input
            type="url"
            id="url"
            name="url"
            value={formData.url}
            onChange={handleChange}
            required
            placeholder="https://www.example.com"
          />
        </div>
        
        <div className="form-group">
          <label htmlFor="browser">Browser</label>
          <select
            id="browser"
            name="browser"
            value={formData.browser}
            onChange={handleChange}
          >
            <option value="chrome">Chrome</option>
            <option value="firefox">Firefox</option>
            <option value="edge">Edge</option>
            <option value="safari">Safari</option>
          </select>
        </div>
        
        <div className="form-row">
          <div className="form-group">
            <label htmlFor="viewportWidth">Viewport Width</label>
            <input
              type="number"
              id="viewportWidth"
              name="viewportWidth"
              value={formData.viewportWidth}
              onChange={handleChange}
              min="320"
              max="3840"
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="viewportHeight">Viewport Height</label>
            <input
              type="number"
              id="viewportHeight"
              name="viewportHeight"
              value={formData.viewportHeight}
              onChange={handleChange}
              min="240"
              max="2160"
            />
          </div>
        </div>
        
        <div className="form-actions">
          <button type="button" className="cancel-button" onClick={onCancel}>
            <FaTimes />
            <span>Cancel</span>
          </button>
          <button type="submit" className="save-button">
            <FaSave />
            <span>Save Settings</span>
          </button>
        </div>
      </form>
    </div>
  );
};

export default RecorderSettings;

// src/main/webapp/src/components/TestList.js
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { FaPlay, FaEdit, FaTrash, FaPlus, FaSearch, FaFilter } from 'react-icons/fa';
import { fetchTests, deleteTest } from '../services/testService';
import { toast } from 'react-toastify';

/**
 * Test List component showing all saved tests
 */
const TestList = () => {
  const [tests, setTests] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterTag, setFilterTag] = useState('');
  const [allTags, setAllTags] = useState([]);

  // Load tests
  useEffect(() => {
    const loadTests = async () => {
      try {
        setLoading(true);
        const testData = await fetchTests();
        setTests(testData);
        
        // Extract all unique tags
        const tags = new Set();
        testData.forEach(test => {
          if (test.tags) {
            test.tags.forEach(tag => tags.add(tag));
          }
        });
        setAllTags(Array.from(tags));
        
        setError(null);
      } catch (err) {
        setError('Failed to load tests');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    loadTests();
  }, []);

  // Handle test deletion
  const handleDeleteTest = async (id, name) => {
    if (window.confirm(`Are you sure you want to delete test "${name}"?`)) {
      try {
        await deleteTest(id);
        setTests(tests.filter(test => test.id !== id));
        toast.success(`Test "${name}" deleted successfully`);
      } catch (err) {
        toast.error(`Failed to delete test: ${err.message}`);
      }
    }
  };

  // Filter tests based on search term and tag
  const filteredTests = tests.filter(test => {
    const matchesSearch = test.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                          test.className.toLowerCase().includes(searchTerm.toLowerCase()) ||
                          test.description.toLowerCase().includes(searchTerm.toLowerCase());
                          
    const matchesTag = filterTag === '' || (test.tags && test.tags.includes(filterTag));
    
    return matchesSearch && matchesTag;
  });

  if (loading) {
    return <div className="loading">Loading tests...</div>;
  }

  if (error) {
    return <div className="error-message">{error}</div>;
  }

  return (
    <div className="test-list-container">
      <div className="list-header">
        <h1>Test Scripts</h1>
        <Link to="/recorder" className="add-test-button">
          <FaPlus />
          <span>Create New Test</span>
        </Link>
      </div>

      <div className="list-filters">
        <div className="search-container">
          <FaSearch className="search-icon" />
          <input
            type="text"
            placeholder="Search tests..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="search-input"
          />
        </div>

        <div className="filter-container">
          <FaFilter className="filter-icon" />
          <select
            value={filterTag}
            onChange={(e) => setFilterTag(e.target.value)}
            className="filter-select"
          >
            <option value="">All Tags</option>
            {allTags.map((tag) => (
              <option key={tag} value={tag}>
                {tag}
              </option>
            ))}
          </select>
        </div>
      </div>

      {filteredTests.length === 0 ? (
        <div className="no-tests">
          No tests found. Use the recorder to create your first test.
        </div>
      ) : (
        <div className="test-grid">
          {filteredTests.map(test => (
            <div key={test.id} className="test-card">
              <div className="test-header">
                <h3 className="test-name">{test.name}</h3>
                <div className="tag-container">
                  {test.tags && test.tags.map(tag => (
                    <span key={tag} className="tag">
                      {tag}
                    </span>
                  ))}
                </div>
              </div>
              
              <div className="test-info">
                <div className="info-item">
                  <strong>Class:</strong> {test.className}
                </div>
                <div className="info-item">
                  <strong>Created:</strong> {new Date(test.createdAt).toLocaleDateString()}
                </div>
              </div>
              
              <p className="test-description">{test.description}</p>
              
              <div className="test-actions">
                <Link to={`/test/${test.id}`} className="action-btn edit" title="Edit Test">
                  <FaEdit />
                </Link>
                <button className="action-btn run" title="Run Test">
                  <FaPlay />
                </button>
                <button 
                  className="action-btn delete" 
                  title="Delete Test"
                  onClick={() => handleDeleteTest(test.id, test.name)}
                >
                  <FaTrash />
                </button>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default TestList;

// src/main/webapp/src/components/TestEditor.js
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { toast } from 'react-toastify';
import { FaSave, FaPlay, FaTimes, FaPlus } from 'react-icons/fa';
import { fetchTestById, updateTest } from '../services/testService';
import AceEditor from 'react-ace';
import 'ace-builds/src-noconflict/mode-java';
import 'ace-builds/src-noconflict/theme-monokai';
import 'ace-builds/src-noconflict/theme-github';

/**
 * Test Editor component for editing test scripts
 */
const TestEditor = () => {
  const { id } = useParams();
  const navigate = useNavigate();
  
  const [test, setTest] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    packageName: '',
    className: '',
    tags: [],
    browser: 'chrome',
    code: ''
  });
  const [tagInput, setTagInput] = useState('');
  const [darkTheme, setDarkTheme] = useState(localStorage.getItem('editorDarkTheme') === 'true');

  // Load test data
  useEffect(() => {
    const loadTest = async () => {
      try {
        setLoading(true);
        const testData = await fetchTestById(id);
        setTest(testData);
        setFormData({
          name: testData.name || '',
          description: testData.description || '',
          packageName: testData.packageName || '',
          className: testData.className || '',
          tags: testData.tags || [],
          browser: testData.browser || 'chrome',
          code: testData.code || ''
        });
        setError(null);
      } catch (err) {
        setError('Failed to load test');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    loadTest();
  }, [id]);

  // Handle form input changes
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value
    });
  };

  // Handle code changes
  const handleCodeChange = (newCode) => {
    setFormData({
      ...formData,
      code: newCode
    });
  };

  // Toggle editor theme
  const toggleTheme = () => {
    const newTheme = !darkTheme;
    setDarkTheme(newTheme);
    localStorage.setItem('editorDarkTheme', newTheme);
  };

  // Add a tag
  const addTag = () => {
    if (tagInput.trim() !== '' && !formData.tags.includes(tagInput.trim())) {
      setFormData({
        ...formData,
        tags: [...formData.tags, tagInput.trim()]
      });
      setTagInput('');
    }
  };

  // Remove a tag
  const removeTag = (tagToRemove) => {
    setFormData({
      ...formData,
      tags: formData.tags.filter(tag => tag !== tagToRemove)
    });
  };

  // Handle tag input key press
  const handleTagKeyPress = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      addTag();
    }
  };

  // Save the test
  const handleSave = async () => {
    try {
      await updateTest(id, formData);
      toast.success('Test saved successfully');
    } catch (err) {
      toast.error(`Failed to save test: ${err.message}`);
    }
  };

  // Run the test
  const handleRun = () => {
    toast.info('Test execution feature coming soon');
  };

  if (loading) {
    return <div className="loading">Loading test...</div>;
  }

  if (error) {
    return <div className="error-message">{error}</div>;
  }

  return (
    <div className="test-editor">
      <div className="editor-header">
        <h1>Test Editor</h1>
        <div className="editor-actions">
          <button 
            className="theme-toggle"
            onClick={toggleTheme}
            title={darkTheme ? 'Switch to light theme' : 'Switch to dark theme'}
          >
            {darkTheme ? 'Light Theme' : 'Dark Theme'}
          </button>
          <button className="action-button run" onClick={handleRun}>
            <FaPlay />
            <span>Run Test</span>
          </button>
          <button className="action-button save" onClick={handleSave}>
            <FaSave />
            <span>Save</span>
          </button>
        </div>
      </div>

      <div className="editor-content">
        <div className="test-metadata">
          <div className="form-group">
            <label htmlFor="name">Test Name</label>
            <input
              type="text"
              id="name"
              name="name"
              value={formData.name}
              onChange={handleChange}
              required
            />
          </div>

          <div className="form-group">
            <label htmlFor="description">Description</label>
            <textarea
              id="description"
              name="description"
              value={formData.description}
              onChange={handleChange}
              rows="3"
            />
          </div>

          <div className="form-row">
            <div className="form-group">
              <label htmlFor="packageName">Package</label>
              <input
                type="text"
                id="packageName"
                name="packageName"
                value={formData.packageName}
                onChange={handleChange}
              />
            </div>

            <div className="form-group">
              <label htmlFor="className">Class Name</label>
              <input
                type="text"
                id="className"
                name="className"
                value={formData.className}
                onChange={handleChange}
              />
            </div>
          </div>

          <div className="form-group">
            <label htmlFor="browser">Browser</label>
            <select
              id="browser"
              name="browser"
              value={formData.browser}
              onChange={handleChange}
            >
              <option value="chrome">Chrome</option>
              <option value="firefox">Firefox</option>
              <option value="edge">Edge</option>
              <option value="safari">Safari</option>
            </select>
          </div>

          <div className="form-group">
            <label>Tags</label>
            <div className="tag-input-container">
              <input
                type="text"
                value={tagInput}
                onChange={(e) => setTagInput(e.target.value)}
                onKeyPress={handleTagKeyPress}
                placeholder="Add a tag and press Enter"
              />
              <button className="add-tag-button" onClick={addTag}>
                <FaPlus />
              </button>
            </div>
            <div className="tags-container">
              {formData.tags.map(tag => (
                <div key={tag} className="tag">
                  <span>{tag}</span>
                  <button onClick={() => removeTag(tag)}>
                    <FaTimes />
                  </button>
                </div>
              ))}
            </div>
          </div>
        </div>

        <div className="code-editor">
          <h2>Test Code</h2>
          <AceEditor
            mode="java"
            theme={darkTheme ? "monokai" : "github"}
            onChange={handleCodeChange}
            value={formData.code}
            name="code-editor"
            editorProps={{ $blockScrolling: true }}
            setOptions={{
              showLineNumbers: true,
              tabSize: 4,
              useSoftTabs: true,
              showPrintMargin: false,
              enableBasicAutocompletion: true,
              enableLiveAutocompletion: true,
              enableSnippets: true,
            }}
            width="100%"
            height="500px"
            className="ace-editor"
          />
        </div>
      </div>
    </div>
  );
};

export default TestEditor;

// src/main/webapp/src/components/Settings.js
import React, { useState, useEffect } from 'react';
import { toast } from 'react-toastify';
import { FaSave } from 'react-icons/fa';
import { fetchSettings, updateSettings } from '../services/settingsService';

/**
 * Settings component for framework configuration
 */
const Settings = () => {
  const [settings, setSettings] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Load settings
  useEffect(() => {
    const loadSettings = async () => {
      try {
        setLoading(true);
        const data = await fetchSettings();
        setSettings(data);
        setError(null);
      } catch (err) {
        setError('Failed to load settings');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    loadSettings();
  }, []);

  // Handle input changes
  const handleChange = (section, key, value) => {
    setSettings({
      ...settings,
      [section]: {
        ...settings[section],
        [key]: value
      }
    });
  };

  // Handle checkbox changes
  const handleCheckboxChange = (section, key) => {
    setSettings({
      ...settings,
      [section]: {
        ...settings[section],
        [key]: !settings[section][key]
      }
    });
  };

  // Save settings
  const handleSave = async () => {
    try {
      await updateSettings(settings);
      toast.success('Settings saved successfully');
    } catch (err) {
      toast.error(`Failed to save settings: ${err.message}`);
    }
  };

  if (loading) {
    return <div className="loading">Loading settings...</div>;
  }

  if (error) {
    return <div className="error-message">{error}</div>;
  }

  if (!settings) {
    return <div className="error-message">No settings available</div>;
  }

  return (
    <div className="settings-container">
      <div className="settings-header">
        <h1>Framework Settings</h1>
        <button className="save-button" onClick={handleSave}>
          <FaSave />
          <span>Save Settings</span>
        </button>
      </div>

      <div className="settings-sections">
        <div className="settings-section">
          <h2>General</h2>
          <div className="form-group">
            <label htmlFor="environment">Environment</label>
            <select
              id="environment"
              value={settings.general.environment}
              onChange={(e) => handleChange('general', 'environment', e.target.value)}
            >
              <option value="dev">Development</option>
              <option value="test">Test</option>
              <option value="staging">Staging</option>
              <option value="prod">Production</option>
            </select>
          </div>
          
          <div className="form-group">
            <label htmlFor="baseUrl">Base URL</label>
            <input
              type="text"
              id="baseUrl"
              value={settings.general.baseUrl}
              onChange={(e) => handleChange('general', 'baseUrl', e.target.value)}
            />
          </div>
        </div>

        <div className="settings-section">
          <h2>Browser</h2>
          <div className="form-group">
            <label htmlFor="defaultBrowser">Default Browser</label>
            <select
              id="defaultBrowser"
              value={settings.browser.default}
              onChange={(e) => handleChange('browser', 'default', e.target.value)}
            >
              <option value="chrome">Chrome</option>
              <option value="firefox">Firefox</option>
              <option value="edge">Edge</option>
              <option value="safari">Safari</option>
            </select>
          </div>
          
          <div className="form-row">
            <div className="form-group">
              <label htmlFor="browserWidth">Browser Width</label>
              <input
                type="number"
                id="browserWidth"
                value={settings.browser.width}
                onChange={(e) => handleChange('browser', 'width', parseInt(e.target.value))}
              />
            </div>
            <div className="form-group">
              <label htmlFor="browserHeight">Browser Height</label>
              <input
                type="number"
                id="browserHeight"
                value={settings.browser.height}
                onChange={(e) => handleChange('browser', 'height', parseInt(e.target.value))}
              />
            </div>
          </div>
          
          <div className="form-group checkbox">
            <input
              type="checkbox"
              id="maximizeBrowser"
              checked={settings.browser.maximize}
              onChange={() => handleCheckboxChange('browser', 'maximize')}
            />
            <label htmlFor="maximizeBrowser">Maximize browser on start</label>
          </div>
        </div>

        <div className="settings-section">
          <h2>Timeouts</h2>
          <div className="form-group">
            <label htmlFor="implicitTimeout">Implicit Wait (seconds)</label>
            <input
              type="number"
              id="implicitTimeout"
              value={settings.timeouts.implicit}
              onChange={(e) => handleChange('timeouts', 'implicit', parseInt(e.target.value))}
              min="0"
              max="60"
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="explicitTimeout">Explicit Wait (seconds)</label>
            <input
              type="number"
              id="explicitTimeout"
              value={settings.timeouts.explicit}
              onChange={(e) => handleChange('timeouts', 'explicit', parseInt(e.target.value))}
              min="0"
              max="60"
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="pageLoadTimeout">Page Load Timeout (seconds)</label>
            <input
              type="number"
              id="pageLoadTimeout"
              value={settings.timeouts.pageLoad}
              onChange={(e) => handleChange('timeouts', 'pageLoad', parseInt(e.target.value))}
              min="0"
              max="120"
            />
          </div>
          
          <div className="form-group">
            <label htmlFor="scriptTimeout">Script Timeout (seconds)</label>
            <input
              type="number"
              id="scriptTimeout"
              value={settings.timeouts.script}
              onChange={(e) => handleChange('timeouts', 'script', parseInt(e.target.value))}
              min="0"
              max="120"
            />
          </div>
        </div>

        <div className="settings-section">
          <h2>Reporting</h2>
          <div className="form-group checkbox">
            <input
              type="checkbox"
              id="screenshotOnFailure"
              checked={settings.reporting.screenshots.onFailure}
              onChange={() => handleCheckboxChange('reporting.screenshots', 'onFailure')}
            />
            <label htmlFor="screenshotOnFailure">Take screenshot on test failure</label>
          </div>
          
          <div className="form-group checkbox">
            <input
              type="checkbox"
              id="screenshotOnStep"
              checked={settings.reporting.screenshots.onStep}
              onChange={() => handleCheckboxChange('reporting.screenshots', 'onStep')}
            />
            <label htmlFor="screenshotOnStep">Take screenshot on each step</label>
          </div>
          
          <div className="form-group">
            <label htmlFor="outputDir">Report Output Directory</label>
            <input
              type="text"
              id="outputDir"
              value={settings.reporting.outputDir}
              onChange={(e) => handleChange('reporting', 'outputDir', e.target.value)}
            />
          </div>
        </div>

        <div className="settings-section">
          <h2>AI Engine</h2>
          <div className="form-group">
            <label htmlFor="confidenceThreshold">Confidence Threshold</label>
            <input
              type="range"
              id="confidenceThreshold"
              min="0"
              max="100"
              value={settings.ai.confidenceThreshold * 100}
              onChange={(e) => handleChange('ai', 'confidenceThreshold', parseInt(e.target.value) / 100)}
            />
            <span className="range-value">{Math.round(settings.ai.confidenceThreshold * 100)}%</span>
          </div>
          
          <div className="form-group checkbox">
            <input
              type="checkbox"
              id="selfHealing"
              checked={settings.ai.selfHealing}
              onChange={() => handleCheckboxChange('ai', 'selfHealing')}
            />
            <label htmlFor="selfHealing">Enable self-healing tests</label>
          </div>
          
          <div className="form-group checkbox">
            <input
              type="checkbox"
              id="generateAssertions"
              checked={settings.ai.generateAssertions}
              onChange={() => handleCheckboxChange('ai', 'generateAssertions')}
            />
            <label htmlFor="generateAssertions">Auto-generate assertions</label>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Settings;


// src/main/webapp/src/services/recorderService.js

/**
 * Service for interacting with the test recorder API
 */
export const startRecording = async (config) => {
  try {
    const response = await fetch('/api/recorder/start', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(config),
    });

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error starting recording:', error);
    throw error;
  }
};

export const stopRecording = async (sessionId) => {
  try {
    const response = await fetch(`/api/recorder/stop/${sessionId}`, {
      method: 'POST',
    });

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error stopping recording:', error);
    throw error;
  }
};

export const saveRecording = async (saveRequest) => {
  try {
    const response = await fetch('/api/recorder/save', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(saveRequest),
    });

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error saving recording:', error);
    throw error;
  }
};

export const getRecordedActions = async (sessionId) => {
  try {
    const response = await fetch(`/api/recorder/actions/${sessionId}`);

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error getting recorded actions:', error);
    throw error;
  }
};

export const generateTestScript = async (sessionId) => {
  try {
    const response = await fetch(`/api/recorder/generate/${sessionId}`);

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error generating test script:', error);
    throw error;
  }
};

// src/main/webapp/src/services/testService.js

/**
 * Service for interacting with the test management API
 */
export const fetchTests = async () => {
  try {
    const response = await fetch('/api/recorder/tests');

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error fetching tests:', error);
    throw error;
  }
};

export const fetchTestById = async (id) => {
  try {
    const response = await fetch(`/api/tests/${id}`);

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error(`Error fetching test ${id}:`, error);
    throw error;
  }
};

export const updateTest = async (id, testData) => {
  try {
    const response = await fetch(`/api/tests/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(testData),
    });

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error(`Error updating test ${id}:`, error);
    throw error;
  }
};

export const deleteTest = async (id) => {
  try {
    const response = await fetch(`/api/tests/${id}`, {
      method: 'DELETE',
    });

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return true;
  } catch (error) {
    console.error(`Error deleting test ${id}:`, error);
    throw error;
  }
};

export const runTest = async (id) => {
  try {
    const response = await fetch(`/api/tests/${id}/run`, {
      method: 'POST',
    });

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error(`Error running test ${id}:`, error);
    throw error;
  }
};

// src/main/webapp/src/services/dashboardService.js

/**
 * Service for interacting with the dashboard API
 */
export const fetchDashboardData = async () => {
  try {
    const response = await fetch('/api/dashboard');

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error fetching dashboard data:', error);
    
    // Return mock data for development
    return {
      testCount: 24,
      successRate: 87,
      avgDuration: 12.5,
      executionHistory: [
        { date: '2023-01-01', passed: 10, failed: 2, skipped: 1 },
        { date: '2023-01-02', passed: 12, failed: 1, skipped: 0 },
        { date: '2023-01-03', passed: 15, failed: 3, skipped: 1 },
        { date: '2023-01-04', passed: 14, failed: 2, skipped: 0 },
        { date: '2023-01-05', passed: 16, failed: 1, skipped: 2 },
        { date: '2023-01-06', passed: 18, failed: 0, skipped: 0 },
        { date: '2023-01-07', passed: 17, failed: 2, skipped: 1 },
      ],
      testStatus: {
        passed: 18,
        failed: 4,
        skipped: 2
      },
      recentTests: [
        {
          id: '1',
          name: 'Login Test',
          status: 'Passed',
          duration: 8.2,
          lastRun: '2023-01-07T10:30:00Z'
        },
        {
          id: '2',
          name: 'Shopping Cart Test',
          status: 'Failed',
          duration: 12.7,
          lastRun: '2023-01-07T11:45:00Z'
        },
        {
          id: '3',
          name: 'Product Search Test',
          status: 'Passed',
          duration: 10.5,
          lastRun: '2023-01-07T13:15:00Z'
        },
        {
          id: '4',
          name: 'Checkout Process Test',
          status: 'Passed',
          duration: 15.3,
          lastRun: '2023-01-07T14:30:00Z'
        },
        {
          id: '5',
          name: 'User Registration Test',
          status: 'Skipped',
          duration: 0,
          lastRun: '2023-01-07T15:00:00Z'
        }
      ]
    };
  }
};

// src/main/webapp/src/services/settingsService.js

/**
 * Service for interacting with the settings API
 */
export const fetchSettings = async () => {
  try {
    const response = await fetch('/api/settings');

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error fetching settings:', error);
    
    // Return mock settings for development
    return {
      general: {
        environment: 'dev',
        baseUrl: 'https://example.com'
      },
      browser: {
        default: 'chrome',
        width: 1920,
        height: 1080,
        maximize: true
      },
      timeouts: {
        implicit: 5,
        explicit: 10,
        pageLoad: 30,
        script: 30
      },
      reporting: {
        screenshots: {
          onFailure: true,
          onStep: false
        },
        outputDir: 'target/cssmart-reports'
      },
      ai: {
        confidenceThreshold: 0.75,
        selfHealing: true,
        generateAssertions: true
      }
    };
  }
};

export const updateSettings = async (settings) => {
  try {
    const response = await fetch('/api/settings', {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(settings),
    });

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error updating settings:', error);
    throw error;
  }
};


/* src/main/webapp/src/styles/index.css */

/* 
 * This file contains all the styles for the CS Smart Test Framework UI
 */

/* ===== Global Variables ===== */
:root {
  /* Light theme colors */
  --primary-color: #4a69bd;
  --primary-light: #6a89cc;
  --primary-dark: #1e3799;
  --secondary-color: #60a3bc;
  --accent-color: #e55039;
  --background-color: #f5f6fa;
  --card-background: #ffffff;
  --text-color: #2f3542;
  --text-light: #57606f;
  --border-color: #dfe4ea;
  --success-color: #4cd137;
  --warning-color: #fbc531;
  --error-color: #e84118;
  --info-color: #00a8ff;

  /* Spacing */
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;
  --spacing-xl: 2rem;

  /* Borders */
  --border-radius-sm: 4px;
  --border-radius-md: 8px;
  --border-radius-lg: 12px;
  
  /* Shadows */
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.12);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  
  /* Transitions */
  --transition-short: 0.2s ease;
  --transition-medium: 0.3s ease;
  --transition-long: 0.5s ease;
}

/* Dark theme colors */
.dark {
  --primary-color: #6a89cc;
  --primary-light: #8da5e3;
  --primary-dark: #4a69bd;
  --secondary-color: #82ccdd;
  --accent-color: #ff6b6b;
  --background-color: #1e272e;
  --card-background: #2d3436;
  --text-color: #f5f6fa;
  --text-light: #dfe4ea;
  --border-color: #485460;
  --success-color: #7bed9f;
  --warning-color: #ffeaa7;
  --error-color: #ff7f50;
  --info-color: #70a1ff;
  
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.5);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.4);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.4);
}

/* ===== Reset and Base Styles ===== */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  font-family: 'Roboto', 'Segoe UI', Arial, sans-serif;
  font-size: 16px;
  line-height: 1.5;
  color: var(--text-color);
  background-color: var(--background-color);
  height: 100%;
  width: 100%;
}

#root, .app {
  height: 100%;
  display: flex;
  flex-direction: column;
}

h1, h2, h3, h4, h5, h6 {
  font-weight: 500;
  margin-bottom: var(--spacing-md);
}

h1 {
  font-size: 1.8rem;
}

h2 {
  font-size: 1.5rem;
}

h3 {
  font-size: 1.2rem;
}

a {
  color: var(--primary-color);
  text-decoration: none;
  transition: color var(--transition-short);
}

a:hover {
  color: var(--primary-light);
}

button {
  cursor: pointer;
  border: none;
  background: none;
  font-family: inherit;
  font-size: inherit;
  color: inherit;
}

input, textarea, select {
  font-family: inherit;
  font-size: inherit;
  color: var(--text-color);
  background-color: var(--card-background);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-sm);
  padding: var(--spacing-sm) var(--spacing-md);
  transition: border-color var(--transition-short);
}

input:focus, textarea:focus, select:focus {
  outline: none;
  border-color: var(--primary-color);
}

.main-content {
  flex: 1;
  padding: var(--spacing-lg);
  overflow-y: auto;
}

.loading {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  font-size: 1.2rem;
  color: var(--text-light);
}

.error-message {
  background-color: var(--error-color);
  color: white;
  padding: var(--spacing-md);
  border-radius: var(--border-radius-md);
  margin-bottom: var(--spacing-lg);
}

/* ===== Navigation ===== */
.navbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: var(--card-background);
  padding: var(--spacing-md) var(--spacing-lg);
  box-shadow: var(--shadow-sm);
  height: 64px;
}

.navbar-brand {
  display: flex;
  align-items: center;
}

.navbar-brand a {
  display: flex;
  align-items: center;
  font-weight: 600;
  font-size: 1.2rem;
  color: var(--text-color);
}

.logo {
  height: 32px;
  margin-right: var(--spacing-sm);
}

.brand-text {
  color: var(--primary-color);
}

.nav-links {
  display: flex;
  list-style: none;
  margin: 0;
  padding: 0;
}

.nav-links li {
  margin: 0 var(--spacing-md);
}

.nav-links a {
  display: flex;
  align-items: center;
  color: var(--text-light);
  transition: color var(--transition-short);
}

.nav-links a:hover {
  color: var(--primary-color);
}

.nav-links svg {
  margin-right: var(--spacing-sm);
}

.nav-links li.active a {
  color: var(--primary-color);
  font-weight: 500;
}

.nav-actions {
  display: flex;
  align-items: center;
}

.theme-toggle {
  background: none;
  border: none;
  color: var(--text-light);
  cursor: pointer;
  font-size: 1.2rem;
  transition: color var(--transition-short);
}

.theme-toggle:hover {
  color: var(--primary-color);
}

/* ===== Dashboard ===== */
.dashboard {
  max-width: 1200px;
  margin: 0 auto;
}

.metric-cards {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: var(--spacing-lg);
  margin-bottom: var(--spacing-xl);
}

.metric-card {
  display: flex;
  align-items: center;
  background-color: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-md);
}

.metric-icon {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 50px;
  height: 50px;
  background-color: var(--primary-light);
  color: white;
  border-radius: 50%;
  margin-right: var(--spacing-lg);
  font-size: 1.5rem;
}

.metric-content {
  flex: 1;
}

.metric-content h3 {
  margin-bottom: var(--spacing-xs);
  font-size: 1rem;
  color: var(--text-light);
}

.metric-value {
  font-size: 1.8rem;
  font-weight: 600;
  color: var(--text-color);
}

.dashboard-charts {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
  gap: var(--spacing-lg);
  margin-bottom: var(--spacing-xl);
}

.chart-container {
  background-color: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-md);
}

.chart-container h2 {
  margin-bottom: var(--spacing-lg);
  font-size: 1.2rem;
}

.recent-tests {
  background-color: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-md);
}

.recent-tests h2 {
  margin-bottom: var(--spacing-lg);
  font-size: 1.2rem;
}

.tests-table {
  width: 100%;
  border-collapse: collapse;
}

.tests-table th, .tests-table td {
  padding: var(--spacing-md);
  text-align: left;
  border-bottom: 1px solid var(--border-color);
}

.tests-table th {
  font-weight: 500;
  color: var(--text-light);
}

.status-badge {
  display: inline-block;
  padding: 4px 8px;
  border-radius: 50px;
  font-size: 0.8rem;
  font-weight: 500;
}

.status-badge.passed {
  background-color: rgba(76, 209, 55, 0.2);
  color: var(--success-color);
}

.status-badge.failed {
  background-color: rgba(232, 65, 24, 0.2);
  color: var(--error-color);
}

.status-badge.skipped {
  background-color: rgba(251, 197, 49, 0.2);
  color: var(--warning-color);
}

.actions {
  display: flex;
  gap: var(--spacing-sm);
}

.action-btn {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background-color: transparent;
  transition: background-color var(--transition-short);
}

.action-btn.edit:hover {
  background-color: rgba(0, 168, 255, 0.2);
  color: var(--info-color);
}

.action-btn.run:hover {
  background-color: rgba(76, 209, 55, 0.2);
  color: var(--success-color);
}

.action-btn.delete:hover {
  background-color: rgba(232, 65, 24, 0.2);
  color: var(--error-color);
}

/* ===== Recorder ===== */
.recorder-container {
  max-width: 1200px;
  margin: 0 auto;
}

.recorder-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-lg);
}

.recorder-controls {
  display: flex;
  gap: var(--spacing-md);
}

.control-button {
  display: flex;
  align-items: center;
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius-md);
  background-color: var(--card-background);
  color: var(--text-color);
  box-shadow: var(--shadow-sm);
  transition: all var(--transition-short);
}

.control-button svg {
  margin-right: var(--spacing-sm);
}

.control-button.start {
  background-color: var(--success-color);
  color: white;
}

.control-button.stop {
  background-color: var(--error-color);
  color: white;
}

.control-button.save {
  background-color: var(--primary-color);
  color: white;
}

.control-button:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.recorder-content {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--spacing-lg);
}

.recorded-actions-panel, .generated-code-panel {
  background-color: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-md);
  height: 600px;
  overflow-y: auto;
}

.recorded-actions-panel h2, .generated-code-panel h2 {
  margin-bottom: var(--spacing-lg);
  font-size: 1.2rem;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: var(--spacing-sm);
}

.no-actions, .no-code {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 80%;
  color: var(--text-light);
  font-style: italic;
}

.actions-list {
  list-style: none;
}

.action-item {
  margin-bottom: var(--spacing-md);
  padding: var(--spacing-md);
  background-color: var(--background-color);
  border-radius: var(--border-radius-sm);
  border-left: 4px solid var(--primary-color);
}

.action-type {
  font-weight: 500;
  margin-bottom: var(--spacing-xs);
  color: var(--primary-color);
}

.action-details {
  color: var(--text-light);
}

.action-value {
  margin-left: var(--spacing-sm);
  font-weight: 500;
  color: var(--text-color);
}

.code-preview {
  background-color: var(--background-color);
  padding: var(--spacing-md);
  border-radius: var(--border-radius-sm);
  max-height: 500px;
  overflow-y: auto;
  font-family: monospace;
  line-height: 1.5;
  white-space: pre-wrap;
}

/* Settings Panel */
.settings-panel {
  background-color: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-lg);
  margin-bottom: var(--spacing-xl);
}

.settings-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-lg);
  border-bottom: 1px solid var(--border-color);
  padding-bottom: var(--spacing-sm);
}

.close-button {
  color: var(--text-light);
  font-size: 1.2rem;
  transition: color var(--transition-short);
}

.close-button:hover {
  color: var(--accent-color);
}

.form-group {
  margin-bottom: var(--spacing-lg);
}

.form-group label {
  display: block;
  margin-bottom: var(--spacing-sm);
  font-weight: 500;
}

.form-group input, .form-group select {
  width: 100%;
}

.form-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--spacing-lg);
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-md);
  margin-top: var(--spacing-lg);
}

.cancel-button, .save-button {
  display: flex;
  align-items: center;
  padding: var(--spacing-sm) var(--spacing-lg);
  border-radius: var(--border-radius-md);
  font-weight: 500;
  transition: all var(--transition-short);
}

.cancel-button {
  background-color: transparent;
  color: var(--text-light);
  border: 1px solid var(--border-color);
}

.cancel-button:hover {
  background-color: var(--border-color);
  color: var(--text-color);
}

.save-button {
  background-color: var(--primary-color);
  color: white;
}

.save-button:hover {
  background-color: var(--primary-dark);
}

.save-button svg, .cancel-button svg {
  margin-right: var(--spacing-sm);
}

/* ===== Test List ===== */
.test-list-container {
  max-width: 1200px;
  margin: 0 auto;
}

.list-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-lg);
}

.add-test-button {
  display: flex;
  align-items: center;
  padding: var(--spacing-sm) var(--spacing-md);
  background-color: var(--primary-color);
  color: white;
  border-radius: var(--border-radius-md);
  font-weight: 500;
  transition: background-color var(--transition-short);
}

.add-test-button:hover {
  background-color: var(--primary-dark);
}

.add-test-button svg {
  margin-right: var(--spacing-sm);
}

.list-filters {
  display: flex;
  gap: var(--spacing-lg);
  margin-bottom: var(--spacing-lg);
}

.search-container, .filter-container {
  position: relative;
  flex: 1;
}

.search-icon, .filter-icon {
  position: absolute;
  left: var(--spacing-md);
  top: 50%;
  transform: translateY(-50%);
  color: var(--text-light);
}

.search-input, .filter-select {
  width: 100%;
  padding-left: calc(var(--spacing-md) * 2 + 16px); /* Icon width + padding */
}

.no-tests {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 200px;
  background-color: var(--card-background);
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-md);
  color: var(--text-light);
  font-style: italic;
}

.test-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
  gap: var(--spacing-lg);
}

.test-card {
  background-color: var(--card-background);
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-md);
  padding: var(--spacing-lg);
  display: flex;
  flex-direction: column;
  transition: transform var(--transition-short), box-shadow var(--transition-short);
}

.test-card:hover {
  transform: translateY(-4px);
  box-shadow: var(--shadow-lg);
}

.test-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: var(--spacing-md);
}

.test-name {
  font-size: 1.2rem;
  margin-bottom: var(--spacing-xs);
  flex: 1;
}

.tag-container {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-xs);
}

.tag {
  display: inline-block;
  padding: 2px 8px;
  background-color: var(--primary-light);
  color: white;
  border-radius: 50px;
  font-size: 0.7rem;
  font-weight: 500;
}

.test-info {
  margin-bottom: var(--spacing-md);
  color: var(--text-light);
  font-size: 0.9rem;
}

.info-item {
  margin-bottom: var(--spacing-xs);
}

.test-description {
  flex: 1;
  margin-bottom: var(--spacing-lg);
  font-size: 0.9rem;
  color: var(--text-color);
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
}

.test-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--spacing-md);
  margin-top: auto;
}

/* ===== Test Editor ===== */
.test-editor {
  max-width: 1200px;
  margin: 0 auto;
}

.editor-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-lg);
}

.editor-actions {
  display: flex;
  gap: var(--spacing-md);
}

.action-button {
  display: flex;
  align-items: center;
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius-md);
  font-weight: 500;
  transition: all var(--transition-short);
}

.action-button.run {
  background-color: var(--success-color);
  color: white;
}

.action-button.save {
  background-color: var(--primary-color);
  color: white;
}

.action-button:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.action-button svg {
  margin-right: var(--spacing-sm);
}

.editor-content {
  display: grid;
  grid-template-columns: 300px 1fr;
  gap: var(--spacing-lg);
}

.test-metadata {
  background-color: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-md);
}

.code-editor {
  background-color: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-md);
}

.code-editor h2 {
  margin-bottom: var(--spacing-lg);
  border-bottom: 1px solid var(--border-color);
  padding-bottom: var(--spacing-sm);
}

.ace-editor {
  border-radius: var(--border-radius-sm);
  overflow: hidden;
}

.tag-input-container {
  display: flex;
  gap: var(--spacing-sm);
  margin-bottom: var(--spacing-sm);
}

.tag-input-container input {
  flex: 1;
}

.add-tag-button {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 36px;
  height: 36px;
  background-color: var(--primary-color);
  color: white;
  border-radius: var(--border-radius-sm);
  transition: background-color var(--transition-short);
}

.add-tag-button:hover {
  background-color: var(--primary-dark);
}

.tags-container {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-sm);
}

.tags-container .tag {
  display: flex;
  align-items: center;
  background-color: var(--primary-light);
}

.tags-container .tag button {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  margin-left: var(--spacing-xs);
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background-color: rgba(255, 255, 255, 0.3);
  font-size: 0.6rem;
  transition: background-color var(--transition-short);
}

.tags-container .tag button:hover {
  background-color: rgba(255, 255, 255, 0.5);
}

/* ===== Settings Page ===== */
.settings-container {
  max-width: 1200px;
  margin: 0 auto;
}

.settings-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--spacing-lg);
}

.settings-sections {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  gap: var(--spacing-lg);
}

.settings-section {
  background-color: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-md);
}

.settings-section h2 {
  margin-bottom: var(--spacing-lg);
  border-bottom: 1px solid var(--border-color);
  padding-bottom: var(--spacing-sm);
}

.form-group.checkbox {
  display: flex;
  align-items: center;
}

.form-group.checkbox input {
  width: auto;
  margin-right: var(--spacing-sm);
}

.form-group.checkbox label {
  margin-bottom: 0;
}

.range-value {
  margin-left: var(--spacing-sm);
  font-weight: 500;
}

/* ===== Responsive adjustments ===== */
@media (max-width: 768px) {
  .recorder-content, .editor-content {
    grid-template-columns: 1fr;
  }
  
  .dashboard-charts {
    grid-template-columns: 1fr;
  }
  
  .metric-cards {
    grid-template-columns: 1fr;
  }
  
  .test-grid {
    grid-template-columns: 1fr;
  }
  
  .settings-sections {
    grid-template-columns: 1fr;
  }
  
  .navbar {
    flex-direction: column;
    height: auto;
    padding: var(--spacing-sm);
  }
  
  .nav-links {
    margin: var(--spacing-md) 0;
  }
  
  .recorder-header, .list-header, .editor-header {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .recorder-controls, .editor-actions {
    margin-top: var(--spacing-md);
    width: 100%;
  }
  
  .list-filters {
    flex-direction: column;
  }
  
  .form-row {
    grid-template-columns: 1fr;
  }
}


package com.cssmart.ui.recorder;

import com.cssmart.ai.engine.AIEngine;
import com.cssmart.ai.engine.model.ElementAnalysis;
import com.cssmart.ai.engine.model.RecordingSession;
import com.cssmart.ai.engine.model.TestScript;
import com.cssmart.config.ConfigurationManager;
import com.cssmart.driver.BrowserManager;
import com.cssmart.driver.DriverManager;
import com.cssmart.ui.recorder.model.*;

import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.Dimension;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Service for recorder functionality with browser management
 */
@Service
@Slf4j
public class RecorderService {

    private final AIEngine aiEngine;
    private final ConfigurationManager configManager;
    private final Map<String, RecordingSession> activeSessions = new ConcurrentHashMap<>();
    private final Map<String, WebDriver> activeDrivers = new ConcurrentHashMap<>();
    private final TestScriptGenerator scriptGenerator;
    private final TestScriptRepository scriptRepository;
    private final String recorderScriptPath;

    @Autowired
    public RecorderService(
            TestScriptGenerator scriptGenerator, 
            TestScriptRepository scriptRepository,
            ConfigurationManager configManager) {
        this.aiEngine = AIEngine.getInstance();
        this.scriptGenerator = scriptGenerator;
        this.scriptRepository = scriptRepository;
        this.configManager = configManager;
        
        // Load recorder script
        this.recorderScriptPath = "src/main/resources/static/js/recorder-script.js";
    }

    /**
     * Start a new recording session with browser initialization
     * 
     * @param request Recording configuration
     * @return Session ID
     */
    public String startRecording(RecordingRequest request) {
        // Create a new session ID
        String sessionId = UUID.randomUUID().toString();
        log.info("Starting recording session: {} for URL: {}", sessionId, request.getUrl());
        
        try {
            // Initialize WebDriver with requested browser
            WebDriver driver = createDriver(request.getBrowser(), request.getCapabilities());
            activeDrivers.put(sessionId, driver);
            
            // Set viewport if specified
            if (request.getViewport() != null) {
                driver.manage().window().setSize(
                    new Dimension(request.getViewport().getWidth(), request.getViewport().getHeight())
                );
            } else {
                // Use default or maximize
                if (configManager.isMaximizeBrowser()) {
                    driver.manage().window().maximize();
                } else {
                    driver.manage().window().setSize(
                        new Dimension(configManager.getBrowserWidth(), configManager.getBrowserHeight())
                    );
                }
            }
            
            // Navigate to target URL
            driver.get(request.getUrl());
            
            // Inject recording script
            injectRecordingScript(driver, sessionId);
            
            // Create and store session
            RecordingSession session = RecordingSession.builder()
                    .id(sessionId)
                    .startTime(LocalDateTime.now())
                    .url(request.getUrl())
                    .browser(request.getBrowser())
                    .viewport(request.getViewport())
                    .actions(new ArrayList<>())
                    .status("recording")
                    .build();
                    
            activeSessions.put(sessionId, session);
            
            log.info("Recording started successfully for session: {}", sessionId);
            return sessionId;
        } catch (Exception e) {
            log.error("Failed to start recording session: {}", sessionId, e);
            throw new RuntimeException("Failed to start recording: " + e.getMessage(), e);
        }
    }

    /**
     * Stop a recording session and close the browser
     * 
     * @param sessionId Session ID
     * @return Recording session data
     */
    public RecordingSession stopRecording(String sessionId) {
        log.info("Stopping recording session: {}", sessionId);
        
        // Get the WebDriver
        WebDriver driver = activeDrivers.get(sessionId);
        
        // Quit the browser
        if (driver != null) {
            try {
                driver.quit();
                log.debug("Browser closed for session: {}", sessionId);
            } catch (Exception e) {
                log.error("Error closing browser for session: {}", sessionId, e);
            } finally {
                activeDrivers.remove(sessionId);
            }
        } else {
            log.warn("No browser found for session: {}", sessionId);
        }
        
        // Update session
        RecordingSession session = getSession(sessionId);
        session.setEndTime(LocalDateTime.now());
        session.setStatus("completed");
        
        log.info("Recording stopped for session: {} with {} actions", 
                sessionId, session.getActions().size());
                
        return session;
    }

    /**
     * Record a user action
     * 
     * @param sessionId Session ID
     * @param action Action to record
     * @return Recorded action with analysis
     */
    public RecordedAction recordAction(String sessionId, UserAction action) {
        RecordingSession session = getSession(sessionId);
        
        log.debug("Recording action for session {}: {}", sessionId, action.getType());
        
        // Analyze the element
        ElementAnalysis elementAnalysis = null;
        if (action.getElement() != null) {
            elementAnalysis = aiEngine.analyzeElement(action.getElement());
        }
        
        // Create recorded action
        RecordedAction recordedAction = RecordedAction.builder()
                .id(UUID.randomUUID().toString())
                .timestamp(LocalDateTime.now())
                .actionType(action.getType())
                .element(action.getElement())
                .value(action.getValue())
                .elementAnalysis(elementAnalysis)
                .build();
                
        // Add to session
        session.getActions().add(recordedAction);
        
        log.debug("Recorded action {} for session {}", 
                recordedAction.getActionType(), sessionId);
                
        return recordedAction;
    }

    /**
     * Generate a test script from recorded actions
     * 
     * @param sessionId Session ID
     * @return Generated test script
     */
    public TestScript generateTestScript(String sessionId) {
        RecordingSession session = getSession(sessionId);
        
        log.info("Generating test script for session: {}", sessionId);
        
        TestScript script = scriptGenerator.generateScript(session);
        
        log.info("Generated test script for session {}: {}", 
                sessionId, script.getName());
                
        return script;
    }

    /**
     * Get all actions for a recording session
     * 
     * @param sessionId Session ID
     * @return List of recorded actions
     */
    public List<RecordedAction> getActions(String sessionId) {
        RecordingSession session = getSession(sessionId);
        return session.getActions();
    }

    /**
     * Save a test script
     * 
     * @param request Save request with test data
     * @return Test ID
     */
    public String saveTest(SaveRequest request) {
        TestScript script = TestScript.builder()
                .id(UUID.randomUUID().toString())
                .name(request.getTestName())
                .description(request.getDescription())
                .packageName(request.getPackageName())
                .className(request.getClassName())
                .testMethod(request.getTestMethod())
                .tags(request.getTags())
                .browser(request.getBrowser())
                .code(request.getCode())
                .createdAt(LocalDateTime.now())
                .build();
                
        String id = scriptRepository.save(script);
        
        log.info("Saved test script: {} with ID {}", script.getName(), id);
        return id;
    }

    /**
     * Get all saved tests
     * 
     * @return List of saved tests
     */
    public List<TestInfo> getSavedTests() {
        List<TestScript> scripts = scriptRepository.findAll();
        
        return scripts.stream()
                .map(script -> TestInfo.builder()
                        .id(script.getId())
                        .name(script.getName())
                        .description(script.getDescription())
                        .className(script.getClassName())
                        .tags(script.getTags())
                        .createdAt(script.getCreatedAt())
                        .build())
                .collect(Collectors.toList());
    }

    /**
     * Create a WebDriver instance for the specified browser
     * 
     * @param browserName Browser name
     * @param capabilities Browser capabilities
     * @return WebDriver instance
     */
    private WebDriver createDriver(String browserName, Map<String, Object> capabilities) {
        log.debug("Creating WebDriver for browser: {}", browserName);
        
        // Use BrowserManager to create driver
        return DriverManager.createDriver(browserName, capabilities);
    }

    /**
     * Inject the recording script into the browser
     * 
     * @param driver WebDriver instance
     * @param sessionId Session ID
     */
    private void injectRecordingScript(WebDriver driver, String sessionId) {
        log.debug("Injecting recording script for session: {}", sessionId);
        
        try {
            // Read the recorder script content
            String scriptContent = readRecorderScript();
            
            // Get the server URL
            String wsUrl = getWebSocketUrl();
            
            // Prepare the initialization script
            String initScript = String.format(
                "window.CS_SMART_TEST = { sessionId: '%s', wsUrl: '%s' };", 
                sessionId, 
                wsUrl
            );
            
            // Execute initialization script
            JavascriptExecutor js = (JavascriptExecutor) driver;
            js.executeScript(initScript);
            
            // Inject the recorder script
            js.executeScript(scriptContent);
            
            log.debug("Recording script injected successfully for session: {}", sessionId);
        } catch (Exception e) {
            log.error("Failed to inject recording script for session: {}", sessionId, e);
            throw new RuntimeException("Failed to inject recording script: " + e.getMessage(), e);
        }
    }

    /**
     * Read the recorder script content from file
     * 
     * @return Recorder script content
     * @throws IOException if reading fails
     */
    private String readRecorderScript() throws IOException {
        return new String(Files.readAllBytes(Paths.get(recorderScriptPath)));
    }

    /**
     * Get the WebSocket URL for recorder connection
     * 
     * @return WebSocket URL
     */
    private String getWebSocketUrl() {
        // In production, this would be the server address
        return "ws://" + configManager.getServerHost() + ":" + configManager.getServerPort() + "/ws/recorder";
    }

    /**
     * Get a recording session by ID
     * 
     * @param sessionId Session ID
     * @return Recording session
     * @throws NotFoundException if session not found
     */
    private RecordingSession getSession(String sessionId) {
        RecordingSession session = activeSessions.get(sessionId);
        if (session == null) {
            log.error("Recording session not found: {}", sessionId);
            throw new NotFoundException("Recording session not found: " + sessionId);
        }
        return session;
    }
    
    /**
     * Check if a session is active
     * 
     * @param sessionId Session ID
     * @return true if active
     */
    public boolean isSessionActive(String sessionId) {
        RecordingSession session = activeSessions.get(sessionId);
        return session != null && "recording".equals(session.getStatus());
    }
    
    /**
     * Get a test by ID
     * 
     * @param id Test ID
     * @return Test script
     */
    public TestScript getTestById(String id) {
        return scriptRepository.findById(id);
    }
    
    /**
     * Update a test script
     * 
     * @param id Test ID
     * @param updates Updated test data
     * @return Updated test script
     */
    public TestScript updateTest(String id, TestScript updates) {
        TestScript existing = scriptRepository.findById(id);
        
        // Update fields
        existing.setName(updates.getName());
        existing.setDescription(updates.getDescription());
        existing.setPackageName(updates.getPackageName());
        existing.setClassName(updates.getClassName());
        existing.setTags(updates.getTags());
        existing.setBrowser(updates.getBrowser());
        existing.setCode(updates.getCode());
        
        // Save updates
        scriptRepository.save(existing);
        
        return existing;
    }
    
    /**
     * Delete a test script
     * 
     * @param id Test ID
     */
    public void deleteTest(String id) {
        scriptRepository.delete(id);
    }
}

/**
 * CS Smart Test Framework - Browser Recorder Script
 * This script is injected into the browser to capture user actions during recording.
 */
(function() {
    // Initialize recorder
    console.log('CS Smart Test Recorder initialized');
    
    // Configuration
    const config = {
        sessionId: window.CS_SMART_TEST.sessionId,
        wsUrl: window.CS_SMART_TEST.wsUrl,
        captureEvents: true,
        highlightElements: true,
        highlightColor: 'rgba(255, 0, 0, 0.3)'
    };
    
    // WebSocket connection
    let ws = null;
    
    // Keep track of the last element interacted with
    let lastElement = null;
    let lastAction = null;
    let lastActionTime = 0;
    
    // Action throttling (ms)
    const ACTION_THROTTLE = 500;
    
    // Initialize the recorder
    function initRecorder() {
        // Create the WebSocket connection
        connectWebSocket();
        
        // Add event listeners
        attachEventListeners();
        
        // Create recorder UI
        createRecorderUI();
        
        // Send heartbeat regularly
        startHeartbeat();
    }
    
    // Connect to WebSocket
    function connectWebSocket() {
        ws = new WebSocket(config.wsUrl);
        
        ws.onopen = function() {
            console.log('WebSocket connected');
            showToast('Recording started', 'success');
            sendHeartbeat();
        };
        
        ws.onclose = function() {
            console.log('WebSocket disconnected');
            showToast('Recording connection lost', 'error');
            
            // Try to reconnect after delay
            setTimeout(connectWebSocket, 3000);
        };
        
        ws.onerror = function(error) {
            console.error('WebSocket error:', error);
            showToast('Recording error', 'error');
        };
        
        ws.onmessage = function(event) {
            const message = JSON.parse(event.data);
            handleWebSocketMessage(message);
        };
    }
    
    // Handle incoming WebSocket messages
    function handleWebSocketMessage(message) {
        console.log('Received message:', message);
        
        switch (message.type) {
            case 'ACTION_RECORDED':
                // Action was recorded successfully
                break;
                
            case 'RECORDING_STOPPED':
                // Recording was stopped from server
                showToast('Recording stopped', 'info');
                break;
                
            case 'HEARTBEAT_ACK':
                // Heartbeat acknowledged
                break;
                
            case 'ERROR':
                showToast(message.payload.message, 'error');
                break;
                
            default:
                console.log('Unhandled message type:', message.type);
        }
    }
    
    // Send message to WebSocket server
    function sendMessage(type, payload) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: type,
                payload: payload
            }));
        } else {
            console.error('WebSocket not connected');
            showToast('Connection lost', 'error');
        }
    }
    
    // Attach event listeners to capture user actions
    function attachEventListeners() {
        // Click events
        document.addEventListener('click', function(event) {
            if (!config.captureEvents) return;
            
            const target = event.target;
            captureElement(target, 'CLICK');
        }, true);
        
        // Input events
        document.addEventListener('change', function(event) {
            if (!config.captureEvents) return;
            
            const target = event.target;
            
            if (target.tagName === 'INPUT') {
                const inputType = target.getAttribute('type') || 'text';
                
                if (inputType === 'checkbox' || inputType === 'radio') {
                    captureElement(target, target.checked ? 'CHECK' : 'UNCHECK');
                } else {
                    captureElement(target, 'TYPE', target.value);
                }
            } else if (target.tagName === 'SELECT') {
                captureElement(target, 'SELECT', target.value);
            } else if (target.tagName === 'TEXTAREA') {
                captureElement(target, 'TYPE', target.value);
            }
        }, true);
        
        // Form submit events
        document.addEventListener('submit', function(event) {
            if (!config.captureEvents) return;
            
            const target = event.target;
            captureElement(target, 'SUBMIT');
        }, true);
        
        // Navigation events
        window.addEventListener('hashchange', function() {
            recordNavigation(window.location.href);
        });
        
        // Record initial navigation
        recordNavigation(window.location.href);
    }
    
    // Record a navigation action
    function recordNavigation(url) {
        if (!config.captureEvents) return;
        
        const now = Date.now();
        if (now - lastActionTime < ACTION_THROTTLE) return;
        
        lastActionTime = now;
        lastAction = 'NAVIGATE';
        
        sendMessage('ACTION', {
            type: 'NAVIGATE',
            value: url
        });
    }
    
    // Capture element information and send action
    function captureElement(element, actionType, value) {
        // Skip if it's the same element and action within throttle time
        const now = Date.now();
        if (
            element === lastElement && 
            actionType === lastAction && 
            now - lastActionTime < ACTION_THROTTLE
        ) {
            return;
        }
        
        lastElement = element;
        lastAction = actionType;
        lastActionTime = now;
        
        // Highlight the element
        if (config.highlightElements) {
            highlightElement(element);
        }
        
        // Extract element information
        const elementInfo = extractElementInfo(element);
        
        // Create action
        const action = {
            type: actionType,
            element: elementInfo,
            value: value
        };
        
        // Send action to server
        sendMessage('ACTION', action);
    }
    
    // Extract element information
    function extractElementInfo(element) {
        if (!element) return null;
        
        // Get element attributes
        const attributes = {};
        Array.from(element.attributes).forEach(attr => {
            attributes[attr.name] = attr.value;
        });
        
        // Calculate XPath
        const xpath = getXPath(element);
        
        // Calculate CSS selector
        const cssSelector = getCssSelector(element);
        
        // Get element rect
        const rect = element.getBoundingClientRect();
        
        return {
            tagName: element.tagName.toLowerCase(),
            id: element.id || null,
            name: element.name || null,
            className: element.className || null,
            type: element.getAttribute('type') || null,
            value: getElementValue(element),
            innerText: element.innerText ? (element.innerText.length > 100 ? element.innerText.substring(0, 100) + '...' : element.innerText) : null,
            placeholder: element.placeholder || null,
            href: element.href || null,
            src: element.src || null,
            alt: element.alt || null,
            attributes: attributes,
            xpath: xpath,
            cssSelector: cssSelector,
            rect: {
                x: Math.round(rect.x),
                y: Math.round(rect.y),
                width: Math.round(rect.width),
                height: Math.round(rect.height)
            }
        };
    }
    
    // Get element value based on element type
    function getElementValue(element) {
        if (!element) return null;
        
        const tagName = element.tagName.toLowerCase();
        const type = element.getAttribute('type');
        
        // Input element
        if (tagName === 'input') {
            if (type === 'checkbox' || type === 'radio') {
                return element.checked ? 'true' : 'false';
            } else if (type === 'password') {
                return '********'; // Don't send actual passwords
            } else {
                return element.value || null;
            }
        }
        
        // Select element
        if (tagName === 'select') {
            return element.value || null;
        }
        
        // Textarea element
        if (tagName === 'textarea') {
            return element.value || null;
        }
        
        // Default
        return element.value || element.textContent || null;
    }
    
    // Generate XPath for element
    function getXPath(element) {
        if (!element) return null;
        
        let xpath = '';
        let current = element;
        
        while (current && current !== document) {
            let index = 0;
            let sibling = current;
            
            // Count preceding siblings with same tag
            while (sibling) {
                if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === current.tagName) {
                    index++;
                }
                sibling = sibling.previousSibling;
            }
            
            const tagName = current.tagName.toLowerCase();
            const pathIndex = index > 0 ? `[${index}]` : '';
            xpath = `/${tagName}${pathIndex}${xpath}`;
            
            current = current.parentNode;
        }
        
        return xpath;
    }
    
    // Generate CSS selector for element
    function getCssSelector(element) {
        if (!element) return null;
        
        // Start with the element
        let current = element;
        let selector = '';
        
        while (current && current !== document) {
            // Try ID first
            if (current.id) {
                return '#' + current.id + selector;
            }
            
            // Try classes
            if (current.className) {
                const classes = current.className.split(' ')
                    .filter(c => c && !c.startsWith('cs-smart-recorder'))
                    .map(c => '.' + c)
                    .join('');
                
                if (classes) {
                    // Check if this selector is unique
                    const testSelector = current.tagName.toLowerCase() + classes + selector;
                    if (document.querySelectorAll(testSelector).length === 1) {
                        return testSelector;
                    }
                    
                    selector = classes + selector;
                }
            }
            
            // Add tag name
            let index = 0;
            let sibling = current;
            
            // Count siblings with same tag
            while (sibling) {
                if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === current.tagName) {
                    index++;
                }
                sibling = sibling.previousSibling;
            }
            
            const pathIndex = index > 1 ? `:nth-of-type(${index})` : '';
            selector = '>' + current.tagName.toLowerCase() + pathIndex + selector;
            
            current = current.parentNode;
        }
        
        return selector.substring(1); // Remove leading '>'
    }
    
    // Highlight element temporarily
    function highlightElement(element) {
        if (!element) return;
        
        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'cs-smart-recorder-highlight';
        
        // Position overlay
        const rect = element.getBoundingClientRect();
        overlay.style.position = 'absolute';
        overlay.style.left = (rect.left + window.scrollX) + 'px';
        overlay.style.top = (rect.top + window.scrollY) + 'px';
        overlay.style.width = rect.width + 'px';
        overlay.style.height = rect.height + 'px';
        overlay.style.backgroundColor = config.highlightColor;
        overlay.style.zIndex = '999999';
        overlay.style.pointerEvents = 'none';
        
        // Add to document
        document.body.appendChild(overlay);
        
        // Remove after short delay
        setTimeout(() => {
            document.body.removeChild(overlay);
        }, 500);
    }
    
    // Create recorder UI
    function createRecorderUI() {
        // Create recorder badge
        const badge = document.createElement('div');
        badge.className = 'cs-smart-recorder-badge';
        badge.innerHTML = `
            <div class="cs-smart-recorder-badge-inner">
                <div class="cs-smart-recorder-badge-recording"></div>
                <div class="cs-smart-recorder-badge-text">Recording</div>
            </div>
        `;
        
        // Style badge
        badge.style.position = 'fixed';
        badge.style.bottom = '20px';
        badge.style.right = '20px';
        badge.style.padding = '10px 15px';
        badge.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        badge.style.color = 'white';
        badge.style.borderRadius = '50px';
        badge.style.fontFamily = 'Arial, sans-serif';
        badge.style.fontSize = '14px';
        badge.style.fontWeight = 'bold';
        badge.style.zIndex = '9999999';
        badge.style.display = 'flex';
        badge.style.alignItems = 'center';
        badge.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.3)';
        
        // Style recording indicator
        const recordingIndicator = badge.querySelector('.cs-smart-recorder-badge-recording');
        recordingIndicator.style.width = '10px';
        recordingIndicator.style.height = '10px';
        recordingIndicator.style.borderRadius = '50%';
        recordingIndicator.style.backgroundColor = 'red';
        recordingIndicator.style.marginRight = '8px';
        recordingIndicator.style.animation = 'cs-smart-recorder-pulse 1.5s infinite';
        
        // Add pulse animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes cs-smart-recorder-pulse {
                0% { opacity: 1; }
                50% { opacity: 0.5; }
                100% { opacity: 1; }
            }
            
            .cs-smart-recorder-toast {
                position: fixed;
                bottom: 80px;
                right: 20px;
                padding: 10px 15px;
                border-radius: 4px;
                color: white;
                font-family: Arial, sans-serif;
                font-size: 14px;
                z-index: 9999999;
                opacity: 0;
                transform: translateY(20px);
                transition: opacity 0.3s, transform 0.3s;
                max-width: 300px;
            }
            
            .cs-smart-recorder-toast.show {
                opacity: 1;
                transform: translateY(0);
            }
            
            .cs-smart-recorder-toast.success {
                background-color: #4caf50;
            }
            
            .cs-smart-recorder-toast.error {
                background-color: #f44336;
            }
            
            .cs-smart-recorder-toast.info {
                background-color: #2196f3;
            }
        `;
        
        // Add to document
        document.head.appendChild(style);
        document.body.appendChild(badge);
    }
    
    // Show a toast message
    function showToast(message, type = 'info') {
        // Create toast
        const toast = document.createElement('div');
        toast.className = `cs-smart-recorder-toast ${type}`;
        toast.textContent = message;
        
        // Add to document
        document.body.appendChild(toast);
        
        // Trigger animation
        setTimeout(() => {
            toast.classList.add('show');
        }, 10);
        
        // Remove after delay
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                document.body.removeChild(toast);
            }, 300);
        }, 3000);
    }
    
    // Send heartbeat to keep connection alive
    function sendHeartbeat() {
        sendMessage('HEARTBEAT', { timestamp: Date.now() });
    }
    
    // Start regular heartbeat
    function startHeartbeat() {
        setInterval(sendHeartbeat, 30000); // Every 30 seconds
    }
    
    // Initialize
    initRecorder();
})();


package com.cssmart.ui.controller;

import com.cssmart.ai.engine.model.TestScript;
import com.cssmart.config.ConfigurationManager;
import com.cssmart.ui.recorder.RecorderService;
import com.cssmart.ui.recorder.model.TestInfo;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * REST controller for test management
 * Handles CRUD operations for test scripts and execution
 */
@RestController
@RequestMapping("/api/tests")
@Slf4j
public class TestController {

    private final RecorderService recorderService;
    private final ConfigurationManager configManager;

    @Autowired
    public TestController(RecorderService recorderService, ConfigurationManager configManager) {
        this.recorderService = recorderService;
        this.configManager = configManager;
    }

    /**
     * Get all tests
     * @return List of tests
     */
    @GetMapping
    public ResponseEntity<List<TestInfo>> getAllTests() {
        log.info("Getting all tests");
        List<TestInfo> tests = recorderService.getSavedTests();
        return ResponseEntity.ok(tests);
    }

    /**
     * Get a test by ID
     * @param id Test ID
     * @return Test script
     */
    @GetMapping("/{id}")
    public ResponseEntity<TestScript> getTestById(@PathVariable String id) {
        log.info("Getting test by ID: {}", id);
        TestScript test = recorderService.getTestById(id);
        return ResponseEntity.ok(test);
    }

    /**
     * Update a test
     * @param id Test ID
     * @param test Updated test script
     * @return Updated test script
     */
    @PutMapping("/{id}")
    public ResponseEntity<TestScript> updateTest(@PathVariable String id, @RequestBody TestScript test) {
        log.info("Updating test with ID: {}", id);
        TestScript updated = recorderService.updateTest(id, test);
        return ResponseEntity.ok(updated);
    }

    /**
     * Delete a test
     * @param id Test ID
     * @return Success message
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Map<String, String>> deleteTest(@PathVariable String id) {
        log.info("Deleting test with ID: {}", id);
        recorderService.deleteTest(id);
        
        Map<String, String> response = new HashMap<>();
        response.put("message", "Test deleted successfully");
        response.put("id", id);
        
        return ResponseEntity.ok(response);
    }

    /**
     * Run a test
     * @param id Test ID
     * @return Execution result
     */
    @PostMapping("/{id}/run")
    public ResponseEntity<Map<String, Object>> runTest(@PathVariable String id) {
        log.info("Running test with ID: {}", id);
        
        // In a real implementation, this would execute the test
        // For now, return a mock result
        
        Map<String, Object> result = new HashMap<>();
        result.put("id", id);
        result.put("status", "completed");
        result.put("result", "passed");
        result.put("startTime", System.currentTimeMillis() - 10000);
        result.put("endTime", System.currentTimeMillis());
        result.put("duration", 10.0);
        
        return ResponseEntity.ok(result);
    }
}

package com.cssmart.ui.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDate;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;

/**
 * REST controller for dashboard data
 */
@RestController
@RequestMapping("/api/dashboard")
@Slf4j
public class DashboardController {

    /**
     * Get dashboard data
     * @return Dashboard metrics and stats
     */
    @GetMapping
    public ResponseEntity<Map<String, Object>> getDashboardData() {
        log.info("Getting dashboard data");
        
        // In a real implementation, this would fetch real metrics from a database
        // For now, return mock data
        
        Map<String, Object> dashboardData = new HashMap<>();
        
        // Basic metrics
        dashboardData.put("testCount", 24);
        dashboardData.put("successRate", 87);
        dashboardData.put("avgDuration", 12.5);
        
        // Test status distribution
        Map<String, Integer> testStatus = new HashMap<>();
        testStatus.put("passed", 18);
        testStatus.put("failed", 4);
        testStatus.put("skipped", 2);
        dashboardData.put("testStatus", testStatus);
        
        // Execution history (last 7 days)
        List<Map<String, Object>> executionHistory = generateExecutionHistory();
        dashboardData.put("executionHistory", executionHistory);
        
        // Recent tests
        List<Map<String, Object>> recentTests = generateRecentTests();
        dashboardData.put("recentTests", recentTests);
        
        return ResponseEntity.ok(dashboardData);
    }
    
    /**
     * Generate test execution history for the last 7 days
     * @return List of daily execution statistics
     */
    private List<Map<String, Object>> generateExecutionHistory() {
        List<Map<String, Object>> history = new ArrayList<>();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        
        // Generate data for the last 7 days
        LocalDate today = LocalDate.now();
        Random random = new Random();
        
        for (int i = 6; i >= 0; i--) {
            LocalDate date = today.minusDays(i);
            int passed = 10 + random.nextInt(10);
            int failed = random.nextInt(5);
            int skipped = random.nextInt(3);
            
            Map<String, Object> dayData = new HashMap<>();
            dayData.put("date", date.format(formatter));
            dayData.put("passed", passed);
            dayData.put("failed", failed);
            dayData.put("skipped", skipped);
            
            history.add(dayData);
        }
        
        return history;
    }
    
    /**
     * Generate recent test executions
     * @return List of recent test executions
     */
    private List<Map<String, Object>> generateRecentTests() {
        List<Map<String, Object>> recentTests = new ArrayList<>();
        Random random = new Random();
        LocalDate today = LocalDate.now();
        
        // Sample test names
        String[] testNames = {
            "Login Test",
            "Shopping Cart Test",
            "Product Search Test",
            "Checkout Process Test",
            "User Registration Test"
        };
        
        // Sample statuses with weights
        String[] statuses = {"Passed", "Failed", "Skipped"};
        int[] statusWeights = {70, 20, 10}; // 70% passed, 20% failed, 10% skipped
        
        for (int i = 0; i < 5; i++) {
            Map<String, Object> test = new HashMap<>();
            
            test.put("id", UUID.randomUUID().toString());
            test.put("name", testNames[i]);
            
            // Weighted random status
            int statusRoll = random.nextInt(100);
            int statusIndex = 0;
            int cumulativeWeight = 0;
            
            for (int j = 0; j < statusWeights.length; j++) {
                cumulativeWeight += statusWeights[j];
                if (statusRoll < cumulativeWeight) {
                    statusIndex = j;
                    break;
                }
            }
            
            String status = statuses[statusIndex];
            test.put("status", status);
            
            // Duration (skipped tests have 0 duration)
            double duration = "Skipped".equals(status) ? 0 : 5 + random.nextDouble() * 15;
            duration = Math.round(duration * 10) / 10.0; // Round to 1 decimal place
            test.put("duration", duration);
            
            // Last run time (within last 24 hours)
            long lastRunMillis = System.currentTimeMillis() - random.nextInt(24 * 60 * 60 * 1000);
            test.put("lastRun", new Date(lastRunMillis).toInstant().toString());
            
            recentTests.add(test);
        }
        
        return recentTests;
    }
}


package com.cssmart.ui.controller;

import com.cssmart.config.ConfigurationManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

/**
 * REST controller for framework settings
 */
@RestController
@RequestMapping("/api/settings")
@Slf4j
public class SettingsController {

    private final ConfigurationManager configManager;

    @Autowired
    public SettingsController(ConfigurationManager configManager) {
        this.configManager = configManager;
    }

    /**
     * Get all settings
     * @return Framework settings
     */
    @GetMapping
    public ResponseEntity<Map<String, Object>> getSettings() {
        log.info("Getting framework settings");
        
        Map<String, Object> settings = new HashMap<>();
        
        // General settings
        Map<String, Object> general = new HashMap<>();
        general.put("environment", configManager.getEnvironment());
        general.put("baseUrl", configManager.getBaseUrl());
        settings.put("general", general);
        
        // Browser settings
        Map<String, Object> browser = new HashMap<>();
        browser.put("default", configManager.getDefaultBrowser());
        browser.put("width", configManager.getBrowserWidth());
        browser.put("height", configManager.getBrowserHeight());
        browser.put("maximize", configManager.isMaximizeBrowser());
        settings.put("browser", browser);
        
        // Timeout settings
        Map<String, Object> timeouts = new HashMap<>();
        timeouts.put("implicit", configManager.getImplicitWaitSeconds());
        timeouts.put("explicit", configManager.getExplicitWaitSeconds());
        timeouts.put("pageLoad", configManager.getPageLoadTimeoutSeconds());
        timeouts.put("script", configManager.getScriptTimeoutSeconds());
        settings.put("timeouts", timeouts);
        
        // Reporting settings
        Map<String, Object> reporting = new HashMap<>();
        Map<String, Object> screenshots = new HashMap<>();
        screenshots.put("onFailure", configManager.isTakeScreenshotOnFailure());
        screenshots.put("onStep", configManager.isTakeScreenshotOnStep());
        reporting.put("screenshots", screenshots);
        reporting.put("outputDir", configManager.getReportOutputDir());
        settings.put("reporting", reporting);
        
        // AI settings
        Map<String, Object> ai = new HashMap<>();
        ai.put("confidenceThreshold", configManager.getAiConfidenceThreshold());
        ai.put("selfHealing", configManager.isAiSelfHealingEnabled());
        ai.put("generateAssertions", configManager.isAiGenerateAssertions());
        settings.put("ai", ai);
        
        return ResponseEntity.ok(settings);
    }

    /**
     * Update settings
     * @param settings Updated settings
     * @return Updated settings
     */
    @PutMapping
    public ResponseEntity<Map<String, Object>> updateSettings(@RequestBody Map<String, Object> settings) {
        log.info("Updating framework settings");
        
        try {
            // Update general settings
            if (settings.containsKey("general")) {
                Map<String, Object> general = (Map<String, Object>) settings.get("general");
                if (general.containsKey("environment")) {
                    configManager.setEnvironment((String) general.get("environment"));
                }
                if (general.containsKey("baseUrl")) {
                    configManager.setBaseUrl((String) general.get("baseUrl"));
                }
            }
            
            // Update browser settings
            if (settings.containsKey("browser")) {
                Map<String, Object> browser = (Map<String, Object>) settings.get("browser");
                if (browser.containsKey("default")) {
                    configManager.setDefaultBrowser((String) browser.get("default"));
                }
                if (browser.containsKey("width")) {
                    configManager.setBrowserWidth(((Number) browser.get("width")).intValue());
                }
                if (browser.containsKey("height")) {
                    configManager.setBrowserHeight(((Number) browser.get("height")).intValue());
                }
                if (browser.containsKey("maximize")) {
                    configManager.setMaximizeBrowser((Boolean) browser.get("maximize"));
                }
            }
            
            // Update timeout settings
            if (settings.containsKey("timeouts")) {
                Map<String, Object> timeouts = (Map<String, Object>) settings.get("timeouts");
                if (timeouts.containsKey("implicit")) {
                    configManager.setImplicitWaitSeconds(((Number) timeouts.get("implicit")).intValue());
                }
                if (timeouts.containsKey("explicit")) {
                    configManager.setExplicitWaitSeconds(((Number) timeouts.get("explicit")).intValue());
                }
                if (timeouts.containsKey("pageLoad")) {
                    configManager.setPageLoadTimeoutSeconds(((Number) timeouts.get("pageLoad")).intValue());
                }
                if (timeouts.containsKey("script")) {
                    configManager.setScriptTimeoutSeconds(((Number) timeouts.get("script")).intValue());
                }
            }
            
            // Update reporting settings
            if (settings.containsKey("reporting")) {
                Map<String, Object> reporting = (Map<String, Object>) settings.get("reporting");
                
                if (reporting.containsKey("screenshots")) {
                    Map<String, Object> screenshots = (Map<String, Object>) reporting.get("screenshots");
                    if (screenshots.containsKey("onFailure")) {
                        configManager.setTakeScreenshotOnFailure((Boolean) screenshots.get("onFailure"));
                    }
                    if (screenshots.containsKey("onStep")) {
                        configManager.setTakeScreenshotOnStep((Boolean) screenshots.get("onStep"));
                    }
                }
                
                if (reporting.containsKey("outputDir")) {
                    configManager.setReportOutputDir((String) reporting.get("outputDir"));
                }
            }
            
            // Update AI settings
            if (settings.containsKey("ai")) {
                Map<String, Object> ai = (Map<String, Object>) settings.get("ai");
                if (ai.containsKey("confidenceThreshold")) {
                    configManager.setAiConfidenceThreshold(((Number) ai.get("confidenceThreshold")).doubleValue());
                }
                if (ai.containsKey("selfHealing")) {
                    configManager.setAiSelfHealingEnabled((Boolean) ai.get("selfHealing"));
                }
                if (ai.containsKey("generateAssertions")) {
                    configManager.setAiGenerateAssertions((Boolean) ai.get("generateAssertions"));
                }
            }
            
            // Save configuration
            configManager.saveConfiguration();
            
            // Return updated settings
            return getSettings();
        } catch (Exception e) {
            log.error("Error updating settings", e);
            throw new RuntimeException("Failed to update settings: " + e.getMessage());
        }
    }
}


package com.cssmart.config;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.yaml.snakeyaml.Yaml;

import java.io.*;
import java.util.HashMap;
import java.util.Map;

/**
 * Singleton class for managing framework configuration
 */
@Slf4j
public class ConfigurationManager {
    private static final String DEFAULT_CONFIG_PATH = "src/main/resources/cssmart.yml";
    private static ConfigurationManager instance;
    
    // General settings
    @Getter @Setter private String environment = "dev";
    @Getter @Setter private String baseUrl = "https://example.com";
    @Getter @Setter private String serverHost = "localhost";
    @Getter @Setter private int serverPort = 8080;
    
    // Browser settings
    @Getter @Setter private String defaultBrowser = "chrome";
    @Getter @Setter private int browserWidth = 1920;
    @Getter @Setter private int browserHeight = 1080;
    @Getter @Setter private boolean maximizeBrowser = true;
    @Getter @Setter private Map<String, Map<String, Object>> browserCapabilities = new HashMap<>();
    
    // Timeout settings
    @Getter @Setter private int implicitWaitSeconds = 5;
    @Getter @Setter private int explicitWaitSeconds = 10;
    @Getter @Setter private int pageLoadTimeoutSeconds = 30;
    @Getter @Setter private int scriptTimeoutSeconds = 30;
    
    // Reporting settings
    @Getter @Setter private boolean takeScreenshotOnFailure = true;
    @Getter @Setter private boolean takeScreenshotOnStep = false;
    @Getter @Setter private String reportOutputDir = "target/cssmart-reports";
    
    // Test execution settings
    @Getter @Setter private boolean keepBrowserOpenBetweenTests = false;
    @Getter @Setter private boolean parallelExecution = false;
    @Getter @Setter private int maxThreads = 5;
    
    // AI settings
    @Getter @Setter private double aiConfidenceThreshold = 0.75;
    @Getter @Setter private boolean aiSelfHealingEnabled = true;
    @Getter @Setter private boolean aiGenerateAssertions = true;
    
    // File paths
    private String configFilePath;
    
    /**
     * Private constructor for singleton pattern
     */
    private ConfigurationManager() {
        this.configFilePath = DEFAULT_CONFIG_PATH;
        loadConfiguration();
    }
    
    /**
     * Private constructor with custom config path
     * @param configFilePath Path to configuration file
     */
    private ConfigurationManager(String configFilePath) {
        this.configFilePath = configFilePath;
        loadConfiguration();
    }
    
    /**
     * Get singleton instance with default config path
     * @return ConfigurationManager instance
     */
    public static synchronized ConfigurationManager getInstance() {
        if (instance == null) {
            instance = new ConfigurationManager();
        }
        return instance;
    }
    
    /**
     * Get singleton instance with custom config path
     * @param configFilePath Path to configuration file
     * @return ConfigurationManager instance
     */
    public static synchronized ConfigurationManager getInstance(String configFilePath) {
        if (instance == null) {
            instance = new ConfigurationManager(configFilePath);
        }
        return instance;
    }
    
    /**
     * Load configuration from file
     */
    @SuppressWarnings("unchecked")
    public void loadConfiguration() {
        log.info("Loading configuration from: {}", configFilePath);
        
        File configFile = new File(configFilePath);
        
        if (!configFile.exists()) {
            log.warn("Configuration file not found: {}. Using default configuration.", configFilePath);
            return;
        }
        
        try (InputStream input = new FileInputStream(configFile)) {
            Yaml yaml = new Yaml();
            Map<String, Object> config = yaml.load(input);
            
            if (config == null) {
                log.warn("Empty configuration file: {}", configFilePath);
                return;
            }
            
            // Load general settings
            if (config.containsKey("environment")) {
                environment = (String) config.get("environment");
            }
            
            if (config.containsKey("baseUrl")) {
                baseUrl = (String) config.get("baseUrl");
            }
            
            if (config.containsKey("server")) {
                Map<String, Object> server = (Map<String, Object>) config.get("server");
                if (server.containsKey("host")) {
                    serverHost = (String) server.get("host");
                }
                if (server.containsKey("port")) {
                    serverPort = ((Number) server.get("port")).intValue();
                }
            }
            
            // Load browser settings
            if (config.containsKey("browser")) {
                Map<String, Object> browser = (Map<String, Object>) config.get("browser");
                
                if (browser.containsKey("default")) {
                    defaultBrowser = (String) browser.get("default");
                }
                
                if (browser.containsKey("width")) {
                    browserWidth = ((Number) browser.get("width")).intValue();
                }
                
                if (browser.containsKey("height")) {
                    browserHeight = ((Number) browser.get("height")).intValue();
                }
                
                if (browser.containsKey("maximize")) {
                    maximizeBrowser = (Boolean) browser.get("maximize");
                }
                
                if (browser.containsKey("capabilities")) {
                    browserCapabilities = (Map<String, Map<String, Object>>) browser.get("capabilities");
                }
            }
            
            // Load timeout settings
            if (config.containsKey("timeouts")) {
                Map<String, Object> timeouts = (Map<String, Object>) config.get("timeouts");
                
                if (timeouts.containsKey("implicit")) {
                    implicitWaitSeconds = ((Number) timeouts.get("implicit")).intValue();
                }
                
                if (timeouts.containsKey("explicit")) {
                    explicitWaitSeconds = ((Number) timeouts.get("explicit")).intValue();
                }
                
                if (timeouts.containsKey("pageLoad")) {
                    pageLoadTimeoutSeconds = ((Number) timeouts.get("pageLoad")).intValue();
                }
                
                if (timeouts.containsKey("script")) {
                    scriptTimeoutSeconds = ((Number) timeouts.get("script")).intValue();
                }
            }
            
            // Load reporting settings
            if (config.containsKey("reporting")) {
                Map<String, Object> reporting = (Map<String, Object>) config.get("reporting");
                
                if (reporting.containsKey("screenshots")) {
                    Map<String, Object> screenshots = (Map<String, Object>) reporting.get("screenshots");
                    
                    if (screenshots.containsKey("onFailure")) {
                        takeScreenshotOnFailure = (Boolean) screenshots.get("onFailure");
                    }
                    
                    if (screenshots.containsKey("onStep")) {
                        takeScreenshotOnStep = (Boolean) screenshots.get("onStep");
                    }
                }
                
                if (reporting.containsKey("outputDir")) {
                    reportOutputDir = (String) reporting.get("outputDir");
                }
            }
            
            // Load test execution settings
            if (config.containsKey("execution")) {
                Map<String, Object> execution = (Map<String, Object>) config.get("execution");
                
                if (execution.containsKey("keepBrowserOpen")) {
                    keepBrowserOpenBetweenTests = (Boolean) execution.get("keepBrowserOpen");
                }
                
                if (execution.containsKey("parallel")) {
                    parallelExecution = (Boolean) execution.get("parallel");
                }
                
                if (execution.containsKey("maxThreads")) {
                    maxThreads = ((Number) execution.get("maxThreads")).intValue();
                }
            }
            
            // Load AI settings
            if (config.containsKey("ai")) {
                Map<String, Object> ai = (Map<String, Object>) config.get("ai");
                
                if (ai.containsKey("confidenceThreshold")) {
                    aiConfidenceThreshold = ((Number) ai.get("confidenceThreshold")).doubleValue();
                }
                
                if (ai.containsKey("selfHealing")) {
                    aiSelfHealingEnabled = (Boolean) ai.get("selfHealing");
                }
                
                if (ai.containsKey("generateAssertions")) {
                    aiGenerateAssertions = (Boolean) ai.get("generateAssertions");
                }
            }
            
            log.info("Configuration loaded successfully");
        } catch (IOException e) {
            log.error("Error loading configuration", e);
        }
    }
    
    /**
     * Save configuration to file
     */
    @SuppressWarnings("unchecked")
    public void saveConfiguration() {
        log.info("Saving configuration to: {}", configFilePath);
        
        File configFile = new File(configFilePath);
        
        // Create parent directories if they don't exist
        if (!configFile.getParentFile().exists()) {
            configFile.getParentFile().mkdirs();
        }
        
        try (FileWriter writer = new FileWriter(configFile)) {
            // Build configuration map
            Map<String, Object> config = new HashMap<>();
            
            // General settings
            config.put("environment", environment);
            config.put("baseUrl", baseUrl);
            
            Map<String, Object> server = new HashMap<>();
            server.put("host", serverHost);
            server.put("port", serverPort);
            config.put("server", server);
            
            // Browser settings
            Map<String, Object> browser = new HashMap<>();
            browser.put("default", defaultBrowser);
            browser.put("width", browserWidth);
            browser.put("height", browserHeight);
            browser.put("maximize", maximizeBrowser);
            browser.put("capabilities", browserCapabilities);
            config.put("browser", browser);
            
            // Timeout settings
            Map<String, Object> timeouts = new HashMap<>();
            timeouts.put("implicit", implicitWaitSeconds);
            timeouts.put("explicit", explicitWaitSeconds);
            timeouts.put("pageLoad", pageLoadTimeoutSeconds);
            timeouts.put("script", scriptTimeoutSeconds);
            config.put("timeouts", timeouts);
            
            // Reporting settings
            Map<String, Object> reporting = new HashMap<>();
            Map<String, Object> screenshots = new HashMap<>();
            screenshots.put("onFailure", takeScreenshotOnFailure);
            screenshots.put("onStep", takeScreenshotOnStep);
            reporting.put("screenshots", screenshots);
            reporting.put("outputDir", reportOutputDir);
            config.put("reporting", reporting);
            
            // Test execution settings
            Map<String, Object> execution = new HashMap<>();
            execution.put("keepBrowserOpen", keepBrowserOpenBetweenTests);
            execution.put("parallel", parallelExecution);
            execution.put("maxThreads", maxThreads);
            config.put("execution", execution);
            
            // AI settings
            Map<String, Object> ai = new HashMap<>();
            ai.put("confidenceThreshold", aiConfidenceThreshold);
            ai.put("selfHealing", aiSelfHealingEnabled);
            ai.put("generateAssertions", aiGenerateAssertions);
            config.put("ai", ai);
            
            // Write to file
            Yaml yaml = new Yaml();
            yaml.dump(config, writer);
            
            log.info("Configuration saved successfully");
        } catch (IOException e) {
            log.error("Error saving configuration", e);
        }
    }
    
    /**
     * Get browser capabilities
     * @param browserName Browser name
     * @return Map of capabilities
     */
    public Map<String, Object> getBrowserCapabilities(String browserName) {
        return browserCapabilities.getOrDefault(browserName, new HashMap<>());
    }
    
    /**
     * Set browser capabilities
     * @param browserName Browser name
     * @param capabilities Map of capabilities
     */
    public void setBrowserCapabilities(String browserName, Map<String, Object> capabilities) {
        browserCapabilities.put(browserName, capabilities);
    }
    
    /**
     * Add/update a browser capability
     * @param browserName Browser name
     * @param key Capability key
     * @param value Capability value
     */
    public void setBrowserCapability(String browserName, String key, Object value) {
        browserCapabilities.computeIfAbsent(browserName, k -> new HashMap<>()).put(key, value);
    }
}


package com.cssmart;

import com.cssmart.config.ConfigurationManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import javax.annotation.PostConstruct;
import java.io.File;

/**
 * Main application class for CS Smart Test Framework
 */
@SpringBootApplication
@Slf4j
public class CSSmartTestApplication {

    /**
     * Main method to start the application
     * @param args Command line arguments
     */
    public static void main(String[] args) {
        SpringApplication.run(CSSmartTestApplication.class, args);
    }

    /**
     * Initialize the application
     */
    @PostConstruct
    public void init() {
        log.info("Initializing CS Smart Test Framework");
        
        // Initialize configuration
        ConfigurationManager configManager = ConfigurationManager.getInstance();
        
        // Create required directories
        createDirectories(configManager.getReportOutputDir());
        
        log.info("CS Smart Test Framework initialized successfully");
    }

    /**
     * Create directories if they don't exist
     * @param path Directory path
     */
    private void createDirectories(String path) {
        File dir = new File(path);
        if (!dir.exists()) {
            boolean created = dir.mkdirs();
            if (created) {
                log.info("Created directory: {}", path);
            } else {
                log.warn("Failed to create directory: {}", path);
            }
        }
    }

    /**
     * Configure CORS for development
     * In production, this should be restricted
     * @return WebMvcConfigurer
     */
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**")
                        .allowedOrigins("*")
                        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                        .allowedHeaders("*");
            }
        };
    }
}

package com.cssmart.config;

import com.cssmart.ai.engine.AIEngine;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * Spring configuration for CS Smart Test Framework
 */
@Configuration
public class AppConfig implements WebMvcConfigurer {

    /**
     * Create ConfigurationManager bean
     * @return ConfigurationManager instance
     */
    @Bean
    public ConfigurationManager configurationManager() {
        return ConfigurationManager.getInstance();
    }
    
    /**
     * Create AIEngine bean
     * @return AIEngine instance
     */
    @Bean
    public AIEngine aiEngine() {
        return AIEngine.getInstance();
    }
    
    /**
     * Create ObjectMapper bean
     * @return ObjectMapper instance
     */
    @Bean
    public ObjectMapper objectMapper() {
        return new ObjectMapper();
    }
    
    /**
     * Configure static resource handling
     * @param registry ResourceHandlerRegistry
     */
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // Handle static resources from the webapp build
        registry.addResourceHandler("/**")
                .addResourceLocations("classpath:/static/");
                
        // Handle report resources
        registry.addResourceHandler("/reports/**")
                .addResourceLocations("file:" + configurationManager().getReportOutputDir() + "/");
    }
    
    /**
     * Configure view controllers for SPA
     * @param registry ViewControllerRegistry
     */
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        // Forward requests to the index.html for the React SPA
        registry.addViewController("/").setViewName("forward:/index.html");
        registry.addViewController("/{x:[\\w\\-]+}").setViewName("forward:/index.html");
        registry.addViewController("/{x:^(?!api$).*$}/**/{y:[\\w\\-]+}").setViewName("forward:/index.html");
    }
}


// src/main/webapp/src/services/recorderService.js

/**
 * Service for interacting with the test recorder API
 */
export const startRecording = async (config) => {
  try {
    const response = await fetch('/api/recorder/start', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(config),
    });

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error starting recording:', error);
    throw error;
  }
};

export const stopRecording = async (sessionId) => {
  try {
    const response = await fetch(`/api/recorder/stop/${sessionId}`, {
      method: 'POST',
    });

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error stopping recording:', error);
    throw error;
  }
};

export const saveRecording = async (saveRequest) => {
  try {
    const response = await fetch('/api/recorder/save', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(saveRequest),
    });

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error saving recording:', error);
    throw error;
  }
};

export const getRecordedActions = async (sessionId) => {
  try {
    const response = await fetch(`/api/recorder/actions/${sessionId}`);

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error getting recorded actions:', error);
    throw error;
  }
};

export const generateTestScript = async (sessionId) => {
  try {
    const response = await fetch(`/api/recorder/generate/${sessionId}`);

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error generating test script:', error);
    throw error;
  }
};

// src/main/webapp/src/services/testService.js

/**
 * Service for interacting with the test management API
 */
export const fetchTests = async () => {
  try {
    // Updated to match our backend endpoint
    const response = await fetch('/api/tests');

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error fetching tests:', error);
    throw error;
  }
};

export const fetchTestById = async (id) => {
  try {
    const response = await fetch(`/api/tests/${id}`);

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error(`Error fetching test ${id}:`, error);
    throw error;
  }
};

export const updateTest = async (id, testData) => {
  try {
    const response = await fetch(`/api/tests/${id}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(testData),
    });

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error(`Error updating test ${id}:`, error);
    throw error;
  }
};

export const deleteTest = async (id) => {
  try {
    const response = await fetch(`/api/tests/${id}`, {
      method: 'DELETE',
    });

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return true;
  } catch (error) {
    console.error(`Error deleting test ${id}:`, error);
    throw error;
  }
};

export const runTest = async (id) => {
  try {
    const response = await fetch(`/api/tests/${id}/run`, {
      method: 'POST',
    });

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error(`Error running test ${id}:`, error);
    throw error;
  }
};

// src/main/webapp/src/services/dashboardService.js

/**
 * Service for interacting with the dashboard API
 */
export const fetchDashboardData = async () => {
  try {
    const response = await fetch('/api/dashboard');

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error fetching dashboard data:', error);
    throw error;
  }
};

// src/main/webapp/src/services/settingsService.js

/**
 * Service for interacting with the settings API
 */
export const fetchSettings = async () => {
  try {
    const response = await fetch('/api/settings');

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error fetching settings:', error);
    throw error;
  }
};

export const updateSettings = async (settings) => {
  try {
    const response = await fetch('/api/settings', {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(settings),
    });

    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error updating settings:', error);
    throw error;
  }
};


// src/main/webapp/src/components/Recorder.js
import React, { useState, useEffect, useRef } from 'react';
import { toast } from 'react-toastify';
import { FaPlay, FaStop, FaCode, FaSave, FaCog } from 'react-icons/fa';
import RecorderSettings from './RecorderSettings';
import { getRecordedActions, saveRecording } from '../services/recorderService';

/**
 * Test Recorder component for recording browser interactions
 */
const Recorder = () => {
  const [isRecording, setIsRecording] = useState(false);
  const [recordingSessionId, setRecordingSessionId] = useState(null);
  const [recordedActions, setRecordedActions] = useState([]);
  const [generatedCode, setGeneratedCode] = useState('');
  const [showSettings, setShowSettings] = useState(false);
  const [settings, setSettings] = useState({
    url: 'https://www.example.com',
    browser: 'chrome',
    viewport: { width: 1366, height: 768 }
  });
  const websocketRef = useRef(null);
  const actionsPollingRef = useRef(null);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      // Close WebSocket if open
      if (websocketRef.current && websocketRef.current.readyState === WebSocket.OPEN) {
        websocketRef.current.close();
      }
      
      // Clear polling interval
      if (actionsPollingRef.current) {
        clearInterval(actionsPollingRef.current);
      }
    };
  }, []);

  // Initialize websocket connection
  const setupWebSocket = () => {
    // Determine WebSocket URL based on current window location
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/recorder`;
    
    // Create WebSocket connection
    const ws = new WebSocket(wsUrl);
    
    ws.onopen = () => {
      console.log('WebSocket connection established');
    };
    
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      handleWebSocketMessage(message);
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      toast.error('WebSocket connection error');
    };
    
    ws.onclose = () => {
      console.log('WebSocket connection closed');
      if (isRecording) {
        toast.warning('Recording connection lost. Recording stopped.');
        setIsRecording(false);
      }
    };
    
    websocketRef.current = ws;
  };
  
  // Handle incoming WebSocket messages
  const handleWebSocketMessage = (message) => {
    console.log('Received message:', message);
    
    switch (message.type) {
      case 'RECORDING_STARTED':
        toast.success('Recording started');
        setRecordingSessionId(message.payload.recordingId);
        setIsRecording(true);
        
        // Start polling for actions
        startActionsPolling(message.payload.recordingId);
        break;
        
      case 'RECORDING_STOPPED':
        toast.success('Recording stopped');
        setIsRecording(false);
        setGeneratedCode(message.payload.testScript.code);
        
        // Stop polling for actions
        if (actionsPollingRef.current) {
          clearInterval(actionsPollingRef.current);
        }
        break;
        
      case 'ACTION_RECORDED':
        // Just trigger a refresh of actions
        fetchRecordedActions(message.payload.recordingId);
        break;
        
      case 'ERROR':
        toast.error(message.payload.message);
        break;
        
      default:
        console.log('Unhandled message type:', message.type);
    }
  };
  
  // Send message to WebSocket server
  const sendWebSocketMessage = (type, payload) => {
    if (websocketRef.current?.readyState === WebSocket.OPEN) {
      websocketRef.current.send(JSON.stringify({
        type: type,
        payload: payload
      }));
    } else {
      console.error('WebSocket not connected');
      toast.error('Connection to server lost');
      
      // Try to reconnect
      setupWebSocket();
    }
  };
  
  // Start polling for actions at regular intervals
  const startActionsPolling = (sessionId) => {
    // Initial fetch
    fetchRecordedActions(sessionId);
    
    // Setup polling interval (every 2 seconds)
    actionsPollingRef.current = setInterval(() => {
      fetchRecordedActions(sessionId);
    }, 2000);
  };
  
  // Fetch recorded actions from the server
  const fetchRecordedActions = async (sessionId) => {
    try {
      const actions = await getRecordedActions(sessionId);
      setRecordedActions(actions);
    } catch (error) {
      console.error('Error fetching actions:', error);
    }
  };
  
  // Start recording
  const handleStartRecording = () => {
    // Close existing WebSocket if any
    if (websocketRef.current) {
      websocketRef.current.close();
    }
    
    // Setup new WebSocket
    setupWebSocket();
    
    // Give WebSocket time to connect
    setTimeout(() => {
      // Send start recording message
      sendWebSocketMessage('START_RECORDING', settings);
    }, 500);
  };
  
  // Stop recording
  const handleStopRecording = () => {
    if (recordingSessionId) {
      sendWebSocketMessage('STOP_RECORDING', { sessionId: recordingSessionId });
    } else {
      toast.error('No active recording session');
    }
  };
  
  // Save the recorded test
  const handleSaveTest = async () => {
    try {
      const testName = prompt('Enter a name for this test:');
      if (!testName) return;
      
      const saveRequest = {
        sessionId: recordingSessionId,
        testName: testName,
        description: `Test recorded on ${new Date().toLocaleDateString()}`,
        packageName: 'com.cssmart.generated',
        className: testName.replace(/[^a-zA-Z0-9]/g, '') + 'Test',
        testMethod: 'test' + testName.replace(/[^a-zA-Z0-9]/g, ''),
        tags: ['generated', 'recorder'],
        browser: settings.browser,
        code: generatedCode
      };
      
      const response = await saveRecording(saveRequest);
      toast.success('Test saved successfully');
    } catch (error) {
      console.error('Error saving test:', error);
      toast.error('Failed to save test');
    }
  };
  
  // Toggle settings panel
  const toggleSettings = () => {
    setShowSettings(!showSettings);
  };
  
  // Update settings
  const updateSettings = (newSettings) => {
    setSettings(newSettings);
    setShowSettings(false);
  };

  return (
    <div className="recorder-container">
      <div className="recorder-header">
        <h1>Test Recorder</h1>
        <div className="recorder-controls">
          <button 
            className="control-button settings"
            onClick={toggleSettings}
          >
            <FaCog />
            <span>Settings</span>
          </button>
          
          {!isRecording ? (
            <button 
              className="control-button start"
              onClick={handleStartRecording}
            >
              <FaPlay />
              <span>Start Recording</span>
            </button>
          ) : (
            <button 
              className="control-button stop"
              onClick={handleStopRecording}
            >
              <FaStop />
              <span>Stop Recording</span>
            </button>
          )}
          
          {generatedCode && (
            <button 
              className="control-button save"
              onClick={handleSaveTest}
            >
              <FaSave />
              <span>Save Test</span>
            </button>
          )}
        </div>
      </div>
      
      {showSettings && (
        <RecorderSettings 
          settings={settings} 
          onSave={updateSettings} 
          onCancel={() => setShowSettings(false)} 
        />
      )}
      
      <div className="recorder-content">
        <div className="recorded-actions-panel">
          <h2>Recorded Actions</h2>
          {recordedActions.length === 0 ? (
            <div className="no-actions">
              {isRecording ? 'Waiting for actions...' : 'No actions recorded yet'}
            </div>
          ) : (
            <ul className="actions-list">
              {recordedActions.map((action, index) => (
                <li key={action.id || index} className="action-item">
                  <div className="action-type">{action.actionType}</div>
                  <div className="action-details">
                    {action.elementAnalysis?.description || 
                     (action.element?.tagName ? `${action.element.tagName} element` : 'Unknown element')}
                    {action.value && <span className="action-value">{action.value}</span>}
                  </div>
                </li>
              ))}
            </ul>
          )}
        </div>
        
        <div className="generated-code-panel">
          <h2>Generated Test Code</h2>
          {generatedCode ? (
            <pre className="code-preview">
              <code>{generatedCode}</code>
            </pre>
          ) : (
            <div className="no-code">
              {isRecording ? 'Recording in progress...' : 'Start recording to generate code'}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default Recorder;



package com.cssmart.data;

import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * Interface for all data providers in the CS Smart Test Framework
 */
public interface DataProvider {
    
    /**
     * Get all data as a list of maps
     * Each map represents a row with column name as key
     * 
     * @return List of data row maps
     */
    List<Map<String, Object>> getAllData();
    
    /**
     * Get data iterator for TestNG data provider
     * 
     * @return Iterator of Object arrays
     */
    Iterator<Object[]> getDataIterator();
    
    /**
     * Get data as Object[][] array for TestNG
     * 
     * @return Object[][] array
     */
    Object[][] getDataArray();
    
    /**
     * Get data by index
     * 
     * @param index Row index
     * @return Map with column name as key
     */
    Map<String, Object> getDataAt(int index);
    
    /**
     * Get column names
     * 
     * @return List of column names
     */
    List<String> getColumns();
    
    /**
     * Get row count
     * 
     * @return Number of rows
     */
    int getRowCount();
    
    /**
     * Filter data by column value
     * 
     * @param column Column name
     * @param value Value to filter by
     * @return Filtered data provider
     */
    DataProvider filter(String column, Object value);
    
    /**
     * Sort data by column
     * 
     * @param column Column name
     * @param ascending True for ascending, false for descending
     * @return Sorted data provider
     */
    DataProvider sort(String column, boolean ascending);
}

/**
 * Abstract base implementation of DataProvider
 */
public abstract class AbstractDataProvider implements DataProvider {
    
    @Override
    public Iterator<Object[]> getDataIterator() {
        List<Map<String, Object>> data = getAllData();
        return data.stream()
                .map(row -> new Object[]{row})
                .iterator();
    }
    
    @Override
    public Object[][] getDataArray() {
        List<Map<String, Object>> data = getAllData();
        Object[][] result = new Object[data.size()][1];
        
        for (int i = 0; i < data.size(); i++) {
            result[i][0] = data.get(i);
        }
        
        return result;
    }
    
    @Override
    public int getRowCount() {
        return getAllData().size();
    }
    
    @Override
    public Map<String, Object> getDataAt(int index) {
        List<Map<String, Object>> data = getAllData();
        if (index < 0 || index >= data.size()) {
            throw new IndexOutOfBoundsException("Invalid data index: " + index);
        }
        return data.get(index);
    }
}

package com.cssmart.data.provider;

import com.cssmart.data.AbstractDataProvider;
import com.cssmart.data.DataProvider;
import lombok.extern.slf4j.Slf4j;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Data provider for Excel files (XLS and XLSX)
 */
@Slf4j
public class ExcelDataProvider extends AbstractDataProvider {
    
    private final List<Map<String, Object>> data;
    private final List<String> columns;
    
    /**
     * Create a new Excel data provider from file path
     * 
     * @param filePath Path to Excel file
     * @throws IOException If file cannot be read
     */
    public ExcelDataProvider(String filePath) throws IOException {
        this(filePath, 0);
    }
    
    /**
     * Create a new Excel data provider from file path with specific sheet
     * 
     * @param filePath Path to Excel file
     * @param sheetIndex Sheet index (0-based)
     * @throws IOException If file cannot be read
     */
    public ExcelDataProvider(String filePath, int sheetIndex) throws IOException {
        File file = new File(filePath);
        try (FileInputStream fis = new FileInputStream(file)) {
            if (filePath.toLowerCase().endsWith(".xlsx")) {
                try (Workbook workbook = new XSSFWorkbook(fis)) {
                    Sheet sheet = workbook.getSheetAt(sheetIndex);
                    this.data = readSheet(sheet);
                    this.columns = extractColumns(sheet);
                }
            } else if (filePath.toLowerCase().endsWith(".xls")) {
                try (Workbook workbook = new HSSFWorkbook(fis)) {
                    Sheet sheet = workbook.getSheetAt(sheetIndex);
                    this.data = readSheet(sheet);
                    this.columns = extractColumns(sheet);
                }
            } else {
                throw new IllegalArgumentException("Unsupported file format. Must be .xls or .xlsx");
            }
        }
    }
    
    /**
     * Create a new Excel data provider from input stream
     * 
     * @param inputStream Input stream of Excel file
     * @param isXlsx True if XLSX format, false if XLS
     * @throws IOException If stream cannot be read
     */
    public ExcelDataProvider(InputStream inputStream, boolean isXlsx) throws IOException {
        this(inputStream, isXlsx, 0);
    }
    
    /**
     * Create a new Excel data provider from input stream with specific sheet
     * 
     * @param inputStream Input stream of Excel file
     * @param isXlsx True if XLSX format, false if XLS
     * @param sheetIndex Sheet index (0-based)
     * @throws IOException If stream cannot be read
     */
    public ExcelDataProvider(InputStream inputStream, boolean isXlsx, int sheetIndex) throws IOException {
        if (isXlsx) {
            try (Workbook workbook = new XSSFWorkbook(inputStream)) {
                Sheet sheet = workbook.getSheetAt(sheetIndex);
                this.data = readSheet(sheet);
                this.columns = extractColumns(sheet);
            }
        } else {
            try (Workbook workbook = new HSSFWorkbook(inputStream)) {
                Sheet sheet = workbook.getSheetAt(sheetIndex);
                this.data = readSheet(sheet);
                this.columns = extractColumns(sheet);
            }
        }
    }
    
    /**
     * Create a new Excel data provider from existing data
     * 
     * @param data List of data row maps
     * @param columns List of column names
     */
    private ExcelDataProvider(List<Map<String, Object>> data, List<String> columns) {
        this.data = new ArrayList<>(data);
        this.columns = new ArrayList<>(columns);
    }
    
    @Override
    public List<Map<String, Object>> getAllData() {
        return Collections.unmodifiableList(data);
    }
    
    @Override
    public List<String> getColumns() {
        return Collections.unmodifiableList(columns);
    }
    
    @Override
    public DataProvider filter(String column, Object value) {
        List<Map<String, Object>> filteredData = data.stream()
                .filter(row -> Objects.equals(row.get(column), value))
                .collect(Collectors.toList());
        
        return new ExcelDataProvider(filteredData, columns);
    }
    
    @Override
    public DataProvider sort(String column, boolean ascending) {
        List<Map<String, Object>> sortedData = new ArrayList<>(data);
        
        sortedData.sort((row1, row2) -> {
            Object val1 = row1.get(column);
            Object val2 = row2.get(column);
            
            if (val1 == null && val2 == null) return 0;
            if (val1 == null) return ascending ? -1 : 1;
            if (val2 == null) return ascending ? 1 : -1;
            
            if (val1 instanceof Comparable && val1.getClass().equals(val2.getClass())) {
                @SuppressWarnings("unchecked")
                int result = ((Comparable<Object>) val1).compareTo(val2);
                return ascending ? result : -result;
            }
            
            // Fallback to string comparison
            String str1 = String.valueOf(val1);
            String str2 = String.valueOf(val2);
            return ascending ? str1.compareTo(str2) : str2.compareTo(str1);
        });
        
        return new ExcelDataProvider(sortedData, columns);
    }
    
    /**
     * Read data from Excel sheet
     * 
     * @param sheet Excel sheet
     * @return List of data row maps
     */
    private List<Map<String, Object>> readSheet(Sheet sheet) {
        List<Map<String, Object>> result = new ArrayList<>();
        Iterator<Row> rowIterator = sheet.iterator();
        
        // Skip header row
        if (rowIterator.hasNext()) {
            Row headerRow = rowIterator.next();
            List<String> headers = extractHeaders(headerRow);
            
            // Process data rows
            while (rowIterator.hasNext()) {
                Row row = rowIterator.next();
                Map<String, Object> rowData = new LinkedHashMap<>();
                
                // Skip entirely empty rows
                if (isEmptyRow(row)) continue;
                
                for (int i = 0; i < headers.size(); i++) {
                    Cell cell = row.getCell(i, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL);
                    rowData.put(headers.get(i), getCellValue(cell));
                }
                
                result.add(rowData);
            }
        }
        
        return result;
    }
    
    /**
     * Extract column names from Excel sheet
     * 
     * @param sheet Excel sheet
     * @return List of column names
     */
    private List<String> extractColumns(Sheet sheet) {
        Row headerRow = sheet.getRow(0);
        return headerRow != null ? extractHeaders(headerRow) : new ArrayList<>();
    }
    
    /**
     * Extract headers from header row
     * 
     * @param headerRow Header row
     * @return List of header names
     */
    private List<String> extractHeaders(Row headerRow) {
        List<String> headers = new ArrayList<>();
        for (int i = 0; i < headerRow.getLastCellNum(); i++) {
            Cell cell = headerRow.getCell(i, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL);
            String header = cell != null ? cell.getStringCellValue() : "Column" + (i + 1);
            header = header.trim();
            
            // Handle duplicate headers
            String baseHeader = header;
            int count = 1;
            while (headers.contains(header)) {
                header = baseHeader + "_" + count++;
            }
            
            headers.add(header);
        }
        return headers;
    }
    
    /**
     * Check if a row is completely empty
     * 
     * @param row Excel row
     * @return True if row is empty
     */
    private boolean isEmptyRow(Row row) {
        if (row == null) return true;
        
        for (int i = 0; i < row.getLastCellNum(); i++) {
            Cell cell = row.getCell(i, Row.MissingCellPolicy.RETURN_BLANK_AS_NULL);
            if (cell != null) return false;
        }
        
        return true;
    }
    
    /**
     * Get cell value with appropriate type
     * 
     * @param cell Excel cell
     * @return Cell value (String, Double, Boolean, Date, or null)
     */
    private Object getCellValue(Cell cell) {
        if (cell == null) return null;
        
        switch (cell.getCellType()) {
            case STRING:
                return cell.getStringCellValue();
                
            case NUMERIC:
                if (DateUtil.isCellDateFormatted(cell)) {
                    return cell.getDateCellValue();
                } else {
                    double value = cell.getNumericCellValue();
                    // Convert to integer if it's a whole number
                    if (value == Math.floor(value)) {
                        if (value >= Integer.MIN_VALUE && value <= Integer.MAX_VALUE) {
                            return (int) value;
                        } else {
                            return (long) value;
                        }
                    }
                    return value;
                }
                
            case BOOLEAN:
                return cell.getBooleanCellValue();
                
            case FORMULA:
                FormulaEvaluator evaluator = cell.getSheet().getWorkbook().getCreationHelper().createFormulaEvaluator();
                CellValue cellValue = evaluator.evaluate(cell);
                
                switch (cellValue.getCellType()) {
                    case STRING:
                        return cellValue.getStringValue();
                    case NUMERIC:
                        return cellValue.getNumberValue();
                    case BOOLEAN:
                        return cellValue.getBooleanValue();
                    default:
                        return null;
                }
                
            default:
                return null;
        }
    }
}


package com.cssmart.data.provider;

import com.cssmart.data.AbstractDataProvider;
import com.cssmart.data.DataProvider;
import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;
import com.opencsv.enums.CSVReaderNullFieldIndicator;
import com.opencsv.exceptions.CsvException;
import lombok.extern.slf4j.Slf4j;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Data provider for CSV files
 */
@Slf4j
public class CSVDataProvider extends AbstractDataProvider {
    
    private final List<Map<String, Object>> data;
    private final List<String> columns;
    
    /**
     * Create a new CSV data provider from file path
     * 
     * @param filePath Path to CSV file
     * @throws IOException If file cannot be read
     */
    public CSVDataProvider(String filePath) throws IOException {
        this(filePath, true, ',');
    }
    
    /**
     * Create a new CSV data provider from file path
     * 
     * @param filePath Path to CSV file
     * @param hasHeader True if CSV has a header row
     * @param separator Separator character
     * @throws IOException If file cannot be read
     */
    public CSVDataProvider(String filePath, boolean hasHeader, char separator) throws IOException {
        File file = new File(filePath);
        try (FileInputStream fis = new FileInputStream(file);
             InputStreamReader isr = new InputStreamReader(fis, StandardCharsets.UTF_8)) {
            CSVReader reader = new CSVReaderBuilder(isr)
                    .withSkipLines(0)
                    .withFieldAsNull(CSVReaderNullFieldIndicator.EMPTY_QUOTES)
                    .withCSVParser(new com.opencsv.CSVParserBuilder()
                            .withSeparator(separator)
                            .build())
                    .build();
            
            List<String[]> rows = reader.readAll();
            if (rows.isEmpty()) {
                this.columns = new ArrayList<>();
                this.data = new ArrayList<>();
            } else {
                if (hasHeader) {
                    this.columns = Arrays.asList(rows.get(0));
                    rows.remove(0);
                } else {
                    // Generate column names (Column1, Column2, etc.)
                    String[] firstRow = rows.get(0);
                    this.columns = new ArrayList<>();
                    for (int i = 0; i < firstRow.length; i++) {
                        this.columns.add("Column" + (i + 1));
                    }
                }
                
                this.data = convertRowsToMaps(rows, this.columns);
            }
        } catch (CsvException e) {
            throw new IOException("Error parsing CSV file: " + e.getMessage(), e);
        }
    }
    
    /**
     * Create a new CSV data provider from input stream
     * 
     * @param inputStream Input stream of CSV file
     * @param hasHeader True if CSV has a header row
     * @param separator Separator character
     * @throws IOException If stream cannot be read
     */
    public CSVDataProvider(InputStream inputStream, boolean hasHeader, char separator) throws IOException {
        try (InputStreamReader isr = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {
            CSVReader reader = new CSVReaderBuilder(isr)
                    .withSkipLines(0)
                    .withFieldAsNull(CSVReaderNullFieldIndicator.EMPTY_QUOTES)
                    .withCSVParser(new com.opencsv.CSVParserBuilder()
                            .withSeparator(separator)
                            .build())
                    .build();
            
            List<String[]> rows = reader.readAll();
            if (rows.isEmpty()) {
                this.columns = new ArrayList<>();
                this.data = new ArrayList<>();
            } else {
                if (hasHeader) {
                    this.columns = Arrays.asList(rows.get(0));
                    rows.remove(0);
                } else {
                    // Generate column names (Column1, Column2, etc.)
                    String[] firstRow = rows.get(0);
                    this.columns = new ArrayList<>();
                    for (int i = 0; i < firstRow.length; i++) {
                        this.columns.add("Column" + (i + 1));
                    }
                }
                
                this.data = convertRowsToMaps(rows, this.columns);
            }
        } catch (CsvException e) {
            throw new IOException("Error parsing CSV file: " + e.getMessage(), e);
        }
    }
    
    /**
     * Create a new CSV data provider from existing data
     * 
     * @param data List of data row maps
     * @param columns List of column names
     */
    private CSVDataProvider(List<Map<String, Object>> data, List<String> columns) {
        this.data = new ArrayList<>(data);
        this.columns = new ArrayList<>(columns);
    }
    
    @Override
    public List<Map<String, Object>> getAllData() {
        return Collections.unmodifiableList(data);
    }
    
    @Override
    public List<String> getColumns() {
        return Collections.unmodifiableList(columns);
    }
    
    @Override
    public DataProvider filter(String column, Object value) {
        List<Map<String, Object>> filteredData = data.stream()
                .filter(row -> Objects.equals(row.get(column), value))
                .collect(Collectors.toList());
        
        return new CSVDataProvider(filteredData, columns);
    }
    
    @Override
    public DataProvider sort(String column, boolean ascending) {
        List<Map<String, Object>> sortedData = new ArrayList<>(data);
        
        sortedData.sort((row1, row2) -> {
            Object val1 = row1.get(column);
            Object val2 = row2.get(column);
            
            if (val1 == null && val2 == null) return 0;
            if (val1 == null) return ascending ? -1 : 1;
            if (val2 == null) return ascending ? 1 : -1;
            
            if (val1 instanceof Comparable && val1.getClass().equals(val2.getClass())) {
                @SuppressWarnings("unchecked")
                int result = ((Comparable<Object>) val1).compareTo(val2);
                return ascending ? result : -result;
            }
            
            // Fallback to string comparison
            String str1 = String.valueOf(val1);
            String str2 = String.valueOf(val2);
            return ascending ? str1.compareTo(str2) : str2.compareTo(str1);
        });
        
        return new CSVDataProvider(sortedData, columns);
    }
    
    /**
     * Convert rows of string arrays to maps with column names as keys
     * 
     * @param rows List of string arrays
     * @param columns List of column names
     * @return List of data row maps
     */
    private List<Map<String, Object>> convertRowsToMaps(List<String[]> rows, List<String> columns) {
        List<Map<String, Object>> result = new ArrayList<>();
        
        for (String[] row : rows) {
            Map<String, Object> rowMap = new LinkedHashMap<>();
            
            for (int i = 0; i < columns.size() && i < row.length; i++) {
                String value = row[i];
                Object convertedValue = convertStringToTypedValue(value);
                rowMap.put(columns.get(i), convertedValue);
            }
            
            // Fill missing values with null
            for (int i = row.length; i < columns.size(); i++) {
                rowMap.put(columns.get(i), null);
            }
            
            result.add(rowMap);
        }
        
        return result;
    }
    
    /**
     * Convert string to typed value (Integer, Double, Boolean, or String)
     * 
     * @param value String value
     * @return Typed value
     */
    private Object convertStringToTypedValue(String value) {
        if (value == null) return null;
        value = value.trim();
        if (value.isEmpty()) return null;
        
        // Try boolean
        if (value.equalsIgnoreCase("true")) return Boolean.TRUE;
        if (value.equalsIgnoreCase("false")) return Boolean.FALSE;
        
        // Try number
        try {
            // Check if it's an integer
            if (!value.contains(".")) {
                try {
                    return Integer.parseInt(value);
                } catch (NumberFormatException e) {
                    try {
                        return Long.parseLong(value);
                    } catch (NumberFormatException e2) {
                        // Not an integer, try double
                    }
                }
            }
            
            // Try double
            return Double.parseDouble(value);
        } catch (NumberFormatException e) {
            // Not a number, return as string
            return value;
        }
    }
}


package com.cssmart.data.provider;

import com.cssmart.data.AbstractDataProvider;
import com.cssmart.data.DataProvider;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Data provider for JSON files
 */
@Slf4j
public class JSONDataProvider extends AbstractDataProvider {
    
    private final List<Map<String, Object>> data;
    private final List<String> columns;
    
    /**
     * Create a new JSON data provider from file path
     * 
     * @param filePath Path to JSON file
     * @throws IOException If file cannot be read
     */
    public JSONDataProvider(String filePath) throws IOException {
        this(filePath, null);
    }
    
    /**
     * Create a new JSON data provider from file path with specific JSON path
     * 
     * @param filePath Path to JSON file
     * @param jsonPath JSON path to data array (e.g., "data.records")
     * @throws IOException If file cannot be read
     */
    public JSONDataProvider(String filePath, String jsonPath) throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        File file = new File(filePath);
        
        JsonNode rootNode = mapper.readTree(file);
        JsonNode dataNode = (jsonPath != null) ? getNodeAtPath(rootNode, jsonPath) : rootNode;
        
        if (dataNode == null || !dataNode.isArray()) {
            throw new IllegalArgumentException("JSON data must be an array or specified by a valid JSON path");
        }
        
        List<Map<String, Object>> tempData = new ArrayList<>();
        Set<String> allColumns = new LinkedHashSet<>();
        
        // First pass: collect all possible columns
        for (JsonNode node : dataNode) {
            if (node.isObject()) {
                Iterator<String> fieldNames = node.fieldNames();
                while (fieldNames.hasNext()) {
                    allColumns.add(fieldNames.next());
                }
            }
        }
        
        // Second pass: convert to maps with consistent columns
        for (JsonNode node : dataNode) {
            if (node.isObject()) {
                Map<String, Object> rowData = new LinkedHashMap<>();
                
                // Initialize all columns to null
                for (String column : allColumns) {
                    rowData.put(column, null);
                }
                
                // Set values for columns present in this row
                Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
                while (fields.hasNext()) {
                    Map.Entry<String, JsonNode> field = fields.next();
                    rowData.put(field.getKey(), convertJsonValue(field.getValue()));
                }
                
                tempData.add(rowData);
            }
        }
        
        this.data = tempData;
        this.columns = new ArrayList<>(allColumns);
    }
    
    /**
     * Create a new JSON data provider from input stream
     * 
     * @param inputStream Input stream of JSON file
     * @param jsonPath JSON path to data array (e.g., "data.records")
     * @throws IOException If stream cannot be read
     */
    public JSONDataProvider(InputStream inputStream, String jsonPath) throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        
        JsonNode rootNode = mapper.readTree(inputStream);
        JsonNode dataNode = (jsonPath != null) ? getNodeAtPath(rootNode, jsonPath) : rootNode;
        
        if (dataNode == null || !dataNode.isArray()) {
            throw new IllegalArgumentException("JSON data must be an array or specified by a valid JSON path");
        }
        
        List<Map<String, Object>> tempData = new ArrayList<>();
        Set<String> allColumns = new LinkedHashSet<>();
        
        // First pass: collect all possible columns
        for (JsonNode node : dataNode) {
            if (node.isObject()) {
                Iterator<String> fieldNames = node.fieldNames();
                while (fieldNames.hasNext()) {
                    allColumns.add(fieldNames.next());
                }
            }
        }
        
        // Second pass: convert to maps with consistent columns
        for (JsonNode node : dataNode) {
            if (node.isObject()) {
                Map<String, Object> rowData = new LinkedHashMap<>();
                
                // Initialize all columns to null
                for (String column : allColumns) {
                    rowData.put(column, null);
                }
                
                // Set values for columns present in this row
                Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
                while (fields.hasNext()) {
                    Map.Entry<String, JsonNode> field = fields.next();
                    rowData.put(field.getKey(), convertJsonValue(field.getValue()));
                }
                
                tempData.add(rowData);
            }
        }
        
        this.data = tempData;
        this.columns = new ArrayList<>(allColumns);
    }
    
    /**
     * Create a new JSON data provider from existing data
     * 
     * @param data List of data row maps
     * @param columns List of column names
     */
    private JSONDataProvider(List<Map<String, Object>> data, List<String> columns) {
        this.data = new ArrayList<>(data);
        this.columns = new ArrayList<>(columns);
    }
    
    @Override
    public List<Map<String, Object>> getAllData() {
        return Collections.unmodifiableList(data);
    }
    
    @Override
    public List<String> getColumns() {
        return Collections.unmodifiableList(columns);
    }
    
    @Override
    public DataProvider filter(String column, Object value) {
        List<Map<String, Object>> filteredData = data.stream()
                .filter(row -> Objects.equals(row.get(column), value))
                .collect(Collectors.toList());
        
        return new JSONDataProvider(filteredData, columns);
    }
    
    @Override
    public DataProvider sort(String column, boolean ascending) {
        List<Map<String, Object>> sortedData = new ArrayList<>(data);
        
        sortedData.sort((row1, row2) -> {
            Object val1 = row1.get(column);
            Object val2 = row2.get(column);
            
            if (val1 == null && val2 == null) return 0;
            if (val1 == null) return ascending ? -1 : 1;
            if (val2 == null) return ascending ? 1 : -1;
            
            if (val1 instanceof Comparable && val1.getClass().equals(val2.getClass())) {
                @SuppressWarnings("unchecked")
                int result = ((Comparable<Object>) val1).compareTo(val2);
                return ascending ? result : -result;
            }
            
            // Fallback to string comparison
            String str1 = String.valueOf(val1);
            String str2 = String.valueOf(val2);
            return ascending ? str1.compareTo(str2) : str2.compareTo(str1);
        });
        
        return new JSONDataProvider(sortedData, columns);
    }
    
    /**
     * Get JsonNode at specified path (e.g., "data.records")
     * 
     * @param rootNode Root JsonNode
     * @param path Path separated by dots
     * @return JsonNode at path or null if not found
     */
    private JsonNode getNodeAtPath(JsonNode rootNode, String path) {
        if (path == null || path.isEmpty()) {
            return rootNode;
        }
        
        String[] parts = path.split("\\.");
        JsonNode currentNode = rootNode;
        
        for (String part : parts) {
            currentNode = currentNode.path(part);
            if (currentNode.isMissingNode()) {
                return null;
            }
        }
        
        return currentNode;
    }
    
    /**
     * Convert JsonNode to appropriate Java type
     * 
     * @param node JsonNode to convert
     * @return Converted value
     */
    private Object convertJsonValue(JsonNode node) {
        if (node.isNull()) {
            return null;
        } else if (node.isTextual()) {
            return node.textValue();
        } else if (node.isInt()) {
            return node.intValue();
        } else if (node.isLong()) {
            return node.longValue();
        } else if (node.isDouble()) {
            return node.doubleValue();
        } else if (node.isBoolean()) {
            return node.booleanValue();
        } else if (node.isArray()) {
            List<Object> list = new ArrayList<>();
            for (JsonNode item : node) {
                list.add(convertJsonValue(item));
            }
            return list;
        } else if (node.isObject()) {
            Map<String, Object> map = new LinkedHashMap<>();
            Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> field = fields.next();
                map.put(field.getKey(), convertJsonValue(field.getValue()));
            }
            return map;
        } else {
            return node.toString();
        }
    }
}


package com.cssmart.data.generator;

import com.cssmart.data.AbstractDataProvider;
import com.cssmart.data.DataProvider;
import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.concurrent.ThreadLocalRandom;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Random data generator for creating test data
 */
@Slf4j
public class RandomDataGenerator extends AbstractDataProvider {
    
    private final List<Map<String, Object>> data;
    private final List<String> columns;
    
    /**
     * Create a new random data generator with default column configuration
     * 
     * @param rowCount Number of rows to generate
     */
    public RandomDataGenerator(int rowCount) {
        this.columns = Arrays.asList("id", "name", "email", "age", "active");
        this.data = generateRandomData(rowCount, this.columns);
    }
    
    /**
     * Create a new random data generator with custom columns
     * 
     * @param rowCount Number of rows to generate
     * @param columns List of column names
     */
    public RandomDataGenerator(int rowCount, List<String> columns) {
        this.columns = new ArrayList<>(columns);
        this.data = generateRandomData(rowCount, this.columns);
    }
    
    /**
     * Create a new random data generator with custom columns and data generators
     * 
     * @param rowCount Number of rows to generate
     * @param columnGenerators Map of column names to data generator functions
     */
    public RandomDataGenerator(int rowCount, Map<String, Supplier<Object>> columnGenerators) {
        this.columns = new ArrayList<>(columnGenerators.keySet());
        this.data = generateRandomData(rowCount, columnGenerators);
    }
    
    /**
     * Create a new random data generator from existing data
     * 
     * @param data List of data row maps
     * @param columns List of column names
     */
    private RandomDataGenerator(List<Map<String, Object>> data, List<String> columns) {
        this.data = new ArrayList<>(data);
        this.columns = new ArrayList<>(columns);
    }
    
    @Override
    public List<Map<String, Object>> getAllData() {
        return Collections.unmodifiableList(data);
    }
    
    @Override
    public List<String> getColumns() {
        return Collections.unmodifiableList(columns);
    }
    
    @Override
    public DataProvider filter(String column, Object value) {
        List<Map<String, Object>> filteredData = data.stream()
                .filter(row -> Objects.equals(row.get(column), value))
                .collect(Collectors.toList());
        
        return new RandomDataGenerator(filteredData, columns);
    }
    
    @Override
    public DataProvider sort(String column, boolean ascending) {
        List<Map<String, Object>> sortedData = new ArrayList<>(data);
        
        sortedData.sort((row1, row2) -> {
            Object val1 = row1.get(column);
            Object val2 = row2.get(column);
            
            if (val1 == null && val2 == null) return 0;
            if (val1 == null) return ascending ? -1 : 1;
            if (val2 == null) return ascending ? 1 : -1;
            
            if (val1 instanceof Comparable && val1.getClass().equals(val2.getClass())) {
                @SuppressWarnings("unchecked")
                int result = ((Comparable<Object>) val1).compareTo(val2);
                return ascending ? result : -result;
            }
            
            // Fallback to string comparison
            String str1 = String.valueOf(val1);
            String str2 = String.valueOf(val2);
            return ascending ? str1.compareTo(str2) : str2.compareTo(str1);
        });
        
        return new RandomDataGenerator(sortedData, columns);
    }
    
    /**
     * Generate random data with default generators
     * 
     * @param rowCount Number of rows to generate
     * @param columns List of column names
     * @return List of generated data maps
     */
    private List<Map<String, Object>> generateRandomData(int rowCount, List<String> columns) {
        Map<String, Supplier<Object>> generators = new LinkedHashMap<>();
        
        for (String column : columns) {
            switch (column.toLowerCase()) {
                case "id":
                    generators.put(column, () -> ThreadLocalRandom.current().nextInt(1, 10000));
                    break;
                case "name":
                    generators.put(column, () -> generateRandomName());
                    break;
                case "firstname":
                case "first_name":
                    generators.put(column, () -> generateRandomFirstName());
                    break;
                case "lastname":
                case "last_name":
                    generators.put(column, () -> generateRandomLastName());
                    break;
                case "email":
                    generators.put(column, () -> generateRandomEmail());
                    break;
                case "age":
                    generators.put(column, () -> ThreadLocalRandom.current().nextInt(18, 80));
                    break;
                case "date":
                case "date_of_birth":
                case "dob":
                    generators.put(column, () -> generateRandomDate());
                    break;
                case "phone":
                case "phone_number":
                    generators.put(column, () -> generateRandomPhoneNumber());
                    break;
                case "address":
                    generators.put(column, () -> generateRandomAddress());
                    break;
                case "city":
                    generators.put(column, () -> generateRandomCity());
                    break;
                case "state":
                    generators.put(column, () -> generateRandomState());
                    break;
                case "zipcode":
                case "zip":
                case "postal_code":
                    generators.put(column, () -> generateRandomZipCode());
                    break;
                case "country":
                    generators.put(column, () -> generateRandomCountry());
                    break;
                case "company":
                case "company_name":
                    generators.put(column, () -> generateRandomCompany());
                    break;
                case "job":
                case "job_title":
                case "position":
                    generators.put(column, () -> generateRandomJobTitle());
                    break;
                case "username":
                case "user_name":
                    generators.put(column, () -> generateRandomUsername());
                    break;
                case "password":
                    generators.put(column, () -> generateRandomPassword());
                    break;
                case "active":
                case "enabled":
                case "status":
                    generators.put(column, () -> ThreadLocalRandom.current().nextBoolean());
                    break;
                default:
                    // For unknown columns, generate random strings
                    generators.put(column, () -> generateRandomString(10));
                    break;
            }
        }
        
        return generateRandomData(rowCount, generators);
    }
    
    /**
     * Generate random data with custom generators
     * 
     * @param rowCount Number of rows to generate
     * @param columnGenerators Map of column names to data generator functions
     * @return List of generated data maps
     */
    private List<Map<String, Object>> generateRandomData(int rowCount, Map<String, Supplier<Object>> columnGenerators) {
        return IntStream.range(0, rowCount)
                .mapToObj(i -> {
                    Map<String, Object> row = new LinkedHashMap<>();
                    columnGenerators.forEach((column, generator) -> row.put(column, generator.get()));
                    return row;
                })
                .collect(Collectors.toList());
    }
    
    // Random data generators
    
    private String generateRandomName() {
        return generateRandomFirstName() + " " + generateRandomLastName();
    }
    
    private String generateRandomFirstName() {
        List<String> firstNames = Arrays.asList(
                "James", "John", "Robert", "Michael", "William", "David", "Richard", "Joseph", "Thomas", "Charles",
                "Mary", "Patricia", "Jennifer", "Linda", "Elizabeth", "Barbara", "Susan", "Jessica", "Sarah", "Karen"
        );
        return firstNames.get(ThreadLocalRandom.current().nextInt(firstNames.size()));
    }
    
    private String generateRandomLastName() {
        List<String> lastNames = Arrays.asList(
                "Smith", "Johnson", "Williams", "Brown", "Jones", "Miller", "Davis", "Garcia", "Rodriguez", "Wilson",
                "Martinez", "Anderson", "Taylor", "Thomas", "Hernandez", "Moore", "Martin", "Jackson", "Thompson", "White"
        );
        return lastNames.get(ThreadLocalRandom.current().nextInt(lastNames.size()));
    }
    
    private String generateRandomEmail() {
        String firstName = generateRandomFirstName().toLowerCase();
        String lastName = generateRandomLastName().toLowerCase();
        List<String> domains = Arrays.asList("gmail.com", "yahoo.com", "hotmail.com", "outlook.com", "example.com");
        String domain = domains.get(ThreadLocalRandom.current().nextInt(domains.size()));
        
        return firstName + "." + lastName + "@" + domain;
    }
    
    private Date generateRandomDate() {
        long minDay = new GregorianCalendar(1950, 0, 1).getTimeInMillis();
        long maxDay = new GregorianCalendar(2010, 0, 1).getTimeInMillis();
        long randomDay = minDay + (long) (ThreadLocalRandom.current().nextDouble() * (maxDay - minDay));
        return new Date(randomDay);
    }
    
    private String generateRandomPhoneNumber() {
        ThreadLocalRandom random = ThreadLocalRandom.current();
        return String.format("(%03d) %03d-%04d",
                random.nextInt(100, 1000),
                random.nextInt(100, 1000),
                random.nextInt(1000, 10000));
    }
    
    private String generateRandomAddress() {
        ThreadLocalRandom random = ThreadLocalRandom.current();
        int number = random.nextInt(1, 10000);
        
        List<String> streetNames = Arrays.asList(
                "Main St", "Oak Ave", "Maple Dr", "Washington Blvd", "Park Rd", "Lake St",
                "Elm St", "Broadway", "First Ave", "Second St", "Third Ave", "Fourth St"
        );
        
        String streetName = streetNames.get(random.nextInt(streetNames.size()));
        return number + " " + streetName;
    }
    
    private String generateRandomCity() {
        List<String> cities = Arrays.asList(
                "New York", "Los Angeles", "Chicago", "Houston", "Phoenix", "Philadelphia",
                "San Antonio", "San Diego", "Dallas", "San Jose", "Austin", "Jacksonville"
        );
        return cities.get(ThreadLocalRandom.current().nextInt(cities.size()));
    }
    
    private String generateRandomState() {
        List<String> states = Arrays.asList(
                "AL", "AK", "AZ", "AR", "CA", "CO", "CT", "DE", "FL", "GA", "HI", "ID",
                "IL", "IN", "IA", "KS", "KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS"
        );
        return states.get(ThreadLocalRandom.current().nextInt(states.size()));
    }
    
    private String generateRandomZipCode() {
        return String.format("%05d", ThreadLocalRandom.current().nextInt(10000, 100000));
    }
    
    private String generateRandomCountry() {
        List<String> countries = Arrays.asList(
                "United States", "Canada", "United Kingdom", "Australia", "Germany", "France",
                "Italy", "Spain", "Japan", "China", "Brazil", "Mexico", "India"
        );
        return countries.get(ThreadLocalRandom.current().nextInt(countries.size()));
    }
    
    private String generateRandomCompany() {
        List<String> prefixes = Arrays.asList(
                "Tech", "Acme", "Global", "National", "United", "Advanced", "Pacific", "Eastern",
                "Western", "Northern", "Southern", "Metro", "American", "International"
        );
        
        List<String> suffixes = Arrays.asList(
                "Corp", "Inc", "LLC", "Systems", "Solutions", "Technologies", "Industries",
                "Enterprises", "Services", "Group", "Partners", "Associates"
        );
        
        String prefix = prefixes.get(ThreadLocalRandom.current().nextInt(prefixes.size()));
        String suffix = suffixes.get(ThreadLocalRandom.current().nextInt(suffixes.size()));
        
        return prefix + " " + suffix;
    }
    
    private String generateRandomJobTitle() {
        List<String> titles = Arrays.asList(
                "Software Engineer", "Project Manager", "Product Manager", "QA Engineer", "Data Analyst",
                "System Administrator", "Network Engineer", "Web Developer", "DevOps Engineer", "Database Administrator",
                "UI/UX Designer", "Business Analyst", "Marketing Manager", "Sales Representative", "HR Manager"
        );
        return titles.get(ThreadLocalRandom.current().nextInt(titles.size()));
    }
    
    private String generateRandomUsername() {
        String firstName = generateRandomFirstName().toLowerCase();
        String lastName = generateRandomLastName().toLowerCase();
        int number = ThreadLocalRandom.current().nextInt(10, 1000);
        
        if (ThreadLocalRandom.current().nextBoolean()) {
            return firstName + lastName.charAt(0) + number;
        } else {
            return firstName.charAt(0) + lastName + number;
        }
    }
    
    private String generateRandomPassword() {
        return generateRandomString(12);
    }
    
    private String generateRandomString(int length) {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        StringBuilder sb = new StringBuilder();
        ThreadLocalRandom random = ThreadLocalRandom.current();
        
        for (int i = 0; i < length; i++) {
            int index = random.nextInt(chars.length());
            sb.append(chars.charAt(index));
        }
        
        return sb.toString();
    }
    
    // Static factory methods for common generators
    
    /**
     * Creates a data provider with typical user data
     * 
     * @param count Number of rows to generate
     * @return DataProvider with user data
     */
    public static DataProvider createUserDataProvider(int count) {
        List<String> columns = Arrays.asList(
                "id", "username", "password", "first_name", "last_name", "email", "phone", "active"
        );
        return new RandomDataGenerator(count, columns);
    }
    
    /**
     * Creates a data provider with typical product data
     * 
     * @param count Number of rows to generate
     * @return DataProvider with product data
     */
    public static DataProvider createProductDataProvider(int count) {
        Map<String, Supplier<Object>> generators = new LinkedHashMap<>();
        generators.put("id", () -> ThreadLocalRandom.current().nextInt(1000, 10000));
        generators.put("name", () -> {
            List<String> products = Arrays.asList(
                    "Laptop", "Smartphone", "Tablet", "Monitor", "Keyboard", "Mouse", "Headphones",
                    "Speaker", "Camera", "Printer", "Scanner", "Router", "Hard Drive", "SSD"
            );
            return products.get(ThreadLocalRandom.current().nextInt(products.size()));
        });
        generators.put("description", () -> "This is a description for the product.");
        generators.put("price", () -> ThreadLocalRandom.current().nextDouble(10.0, 1000.0));
        generators.put("quantity", () -> ThreadLocalRandom.current().nextInt(0, 100));
        generators.put("category", () -> {
            List<String> categories = Arrays.asList(
                    "Electronics", "Computers", "Accessories", "Peripherals", "Audio", "Video", "Storage"
            );
            return categories.get(ThreadLocalRandom.current().nextInt(categories.size()));
        });
        generators.put("in_stock", () -> ThreadLocalRandom.current().nextBoolean());
        
        return new RandomDataGenerator(count, generators);
    }
    
    /**
     * Creates a data provider with typical order data
     * 
     * @param count Number of rows to generate
     * @return DataProvider with order data
     */
    public static DataProvider createOrderDataProvider(int count) {
        Map<String, Supplier<Object>> generators = new LinkedHashMap<>();
        generators.put("order_id", () -> ThreadLocalRandom.current().nextInt(100000, 1000000));
        generators.put("customer_id", () -> ThreadLocalRandom.current().nextInt(1000, 10000));
        generators.put("order_date", RandomDataGenerator::generateRandomOrderDate);
        generators.put("total_amount", () -> ThreadLocalRandom.current().nextDouble(10.0, 500.0));
        generators.put("status", () -> {
            List<String> statuses = Arrays.asList("Pending", "Processing", "Shipped", "Delivered", "Cancelled");
            return statuses.get(ThreadLocalRandom.current().nextInt(statuses.size()));
        });
        generators.put("payment_method", () -> {
            List<String> methods = Arrays.asList("Credit Card", "PayPal", "Bank Transfer", "Cash on Delivery");
            return methods.get(ThreadLocalRandom.current().nextInt(methods.size()));
        });
        
        return new RandomDataGenerator(count, generators);
    }
    
    /**
     * Generate a random recent order date
     * 
     * @return Random date in the last 30 days
     */
    private static Date generateRandomOrderDate() {
        long now = System.currentTimeMillis();
        long thirtyDaysAgo = now - (30L * 24 * 60 * 60 * 1000);
        long randomTime = thirtyDaysAgo + (long) (ThreadLocalRandom.current().nextDouble() * (now - thirtyDaysAgo));
        return new Date(randomTime);
    }
}


package com.cssmart.data;

import com.cssmart.data.generator.RandomDataGenerator;
import com.cssmart.data.provider.CSVDataProvider;
import com.cssmart.data.provider.ExcelDataProvider;
import com.cssmart.data.provider.JSONDataProvider;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.Map;

/**
 * Factory for creating data providers
 */
@Slf4j
public class DataProviderFactory {
    
    /**
     * Create a data provider from a file
     * 
     * @param filePath Path to the file
     * @return DataProvider for the file
     * @throws IOException If file cannot be read
     */
    public static DataProvider createFromFile(String filePath) throws IOException {
        File file = new File(filePath);
        if (!file.exists()) {
            throw new IOException("File not found: " + filePath);
        }
        
        String extension = getFileExtension(filePath);
        
        switch (extension.toLowerCase()) {
            case "csv":
                return new CSVDataProvider(filePath);
                
            case "xlsx":
            case "xls":
                return new ExcelDataProvider(filePath);
                
            case "json":
                return new JSONDataProvider(filePath);
                
            default:
                throw new IllegalArgumentException("Unsupported file type: " + extension);
        }
    }
    
    /**
     * Create a data provider from a resource file
     * 
     * @param resourcePath Path to the resource file
     * @return DataProvider for the resource
     * @throws IOException If resource cannot be read
     */
    public static DataProvider createFromResource(String resourcePath) throws IOException {
        String extension = getFileExtension(resourcePath);
        
        try (InputStream is = DataProviderFactory.class.getResourceAsStream(resourcePath)) {
            if (is == null) {
                throw new IOException("Resource not found: " + resourcePath);
            }
            
            switch (extension.toLowerCase()) {
                case "csv":
                    return new CSVDataProvider(is, true, ',');
                    
                case "xlsx":
                    return new ExcelDataProvider(is, true);
                    
                case "xls":
                    return new ExcelDataProvider(is, false);
                    
                case "json":
                    return new JSONDataProvider(is, null);
                    
                default:
                    throw new IllegalArgumentException("Unsupported file type: " + extension);
            }
        }
    }
    
    /**
     * Create a random data provider with a specified number of rows
     * 
     * @param rowCount Number of rows to generate
     * @return RandomDataGenerator
     */
    public static DataProvider createRandom(int rowCount) {
        return new RandomDataGenerator(rowCount);
    }
    
    /**
     * Create a random data provider with specified columns
     * 
     * @param rowCount Number of rows to generate
     * @param columns List of column names
     * @return RandomDataGenerator
     */
    public static DataProvider createRandom(int rowCount, java.util.List<String> columns) {
        return new RandomDataGenerator(rowCount, columns);
    }
    
    /**
     * Create a random data provider with custom data generators
     * 
     * @param rowCount Number of rows to generate
     * @param columnGenerators Map of column names to data generator functions
     * @return RandomDataGenerator
     */
    public static DataProvider createRandom(int rowCount, Map<String, java.util.function.Supplier<Object>> columnGenerators) {
        return new RandomDataGenerator(rowCount, columnGenerators);
    }
    
    /**
     * Create a random user data provider
     * 
     * @param rowCount Number of rows to generate
     * @return DataProvider with user data
     */
    public static DataProvider createRandomUserData(int rowCount) {
        return RandomDataGenerator.createUserDataProvider(rowCount);
    }
    
    /**
     * Create a random product data provider
     * 
     * @param rowCount Number of rows to generate
     * @return DataProvider with product data
     */
    public static DataProvider createRandomProductData(int rowCount) {
        return RandomDataGenerator.createProductDataProvider(rowCount);
    }
    
    /**
     * Create a random order data provider
     * 
     * @param rowCount Number of rows to generate
     * @return DataProvider with order data
     */
    public static DataProvider createRandomOrderData(int rowCount) {
        return RandomDataGenerator.createOrderDataProvider(rowCount);
    }
    
    /**
     * Get the extension of a file
     * 
     * @param filePath Path to the file
     * @return File extension without the dot
     */
    private static String getFileExtension(String filePath) {
        int lastDotIndex = filePath.lastIndexOf('.');
        if (lastDotIndex == -1 || lastDotIndex == filePath.length() - 1) {
            return "";
        }
        return filePath.substring(lastDotIndex + 1);
    }
}


package com.cssmart.core.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for specifying data provider in CS Smart Test Framework
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface CSSmartDataProvider {
    
    /**
     * Type of data provider
     */
    enum Type {
        CSV,    // CSV file
        EXCEL,  // Excel file (XLS/XLSX)
        JSON,   // JSON file
        RANDOM, // Random data generator
        SQL,    // SQL database query
        XML     // XML file
    }
    
    /**
     * Type of data provider
     * @return Data provider type
     */
    Type type();
    
    /**
     * Path to the data file or resource
     * Empty for random data
     * @return Data file path
     */
    String path() default "";
    
    /**
     * Number of rows for random data generator
     * Ignored for file-based data providers
     * @return Number of rows to generate
     */
    int rows() default 10;
    
    /**
     * Custom columns for random data generator
     * Ignored for file-based data providers
     * @return Array of column names
     */
    String[] columns() default {};
    
    /**
     * Sheet name or index for Excel data provider
     * Sheet index is used if it's a number
     * Sheet name is used if it's not a number
     * Default is the first sheet (index 0)
     * Ignored for non-Excel data providers
     * @return Sheet name or index
     */
    String sheet() default "0";
    
    /**
     * JSON path for JSON data provider (e.g., "data.records")
     * Ignored for non-JSON data providers
     * @return JSON path
     */
    String jsonPath() default "";
    
    /**
     * SQL query for SQL data provider
     * Ignored for non-SQL data providers
     * @return SQL query
     */
    String query() default "";
    
    /**
     * Datasource name for SQL data provider
     * Ignored for non-SQL data providers
     * @return Datasource name
     */
    String datasource() default "";
    
    /**
     * Filter expression for filtering data
     * Format: "column=value" or "column!=value"
     * @return Filter expression
     */
    String filter() default "";
    
    /**
     * Sort expression for sorting data
     * Format: "column" (ascending) or "column:desc" (descending)
     * @return Sort expression
     */
    String sort() default "";
    
    /**
     * Indicates if the resource is a classpath resource
     * @return True if resource is in classpath
     */
    boolean classpath() default false;
    
    /**
     * Indicates if the first row/record contains headers
     * Applies to CSV, Excel, etc.
     * @return True if data has headers
     */
    boolean hasHeaders() default true;
    
    /**
     * Separator character for CSV files
     * @return Separator character
     */
    char separator() default ',';
    
    /**
     * Whether to parallelize tests by data
     * @return True to run tests in parallel with each data row
     */
    boolean parallel() default false;
    
    /**
     * Random data template for generating data
     * Options: "user", "product", "order", "address"
     * Only used when type is RANDOM
     * @return Template name
     */
    String template() default "";
}


package com.cssmart.core.processor;

import com.cssmart.core.annotation.CSSmartDataProvider;
import com.cssmart.data.DataProvider;
import com.cssmart.data.DataProviderFactory;
import com.cssmart.data.generator.RandomDataGenerator;
import com.cssmart.data.provider.CSVDataProvider;
import com.cssmart.data.provider.ExcelDataProvider;
import com.cssmart.data.provider.JSONDataProvider;
import com.cssmart.data.provider.SQLDataProvider;
import lombok.extern.slf4j.Slf4j;
import org.testng.annotations.DataProvider;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Processor for CSSmartDataProvider annotation
 */
@Slf4j
public class DataProviderProcessor {

    /**
     * TestNG data provider method that processes CSSmartDataProvider annotation
     * 
     * @param method Test method
     * @return Iterator of Object arrays for TestNG
     */
    @DataProvider(name = "smartDataProvider", parallel = true)
    public static Iterator<Object[]> provideData(Method method) {
        // Get the annotation
        CSSmartDataProvider annotation = method.getAnnotation(CSSmartDataProvider.class);
        if (annotation == null) {
            throw new IllegalStateException("Method " + method.getName() + " is not annotated with @CSSmartDataProvider");
        }
        
        try {
            // Create data provider
            com.cssmart.data.DataProvider dataProvider = createDataProvider(annotation);
            
            // Apply filter if specified
            if (!annotation.filter().isEmpty()) {
                dataProvider = applyFilter(dataProvider, annotation.filter());
            }
            
            // Apply sort if specified
            if (!annotation.sort().isEmpty()) {
                dataProvider = applySort(dataProvider, annotation.sort());
            }
            
            log.info("Created data provider for method {} with {} rows", method.getName(), dataProvider.getRowCount());
            return dataProvider.getDataIterator();
        } catch (Exception e) {
            log.error("Error creating data provider for method " + method.getName(), e);
            throw new RuntimeException("Failed to create data provider: " + e.getMessage(), e);
        }
    }
    
    /**
     * Create a data provider based on annotation
     * 
     * @param annotation CSSmartDataProvider annotation
     * @return DataProvider instance
     * @throws Exception if data provider creation fails
     */
    private static com.cssmart.data.DataProvider createDataProvider(CSSmartDataProvider annotation) throws Exception {
        switch (annotation.type()) {
            case CSV:
                return createCsvDataProvider(annotation);
                
            case EXCEL:
                return createExcelDataProvider(annotation);
                
            case JSON:
                return createJsonDataProvider(annotation);
                
            case RANDOM:
                return createRandomDataProvider(annotation);
                
            case SQL:
                return createSqlDataProvider(annotation);
                
            case XML:
                throw new UnsupportedOperationException("XML data provider not yet implemented");
                
            default:
                throw new IllegalArgumentException("Unknown data provider type: " + annotation.type());
        }
    }
    
    /**
     * Create a CSV data provider
     * 
     * @param annotation CSSmartDataProvider annotation
     * @return CSVDataProvider instance
     * @throws IOException if file cannot be read
     */
    private static com.cssmart.data.DataProvider createCsvDataProvider(CSSmartDataProvider annotation) throws IOException {
        if (annotation.path().isEmpty()) {
            throw new IllegalArgumentException("Path must be specified for CSV data provider");
        }
        
        if (annotation.classpath()) {
            try (InputStream is = DataProviderProcessor.class.getResourceAsStream(annotation.path())) {
                return new CSVDataProvider(is, annotation.hasHeaders(), annotation.separator());
            }
        } else {
            return new CSVDataProvider(annotation.path(), annotation.hasHeaders(), annotation.separator());
        }
    }
    
    /**
     * Create an Excel data provider
     * 
     * @param annotation CSSmartDataProvider annotation
     * @return ExcelDataProvider instance
     * @throws IOException if file cannot be read
     */
    private static com.cssmart.data.DataProvider createExcelDataProvider(CSSmartDataProvider annotation) throws IOException {
        if (annotation.path().isEmpty()) {
            throw new IllegalArgumentException("Path must be specified for Excel data provider");
        }
        
        // Determine sheet index or name
        String sheet = annotation.sheet();
        
        if (annotation.classpath()) {
            boolean isXlsx = annotation.path().toLowerCase().endsWith(".xlsx");
            try (InputStream is = DataProviderProcessor.class.getResourceAsStream(annotation.path())) {
                if (is == null) {
                    throw new IOException("Resource not found: " + annotation.path());
                }
                
                // Try to parse sheet as index
                try {
                    int sheetIndex = Integer.parseInt(sheet);
                    return new ExcelDataProvider(is, isXlsx, sheetIndex);
                } catch (NumberFormatException e) {
                    // Sheet is a name, not an index
                    // This would require extending ExcelDataProvider to support sheet by name
                    throw new UnsupportedOperationException("Sheet by name not supported for classpath resources");
                }
            }
        } else {
            // Try to parse sheet as index
            try {
                int sheetIndex = Integer.parseInt(sheet);
                return new ExcelDataProvider(annotation.path(), sheetIndex);
            } catch (NumberFormatException e) {
                // Sheet is a name, not an index
                // This would require extending ExcelDataProvider to support sheet by name
                throw new UnsupportedOperationException("Sheet by name not supported yet");
            }
        }
    }
    
    /**
     * Create a JSON data provider
     * 
     * @param annotation CSSmartDataProvider annotation
     * @return JSONDataProvider instance
     * @throws IOException if file cannot be read
     */
    private static com.cssmart.data.DataProvider createJsonDataProvider(CSSmartDataProvider annotation) throws IOException {
        if (annotation.path().isEmpty()) {
            throw new IllegalArgumentException("Path must be specified for JSON data provider");
        }
        
        String jsonPath = annotation.jsonPath().isEmpty() ? null : annotation.jsonPath();
        
        if (annotation.classpath()) {
            try (InputStream is = DataProviderProcessor.class.getResourceAsStream(annotation.path())) {
                return new JSONDataProvider(is, jsonPath);
            }
        } else {
            return new JSONDataProvider(annotation.path(), jsonPath);
        }
    }
    
    /**
     * Create a random data provider
     * 
     * @param annotation CSSmartDataProvider annotation
     * @return RandomDataGenerator instance
     */
    private static com.cssmart.data.DataProvider createRandomDataProvider(CSSmartDataProvider annotation) {
        int rows = Math.max(1, annotation.rows());
        
        // Use template if specified
        String template = annotation.template();
        if (!template.isEmpty()) {
            switch (template.toLowerCase()) {
                case "user":
                    return RandomDataGenerator.createUserDataProvider(rows);
                case "product":
                    return RandomDataGenerator.createProductDataProvider(rows);
                case "order":
                    return RandomDataGenerator.createOrderDataProvider(rows);
                default:
                    log.warn("Unknown template: {}. Using default random data.", template);
            }
        }
        
        // Use columns if specified
        String[] columns = annotation.columns();
        if (columns.length > 0) {
            return new RandomDataGenerator(rows, Arrays.asList(columns));
        }
        
        // Default random data
        return new RandomDataGenerator(rows);
    }
    
    /**
     * Create an SQL data provider
     * 
     * @param annotation CSSmartDataProvider annotation
     * @return SQLDataProvider instance
     * @throws Exception if SQL query fails
     */
    private static com.cssmart.data.DataProvider createSqlDataProvider(CSSmartDataProvider annotation) throws Exception {
        if (annotation.query().isEmpty()) {
            throw new IllegalArgumentException("Query must be specified for SQL data provider");
        }
        
        return new SQLDataProvider(annotation.datasource(), annotation.query());
    }
    
    /**
     * Apply filter to data provider
     * 
     * @param dataProvider DataProvider to filter
     * @param filterExpression Filter expression (e.g., "column=value" or "column!=value")
     * @return Filtered DataProvider
     */
    private static com.cssmart.data.DataProvider applyFilter(com.cssmart.data.DataProvider dataProvider, String filterExpression) {
        if (filterExpression.isEmpty()) {
            return dataProvider;
        }
        
        // Parse filter expression
        String[] parts;
        boolean isEquality = true;
        
        if (filterExpression.contains("!=")) {
            parts = filterExpression.split("!=", 2);
            isEquality = false;
        } else if (filterExpression.contains("=")) {
            parts = filterExpression.split("=", 2);
        } else {
            throw new IllegalArgumentException("Invalid filter expression: " + filterExpression);
        }
        
        if (parts.length != 2) {
            throw new IllegalArgumentException("Invalid filter expression: " + filterExpression);
        }
        
        String column = parts[0].trim();
        String valueStr = parts[1].trim();
        
        // Convert value to appropriate type
        Object value = convertStringToTypedValue(valueStr);
        
        // Apply filter
        List<Map<String, Object>> allData = dataProvider.getAllData();
        List<Map<String, Object>> filteredData = allData.stream()
                .filter(row -> {
                    Object rowValue = row.get(column);
                    boolean matches = (rowValue == value) || (rowValue != null && rowValue.equals(value));
                    return isEquality ? matches : !matches;
                })
                .collect(Collectors.toList());
        
        // Create new provider with filtered data
        // This would require extending DataProvider to support creation from data
        // For now, just return the original provider with a warning
        log.warn("Filtering not fully implemented yet. Returning original data provider.");
        return dataProvider;
    }
    
    /**
     * Apply sort to data provider
     * 
     * @param dataProvider DataProvider to sort
     * @param sortExpression Sort expression (e.g., "column" or "column:desc")
     * @return Sorted DataProvider
     */
    private static com.cssmart.data.DataProvider applySort(com.cssmart.data.DataProvider dataProvider, String sortExpression) {
        if (sortExpression.isEmpty()) {
            return dataProvider;
        }
        
        // Parse sort expression
        String[] parts = sortExpression.split(":", 2);
        String column = parts[0].trim();
        boolean ascending = parts.length == 1 || !parts[1].trim().equalsIgnoreCase("desc");
        
        // Apply sort
        return dataProvider.sort(column, ascending);
    }
    
    /**
     * Convert string to typed value (Integer, Double, Boolean, or String)
     * 
     * @param value String value
     * @return Typed value
     */
    private static Object convertStringToTypedValue(String value) {
        if (value == null) return null;
        value = value.trim();
        if (value.isEmpty()) return null;
        
        // Try boolean
        if (value.equalsIgnoreCase("true")) return Boolean.TRUE;
        if (value.equalsIgnoreCase("false")) return Boolean.FALSE;
        
        // Try number
        try {
            // Check if it's an integer
            if (!value.contains(".")) {
                try {
                    return Integer.parseInt(value);
                } catch (NumberFormatException e) {
                    try {
                        return Long.parseLong(value);
                    } catch (NumberFormatException e2) {
                        // Not an integer, try double
                    }
                }
            }
            
            // Try double
            return Double.parseDouble(value);
        } catch (NumberFormatException e) {
            // Not a number, return as string
            return value;
        }
    }
}


package com.cssmart.data.provider;

import com.cssmart.data.AbstractDataProvider;
import com.cssmart.data.DataProvider;
import lombok.extern.slf4j.Slf4j;

import javax.sql.DataSource;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Data provider for SQL databases
 */
@Slf4j
public class SQLDataProvider extends AbstractDataProvider {
    
    private final List<Map<String, Object>> data;
    private final List<String> columns;
    
    /**
     * Create a new SQL data provider using the default datasource
     * 
     * @param query SQL query
     * @throws SQLException If query execution fails
     */
    public SQLDataProvider(String query) throws SQLException {
        this(null, query);
    }
    
    /**
     * Create a new SQL data provider
     * 
     * @param datasourceName Name of datasource
     * @param query SQL query
     * @throws SQLException If query execution fails
     */
    public SQLDataProvider(String datasourceName, String query) throws SQLException {
        // Get datasource
        DataSource dataSource = getDataSource(datasourceName);
        
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {
            
            ResultSetMetaData metaData = rs.getMetaData();
            int columnCount = metaData.getColumnCount();
            
            // Extract column names
            List<String> columnNames = new ArrayList<>();
            for (int i = 1; i <= columnCount; i++) {
                columnNames.add(metaData.getColumnLabel(i));
            }
            
            // Extract data
            List<Map<String, Object>> rows = new ArrayList<>();
            while (rs.next()) {
                Map<String, Object> row = new LinkedHashMap<>();
                for (int i = 1; i <= columnCount; i++) {
                    row.put(columnNames.get(i - 1), rs.getObject(i));
                }
                rows.add(row);
            }
            
            this.columns = columnNames;
            this.data = rows;
        }
    }
    
    /**
     * Create a new SQL data provider from existing data
     * 
     * @param data List of data row maps
     * @param columns List of column names
     */
    private SQLDataProvider(List<Map<String, Object>> data, List<String> columns) {
        this.data = new ArrayList<>(data);
        this.columns = new ArrayList<>(columns);
    }
    
    @Override
    public List<Map<String, Object>> getAllData() {
        return Collections.unmodifiableList(data);
    }
    
    @Override
    public List<String> getColumns() {
        return Collections.unmodifiableList(columns);
    }
    
    @Override
    public DataProvider filter(String column, Object value) {
        List<Map<String, Object>> filteredData = data.stream()
                .filter(row -> Objects.equals(row.get(column), value))
                .collect(Collectors.toList());
        
        return new SQLDataProvider(filteredData, columns);
    }
    
    @Override
    public DataProvider sort(String column, boolean ascending) {
        List<Map<String, Object>> sortedData = new ArrayList<>(data);
        
        sortedData.sort((row1, row2) -> {
            Object val1 = row1.get(column);
            Object val2 = row2.get(column);
            
            if (val1 == null && val2 == null) return 0;
            if (val1 == null) return ascending ? -1 : 1;
            if (val2 == null) return ascending ? 1 : -1;
            
            if (val1 instanceof Comparable && val1.getClass().equals(val2.getClass())) {
                @SuppressWarnings("unchecked")
                int result = ((Comparable<Object>) val1).compareTo(val2);
                return ascending ? result : -result;
            }
            
            // Fallback to string comparison
            String str1 = String.valueOf(val1);
            String str2 = String.valueOf(val2);
            return ascending ? str1.compareTo(str2) : str2.compareTo(str1);
        });
        
        return new SQLDataProvider(sortedData, columns);
    }
    
    /**
     * Get DataSource by name
     * 
     * @param datasourceName Name of datasource
     * @return DataSource
     */
    private DataSource getDataSource(String datasourceName) {
        // In a real implementation, this would look up the datasource from JNDI or a registry
        // For now, we'll return a mock datasource for demonstration
        return new MockDataSource(datasourceName);
    }
    
    /**
     * Mock DataSource for demonstration purposes
     */
    private static class MockDataSource implements DataSource {
        private final String name;
        
        public MockDataSource(String name) {
            this.name = name;
        }
        
        @Override
        public Connection getConnection() throws SQLException {
            throw new UnsupportedOperationException("Mock DataSource does not support getConnection");
        }
        
        @Override
        public Connection getConnection(String username, String password) throws SQLException {
            throw new UnsupportedOperationException("Mock DataSource does not support getConnection");
        }
        
        @Override
        public PrintWriter getLogWriter() throws SQLException {
            return null;
        }
        
        @Override
        public void setLogWriter(PrintWriter out) throws SQLException {
            // Not implemented
        }
        
        @Override
        public void setLoginTimeout(int seconds) throws SQLException {
            // Not implemented
        }
        
        @Override
        public int getLoginTimeout() throws SQLException {
            return 0;
        }
        
        @Override
        public <T> T unwrap(Class<T> iface) throws SQLException {
            throw new SQLException("MockDataSource does not wrap " + iface.getName());
        }
        
        @Override
        public boolean isWrapperFor(Class<?> iface) throws SQLException {
            return false;
        }
        
        // JDK 7+ methods
        public java.util.logging.Logger getParentLogger() {
            return java.util.logging.Logger.getLogger(java.util.logging.Logger.GLOBAL_LOGGER_NAME);
        }
    }
}


package com.cssmart.core;

import com.cssmart.ai.engine.AIEngine;
import com.cssmart.ai.engine.model.ElementAnalysis;
import com.cssmart.ai.engine.model.Locator;
import com.cssmart.ai.engine.model.Action;
import com.cssmart.config.ConfigurationManager;
import com.cssmart.config.EnvironmentManager;
import com.cssmart.core.annotation.CSSmartDataProvider;
import com.cssmart.core.processor.DataProviderProcessor;
import com.cssmart.driver.BrowserManager;
import com.cssmart.driver.DriverManager;
import com.cssmart.reporting.ReportManager;
import com.cssmart.reporting.ScreenshotManager;
import com.cssmart.ui.controls.*;

import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;
import org.testng.ITestContext;
import org.testng.ITestResult;
import org.testng.annotations.*;

import java.io.File;
import java.lang.reflect.Method;
import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * Base class for all test classes that provides common functionality and lifecycle management
 */
@Slf4j
public class CSSmartTestBase {
    protected WebDriver driver;
    protected AIEngine aiEngine;
    protected ConfigurationManager config;
    protected TestContext testContext;
    protected ReportManager reportManager;
    protected UIControlFactory controlFactory;
    
    private String testName;
    private String testDescription;
    private String[] testTags;
    private Map<String, Object> testData; // Current data row for data-driven tests
    
    @BeforeSuite(alwaysRun = true)
    public void beforeSuite() {
        log.info("Starting test suite execution");
        config = ConfigurationManager.getInstance();
        EnvironmentManager.initialize(config.getEnvironment());
        reportManager = ReportManager.getInstance();
        reportManager.startSuite();
        
        // Initialize AI Engine
        aiEngine = AIEngine.getInstance();
        aiEngine.initialize();
    }
    
    @BeforeClass(alwaysRun = true)
    public void beforeClass() {
        log.info("Starting test class: {}", getClass().getSimpleName());
        testContext = new TestContext();
    }
    
    @BeforeMethod(alwaysRun = true)
    public void beforeMethod(Method method, Object[] params, ITestResult testResult) {
        // Get test metadata from annotation
        CSSmartTest testAnnotation = method.getAnnotation(CSSmartTest.class);
        
        // Handle data-driven tests
        if (params != null && params.length > 0 && params[0] instanceof Map) {
            @SuppressWarnings("unchecked")
            Map<String, Object> dataRow = (Map<String, Object>) params[0];
            testData = dataRow;
            log.info("Test data: {}", testData);
        } else {
            testData = null;
        }
        
        if (testAnnotation != null) {
            testName = testAnnotation.name().isEmpty() ? method.getName() : testAnnotation.name();
            testDescription = testAnnotation.description();
            testTags = testAnnotation.tags();
            
            String browser = testAnnotation.browser().isEmpty() ? 
                    config.getDefaultBrowser() : testAnnotation.browser();
            
            // Initialize driver with configuration from annotation
            initializeDriver(browser);
        } else {
            testName = method.getName();
            testDescription = "";
            testTags = new String[0];
            
            // Initialize driver with default configuration
            initializeDriver(config.getDefaultBrowser());
        }
        
        // For data-driven tests, append data identifier to test name
        if (testData != null) {
            // Find a suitable identifier column
            String identifier = findIdentifierColumn(testData);
            if (identifier != null) {
                testName += " [" + identifier + "]";
            }
        }
        
        log.info("Starting test: {}", testName);
        reportManager.startTest(testName, testDescription, testTags);
        
        // Initialize UI Control Factory
        controlFactory = new UIControlFactory(driver);
    }
    
    @AfterMethod(alwaysRun = true)
    public void afterMethod(ITestResult result) {
        if (result.getStatus() == ITestResult.FAILURE) {
            log.error("Test failed: {}", result.getName());
            reportManager.testFailed(result.getThrowable());
            
            // Capture screenshot on failure
            if (driver != null) {
                byte[] screenshot = ScreenshotManager.takeScreenshot(driver);
                reportManager.addScreenshot("Failure Screenshot", screenshot);
            }
        } else if (result.getStatus() == ITestResult.SUCCESS) {
            log.info("Test passed: {}", result.getName());
            reportManager.testPassed();
        } else {
            log.warn("Test skipped: {}", result.getName());
            reportManager.testSkipped();
        }
        
        // Clean up driver if needed
        if (driver != null && !config.isKeepBrowserOpenBetweenTests()) {
            quitDriver();
        }
        
        // Clear test data
        testData = null;
    }
    
    @AfterClass(alwaysRun = true)
    public void afterClass() {
        log.info("Finished test class: {}", getClass().getSimpleName());
        testContext.clear();
    }
    
    @AfterSuite(alwaysRun = true)
    public void afterSuite() {
        log.info("Finished test suite execution");
        reportManager.endSuite();
        
        // Clean up resources
        if (driver != null) {
            quitDriver();
        }
    }
    
    /**
     * TestNG data provider that processes CSSmartDataProvider annotation
     * 
     * @param method Test method
     * @param context Test context
     * @return Iterator of Object arrays for TestNG
     */
    @DataProvider(name = "smartDataProvider", parallel = true)
    public Iterator<Object[]> smartDataProvider(Method method, ITestContext context) {
        return DataProviderProcessor.provideData(method);
    }
    
    /**
     * Initializes the WebDriver with the specified browser
     * @param browser the browser to use
     */
    protected void initializeDriver(String browser) {
        log.info("Initializing WebDriver for browser: {}", browser);
        
        // Get driver configuration
        int implicitWaitSeconds = config.getImplicitWaitSeconds();
        int pageLoadTimeoutSeconds = config.getPageLoadTimeoutSeconds();
        int scriptTimeoutSeconds = config.getScriptTimeoutSeconds();
        boolean maximizeBrowser = config.isMaximizeBrowser();
        Map<String, Object> capabilities = config.getBrowserCapabilities(browser);
        
        // Create driver
        driver = DriverManager.createDriver(browser, capabilities);
        
        // Configure timeouts
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(implicitWaitSeconds));
        driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(pageLoadTimeoutSeconds));
        driver.manage().timeouts().scriptTimeout(Duration.ofSeconds(scriptTimeoutSeconds));
        
        // Maximize if configured
        if (maximizeBrowser) {
            driver.manage().window().maximize();
        }
        
        // Set window size if not maximized
        if (!maximizeBrowser && config.getBrowserWidth() > 0 && config.getBrowserHeight() > 0) {
            driver.manage().window().setSize(
                    new Dimension(config.getBrowserWidth(), config.getBrowserHeight()));
        }
        
        // Add driver to test context
        testContext.set("driver", driver);
    }
    
    /**
     * Quits the WebDriver and cleans up resources
     */
    protected void quitDriver() {
        if (driver != null) {
            try {
                log.info("Quitting WebDriver");
                driver.quit();
            } catch (Exception e) {
                log.error("Error quitting WebDriver", e);
            } finally {
                driver = null;
                DriverManager.removeDriver();
            }
        }
    }
    
    /**
     * Navigates to the specified URL
     * @param url the URL to navigate to
     */
    protected void navigateTo(String url) {
        log.info("Navigating to URL: {}", url);
        driver.get(url);
        reportManager.logStep("Navigated to " + url);
    }
    
    /**
     * Gets a value from current test data
     * @param column the column name
     * @return the value
     */
    protected Object getTestData(String column) {
        if (testData == null) {
            throw new IllegalStateException("No test data available. Make sure the test is using @CSSmartDataProvider.");
        }
        return testData.get(column);
    }
    
    /**
     * Gets a string value from current test data
     * @param column the column name
     * @return the string value
     */
    protected String getTestDataString(String column) {
        Object value = getTestData(column);
        return value != null ? value.toString() : null;
    }
    
    /**
     * Gets an integer value from current test data
     * @param column the column name
     * @return the integer value
     */
    protected Integer getTestDataInteger(String column) {
        Object value = getTestData(column);
        if (value == null) return null;
        if (value instanceof Number) return ((Number) value).intValue();
        try {
            return Integer.parseInt(value.toString());
        } catch (NumberFormatException e) {
            throw new IllegalStateException("Value for column '" + column + "' is not an integer: " + value);
        }
    }
    
    /**
     * Gets a double value from current test data
     * @param column the column name
     * @return the double value
     */
    protected Double getTestDataDouble(String column) {
        Object value = getTestData(column);
        if (value == null) return null;
        if (value instanceof Number) return ((Number) value).doubleValue();
        try {
            return Double.parseDouble(value.toString());
        } catch (NumberFormatException e) {
            throw new IllegalStateException("Value for column '" + column + "' is not a number: " + value);
        }
    }
    
    /**
     * Gets a boolean value from current test data
     * @param column the column name
     * @return the boolean value
     */
    protected Boolean getTestDataBoolean(String column) {
        Object value = getTestData(column);
        if (value == null) return null;
        if (value instanceof Boolean) return (Boolean) value;
        String str = value.toString().toLowerCase();
        if (str.equals("true") || str.equals("yes") || str.equals("1")) return true;
        if (str.equals("false") || str.equals("no") || str.equals("0")) return false;
        throw new IllegalStateException("Value for column '" + column + "' is not a boolean: " + value);
    }
    
    /**
     * Gets the current test data map
     * @return the test data map
     */
    protected Map<String, Object> getTestData() {
        if (testData == null) {
            throw new IllegalStateException("No test data available. Make sure the test is using @CSSmartDataProvider.");
        }
        return testData;
    }
    
    /**
     * Finds the best column to use as an identifier for the test name
     * 
     * @param data Test data row
     * @return Identifier value as string
     */
    private String findIdentifierColumn(Map<String, Object> data) {
        // Try common identifier columns
        String[] possibleIdColumns = {"id", "ID", "Id", "name", "Name", "key", "Key", "testId", "testName"};
        
        for (String column : possibleIdColumns) {
            if (data.containsKey(column) && data.get(column) != null) {
                return data.get(column).toString();
            }
        }
        
        // If no suitable column found, use the first non-null value
        for (Map.Entry<String, Object> entry : data.entrySet()) {
            if (entry.getValue() != null) {
                return entry.getKey() + "=" + entry.getValue();
            }
        }
        
        // If all else fails, return a hash code
        return "data_" + data.hashCode();
    }
    
    // All the UI control and element finder methods from the original class...
    // (The rest of the class remains the same)
    
    // Here's just one example to show how the existing methods would be used with data:
    /**
     * Types text into an element, supports substituting test data
     * @param description natural language description of the element
     * @param text the text to type, can contain ${column} placeholders for test data
     */
    protected void type(String description, String text) {
        // Substitute test data if available
        if (testData != null && text.contains("${")) {
            text = substituteTestData(text);
        }
        
        log.info("Typing '{}' into {}", text, description);
        TextField textField = controlFactory.textField(description);
        textField.type(text);
        reportManager.logStep("Typed '" + text + "' into " + description);
    }
    
    /**
     * Substitutes ${column} placeholders in text with test data values
     * 
     * @param text Text with placeholders
     * @return Text with substituted values
     */
    protected String substituteTestData(String text) {
        if (testData == null || !text.contains("${")) {
            return text;
        }
        
        String result = text;
        for (Map.Entry<String, Object> entry : testData.entrySet()) {
            String placeholder = "${" + entry.getKey() + "}";
            if (result.contains(placeholder)) {
                String value = entry.getValue() != null ? entry.getValue().toString() : "";
                result = result.replace(placeholder, value);
            }
        }
        
        return result;
    }
    
    /**
     * Extract number from text (e.g., "123 results found" -> 123)
     * 
     * @param text Text containing a number
     * @return Extracted number
     */
    protected int extractNumberFromText(String text) {
        if (text == null || text.isEmpty()) {
            return 0;
        }
        
        // Extract digits from the text
        String digits = text.replaceAll("[^0-9]", "");
        if (digits.isEmpty()) {
            return 0;
        }
        
        try {
            return Integer.parseInt(digits);
        } catch (NumberFormatException e) {
            log.warn("Failed to extract number from text: {}", text);
            return 0;
        }
    }
}


package com.cssmart.examples;

import com.cssmart.core.CSSmartTestBase;
import com.cssmart.core.CSSmartTest;
import com.cssmart.core.annotation.CSSmartDataProvider;
import org.testng.Assert;
import org.testng.annotations.Test;

import java.util.Map;

/**
 * Example of using CSSmartDataProvider annotation for data-driven testing
 */
public class DataProviderExampleTest extends CSSmartTestBase {

    /**
     * Test login functionality with data from CSV
     * 
     * @param data Test data row
     */
    @Test(dataProvider = "smartDataProvider")
    @CSSmartTest(
        name = "CSV Data Provider Test",
        description = "Test login functionality with data from CSV",
        tags = {"data-driven", "login"}
    )
    @CSSmartDataProvider(
        type = CSSmartDataProvider.Type.CSV,
        path = "/data/login-credentials.csv",
        classpath = true
    )
    public void testLoginWithCSVData(Map<String, Object> data) {
        // Access test data directly from the data map
        String username = (String) data.get("username");
        String password = (String) data.get("password");
        boolean expectedResult = (Boolean) data.get("valid");
        
        log.info("Testing login with username: {}, expected result: {}", username, expectedResult);
        
        // Navigate to login page
        navigateTo("https://example.com/login");
        
        // Enter credentials
        type("username field", username);
        type("password field", password);
        
        // Click login button
        click("login button");
        
        // Verify result
        if (expectedResult) {
            verifyTextPresent("Welcome");
        } else {
            verifyTextPresent("Invalid username or password");
        }
    }
    
    /**
     * Test product search with data from Excel
     * 
     * @param data Test data row
     */
    @Test(dataProvider = "smartDataProvider")
    @CSSmartTest(
        name = "Excel Data Provider Test",
        description = "Test product search with data from Excel",
        tags = {"data-driven", "search"}
    )
    @CSSmartDataProvider(
        type = CSSmartDataProvider.Type.EXCEL,
        path = "/data/search-terms.xlsx",
        sheet = "SearchTerms",
        classpath = true
    )
    public void testProductSearchWithExcelData(Map<String, Object> data) {
        // Use the helper methods for type-safe data access
        String searchTerm = getTestDataString("searchTerm");
        Integer expectedResults = getTestDataInteger("expectedResults");
        String category = getTestDataString("category");
        
        log.info("Testing search with term: {}, category: {}, expected results: {}", 
                searchTerm, category, expectedResults);
        
        // Navigate to search page
        navigateTo("https://example.com/search");
        
        // Enter search term
        type("search field", searchTerm);
        
        // Select category if provided
        if (category != null && !category.isEmpty()) {
            selectByText("category dropdown", category);
        }
        
        // Click search button
        click("search button");
        
        // Verify results count
        String resultText = getText("search results count");
        int actualResults = extractNumberFromText(resultText);
        
        Assert.assertEquals(actualResults, expectedResults.intValue(), 
                "Search results count does not match expected value");
    }
    
    /**
     * Test checkout process with data from JSON
     * 
     * @param data Test data row
     */
    @Test(dataProvider = "smartDataProvider")
    @CSSmartTest(
        name = "JSON Data Provider Test",
        description = "Test checkout process with data from JSON",
        tags = {"data-driven", "checkout"}
    )
    @CSSmartDataProvider(
        type = CSSmartDataProvider.Type.JSON,
        path = "/data/checkout-scenarios.json",
        jsonPath = "scenarios",
        classpath = true
    )
    public void testCheckoutWithJSONData(Map<String, Object> data) {
        // Access test data
        String scenario = getTestDataString("scenario");
        String paymentMethod = getTestDataString("paymentMethod");
        Double orderTotal = getTestDataDouble("orderTotal");
        Boolean expectedSuccess = getTestDataBoolean("expectedSuccess");
        
        log.info("Testing checkout scenario: {}, payment: {}, total: {}, expected: {}", 
                scenario, paymentMethod, orderTotal, expectedSuccess);
        
        // Navigate to checkout page
        navigateTo("https://example.com/checkout");
        
        // Fill delivery address
        type("address line 1", "${addressLine1}");
        type("address line 2", "${addressLine2}");
        type("city", "${city}");
        type("state", "${state}");
        type("zip code", "${zipCode}");
        
        // Select payment method
        click(paymentMethod + " payment option");
        
        // Fill payment details based on payment method
        if ("credit_card".equals(paymentMethod)) {
            type("card number", "${cardNumber}");
            type("card expiry", "${cardExpiry}");
            type("card cvv", "${cardCVV}");
        } else if ("paypal".equals(paymentMethod)) {
            click("paypal button");
            type("paypal email", "${paypalEmail}");
            type("paypal password", "${paypalPassword}");
        }
        
        // Complete order
        click("place order button");
        
        // Verify result
        if (expectedSuccess) {
            verifyTextPresent("Order Confirmation");
            String orderNumber = getText("order number");
            Assert.assertFalse(orderNumber.isEmpty(), "Order number should not be empty");
            
            // Verify order total
            String totalText = getText("order total");
            double actualTotal = extractTotalFromText(totalText);
            Assert.assertEquals(actualTotal, orderTotal, 0.01, 
                    "Order total does not match expected value");
        } else {
            verifyTextPresent("There was a problem with your payment");
        }
    }
    
    /**
     * Test user registration with random data
     * 
     * @param data Test data row
     */
    @Test(dataProvider = "smartDataProvider")
    @CSSmartTest(
        name = "Random Data Provider Test",
        description = "Test user registration with random data",
        tags = {"data-driven", "registration"}
    )
    @CSSmartDataProvider(
        type = CSSmartDataProvider.Type.RANDOM,
        rows = 5,
        template = "user"
    )
    public void testRegistrationWithRandomData(Map<String, Object> data) {
        // Access test data
        String firstName = getTestDataString("first_name");
        String lastName = getTestDataString("last_name");
        String email = getTestDataString("email");
        String username = getTestDataString("username");
        String password = getTestDataString("password");
        
        log.info("Testing registration with username: {}, email: {}", username, email);
        
        // Navigate to registration page
        navigateTo("https://example.com/register");
        
        // Fill registration form
        type("first name field", firstName);
        type("last name field", lastName);
        type("email field", email);
        type("username field", username);
        type("password field", password);
        type("confirm password field", password);
        
        // Accept terms
        setChecked("terms checkbox", true);
        
        // Submit form
        click("register button");
        
        // Verify successful registration
        verifyTextPresent("Registration Successful");
        verifyTextPresent("Welcome, " + firstName);
    }
    
    /**
     * Extract total amount from text (e.g., "$123.45" -> 123.45)
     * 
     * @param text Text containing a currency amount
     * @return Extracted amount
     */
    private double extractTotalFromText(String text) {
        if (text == null || text.isEmpty()) {
            return 0;
        }
        
        // Remove currency symbols and non-numeric characters except decimal point
        String cleaned = text.replaceAll("[^0-9.]", "");
        if (cleaned.isEmpty()) {
            return 0;
        }
        
        try {
            return Double.parseDouble(cleaned);
        } catch (NumberFormatException e) {
            log.warn("Failed to extract amount from text: {}", text);
            return 0;
        }
    }
}


package com.cssmart.bdd;

import com.cssmart.ai.engine.AIEngine;
import com.cssmart.config.ConfigurationManager;
import com.cssmart.core.TestContext;
import com.cssmart.driver.DriverManager;
import com.cssmart.reporting.ReportManager;
import com.cssmart.ui.controls.UIControlFactory;
import io.cucumber.java.After;
import io.cucumber.java.Before;
import io.cucumber.java.Scenario;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.Dimension;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;

import java.time.Duration;
import java.util.Map;

/**
 * Base class for Cucumber step definitions
 * Provides common functionality and Cucumber lifecycle management
 */
@Slf4j
public class CSSmartStepDefinitionBase {
    
    protected WebDriver driver;
    protected AIEngine aiEngine;
    protected ConfigurationManager config;
    protected TestContext testContext;
    protected ReportManager reportManager;
    protected UIControlFactory controlFactory;
    protected Scenario currentScenario;
    
    /**
     * Initialize before scenario
     * 
     * @param scenario Cucumber scenario
     */
    @Before
    public void setUp(Scenario scenario) {
        log.info("Starting scenario: {}", scenario.getName());
        
        // Store current scenario
        this.currentScenario = scenario;
        
        // Initialize configuration
        config = ConfigurationManager.getInstance();
        
        // Initialize test context
        testContext = new TestContext();
        
        // Initialize AI Engine
        aiEngine = AIEngine.getInstance();
        
        // Initialize reporting
        reportManager = ReportManager.getInstance();
        
        // Initialize driver with default browser
        initializeDriver(config.getDefaultBrowser());
        
        // Initialize UI Control Factory
        controlFactory = new UIControlFactory(driver);
        
        // Set context values
        testContext.set("driver", driver);
        testContext.set("scenario", scenario);
        
        reportManager.startTest(scenario.getName(), "", new String[]{"cucumber"});
    }
    
    /**
     * Clean up after scenario
     * 
     * @param scenario Cucumber scenario
     */
    @After
    public void tearDown(Scenario scenario) {
        log.info("Finishing scenario: {}", scenario.getName());
        
        // Take screenshot if scenario failed
        if (scenario.isFailed()) {
            log.error("Scenario failed: {}", scenario.getName());
            
            if (driver instanceof TakesScreenshot) {
                byte[] screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);
                scenario.attach(screenshot, "image/png", "Failure Screenshot");
                reportManager.addScreenshot("Failure Screenshot", screenshot);
            }
            
            reportManager.testFailed(null);
        } else {
            log.info("Scenario passed: {}", scenario.getName());
            reportManager.testPassed();
        }
        
        // Quit driver
        quitDriver();
        
        // Clear context
        testContext.clear();
    }
    
    /**
     * Initializes the WebDriver with the specified browser
     * 
     * @param browser the browser to use
     */
    protected void initializeDriver(String browser) {
        log.info("Initializing WebDriver for browser: {}", browser);
        
        // Get driver configuration
        int implicitWaitSeconds = config.getImplicitWaitSeconds();
        int pageLoadTimeoutSeconds = config.getPageLoadTimeoutSeconds();
        int scriptTimeoutSeconds = config.getScriptTimeoutSeconds();
        boolean maximizeBrowser = config.isMaximizeBrowser();
        Map<String, Object> capabilities = config.getBrowserCapabilities(browser);
        
        // Create driver
        driver = DriverManager.createDriver(browser, capabilities);
        
        // Configure timeouts
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(implicitWaitSeconds));
        driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(pageLoadTimeoutSeconds));
        driver.manage().timeouts().scriptTimeout(Duration.ofSeconds(scriptTimeoutSeconds));
        
        // Maximize if configured
        if (maximizeBrowser) {
            driver.manage().window().maximize();
        }
        
        // Set window size if not maximized
        if (!maximizeBrowser && config.getBrowserWidth() > 0 && config.getBrowserHeight() > 0) {
            driver.manage().window().setSize(
                    new Dimension(config.getBrowserWidth(), config.getBrowserHeight()));
        }
    }
    
    /**
     * Quits the WebDriver and cleans up resources
     */
    protected void quitDriver() {
        if (driver != null) {
            try {
                log.info("Quitting WebDriver");
                driver.quit();
            } catch (Exception e) {
                log.error("Error quitting WebDriver", e);
            } finally {
                driver = null;
                DriverManager.removeDriver();
            }
        }
    }
    
    // Common Cucumber step definitions
    
    /**
     * Step to navigate to a URL
     * 
     * @param url URL to navigate to
     */
    @Given("I navigate to {string}")
    public void i_navigate_to(String url) {
        log.info("Navigating to URL: {}", url);
        driver.get(url);
        currentScenario.log("Navigated to " + url);
        reportManager.logStep("Navigated to " + url);
    }
    
    /**
     * Step to type text into an element
     * 
     * @param text Text to type
     * @param elementDescription Element description
     */
    @When("I type {string} into {string}")
    public void i_type_into(String text, String elementDescription) {
        log.info("Typing '{}' into {}", text, elementDescription);
        controlFactory.textField(elementDescription).type(text);
        currentScenario.log("Typed '" + text + "' into " + elementDescription);
        reportManager.logStep("Typed '" + text + "' into " + elementDescription);
    }
    
    /**
     * Step to click an element
     * 
     * @param elementDescription Element description
     */
    @When("I click on {string}")
    public void i_click_on(String elementDescription) {
        log.info("Clicking on {}", elementDescription);
        controlFactory.createControl(elementDescription).click();
        currentScenario.log("Clicked on " + elementDescription);
        reportManager.logStep("Clicked on " + elementDescription);
    }
    
    /**
     * Step to check if element is displayed
     * 
     * @param elementDescription Element description
     */
    @Then("I should see {string}")
    public void i_should_see(String elementDescription) {
        log.info("Checking if element is displayed: {}", elementDescription);
        boolean isDisplayed = controlFactory.createControl(elementDescription).isDisplayed();
        if (!isDisplayed) {
            throw new AssertionError("Element not displayed: " + elementDescription);
        }
        currentScenario.log("Verified element is displayed: " + elementDescription);
        reportManager.logStep("Verified element is displayed: " + elementDescription);
    }
    
    /**
     * Step to check if text is present
     * 
     * @param text Text to check
     */
    @Then("I should see text {string}")
    public void i_should_see_text(String text) {
        log.info("Checking if text is present: {}", text);
        String pageSource = driver.getPageSource();
        if (!pageSource.contains(text)) {
            throw new AssertionError("Text not found: " + text);
        }
        currentScenario.log("Verified text is present: " + text);
        reportManager.logStep("Verified text is present: " + text);
    }
    
    /**
     * Step to check if element contains text
     * 
     * @param elementDescription Element description
     * @param text Text to check
     */
    @Then("Element {string} should contain text {string}")
    public void element_should_contain_text(String elementDescription, String text) {
        log.info("Checking if element {} contains text: {}", elementDescription, text);
        String actualText = controlFactory.createControl(elementDescription).getText();
        if (!actualText.contains(text)) {
            throw new AssertionError("Element " + elementDescription + " does not contain text: " + text);
        }
        currentScenario.log("Verified element " + elementDescription + " contains text: " + text);
        reportManager.logStep("Verified element " + elementDescription + " contains text: " + text);
    }
    
    /**
     * Step to select an option from a dropdown
     * 
     * @param option Option to select
     * @param dropdownDescription Dropdown description
     */
    @When("I select {string} from {string}")
    public void i_select_from(String option, String dropdownDescription) {
        log.info("Selecting '{}' from {}", option, dropdownDescription);
        controlFactory.dropdown(dropdownDescription).selectByText(option);
        currentScenario.log("Selected '" + option + "' from " + dropdownDescription);
        reportManager.logStep("Selected '" + option + "' from " + dropdownDescription);
    }
    
    /**
     * Step to check or uncheck a checkbox
     * 
     * @param checkboxDescription Checkbox description
     */
    @When("I check {string}")
    public void i_check(String checkboxDescription) {
        log.info("Checking checkbox {}", checkboxDescription);
        controlFactory.checkbox(checkboxDescription).setChecked(true);
        currentScenario.log("Checked " + checkboxDescription);
        reportManager.logStep("Checked " + checkboxDescription);
    }
    
    /**
     * Step to uncheck a checkbox
     * 
     * @param checkboxDescription Checkbox description
     */
    @When("I uncheck {string}")
    public void i_uncheck(String checkboxDescription) {
        log.info("Unchecking checkbox {}", checkboxDescription);
        controlFactory.checkbox(checkboxDescription).setChecked(false);
        currentScenario.log("Unchecked " + checkboxDescription);
        reportManager.logStep("Unchecked " + checkboxDescription);
    }
    
    /**
     * Step to wait for a specific number of seconds
     * 
     * @param seconds Number of seconds to wait
     */
    @When("I wait for {int} seconds")
    public void i_wait_for_seconds(Integer seconds) {
        log.info("Waiting for {} seconds", seconds);
        try {
            Thread.sleep(seconds * 1000L);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        currentScenario.log("Waited for " + seconds + " seconds");
        reportManager.logStep("Waited for " + seconds + " seconds");
    }
}

package com.cssmart.bdd;

import io.cucumber.testng.AbstractTestNGCucumberTests;
import io.cucumber.testng.CucumberOptions;
import org.testng.annotations.DataProvider;

/**
 * TestNG Cucumber runner for BDD tests
 */
@CucumberOptions(
        features = "src/test/resources/features",
        glue = {"com.cssmart.bdd"},
        plugin = {
                "pretty",
                "html:target/cucumber-reports/cucumber-pretty.html",
                "json:target/cucumber-reports/CucumberTestReport.json",
                "rerun:target/cucumber-reports/rerun.txt"
        },
        monochrome = true,
        dryRun = false
)
public class CucumberRunner extends AbstractTestNGCucumberTests {
    
    /**
     * Runs scenarios in parallel if configured
     * @return TestNG data provider
     */
    @Override
    @DataProvider(parallel = true)
    public Object[][] scenarios() {
        return super.scenarios();
    }
}


package com.cssmart.bdd;

import com.cssmart.ai.engine.model.Action;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import lombok.extern.slf4j.Slf4j;

/**
 * AI-enhanced step definitions for natural language steps
 * These steps use AI to interpret and execute complex actions
 */
@Slf4j
public class AIEnhancedStepDefinitions extends CSSmartStepDefinitionBase {

    /**
     * Step to perform an AI-interpreted action
     * 
     * @param action Natural language action description
     */
    @When("I {string}")
    public void i_perform_action(String action) {
        log.info("Performing AI-interpreted action: {}", action);
        
        // Use AI engine to suggest an action
        Action suggestedAction = aiEngine.suggestAction(action);
        
        // Execute the suggested action
        executeAction(suggestedAction);
        
        currentScenario.log("Performed action: " + action);
        reportManager.logStep("Performed action: " + action);
    }
    
    /**
     * Step to verify a condition using AI
     * 
     * @param condition Natural language condition description
     */
    @Then("I should {string}")
    public void i_should_verify_condition(String condition) {
        log.info("Verifying AI-interpreted condition: {}", condition);
        
        // Use AI engine to verify the condition
        boolean isVerified = verifyCondition(condition);
        
        if (!isVerified) {
            throw new AssertionError("Condition not met: " + condition);
        }
        
        currentScenario.log("Verified condition: " + condition);
        reportManager.logStep("Verified condition: " + condition);
    }
    
    /**
     * Step for verification with negative assertion
     * 
     * @param condition Natural language negative condition
     */
    @Then("I should not {string}")
    public void i_should_not_verify_condition(String condition) {
        log.info("Verifying negative AI-interpreted condition: {}", condition);
        
        // Use AI engine to verify the negative condition
        boolean isVerified = verifyCondition(condition);
        
        if (isVerified) {
            throw new AssertionError("Negative condition failed - condition was met: " + condition);
        }
        
        currentScenario.log("Verified negative condition: " + condition);
        reportManager.logStep("Verified negative condition: " + condition);
    }
    
    /**
     * Execute an AI-suggested action
     * 
     * @param action Action to execute
     */
    private void executeAction(Action action) {
        switch (action.getType()) {
            case CLICK:
                controlFactory.createControl(action.getElementDescription()).click();
                break;
                
            case TYPE:
                controlFactory.textField(action.getElementDescription()).type(action.getValue());
                break;
                
            case SELECT:
                controlFactory.dropdown(action.getElementDescription()).selectByText(action.getValue());
                break;
                
            case CHECK:
                controlFactory.checkbox(action.getElementDescription()).setChecked(true);
                break;
                
            case UNCHECK:
                controlFactory.checkbox(action.getElementDescription()).setChecked(false);
                break;
                
            case NAVIGATE:
                driver.get(action.getValue());
                break;
                
            default:
                throw new UnsupportedOperationException("Unsupported action type: " + action.getType());
        }
    }
    
    /**
     * Verify a condition using AI
     * 
     * @param condition Condition to verify
     * @return True if condition is met
     */
    private boolean verifyCondition(String condition) {
        // This is a simplified implementation
        // In a real implementation, AI would interpret the condition and check it
        
        // Common condition patterns
        if (condition.contains("see") || condition.contains("visible")) {
            // Extract element description
            String elementDesc = extractElementDescription(condition);
            if (elementDesc != null) {
                return controlFactory.createControl(elementDesc).isDisplayed();
            }
        }
        
        if (condition.contains("enabled")) {
            String elementDesc = extractElementDescription(condition);
            if (elementDesc != null) {
                return controlFactory.createControl(elementDesc).isEnabled();
            }
        }
        
        if (condition.contains("selected") || condition.contains("checked")) {
            String elementDesc = extractElementDescription(condition);
            if (elementDesc != null) {
                if (elementDesc.toLowerCase().contains("checkbox")) {
                    return controlFactory.checkbox(elementDesc).isChecked();
                } else {
                    return controlFactory.createControl(elementDesc).isSelected();
                }
            }
        }
        
        if (condition.contains("on page") || condition.contains("in page")) {
            String text = extractText(condition);
            if (text != null) {
                return driver.getPageSource().contains(text);
            }
        }
        
        // Default to checking page source for the condition text
        return driver.getPageSource().contains(condition);
    }
    
    /**
     * Extract element description from a condition
     * 
     * @param condition Condition text
     * @return Element description or null
     */
    private String extractElementDescription(String condition) {
        // Simplified extraction - a real implementation would use AI
        // Common patterns: "see the login button", "login button is visible"
        
        // Try to find quoted text first
        if (condition.contains("\"")) {
            int start = condition.indexOf("\"");
            int end = condition.indexOf("\"", start + 1);
            if (end > start) {
                return condition.substring(start + 1, end);
            }
        }
        
        // Common element types
        String[] elementTypes = {
            "button", "field", "link", "checkbox", "dropdown", "radio", "tab", "menu", "panel", "image"
        };
        
        for (String type : elementTypes) {
            if (condition.contains(type)) {
                int index = condition.indexOf(type);
                
                // Try to get a few words before the element type
                int startIndex = Math.max(0, index - 20);
                String beforeText = condition.substring(startIndex, index).trim();
                String[] words = beforeText.split("\\s+");
                
                if (words.length > 0) {
                    // Get the last few words before the element type
                    int wordCount = Math.min(3, words.length);
                    StringBuilder elemDesc = new StringBuilder();
                    for (int i = words.length - wordCount; i < words.length; i++) {
                        elemDesc.append(words[i]).append(" ");
                    }
                    elemDesc.append(type);
                    
                    return elemDesc.toString().trim();
                }
                
                return "the " + type;
            }
        }
        
        return null;
    }
    
    /**
     * Extract text to find from a condition
     * 
     * @param condition Condition text
     * @return Text to find or null
     */
    private String extractText(String condition) {
        // Try to find quoted text
        if (condition.contains("\"")) {
            int start = condition.indexOf("\"");
            int end = condition.indexOf("\"", start + 1);
            if (end > start) {
                return condition.substring(start + 1, end);
            }
        }
        
        // Try to find text after "see" or "contains"
        String[] patterns = {"see ", "contains ", "with "};
        for (String pattern : patterns) {
            if (condition.contains(pattern)) {
                int index = condition.indexOf(pattern) + pattern.length();
                return condition.substring(index).trim();
            }
        }
        
        return null;
    }
}

# Sample Feature File
# src/test/resources/features/login.feature

Feature: User Authentication
  As a user of the application
  I want to be able to log in with my credentials
  So that I can access my account

  Background:
    Given I navigate to "https://example.com/login"

  Scenario: Successful login with valid credentials
    When I type "testuser" into "username field"
    And I type "password123" into "password field"
    And I click on "login button"
    Then I should see "Welcome, Test User"
    And Element "user dashboard" should contain text "Your Account"

  Scenario: Failed login with invalid credentials
    When I type "wronguser" into "username field"
    And I type "wrongpass" into "password field"
    And I click on "login button"
    Then I should see text "Invalid username or password"
    And I should not "see the user dashboard"

  Scenario: Login using remember me functionality
    When I type "testuser" into "username field"
    And I type "password123" into "password field"
    And I check "remember me checkbox"
    And I click on "login button"
    Then I should see "Welcome, Test User"
    
    # Close the browser and reopen it
    When I navigate to "https://example.com/login"
    Then I should see "username field" 
    And Element "username field" should contain text "testuser"

  # Using AI-enhanced steps
  Scenario: Login workflow with AI steps
    When I "enter testuser as username"
    And I "enter password123 as password"
    And I "click the login button"
    Then I should "be logged in successfully"
    And I should "see the user dashboard"
    And I should not "see any error messages"


package com.cssmart.bdd;

import com.cssmart.data.DataProvider;
import com.cssmart.data.DataProviderFactory;
import io.cucumber.java.DataTableType;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Step definitions for data-driven BDD testing
 * Integrates with our data provider system
 */
@Slf4j
public class DataDrivenStepDefinitions extends CSSmartStepDefinitionBase {

    private DataProvider currentDataProvider;
    private Map<String, Object> currentDataRow;
    
    /**
     * Register data table converter for Cucumber
     * 
     * @param entry Map entry from Cucumber data table
     * @return Converted map
     */
    @DataTableType
    public Map<String, Object> convertDataTableEntry(Map<String, String> entry) {
        // Convert all string values to appropriate types
        return entry.entrySet().stream()
                .collect(
                    java.util.stream.Collectors.toMap(
                        Map.Entry::getKey,
                        e -> convertStringToValue(e.getValue())
                    )
                );
    }
    
    /**
     * Step to load test data from a CSV file
     * 
     * @param filePath CSV file path
     * @throws IOException If file cannot be read
     */
    @Given("I load test data from CSV file {string}")
    public void i_load_test_data_from_csv_file(String filePath) throws IOException {
        log.info("Loading test data from CSV file: {}", filePath);
        currentDataProvider = DataProviderFactory.createFromFile(filePath);
        currentScenario.log("Loaded test data from CSV file: " + filePath);
        reportManager.logStep("Loaded test data from CSV file: " + filePath);
    }
    
    /**
     * Step to load test data from an Excel file
     * 
     * @param filePath Excel file path
     * @param sheetName Sheet name
     * @throws IOException If file cannot be read
     */
    @Given("I load test data from Excel file {string} sheet {string}")
    public void i_load_test_data_from_excel_file_sheet(String filePath, String sheetName) throws IOException {
        log.info("Loading test data from Excel file: {} sheet: {}", filePath, sheetName);
        // Note: Simplified - actual implementation would need to support sheet by name
        int sheetIndex = 0;
        try {
            sheetIndex = Integer.parseInt(sheetName);
        } catch (NumberFormatException e) {
            log.warn("Sheet by name not supported yet, using first sheet");
        }
        
        currentDataProvider = new com.cssmart.data.provider.ExcelDataProvider(filePath, sheetIndex);
        currentScenario.log("Loaded test data from Excel file: " + filePath + " sheet: " + sheetName);
        reportManager.logStep("Loaded test data from Excel file: " + filePath + " sheet: " + sheetName);
    }
    
    /**
     * Step to select a data row by index
     * 
     * @param rowIndex Row index (0-based)
     */
    @When("I use test data row {int}")
    public void i_use_test_data_row(Integer rowIndex) {
        log.info("Using test data row: {}", rowIndex);
        if (currentDataProvider == null) {
            throw new IllegalStateException("No test data loaded. Use a 'I load test data...' step first.");
        }
        
        currentDataRow = currentDataProvider.getDataAt(rowIndex);
        currentScenario.log("Using test data row: " + rowIndex);
        reportManager.logStep("Using test data row: " + rowIndex);
    }
    
    /**
     * Step to select a data row by column value
     * 
     * @param columnName Column name
     * @param value Column value
     */
    @When("I use test data where {string} is {string}")
    public void i_use_test_data_where_column_equals_value(String columnName, String value) {
        log.info("Using test data where {} = {}", columnName, value);
        if (currentDataProvider == null) {
            throw new IllegalStateException("No test data loaded. Use a 'I load test data...' step first.");
        }
        
        Object typedValue = convertStringToValue(value);
        List<Map<String, Object>> filteredData = currentDataProvider.getAllData()
                .stream()
                .filter(row -> {
                    Object rowValue = row.get(columnName);
                    return rowValue != null && rowValue.equals(typedValue);
                })
                .collect(java.util.stream.Collectors.toList());
                
        if (filteredData.isEmpty()) {
            throw new IllegalStateException("No data found where " + columnName + " = " + value);
        }
        
        currentDataRow = filteredData.get(0);
        currentScenario.log("Using test data where " + columnName + " = " + value);
        reportManager.logStep("Using test data where " + columnName + " = " + value);
    }
    
    /**
     * Step to type text with data substitution
     * 
     * @param text Text to type (can contain ${column} references)
     * @param elementDescription Element description
     */
    @When("I type data {string} into {string}")
    public void i_type_data_into(String text, String elementDescription) {
        log.info("Typing data '{}' into {}", text, elementDescription);
        if (currentDataRow == null) {
            throw new IllegalStateException("No test data row selected. Use a 'I use test data...' step first.");
        }
        
        // Substitute ${column} references with actual data values
        String substitutedText = substituteDataValues(text);
        
        controlFactory.textField(elementDescription).type(substitutedText);
        currentScenario.log("Typed data '" + substitutedText + "' into " + elementDescription);
        reportManager.logStep("Typed data '" + substitutedText + "' into " + elementDescription);
    }
    
    /**
     * Step to use inline data table
     * 
     * @param dataTable Cucumber data table
     */
    @Given("I use the following test data:")
    public void i_use_the_following_test_data(io.cucumber.datatable.DataTable dataTable) {
        log.info("Using inline test data table");
        List<Map<String, Object>> dataList = dataTable.asMaps(String.class, Object.class);
        
        if (!dataList.isEmpty()) {
            currentDataRow = dataList.get(0);
            currentScenario.log("Using inline test data: " + currentDataRow);
            reportManager.logStep("Using inline test data");
        } else {
            throw new IllegalStateException("Empty data table provided");
        }
    }
    
    /**
     * Substitute ${column} references with actual data values
     * 
     * @param text Text with references
     * @return Substituted text
     */
    private String substituteDataValues(String text) {
        if (currentDataRow == null || !text.contains("${")) {
            return text;
        }
        
        String result = text;
        for (Map.Entry<String, Object> entry : currentDataRow.entrySet()) {
            String placeholder = "${" + entry.getKey() + "}";
            if (result.contains(placeholder)) {
                String value = entry.getValue() != null ? entry.getValue().toString() : "";
                result = result.replace(placeholder, value);
            }
        }
        
        return result;
    }
    
    /**
     * Convert string to typed value (Integer, Double, Boolean, or String)
     * 
     * @param value String value
     * @return Typed value
     */
    private Object convertStringToValue(String value) {
        if (value == null) return null;
        value = value.trim();
        if (value.isEmpty()) return null;
        
        // Try boolean
        if (value.equalsIgnoreCase("true")) return Boolean.TRUE;
        if (value.equalsIgnoreCase("false")) return Boolean.FALSE;
        
        // Try number
        try {
            // Check if it's an integer
            if (!value.contains(".")) {
                try {
                    return Integer.parseInt(value);
                } catch (NumberFormatException e) {
                    // Not an integer, try long
                    try {
                        return Long.parseLong(value);
                    } catch (NumberFormatException e2) {
                        // Not a long, try double
                    }
                }
            }
            
            // Try double
            return Double.parseDouble(value);
        } catch (NumberFormatException e) {
            // Not a number, return as string
            return value;
        }
    }
}


# Data-Driven Feature File
# src/test/resources/features/registration.feature

Feature: User Registration
  As a visitor to the application
  I want to register a new account
  So that I can use the application features

  Scenario: Register new user with CSV data
    Given I navigate to "https://example.com/register"
    And I load test data from CSV file "src/test/resources/data/users.csv"
    And I use test data row 0
    
    When I type data "${firstName}" into "first name field"
    And I type data "${lastName}" into "last name field"
    And I type data "${email}" into "email field"
    And I type data "${username}" into "username field"
    And I type data "${password}" into "password field"
    And I type data "${password}" into "confirm password field"
    And I check "terms checkbox"
    And I click on "register button"
    
    Then I should see "Registration Successful"
    And I should see text "Welcome, ${firstName}"

  Scenario: Register multiple users with inline data
    Given I navigate to "https://example.com/register"
    
    # First user
    Given I use the following test data:
      | firstName | lastName | email               | username | password    |
      | John      | Doe      | john.doe@example.com| johndoe  | Password123 |
    
    When I type data "${firstName}" into "first name field"
    And I type data "${lastName}" into "last name field"
    And I type data "${email}" into "email field"
    And I type data "${username}" into "username field"
    And I type data "${password}" into "password field"
    And I type data "${password}" into "confirm password field"
    And I check "terms checkbox"
    And I click on "register button"
    
    Then I should see "Registration Successful"
    And I should see text "Welcome, ${firstName}"
    
    # Reset for next user
    And I navigate to "https://example.com/register"
    
    # Second user
    Given I use the following test data:
      | firstName | lastName | email                 | username  | password    |
      | Jane      | Smith    | jane.smith@example.com| janesmith | Secret123!  |
    
    When I type data "${firstName}" into "first name field"
    And I type data "${lastName}" into "last name field"
    And I type data "${email}" into "email field"
    And I type data "${username}" into "username field"
    And I type data "${password}" into "password field"
    And I type data "${password}" into "confirm password field"
    And I check "terms checkbox"
    And I click on "register button"
    
    Then I should see "Registration Successful"
    And I should see text "Welcome, ${firstName}"

  Scenario: Register user with Excel data
    Given I navigate to "https://example.com/register"
    And I load test data from Excel file "src/test/resources/data/registration_data.xlsx" sheet "0"
    And I use test data where "testCase" is "valid_registration"
    
    When I type data "${firstName}" into "first name field"
    And I type data "${lastName}" into "last name field"
    And I type data "${email}" into "email field"
    And I type data "${username}" into "username field"
    And I type data "${password}" into "password field"
    And I type data "${password}" into "confirm password field"
    
    # Conditionally check subscription checkbox based on data
    When I "check subscription checkbox if subscribeToNewsletter is true"
    And I check "terms checkbox"
    And I click on "register button"
    
    Then I should see "Registration Successful"
    And I should see text "Welcome, ${firstName}"
    
  # Using Scenario Outline for data-driven testing
  Scenario Outline: Register with different user types
    Given I navigate to "https://example.com/register"
    
    When I type "<firstName>" into "first name field"
    And I type "<lastName>" into "last name field"
    And I type "<email>" into "email field"
    And I type "<username>" into "username field"
    And I type "<password>" into "password field"
    And I type "<password>" into "confirm password field"
    And I check "terms checkbox"
    And I click on "register button"
    
    Then I should see "<expectedMessage>"
    
    Examples:
      | firstName | lastName | email                  | username   | password    | expectedMessage         |
      | Bob       | Johnson  | bob.johnson@example.com| bobjohnson | Password123 | Registration Successful |
      | Alice     | Brown    | alice.brown@example.com| alicebrown | Secret123!  | Registration Successful |
      | Mike      | Wilson   | mike@invalid           | mikewilson | Pass123     | Invalid email format    |
      | Tom       | Davis    | tom.davis@example.com  | tomdavis   | short       | Password too short      |



# BDD Testing with CS Smart Test Framework

The CS Smart Test Framework includes comprehensive support for Behavior-Driven Development (BDD) using Cucumber. This approach allows you to write tests in natural language that both technical and non-technical stakeholders can understand.

## Key Features

- **Natural Language Tests**: Write tests in plain English with Gherkin syntax
- **AI-Enhanced Steps**: Use AI to interpret complex actions and verifications
- **Data-Driven BDD**: Integrate with our data provider system for data-driven scenarios
- **Built-in Step Definitions**: Common steps are pre-defined for quick test creation
- **Custom Step Support**: Easily extend with your own step definitions
- **Cucumber Integration**: Seamless integration with Cucumber and TestNG

## Getting Started

### Directory Structure

```
src/
 test/
    java/
       com/
           yourcompany/
               steps/
                   YourCustomSteps.java
    resources/
        features/
            login.feature
            registration.feature
            checkout.feature
```

### Writing Feature Files

Feature files use Gherkin syntax and should be placed in `src/test/resources/features`. Here's a simple example:

```gherkin
Feature: User Login
  As a user of the application
  I want to be able to log in with my credentials
  So that I can access my account

  Scenario: Successful login with valid credentials
    Given I navigate to "https://example.com/login"
    When I type "testuser" into "username field"
    And I type "password123" into "password field"
    And I click on "login button"
    Then I should see "Welcome, Test User"
```

### Running BDD Tests

You can run your BDD tests using the provided CucumberRunner class:

```java
import io.cucumber.testng.AbstractTestNGCucumberTests;
import io.cucumber.testng.CucumberOptions;
import org.testng.annotations.DataProvider;

@CucumberOptions(
        features = "src/test/resources/features",
        glue = {"com.cssmart.bdd", "com.yourcompany.steps"},
        plugin = {
                "pretty",
                "html:target/cucumber-reports/cucumber-pretty.html",
                "json:target/cucumber-reports/CucumberTestReport.json"
        }
)
public class TestRunner extends AbstractTestNGCucumberTests {
    @Override
    @DataProvider(parallel = true)
    public Object[][] scenarios() {
        return super.scenarios();
    }
}
```

## Pre-defined Step Definitions

The framework includes a comprehensive set of step definitions:

### Navigation Steps

```gherkin
Given I navigate to "https://example.com"
```

### Interaction Steps

```gherkin
When I type "text" into "element description"
When I click on "element description"
When I select "option" from "dropdown description"
When I check "checkbox description"
When I uncheck "checkbox description"
When I wait for 5 seconds
```

### Verification Steps

```gherkin
Then I should see "element description"
Then I should see text "expected text"
Then Element "element description" should contain text "expected text"
```

### Data-Driven Steps

```gherkin
Given I load test data from CSV file "path/to/file.csv"
Given I load test data from Excel file "path/to/file.xlsx" sheet "SheetName"
When I use test data row 0
When I use test data where "column" is "value"
When I type data "${column}" into "element description"
```

### AI-Enhanced Steps

```gherkin
When I "enter username in the login field"
Then I should "be logged in successfully"
Then I should not "see any error messages"
```

## Creating Custom Step Definitions

You can easily create your own step definitions by extending the base class:

```java
package com.yourcompany.steps;

import com.cssmart.bdd.CSSmartStepDefinitionBase;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class CustomSteps extends CSSmartStepDefinitionBase {

    @When("I search for {string}")
    public void i_search_for(String searchTerm) {
        type("search box", searchTerm);
        click("search button");
        log.info("Searched for: {}", searchTerm);
    }
    
    @Then("search results should contain {string}")
    public void search_results_should_contain(String expectedText) {
        // Implementation
    }
}
```

## Data Tables

Cucumber data tables are fully supported:

```gherkin
Given I use the following test data:
  | username | password  | expectedResult |
  | testuser | password  | success        |
  | invalid  | wrongpass | failure        |
```

## Scenario Outlines

For parameterized testing, use scenario outlines:

```gherkin
Scenario Outline: Login with different users
  Given I navigate to "https://example.com/login"
  When I type "<username>" into "username field"
  And I type "<password>" into "password field"
  And I click on "login button"
  Then I should see "<result>"
  
  Examples:
    | username | password    | result            |
    | valid    | correct     | Welcome           |
    | invalid  | wrong       | Invalid username  |
    | valid    | wrong       | Invalid password  |
```

## Best Practices

1. **Keep scenarios focused**: Each scenario should test one behavior
2. **Use background for common steps**: Avoid repetition with Background sections
3. **Be descriptive**: Use clear, descriptive language in your feature files
4. **Leverage AI steps**: Use AI-enhanced steps for complex behaviors
5. **Organize features logically**: Group related scenarios in the same feature file
6. **Use tags**: Add tags like `@smoke`, `@regression` to categorize tests
7. **Data-driven approach**: Use data tables for multiple test cases
8. **Design for readability**: Features should be readable by non-technical stakeholders

## Reports

After test execution, detailed reports are generated in the `target/cucumber-reports` directory, including HTML reports with test results, screenshots, and execution metrics.



package com.cssmart.ui.controls;

import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.SearchContext;
import org.openqa.selenium.WebElement;

import java.util.ArrayList;
import java.util.List;

/**
 * Helper class for working with Shadow DOM elements
 */
@Slf4j
public class ShadowDOMHelper {

    /**
     * Find an element within Shadow DOM
     * 
     * @param driver WebDriver or WebElement acting as search context
     * @param shadowHostSelector CSS selector for the shadow host
     * @param innerSelector CSS selector for the element inside shadow DOM
     * @return Found WebElement
     */
    public static WebElement findInShadowDOM(SearchContext driver, String shadowHostSelector, String innerSelector) {
        try {
            // First find the shadow host
            WebElement shadowHost = driver.findElement(By.cssSelector(shadowHostSelector));
            return findInShadowRoot(driver, shadowHost, innerSelector);
        } catch (Exception e) {
            log.error("Error finding element in Shadow DOM. Host: {}, Inner: {}", shadowHostSelector, innerSelector, e);
            throw new RuntimeException("Failed to find element in Shadow DOM", e);
        }
    }
    
    /**
     * Find an element within the shadow root of a given shadow host
     * 
     * @param driver WebDriver or WebElement acting as search context
     * @param shadowHost WebElement that is the shadow host
     * @param innerSelector CSS selector for the element inside shadow DOM
     * @return Found WebElement
     */
    public static WebElement findInShadowRoot(SearchContext driver, WebElement shadowHost, String innerSelector) {
        JavascriptExecutor js = (JavascriptExecutor) driver;
        
        // Access the shadow root and find the element
        return (WebElement) js.executeScript(
                "return arguments[0].shadowRoot.querySelector(arguments[1])",
                shadowHost, innerSelector);
    }
    
    /**
     * Find all elements within Shadow DOM
     * 
     * @param driver WebDriver or WebElement acting as search context
     * @param shadowHostSelector CSS selector for the shadow host
     * @param innerSelector CSS selector for the elements inside shadow DOM
     * @return List of found WebElements
     */
    public static List<WebElement> findAllInShadowDOM(SearchContext driver, String shadowHostSelector, String innerSelector) {
        try {
            // First find the shadow host
            WebElement shadowHost = driver.findElement(By.cssSelector(shadowHostSelector));
            
            // Access the shadow root and find all elements
            JavascriptExecutor js = (JavascriptExecutor) driver;
            List<WebElement> elements = (List<WebElement>) js.executeScript(
                    "return Array.from(arguments[0].shadowRoot.querySelectorAll(arguments[1]))",
                    shadowHost, innerSelector);
                    
            return elements != null ? elements : new ArrayList<>();
        } catch (Exception e) {
            log.error("Error finding elements in Shadow DOM. Host: {}, Inner: {}", shadowHostSelector, innerSelector, e);
            throw new RuntimeException("Failed to find elements in Shadow DOM", e);
        }
    }
    
    /**
     * Traverse nested Shadow DOMs to find an element
     * 
     * @param driver WebDriver or WebElement acting as search context
     * @param selectors Array of CSS selectors to traverse (first is regular DOM, then shadow hosts, last is target)
     * @return Found WebElement
     */
    public static WebElement findInNestedShadowDOM(SearchContext driver, String... selectors) {
        if (selectors.length < 2) {
            throw new IllegalArgumentException("Need at least 2 selectors (host and inner)");
        }
        
        try {
            // Start with the first selector in the regular DOM
            WebElement currentElement = driver.findElement(By.cssSelector(selectors[0]));
            JavascriptExecutor js = (JavascriptExecutor) driver;
            
            // Traverse through the shadow roots
            for (int i = 1; i < selectors.length - 1; i++) {
                // Get the shadow root of the current element and find the next element
                currentElement = (WebElement) js.executeScript(
                        "return arguments[0].shadowRoot.querySelector(arguments[1])",
                        currentElement, selectors[i]);
            }
            
            // Find the final element in the last shadow root
            return (WebElement) js.executeScript(
                    "return arguments[0].shadowRoot.querySelector(arguments[1])",
                    currentElement, selectors[selectors.length - 1]);
        } catch (Exception e) {
            log.error("Error finding element in nested Shadow DOM", e);
            throw new RuntimeException("Failed to find element in nested Shadow DOM", e);
        }
    }
    
    /**
     * Check if an element has a shadow root
     * 
     * @param driver WebDriver or WebElement acting as search context
     * @param element Element to check
     * @return True if the element has a shadow root
     */
    public static boolean hasShadowRoot(SearchContext driver, WebElement element) {
        JavascriptExecutor js = (JavascriptExecutor) driver;
        return (Boolean) js.executeScript("return !!arguments[0].shadowRoot", element);
    }
}

package com.cssmart.ui.controls;

import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.*;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.time.Duration;

/**
 * UI control for working with elements inside Shadow DOM
 */
@Slf4j
public class ShadowDOMControl {
    private final WebDriver driver;
    private final String shadowHost;
    private final String innerSelector;
    private final WebElement hostElement;
    private WebElement shadowElement;
    private final String description;
    
    /**
     * Create a new Shadow DOM control
     * 
     * @param driver WebDriver instance
     * @param shadowHost CSS selector for shadow host
     * @param innerSelector CSS selector for element inside shadow DOM
     * @param description Description for logging
     */
    public ShadowDOMControl(WebDriver driver, String shadowHost, String innerSelector, String description) {
        this.driver = driver;
        this.shadowHost = shadowHost;
        this.innerSelector = innerSelector;
        this.description = description;
        
        // Find the shadow host element
        this.hostElement = driver.findElement(By.cssSelector(shadowHost));
        
        // Check if it has a shadow root
        if (!ShadowDOMHelper.hasShadowRoot(driver, hostElement)) {
            throw new NoSuchElementException("Element does not have a shadow root: " + shadowHost);
        }
        
        // Find the element inside shadow DOM
        this.shadowElement = ShadowDOMHelper.findInShadowRoot(driver, hostElement, innerSelector);
    }
    
    /**
     * Create a new Shadow DOM control with nested shadow roots
     * 
     * @param driver WebDriver instance
     * @param description Description for logging
     * @param selectors Sequence of selectors to traverse (first is regular DOM, then shadow hosts, last is target)
     */
    public ShadowDOMControl(WebDriver driver, String description, String... selectors) {
        if (selectors.length < 2) {
            throw new IllegalArgumentException("Need at least 2 selectors (host and inner)");
        }
        
        this.driver = driver;
        this.description = description;
        this.shadowHost = selectors[0];
        this.innerSelector = selectors[selectors.length - 1];
        
        // Find the shadow host element
        this.hostElement = driver.findElement(By.cssSelector(shadowHost));
        
        // Find the element through nested shadow DOMs
        this.shadowElement = ShadowDOMHelper.findInNestedShadowDOM(driver, selectors);
    }
    
    /**
     * Refresh element references to avoid stale element exceptions
     */
    private void refresh() {
        try {
            // Test if element is still valid
            shadowElement.isEnabled();
        } catch (StaleElementReferenceException e) {
            log.debug("Refreshing stale shadow DOM element: {}", description);
            shadowElement = ShadowDOMHelper.findInShadowRoot(driver, hostElement, innerSelector);
        }
    }
    
    /**
     * Click on the element
     * 
     * @return This control for chaining
     */
    public ShadowDOMControl click() {
        refresh();
        log.info("Clicking on shadow DOM element: {}", description);
        shadowElement.click();
        return this;
    }
    
    /**
     * Type text into the element
     * 
     * @param text Text to type
     * @return This control for chaining
     */
    public ShadowDOMControl type(String text) {
        refresh();
        log.info("Typing '{}' into shadow DOM element: {}", text, description);
        shadowElement.clear();
        shadowElement.sendKeys(text);
        return this;
    }
    
    /**
     * Clear the element
     * 
     * @return This control for chaining
     */
    public ShadowDOMControl clear() {
        refresh();
        log.info("Clearing shadow DOM element: {}", description);
        shadowElement.clear();
        return this;
    }
    
    /**
     * Get text from the element
     * 
     * @return Text content
     */
    public String getText() {
        refresh();
        return shadowElement.getText();
    }
    
    /**
     * Get attribute value from the element
     * 
     * @param attribute Attribute name
     * @return Attribute value
     */
    public String getAttribute(String attribute) {
        refresh();
        return shadowElement.getAttribute(attribute);
    }
    
    /**
     * Check if the element is displayed
     * 
     * @return True if displayed
     */
    public boolean isDisplayed() {
        refresh();
        return shadowElement.isDisplayed();
    }
    
    /**
     * Check if the element is enabled
     * 
     * @return True if enabled
     */
    public boolean isEnabled() {
        refresh();
        return shadowElement.isEnabled();
    }
    
    /**
     * Check if the element is selected
     * 
     * @return True if selected
     */
    public boolean isSelected() {
        refresh();
        return shadowElement.isSelected();
    }
    
    /**
     * Wait for the element to be visible
     * 
     * @param timeoutSeconds Timeout in seconds
     * @return This control for chaining
     */
    public ShadowDOMControl waitForVisible(int timeoutSeconds) {
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        wait.until(driver -> {
            try {
                refresh();
                return shadowElement.isDisplayed();
            } catch (Exception e) {
                return false;
            }
        });
        return this;
    }
    
    /**
     * Execute JavaScript on the element
     * 
     * @param script JavaScript to execute
     * @param args Additional arguments
     * @return Result of script execution
     */
    public Object executeScript(String script, Object... args) {
        refresh();
        JavascriptExecutor js = (JavascriptExecutor) driver;
        Object[] allArgs = new Object[args.length + 1];
        allArgs[0] = shadowElement;
        System.arraycopy(args, 0, allArgs, 1, args.length);
        return js.executeScript(script, allArgs);
    }
    
    /**
     * Hover over the element
     * 
     * @return This control for chaining
     */
    public ShadowDOMControl hover() {
        refresh();
        Actions actions = new Actions(driver);
        actions.moveToElement(shadowElement).perform();
        return this;
    }
    
    /**
     * Get the underlying WebElement
     * 
     * @return WebElement
     */
    public WebElement getElement() {
        refresh();
        return shadowElement;
    }
    
    /**
     * Get the host element
     * 
     * @return Shadow host WebElement
     */
    public WebElement getHostElement() {
        return hostElement;
    }
}


package com.cssmart.driver;

import com.cssmart.config.ConfigurationManager;
import io.appium.java_client.AppiumDriver;
import io.appium.java_client.android.AndroidDriver;
import io.appium.java_client.ios.IOSDriver;
import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.remote.DesiredCapabilities;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Manager for creating and managing Appium drivers for mobile testing
 */
@Slf4j
public class MobileDriverManager {
    
    private static final ThreadLocal<AppiumDriver> driverThreadLocal = new ThreadLocal<>();
    private static final Map<String, AppiumDriver> activeDrivers = new ConcurrentHashMap<>();
    
    private static MobileDriverManager instance;
    private final ConfigurationManager configManager;
    
    /**
     * Private constructor for singleton pattern
     */
    private MobileDriverManager() {
        configManager = ConfigurationManager.getInstance();
    }
    
    /**
     * Get singleton instance
     * 
     * @return MobileDriverManager instance
     */
    public static synchronized MobileDriverManager getInstance() {
        if (instance == null) {
            instance = new MobileDriverManager();
        }
        return instance;
    }
    
    /**
     * Create an Android driver
     * 
     * @param capabilities Desired capabilities
     * @return AndroidDriver instance
     */
    public AndroidDriver createAndroidDriver(DesiredCapabilities capabilities) {
        try {
            log.info("Creating Android driver with capabilities: {}", capabilities);
            
            // Get Appium server URL from configuration
            String appiumUrl = configManager.getAppiumServerUrl();
            if (appiumUrl == null || appiumUrl.isEmpty()) {
                appiumUrl = "http://localhost:4723/wd/hub";
                log.warn("Appium server URL not configured. Using default: {}", appiumUrl);
            }
            
            // Create driver
            AndroidDriver driver = new AndroidDriver(new URL(appiumUrl), capabilities);
            
            // Store driver in thread local and active drivers map
            String sessionId = driver.getSessionId().toString();
            driverThreadLocal.set(driver);
            activeDrivers.put(sessionId, driver);
            
            log.info("Created Android driver with session ID: {}", sessionId);
            return driver;
        } catch (MalformedURLException e) {
            log.error("Invalid Appium server URL", e);
            throw new RuntimeException("Failed to create Android driver: " + e.getMessage(), e);
        } catch (Exception e) {
            log.error("Failed to create Android driver", e);
            throw new RuntimeException("Failed to create Android driver: " + e.getMessage(), e);
        }
    }
    
    /**
     * Create an iOS driver
     * 
     * @param capabilities Desired capabilities
     * @return IOSDriver instance
     */
    public IOSDriver createIOSDriver(DesiredCapabilities capabilities) {
        try {
            log.info("Creating iOS driver with capabilities: {}", capabilities);
            
            // Get Appium server URL from configuration
            String appiumUrl = configManager.getAppiumServerUrl();
            if (appiumUrl == null || appiumUrl.isEmpty()) {
                appiumUrl = "http://localhost:4723/wd/hub";
                log.warn("Appium server URL not configured. Using default: {}", appiumUrl);
            }
            
            // Create driver
            IOSDriver driver = new IOSDriver(new URL(appiumUrl), capabilities);
            
            // Store driver in thread local and active drivers map
            String sessionId = driver.getSessionId().toString();
            driverThreadLocal.set(driver);
            activeDrivers.put(sessionId, driver);
            
            log.info("Created iOS driver with session ID: {}", sessionId);
            return driver;
        } catch (MalformedURLException e) {
            log.error("Invalid Appium server URL", e);
            throw new RuntimeException("Failed to create iOS driver: " + e.getMessage(), e);
        } catch (Exception e) {
            log.error("Failed to create iOS driver", e);
            throw new RuntimeException("Failed to create iOS driver: " + e.getMessage(), e);
        }
    }
    
    /**
     * Get the current driver from thread local
     * 
     * @return AppiumDriver instance
     */
    public AppiumDriver getDriver() {
        AppiumDriver driver = driverThreadLocal.get();
        if (driver == null) {
            log.error("No AppiumDriver found in current thread");
            throw new IllegalStateException("AppiumDriver not initialized for current thread");
        }
        return driver;
    }
    
    /**
     * Quit the driver and remove it from active drivers
     * 
     * @param driver AppiumDriver to quit
     */
    public void quitDriver(AppiumDriver driver) {
        if (driver != null) {
            try {
                String sessionId = driver.getSessionId().toString();
                log.info("Quitting Appium driver with session ID: {}", sessionId);
                driver.quit();
                activeDrivers.remove(sessionId);
            } catch (Exception e) {
                log.error("Error quitting Appium driver", e);
            } finally {
                driverThreadLocal.remove();
            }
        }
    }
    
    /**
     * Quit the current driver
     */
    public void quitDriver() {
        AppiumDriver driver = driverThreadLocal.get();
        if (driver != null) {
            quitDriver(driver);
        }
    }
    
    /**
     * Quit all active drivers
     */
    public void quitAllDrivers() {
        log.info("Quitting all active Appium drivers");
        for (AppiumDriver driver : activeDrivers.values()) {
            try {
                driver.quit();
            } catch (Exception e) {
                log.error("Error quitting Appium driver", e);
            }
        }
        activeDrivers.clear();
        driverThreadLocal.remove();
    }
    
    /**
     * Create a mobile driver from a platform name
     * 
     * @param platform Platform name (android or ios)
     * @param capabilities Desired capabilities
     * @return AppiumDriver instance
     */
    public AppiumDriver createDriver(String platform, DesiredCapabilities capabilities) {
        if ("android".equalsIgnoreCase(platform)) {
            return createAndroidDriver(capabilities);
        } else if ("ios".equalsIgnoreCase(platform)) {
            return createIOSDriver(capabilities);
        } else {
            throw new IllegalArgumentException("Unsupported platform: " + platform);
        }
    }
    
    /**
     * Create default capabilities for Android
     * 
     * @param deviceName Device name or ID
     * @param appPath Path to the app
     * @return DesiredCapabilities
     */
    public DesiredCapabilities createDefaultAndroidCapabilities(String deviceName, String appPath) {
        DesiredCapabilities capabilities = new DesiredCapabilities();
        capabilities.setCapability("platformName", "Android");
        capabilities.setCapability("deviceName", deviceName);
        capabilities.setCapability("automationName", "UiAutomator2");
        
        if (appPath != null && !appPath.isEmpty()) {
            capabilities.setCapability("app", appPath);
        }
        
        return capabilities;
    }
    
    /**
     * Create default capabilities for iOS
     * 
     * @param deviceName Device name or ID
     * @param appPath Path to the app
     * @return DesiredCapabilities
     */
    public DesiredCapabilities createDefaultIOSCapabilities(String deviceName, String appPath) {
        DesiredCapabilities capabilities = new DesiredCapabilities();
        capabilities.setCapability("platformName", "iOS");
        capabilities.setCapability("deviceName", deviceName);
        capabilities.setCapability("automationName", "XCUITest");
        
        if (appPath != null && !appPath.isEmpty()) {
            capabilities.setCapability("app", appPath);
        }
        
        return capabilities;
    }
}

package com.cssmart.ui.controls.mobile;

import io.appium.java_client.AppiumDriver;
import io.appium.java_client.android.AndroidDriver;
import io.appium.java_client.ios.IOSDriver;
import io.appium.java_client.TouchAction;
import io.appium.java_client.touch.WaitOptions;
import io.appium.java_client.touch.offset.PointOption;
import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.time.Duration;

/**
 * Base class for mobile UI controls
 */
@Slf4j
public class MobileControl {
    protected final AppiumDriver driver;
    protected WebElement element;
    protected final String description;
    protected WebDriverWait wait;

    /**
     * Create a new mobile control with an existing element
     * 
     * @param driver AppiumDriver instance
     * @param element WebElement
     * @param description Description for logging
     */
    public MobileControl(AppiumDriver driver, WebElement element, String description) {
        this.driver = driver;
        this.element = element;
        this.description = description;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
    }

    /**
     * Create a new mobile control with a locator
     * 
     * @param driver AppiumDriver instance
     * @param locator By locator
     * @param description Description for logging
     */
    public MobileControl(AppiumDriver driver, By locator, String description) {
        this.driver = driver;
        this.description = description;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        this.element = wait.until(ExpectedConditions.presenceOfElementLocated(locator));
    }

    /**
     * Refresh the element reference to avoid stale element exceptions
     */
    protected void refresh() {
        try {
            // Test if element is still valid
            element.isEnabled();
        } catch (StaleElementReferenceException e) {
            log.debug("Refreshing stale element: {}", description);
            // Need the original locator to refresh, which we don't have
            // This is a limitation of this approach
            throw new RuntimeException("Element reference is stale and cannot be refreshed automatically", e);
        }
    }

    /**
     * Get the underlying WebElement
     * 
     * @return WebElement
     */
    public WebElement getElement() {
        refresh();
        return element;
    }

    /**
     * Tap on the element
     * 
     * @return This control for chaining
     */
    public MobileControl tap() {
        refresh();
        log.info("Tapping on element: {}", description);
        element.click();
        return this;
    }

    /**
     * Type text into the element
     * 
     * @param text Text to type
     * @return This control for chaining
     */
    public MobileControl type(String text) {
        refresh();
        log.info("Typing '{}' into element: {}", text, description);
        element.clear();
        element.sendKeys(text);
        return this;
    }

    /**
     * Clear the element
     * 
     * @return This control for chaining
     */
    public MobileControl clear() {
        refresh();
        log.info("Clearing element: {}", description);
        element.clear();
        return this;
    }

    /**
     * Get text from the element
     * 
     * @return Text content
     */
    public String getText() {
        refresh();
        return element.getText();
    }

    /**
     * Swipe on the element
     * 
     * @param direction Direction to swipe (up, down, left, right)
     * @return This control for chaining
     */
    @SuppressWarnings("rawtypes")
    public MobileControl swipe(String direction) {
        refresh();
        log.info("Swiping {} on element: {}", direction, description);

        Rectangle rect = element.getRect();
        int startX, startY, endX, endY;

        switch (direction.toLowerCase()) {
            case "up":
                startX = rect.x + rect.width / 2;
                startY = rect.y + rect.height * 3 / 4;
                endX = rect.x + rect.width / 2;
                endY = rect.y + rect.height / 4;
                break;
            case "down":
                startX = rect.x + rect.width / 2;
                startY = rect.y + rect.height / 4;
                endX = rect.x + rect.width / 2;
                endY = rect.y + rect.height * 3 / 4;
                break;
            case "left":
                startX = rect.x + rect.width * 3 / 4;
                startY = rect.y + rect.height / 2;
                endX = rect.x + rect.width / 4;
                endY = rect.y + rect.height / 2;
                break;
            case "right":
                startX = rect.x + rect.width / 4;
                startY = rect.y + rect.height / 2;
                endX = rect.x + rect.width * 3 / 4;
                endY = rect.y + rect.height / 2;
                break;
            default:
                throw new IllegalArgumentException("Invalid swipe direction: " + direction);
        }

        TouchAction touchAction = new TouchAction(driver);
        touchAction.press(PointOption.point(startX, startY))
                .waitAction(WaitOptions.waitOptions(Duration.ofMillis(500)))
                .moveTo(PointOption.point(endX, endY))
                .release()
                .perform();

        return this;
    }

    /**
     * Long press on the element
     * 
     * @param durationMs Duration in milliseconds
     * @return This control for chaining
     */
    @SuppressWarnings("rawtypes")
    public MobileControl longPress(long durationMs) {
        refresh();
        log.info("Long pressing on element: {}", description);

        Rectangle rect = element.getRect();
        int centerX = rect.x + rect.width / 2;
        int centerY = rect.y + rect.height / 2;

        TouchAction touchAction = new TouchAction(driver);
        touchAction.press(PointOption.point(centerX, centerY))
                .waitAction(WaitOptions.waitOptions(Duration.ofMillis(durationMs)))
                .release()
                .perform();

        return this;
    }

    /**
     * Check if the element is displayed
     * 
     * @return True if displayed
     */
    public boolean isDisplayed() {
        try {
            refresh();
            return element.isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Check if the element is enabled
     * 
     * @return True if enabled
     */
    public boolean isEnabled() {
        refresh();
        return element.isEnabled();
    }

    /**
     * Wait for the element to be visible
     * 
     * @param timeoutSeconds Timeout in seconds
     * @return This control for chaining
     */
    public MobileControl waitForVisible(int timeoutSeconds) {
        log.info("Waiting up to {} seconds for element to be visible: {}", timeoutSeconds, description);
        wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        wait.until(ExpectedConditions.visibilityOf(element));
        return this;
    }

    /**
     * Take a screenshot of the element
     * 
     * @return Screenshot as byte array
     */
    public byte[] takeScreenshot() {
        refresh();
        if (element instanceof TakesScreenshot) {
            return ((TakesScreenshot) element).getScreenshotAs(OutputType.BYTES);
        } else {
            log.warn("Element does not support taking screenshots");
            return null;
        }
    }

    /**
     * Check if this is on Android
     * 
     * @return True if Android
     */
    protected boolean isAndroid() {
        return driver instanceof AndroidDriver;
    }

    /**
     * Check if this is on iOS
     * 
     * @return True if iOS
     */
    protected boolean isIOS() {
        return driver instanceof IOSDriver;
    }
}

/**
 * Specialized control for mobile text fields
 */
@Slf4j
class MobileTextField extends MobileControl {

    public MobileTextField(AppiumDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }

    public MobileTextField(AppiumDriver driver, By locator, String description) {
        super(driver, locator, description);
    }

    /**
     * Set text without clearing first (useful for some mobile apps)
     * 
     * @param text Text to set
     * @return This control for chaining
     */
    public MobileTextField setText(String text) {
        refresh();
        log.info("Setting text '{}' in element: {}", text, description);
        element.sendKeys(text);
        return this;
    }

    /**
     * Hide the keyboard after typing
     * 
     * @return This control for chaining
     */
    public MobileTextField hideKeyboard() {
        log.info("Hiding keyboard");
        if (isAndroid()) {
            ((AndroidDriver) driver).hideKeyboard();
        } else if (isIOS()) {
            ((IOSDriver) driver).hideKeyboard();
        }
        return this;
    }
}

/**
 * Specialized control for mobile buttons
 */
@Slf4j
class MobileButton extends MobileControl {

    public MobileButton(AppiumDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }

    public MobileButton(AppiumDriver driver, By locator, String description) {
        super(driver, locator, description);
    }

    /**
     * Double tap on the button
     * 
     * @return This control for chaining
     */
    @SuppressWarnings("rawtypes")
    public MobileButton doubleTap() {
        refresh();
        log.info("Double tapping on element: {}", description);

        Rectangle rect = element.getRect();
        int centerX = rect.x + rect.width / 2;
        int centerY = rect.y + rect.height / 2;

        TouchAction touchAction = new TouchAction(driver);
        touchAction.press(PointOption.point(centerX, centerY))
                .release()
                .perform();
                
        touchAction.press(PointOption.point(centerX, centerY))
                .release()
                .perform();

        return this;
    }
}

/**
 * Specialized control for mobile toggle switches
 */
@Slf4j
class MobileToggle extends MobileControl {

    public MobileToggle(AppiumDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }

    public MobileToggle(AppiumDriver driver, By locator, String description) {
        super(driver, locator, description);
    }

    /**
     * Check if the toggle is on/checked
     * 
     * @return True if on/checked
     */
    public boolean isChecked() {
        refresh();
        String checked;
        
        if (isAndroid()) {
            checked = element.getAttribute("checked");
        } else {
            checked = element.getAttribute("value");
        }
        
        return "true".equalsIgnoreCase(checked) || "1".equals(checked);
    }

    /**
     * Set the toggle to a specific state
     * 
     * @param checked Desired state
     * @return This control for chaining
     */
    public MobileToggle setChecked(boolean checked) {
        refresh();
        boolean currentState = isChecked();
        
        if (currentState != checked) {
            tap();
            log.info("{} toggle {}", checked ? "Checked" : "Unchecked", description);
        } else {
            log.debug("Toggle already in desired state: {}", checked);
        }
        
        return this;
    }
}

/**
 * Specialized control for mobile pickers/dropdowns
 */
@Slf4j
class MobilePicker extends MobileControl {

    public MobilePicker(AppiumDriver driver, WebElement element, String description) {
        super(driver, element, description);
    }

    public MobilePicker(AppiumDriver driver, By locator, String description) {
        super(driver, locator, description);
    }

    /**
     * Select an option by visible text (platform specific)
     * 
     * @param optionText Text of the option to select
     * @return This control for chaining
     */
    public MobilePicker selectOption(String optionText) {
        refresh();
        log.info("Selecting option '{}' from picker: {}", optionText, description);
        
        // Open the picker
        tap();
        
        // Implementation varies by platform
        if (isAndroid()) {
            driver.findElement(By.xpath("//android.widget.TextView[@text='" + optionText + "']")).click();
        } else if (isIOS()) {
            driver.findElement(By.xpath("//XCUIElementTypePickerWheel")).sendKeys(optionText);
            driver.findElement(By.xpath("//XCUIElementTypeButton[@name='Done']")).click();
        }
        
        return this;
    }
}


package com.cssmart.api;

import com.cssmart.config.ConfigurationManager;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Builder;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.*;
import org.apache.http.conn.ssl.NoopHostnameVerifier;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.TrustAllStrategy;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.message.BasicHeader;
import org.apache.http.ssl.SSLContextBuilder;
import org.apache.http.util.EntityUtils;

import javax.net.ssl.SSLContext;
import java.io.IOException;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * HTTP client for API testing
 */
@Slf4j
public class APIClient {
    
    private final CloseableHttpClient httpClient;
    private final ObjectMapper objectMapper;
    private final ConfigurationManager configManager;
    private final String baseUrl;
    
    /**
     * HTTP methods enum
     */
    public enum Method {
        GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS
    }
    
    /**
     * Create a new API client
     */
    public APIClient() {
        this(null);
    }
    
    /**
     * Create a new API client with a specific base URL
     * 
     * @param baseUrl Base URL for requests
     */
    public APIClient(String baseUrl) {
        this.objectMapper = new ObjectMapper();
        this.configManager = ConfigurationManager.getInstance();
        
        // Use provided base URL or get from config
        this.baseUrl = baseUrl != null ? baseUrl : configManager.getApiBaseUrl();
        
        // Create HTTP client with default settings
        this.httpClient = createHttpClient();
    }
    
    /**
     * Create an HTTP client with the specified settings
     * 
     * @return CloseableHttpClient
     */
    private CloseableHttpClient createHttpClient() {
        try {
            // Configure timeouts
            int connectTimeout = configManager.getApiConnectTimeoutMs();
            int socketTimeout = configManager.getApiSocketTimeoutMs();
            int connectionRequestTimeout = configManager.getApiConnectionRequestTimeoutMs();
            
            RequestConfig requestConfig = RequestConfig.custom()
                    .setConnectTimeout(connectTimeout)
                    .setSocketTimeout(socketTimeout)
                    .setConnectionRequestTimeout(connectionRequestTimeout)
                    .build();
            
            // Configure SSL
            boolean ignoreSsl = configManager.isApiIgnoreSslErrors();
            SSLConnectionSocketFactory sslFactory;
            
            if (ignoreSsl) {
                // Create a trust-all SSL context (not recommended for production)
                SSLContext sslContext = new SSLContextBuilder()
                        .loadTrustMaterial(null, new TrustAllStrategy())
                        .build();
                
                sslFactory = new SSLConnectionSocketFactory(sslContext, NoopHostnameVerifier.INSTANCE);
            } else {
                // Use default SSL context
                sslFactory = SSLConnectionSocketFactory.getSystemSocketFactory();
            }
            
            // Build and return the HTTP client
            return HttpClientBuilder.create()
                    .setDefaultRequestConfig(requestConfig)
                    .setSSLSocketFactory(sslFactory)
                    .build();
                    
        } catch (NoSuchAlgorithmException | KeyStoreException | KeyManagementException e) {
            log.error("Error creating HTTP client", e);
            throw new RuntimeException("Failed to create HTTP client: " + e.getMessage(), e);
        }
    }
    
    /**
     * Send an HTTP request
     * 
     * @param method HTTP method
     * @param endpoint API endpoint (path)
     * @param headers HTTP headers
     * @param body Request body (will be converted to JSON)
     * @return APIResponse object
     */
    public APIResponse sendRequest(Method method, String endpoint, Map<String, String> headers, Object body) {
        String url = buildUrl(endpoint);
        log.info("Sending {} request to {}", method, url);
        
        try {
            // Create request
            HttpUriRequest request = createRequest(method, url, headers, body);
            
            // Execute request
            long startTime = System.currentTimeMillis();
            CloseableHttpResponse response = httpClient.execute(request);
            long endTime = System.currentTimeMillis();
            
            // Process response
            APIResponse apiResponse = processResponse(response, endTime - startTime);
            log.info("Received response from {} with status {}", url, apiResponse.getStatusCode());
            
            return apiResponse;
        } catch (Exception e) {
            log.error("Error sending {} request to {}", method, url, e);
            throw new RuntimeException("Failed to send API request: " + e.getMessage(), e);
        }
    }
    
    /**
     * Build the full URL from the endpoint
     * 
     * @param endpoint API endpoint (path)
     * @return Full URL
     */
    private String buildUrl(String endpoint) {
        if (endpoint.startsWith("http://") || endpoint.startsWith("https://")) {
            return endpoint; // Absolute URL
        }
        
        String baseUrl = this.baseUrl;
        if (baseUrl == null || baseUrl.isEmpty()) {
            throw new IllegalStateException("Base URL not configured");
        }
        
        // Handle trailing/leading slashes
        if (baseUrl.endsWith("/") && endpoint.startsWith("/")) {
            return baseUrl + endpoint.substring(1);
        } else if (!baseUrl.endsWith("/") && !endpoint.startsWith("/")) {
            return baseUrl + "/" + endpoint;
        } else {
            return baseUrl + endpoint;
        }
    }
    
    /**
     * Create an HTTP request with the specified parameters
     * 
     * @param method HTTP method
     * @param url Full URL
     * @param headers HTTP headers
     * @param body Request body (will be converted to JSON)
     * @return HttpUriRequest object
     * @throws IOException if body serialization fails
     */
    private HttpUriRequest createRequest(Method method, String url, Map<String, String> headers, Object body) throws IOException {
        // Create request based on method
        HttpUriRequest request;
        
        switch (method) {
            case GET:
                request = new HttpGet(url);
                break;
            case POST:
                HttpPost postRequest = new HttpPost(url);
                if (body != null) {
                    addJsonBody(postRequest, body);
                }
                request = postRequest;
                break;
            case PUT:
                HttpPut putRequest = new HttpPut(url);
                if (body != null) {
                    addJsonBody(putRequest, body);
                }
                request = putRequest;
                break;
            case DELETE:
                request = new HttpDelete(url);
                break;
            case PATCH:
                HttpPatch patchRequest = new HttpPatch(url);
                if (body != null) {
                    addJsonBody(patchRequest, body);
                }
                request = patchRequest;
                break;
            case HEAD:
                request = new HttpHead(url);
                break;
            case OPTIONS:
                request = new HttpOptions(url);
                break;
            default:
                throw new IllegalArgumentException("Unsupported HTTP method: " + method);
        }
        
        // Add headers
        if (headers != null) {
            for (Map.Entry<String, String> entry : headers.entrySet()) {
                request.addHeader(entry.getKey(), entry.getValue());
            }
        }
        
        // Add default headers if not overridden
        if (!hasHeader(request, "Content-Type") && body != null) {
            request.addHeader("Content-Type", "application/json");
        }
        
        if (!hasHeader(request, "Accept")) {
            request.addHeader("Accept", "application/json");
        }
        
        return request;
    }
    
    /**
     * Check if a request has a specific header
     * 
     * @param request HTTP request
     * @param headerName Header name
     * @return true if header exists
     */
    private boolean hasHeader(HttpUriRequest request, String headerName) {
        Header[] headers = request.getHeaders(headerName);
        return headers != null && headers.length > 0;
    }
    
    /**
     * Add a JSON body to a request
     * 
     * @param request HTTP request
     * @param body Body object
     * @throws IOException if serialization fails
     */
    private void addJsonBody(HttpEntityEnclosingRequestBase request, Object body) throws IOException {
        String json;
        if (body instanceof String) {
            json = (String) body;
        } else {
            json = objectMapper.writeValueAsString(body);
        }
        
        StringEntity entity = new StringEntity(json, ContentType.APPLICATION_JSON);
        request.setEntity(entity);
    }
    
    /**
     * Process an HTTP response
     * 
     * @param response HTTP response
     * @param responseTimeMs Response time in milliseconds
     * @return APIResponse object
     * @throws IOException if response processing fails
     */
    private APIResponse processResponse(CloseableHttpResponse response, long responseTimeMs) throws IOException {
        // Get status code
        int statusCode = response.getStatusLine().getStatusCode();
        
        // Get headers
        Map<String, List<String>> headers = new HashMap<>();
        for (Header header : response.getAllHeaders()) {
            headers.computeIfAbsent(header.getName(), k -> new ArrayList<>())
                  .add(header.getValue());
        }
        
        // Get body
        String responseBody = null;
        HttpEntity entity = response.getEntity();
        if (entity != null) {
            responseBody = EntityUtils.toString(entity);
        }
        
        // Parse body as JSON if possible
        JsonNode jsonBody = null;
        if (responseBody != null && !responseBody.isEmpty()) {
            try {
                jsonBody = objectMapper.readTree(responseBody);
            } catch (Exception e) {
                // Not JSON, ignore
                log.debug("Response body is not valid JSON");
            }
        }
        
        // Build and return response object
        return APIResponse.builder()
                .statusCode(statusCode)
                .headers(headers)
                .rawBody(responseBody)
                .jsonBody(jsonBody)
                .responseTimeMs(responseTimeMs)
                .build();
    }
    
    /**
     * Send a GET request
     * 
     * @param endpoint API endpoint
     * @return APIResponse object
     */
    public APIResponse get(String endpoint) {
        return sendRequest(Method.GET, endpoint, null, null);
    }
    
    /**
     * Send a GET request with headers
     * 
     * @param endpoint API endpoint
     * @param headers HTTP headers
     * @return APIResponse object
     */
    public APIResponse get(String endpoint, Map<String, String> headers) {
        return sendRequest(Method.GET, endpoint, headers, null);
    }
    
    /**
     * Send a POST request
     * 
     * @param endpoint API endpoint
     * @param body Request body
     * @return APIResponse object
     */
    public APIResponse post(String endpoint, Object body) {
        return sendRequest(Method.POST, endpoint, null, body);
    }
    
    /**
     * Send a POST request with headers
     * 
     * @param endpoint API endpoint
     * @param headers HTTP headers
     * @param body Request body
     * @return APIResponse object
     */
    public APIResponse post(String endpoint, Map<String, String> headers, Object body) {
        return sendRequest(Method.POST, endpoint, headers, body);
    }
    
    /**
     * Send a PUT request
     * 
     * @param endpoint API endpoint
     * @param body Request body
     * @return APIResponse object
     */
    public APIResponse put(String endpoint, Object body) {
        return sendRequest(Method.PUT, endpoint, null, body);
    }
    
    /**
     * Send a PUT request with headers
     * 
     * @param endpoint API endpoint
     * @param headers HTTP headers
     * @param body Request body
     * @return APIResponse object
     */
    public APIResponse put(String endpoint, Map<String, String> headers, Object body) {
        return sendRequest(Method.PUT, endpoint, headers, body);
    }
    
    /**
     * Send a DELETE request
     * 
     * @param endpoint API endpoint
     * @return APIResponse object
     */
    public APIResponse delete(String endpoint) {
        return sendRequest(Method.DELETE, endpoint, null, null);
    }
    
    /**
     * Send a DELETE request with headers
     * 
     * @param endpoint API endpoint
     * @param headers HTTP headers
     * @return APIResponse object
     */
    public APIResponse delete(String endpoint, Map<String, String> headers) {
        return sendRequest(Method.DELETE, endpoint, headers, null);
    }
    
    /**
     * Send a PATCH request
     * 
     * @param endpoint API endpoint
     * @param body Request body
     * @return APIResponse object
     */
    public APIResponse patch(String endpoint, Object body) {
        return sendRequest(Method.PATCH, endpoint, null, body);
    }
    
    /**
     * Send a PATCH request with headers
     * 
     * @param endpoint API endpoint
     * @param headers HTTP headers
     * @param body Request body
     * @return APIResponse object
     */
    public APIResponse patch(String endpoint, Map<String, String> headers, Object body) {
        return sendRequest(Method.PATCH, endpoint, headers, body);
    }
    
    /**
     * Close the HTTP client
     */
    public void close() {
        try {
            httpClient.close();
        } catch (IOException e) {
            log.error("Error closing HTTP client", e);
        }
    }
    
    /**
     * API response data class
     */
    @Data
    @Builder
    public static class APIResponse {
        private final int statusCode;
        private final Map<String, List<String>> headers;
        private final String rawBody;
        private final JsonNode jsonBody;
        private final long responseTimeMs;
        
        /**
         * Check if the response has a successful status code (2xx)
         * 
         * @return true if successful
         */
        public boolean isSuccessful() {
            return statusCode >= 200 && statusCode < 300;
        }
        
        /**
         * Get header value
         * 
         * @param name Header name
         * @return First header value or null
         */
        public String getHeader(String name) {
            List<String> values = headers.get(name);
            return values != null && !values.isEmpty() ? values.get(0) : null;
        }
        
        /**
         * Get all header values
         * 
         * @param name Header name
         * @return List of header values
         */
        public List<String> getHeaders(String name) {
            return headers.getOrDefault(name, new ArrayList<>());
        }
        
        /**
         * Get a JSON value as an object
         * 
         * @param path JSON path
         * @return JsonNode at path
         */
        public JsonNode getJsonValue(String path) {
            if (jsonBody == null) {
                return null;
            }
            
            String[] parts = path.split("\\.");
            JsonNode current = jsonBody;
            
            for (String part : parts) {
                current = current.path(part);
                if (current.isMissingNode()) {
                    return null;
                }
            }
            
            return current;
        }
        
        /**
         * Get a JSON value as a string
         * 
         * @param path JSON path
         * @return String value
         */
        public String getStringValue(String path) {
            JsonNode node = getJsonValue(path);
            return node != null && !node.isNull() ? node.asText() : null;
        }
        
        /**
         * Get a JSON value as an integer
         * 
         * @param path JSON path
         * @return Integer value
         */
        public Integer getIntValue(String path) {
            JsonNode node = getJsonValue(path);
            return node != null && !node.isNull() ? node.asInt() : null;
        }
        
        /**
         * Get a JSON value as a boolean
         * 
         * @param path JSON path
         * @return Boolean value
         */
        public Boolean getBooleanValue(String path) {
            JsonNode node = getJsonValue(path);
            return node != null && !node.isNull() ? node.asBoolean() : null;
        }
        
        /**
         * Convert JSON body to an object
         * 
         * @param <T> Target type
         * @param objectMapper ObjectMapper for conversion
         * @param type Class of target type
         * @return Converted object
         * @throws IOException if conversion fails
         */
        public <T> T convertJsonBody(ObjectMapper objectMapper, Class<T> type) throws IOException {
            if (rawBody == null || rawBody.isEmpty()) {
                return null;
            }
            return objectMapper.readValue(rawBody, type);
        }
    }
}

package com.cssmart.api;

import com.cssmart.api.APIClient.APIResponse;
import com.fasterxml.jackson.databind.JsonNode;
import org.hamcrest.MatcherAssert;
import org.hamcrest.Matchers;
import org.testng.Assert;

import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

/**
 * Assertions for API testing
 */
public class APIAssertions {
    
    private final APIResponse response;
    
    /**
     * Create new assertions for a response
     * 
     * @param response API response
     */
    public APIAssertions(APIResponse response) {
        this.response = response;
    }
    
    /**
     * Verify status code
     * 
     * @param expectedStatusCode Expected status code
     * @return This assertions object for chaining
     */
    public APIAssertions statusCode(int expectedStatusCode) {
        Assert.assertEquals(response.getStatusCode(), expectedStatusCode,
                "Status code mismatch. Expected: " + expectedStatusCode + ", Actual: " + response.getStatusCode());
        return this;
    }
    
    /**
     * Verify status code is in range
     * 
     * @param minStatusCode Minimum status code (inclusive)
     * @param maxStatusCode Maximum status code (inclusive)
     * @return This assertions object for chaining
     */
    public APIAssertions statusCodeBetween(int minStatusCode, int maxStatusCode) {
        int actualStatusCode = response.getStatusCode();
        Assert.assertTrue(actualStatusCode >= minStatusCode && actualStatusCode <= maxStatusCode,
                "Status code not in range. Expected between: " + minStatusCode + " and " + maxStatusCode +
                        ", Actual: " + actualStatusCode);
        return this;
    }
    
    /**
     * Verify status code is successful (2xx)
     * 
     * @return This assertions object for chaining
     */
    public APIAssertions isSuccessful() {
        Assert.assertTrue(response.isSuccessful(),
                "Expected successful status code, got: " + response.getStatusCode());
        return this;
    }
    
    /**
     * Verify header exists
     * 
     * @param headerName Header name
     * @return This assertions object for chaining
     */
    public APIAssertions headerExists(String headerName) {
        Assert.assertNotNull(response.getHeader(headerName),
                "Header does not exist: " + headerName);
        return this;
    }
    
    /**
     * Verify header value
     * 
     * @param headerName Header name
     * @param expectedValue Expected value
     * @return This assertions object for chaining
     */
    public APIAssertions headerEquals(String headerName, String expectedValue) {
        String actualValue = response.getHeader(headerName);
        Assert.assertEquals(actualValue, expectedValue,
                "Header value mismatch for " + headerName + ". Expected: " + expectedValue + ", Actual: " + actualValue);
        return this;
    }
    
    /**
     * Verify header value contains text
     * 
     * @param headerName Header name
     * @param expectedSubstring Expected substring
     * @return This assertions object for chaining
     */
    public APIAssertions headerContains(String headerName, String expectedSubstring) {
        String actualValue = response.getHeader(headerName);
        Assert.assertNotNull(actualValue, "Header does not exist: " + headerName);
        Assert.assertTrue(actualValue.contains(expectedSubstring),
                "Header value does not contain expected substring. Header: " + headerName +
                        ", Expected substring: " + expectedSubstring + ", Actual value: " + actualValue);
        return this;
    }
    
    /**
     * Verify header value matches pattern
     * 
     * @param headerName Header name
     * @param pattern Expected pattern
     * @return This assertions object for chaining
     */
    public APIAssertions headerMatches(String headerName, String pattern) {
        String actualValue = response.getHeader(headerName);
        Assert.assertNotNull(actualValue, "Header does not exist: " + headerName);
        Assert.assertTrue(Pattern.matches(pattern, actualValue),
                "Header value does not match pattern. Header: " + headerName +
                        ", Pattern: " + pattern + ", Actual value: " + actualValue);
        return this;
    }
    
    /**
     * Verify content type
     * 
     * @param expectedContentType Expected content type
     * @return This assertions object for chaining
     */
    public APIAssertions contentType(String expectedContentType) {
        return headerContains("Content-Type", expectedContentType);
    }
    
    /**
     * Verify body is not empty
     * 
     * @return This assertions object for chaining
     */
    public APIAssertions bodyNotEmpty() {
        Assert.assertTrue(response.getRawBody() != null && !response.getRawBody().isEmpty(),
                "Response body is empty");
        return this;
    }
    
    /**
     * Verify body contains text
     * 
     * @param expectedSubstring Expected substring
     * @return This assertions object for chaining
     */
    public APIAssertions bodyContains(String expectedSubstring) {
        Assert.assertTrue(response.getRawBody() != null && response.getRawBody().contains(expectedSubstring),
                "Response body does not contain expected substring: " + expectedSubstring);
        return this;
    }
    
    /**
     * Verify body matches pattern
     * 
     * @param pattern Expected pattern
     * @return This assertions object for chaining
     */
    public APIAssertions bodyMatches(String pattern) {
        Assert.assertTrue(response.getRawBody() != null && Pattern.matches(pattern, response.getRawBody()),
                "Response body does not match pattern: " + pattern);
        return this;
    }
    
    /**
     * Verify JSON path exists
     * 
     * @param path JSON path
     * @return This assertions object for chaining
     */
    public APIAssertions jsonPathExists(String path) {
        JsonNode node = response.getJsonValue(path);
        Assert.assertNotNull(node, "JSON path does not exist: " + path);
        return this;
    }
    
    /**
     * Verify JSON path value equals
     * 
     * @param path JSON path
     * @param expectedValue Expected value
     * @return This assertions object for chaining
     */
    public APIAssertions jsonPathEquals(String path, String expectedValue) {
        String actualValue = response.getStringValue(path);
        Assert.assertEquals(actualValue, expectedValue,
                "JSON path value mismatch. Path: " + path +
                        ", Expected: " + expectedValue + ", Actual: " + actualValue);
        return this;
    }
    
    /**
     * Verify JSON path value contains
     * 
     * @param path JSON path
     * @param expectedSubstring Expected substring
     * @return This assertions object for chaining
     */
    public APIAssertions jsonPathContains(String path, String expectedSubstring) {
        String actualValue = response.getStringValue(path);
        Assert.assertNotNull(actualValue, "JSON path does not exist: " + path);
        Assert.assertTrue(actualValue.contains(expectedSubstring),
                "JSON path value does not contain expected substring. Path: " + path +
                        ", Expected substring: " + expectedSubstring + ", Actual value: " + actualValue);
        return this;
    }
    
    /**
     * Verify JSON path value as integer
     * 
     * @param path JSON path
     * @param expectedValue Expected value
     * @return This assertions object for chaining
     */
    public APIAssertions jsonPathIntEquals(String path, int expectedValue) {
        Integer actualValue = response.getIntValue(path);
        Assert.assertNotNull(actualValue, "JSON path does not exist or is not an integer: " + path);
        Assert.assertEquals(actualValue.intValue(), expectedValue,
                "JSON path value mismatch. Path: " + path +
                        ", Expected: " + expectedValue + ", Actual: " + actualValue);
        return this;
    }
    
    /**
     * Verify JSON path value as boolean
     * 
     * @param path JSON path
     * @param expectedValue Expected value
     * @return This assertions object for chaining
     */
    public APIAssertions jsonPathBooleanEquals(String path, boolean expectedValue) {
        Boolean actualValue = response.getBooleanValue(path);
        Assert.assertNotNull(actualValue, "JSON path does not exist or is not a boolean: " + path);
        Assert.assertEquals(
