

package com.cssmart.ui.controller;

import com.cssmart.reporting.model.TestReport;
import com.cssmart.reporting.model.TestStatus;
import com.cssmart.ui.service.ReportService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpStatus;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Optional;
import java.time.LocalDateTime;

/**
 * REST controller for test report operations
 */
@Slf4j
@RestController
@RequestMapping("/api/reports")
public class ReportController {
    
    private final ReportService reportService;
    
    @Autowired
    public ReportController(ReportService reportService) {
        this.reportService = reportService;
    }
    
    /**
     * Get test reports with optional filtering
     * @param status Filter by test status
     * @param dateRange Filter by date range (today, yesterday, last7days, etc.)
     * @param search Search by test name or class
     * @return List of filtered test reports
     */
    @GetMapping
    public List<TestReport> getReports(
            @RequestParam(name = "status", required = false) String status,
            @RequestParam(name = "dateRange", required = false, defaultValue = "last7days") String dateRange,
            @RequestParam(name = "search", required = false) String search) {
        
        log.info("Fetching test reports with filters - status: {}, dateRange: {}, search: {}", 
                status, dateRange, search);
        
        TestStatus statusFilter = status != null ? TestStatus.valueOf(status) : null;
        
        // Calculate date range based on the dateRange parameter
        LocalDateTime startDate = null;
        LocalDateTime endDate = LocalDateTime.now();
        
        switch (dateRange) {
            case "today":
                startDate = LocalDateTime.now().withHour(0).withMinute(0).withSecond(0);
                break;
            case "yesterday":
                startDate = LocalDateTime.now().minusDays(1).withHour(0).withMinute(0).withSecond(0);
                endDate = LocalDateTime.now().withHour(0).withMinute(0).withSecond(0);
                break;
            case "last7days":
                startDate = LocalDateTime.now().minusDays(7);
                break;
            case "last30days":
                startDate = LocalDateTime.now().minusDays(30);
                break;
            case "thisMonth":
                startDate = LocalDateTime.now().withDayOfMonth(1).withHour(0).withMinute(0).withSecond(0);
                break;
            case "lastMonth":
                LocalDateTime firstDayOfMonth = LocalDateTime.now().withDayOfMonth(1);
                startDate = firstDayOfMonth.minusMonths(1);
                endDate = firstDayOfMonth.minusSeconds(1);
                break;
            default:
                startDate = LocalDateTime.now().minusDays(7);
        }
        
        return reportService.getReports(statusFilter, startDate, endDate, search);
    }
    
    /**
     * Get a specific test report by ID
     * @param id Report ID
     * @return Test report details
     */
    @GetMapping("/{id}")
    public TestReport getReportById(@PathVariable("id") String id) {
        log.info("Fetching test report with ID: {}", id);
        
        Optional<TestReport> report = reportService.getReportById(id);
        
        if (!report.isPresent()) {
            log.warn("Test report not found with ID: {}", id);
            throw new ResourceNotFoundException("Test report not found with ID: " + id);
        }
        
        return report.get();
    }
    
    /**
     * Delete a test report
     * @param id Report ID
     * @return Success message
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<String> deleteReport(@PathVariable("id") String id) {
        log.info("Deleting test report with ID: {}", id);
        
        boolean deleted = reportService.deleteReport(id);
        
        if (!deleted) {
            log.warn("Test report not found for deletion with ID: {}", id);
            throw new ResourceNotFoundException("Test report not found with ID: " + id);
        }
        
        return ResponseEntity.ok("Report deleted successfully");
    }
    
    /**
     * Export reports to a specific format
     * @param format Export format (pdf, excel, etc.)
     * @return File download response
     */
    @GetMapping("/export")
    public ResponseEntity<Resource> exportReports(@RequestParam("format") String format) {
        log.info("Exporting reports in format: {}", format);
        
        Resource resource = reportService.exportReports(format);
        
        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=test-reports." + format)
                .body(resource);
    }
}

/**
 * Exception for resource not found
 */
@ResponseStatus(HttpStatus.NOT_FOUND)
class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

// src/main/webapp/src/components/common/Navbar.jsx
import React from 'react';
import { useNavigate } from 'react-router-dom';

const Navbar = ({ onNewTest }) => {
  // If not using React Router, you can remove this and use props.navigate or context instead
  const navigate = useNavigate();
  
  // Handle click on New Test button
  const handleNewTest = () => {
    // If onNewTest prop is provided, use it
    if (onNewTest) {
      onNewTest();
    } else {
      // Otherwise navigate to the test recorder as default
      navigate('/recorder');
    }
  };

  return (
    <header className="bg-white shadow h-16 flex items-center justify-between px-6">
      <div className="flex items-center">
        <h1 className="text-xl font-semibold">CS Smart Test Framework</h1>
      </div>
      <div className="flex items-center space-x-4">
        <button 
          className="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700"
          onClick={handleNewTest}
        >
          New Test
        </button>
        <div className="relative">
          <button className="p-1 rounded-full bg-gray-200 hover:bg-gray-300">
            <svg className="h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
            </svg>
          </button>
        </div>
      </div>
    </header>
  );
};

export default Navbar;

// src/main/webapp/src/App.jsx
import React, { useState } from 'react';
import Navbar from './components/common/Navbar';
import Sidebar from './components/common/Sidebar';
import Dashboard from './components/dashboard/Dashboard';
import TestRecorder from './components/recorder/TestRecorder';
import TestGenerator from './components/generator/TestGenerator';
import Reports from './components/reports/Reports';
import Configuration from './components/config/Configuration';

const App = () => {
  const [currentPage, setCurrentPage] = useState('dashboard');

  // Navigation handler
  const navigate = (page) => {
    setCurrentPage(page);
  };

  // Handler for "New Test" button
  const handleNewTest = () => {
    // Navigate to the recorder page
    setCurrentPage('recorder');
  };

  // Render current page based on state
  const renderPage = () => {
    switch (currentPage) {
      case 'dashboard':
        return <Dashboard />;
      case 'recorder':
        return <TestRecorder />;
      case 'generator':
        return <TestGenerator />;
      case 'reports':
        return <Reports />;
      case 'config':
        return <Configuration />;
      default:
        return <Dashboard />;
    }
  };

  return (
    <div className="flex h-screen bg-gray-100">
      <Sidebar navigate={navigate} currentPage={currentPage} />
      <div className="flex-1 flex flex-col overflow-hidden">
        <Navbar onNewTest={handleNewTest} />
        <main className="flex-1 overflow-x-hidden overflow-y-auto bg-gray-100 p-4">
          {renderPage()}
        </main>
      </div>
    </div>
  );
};

export default App;

// src/main/webapp/src/components/config/Configuration.jsx
import React, { useState, useEffect } from 'react';
import GeneralConfig from './GeneralConfig';
import BrowserConfig from './BrowserConfig';
import EnvironmentConfig from './EnvironmentConfig';
import Spinner from '../common/Spinner';
import Alert from '../common/Alert';

const Configuration = () => {
  const [activeTab, setActiveTab] = useState('general');
  const [config, setConfig] = useState({
    general: {},
    browser: {},
    environment: {}
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [saveStatus, setSaveStatus] = useState('');
  
  useEffect(() => {
    fetchConfig();
  }, []);
  
  const fetchConfig = async () => {
    try {
      setLoading(true);
      setError(null);
      
      // Fetch configuration from API
      const response = await fetch('/api/config');
      
      if (!response.ok) {
        throw new Error(`Failed to fetch configuration: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      setConfig(data);
      
    } catch (error) {
      console.error('Error fetching configuration:', error);
      setError(error.message || 'Failed to load configuration');
      // Set sample data for development if API fails
      setSampleConfig();
    } finally {
      setLoading(false);
    }
  };
  
  const setSampleConfig = () => {
    setConfig({
      general: {
        framework: {
          name: 'CSSmartTest',
          version: '1.0.0-SNAPSHOT',
          mode: 'zero-code'
        },
        execution: {
          parallel: true,
          threadCount: 5,
          retryCount: 1,
          timeout: 60
        },
        element: {
          timeout: 15,
          polling: 500
        },
        reporting: {
          format: 'html',
          screenshots: true,
          video: false,
          outputDir: './reports'
        }
      },
      browser: {
        default: 'chrome',
        browsers: {
          chrome: {
            driver: 'webdriver.chrome.driver',
            headless: false,
            arguments: [
              '--start-maximized',
              '--disable-notifications',
              '--disable-infobars'
            ],
            capabilities: {
              acceptInsecureCerts: true,
              pageLoadStrategy: 'normal'
            }
          },
          firefox: {
            driver: 'webdriver.gecko.driver',
            headless: false,
            arguments: [
              '--start-maximized',
              '--disable-notifications'
            ],
            capabilities: {
              acceptInsecureCerts: true,
              pageLoadStrategy: 'normal'
            }
          }
        }
      },
      environment: {
        default: 'qa',
        environments: {
          qa: {
            base: {
              url: 'https://qa.example.com',
              api: 'https://api-qa.example.com'
            },
            database: {
              host: 'qa-db.example.com',
              port: 3306,
              username: '${DB_USERNAME}',
              password: '${DB_PASSWORD}',
              name: 'qa_testdb'
            }
          },
          staging: {
            base: {
              url: 'https://staging.example.com',
              api: 'https://api-staging.example.com'
            },
            database: {
              host: 'staging-db.example.com',
              port: 3306,
              username: '${DB_USERNAME}',
              password: '${DB_PASSWORD}',
              name: 'staging_testdb'
            }
          }
        }
      }
    });
  };
  
  const saveConfig = async (section, data) => {
    setSaveStatus('saving');
    
    try {
      // Update local state for immediate feedback
      setConfig({
        ...config,
        [section]: data
      });
      
      // Make API call to save the config
      const response = await fetch(`/api/config/${section}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });
      
      if (!response.ok) {
        throw new Error(`Failed to save ${section} configuration: ${response.status} ${response.statusText}`);
      }
      
      setSaveStatus('success');
      
      // Clear success message after 3 seconds
      setTimeout(() => setSaveStatus(''), 3000);
      
    } catch (error) {
      console.error(`Error saving ${section} configuration:`, error);
      setSaveStatus('error');
      
      // Clear error message after 5 seconds
      setTimeout(() => setSaveStatus(''), 5000);
    }
  };
  
  const handleTabChange = (tab) => {
    // Only change tab if we're not in a loading state
    if (!loading) {
      setActiveTab(tab);
    }
  };
  
  // Render loading spinner
  if (loading) {
    return (
      <div className="flex justify-center items-center h-64">
        <Spinner size="lg" />
        <span className="ml-2 text-gray-600">Loading configuration...</span>
      </div>
    );
  }
  
  // Render error message
  if (error) {
    return (
      <div className="p-4">
        <Alert 
          type="error" 
          title="Configuration Error"
          onClose={() => setError(null)}
        >
          {error}
        </Alert>
        <div className="mt-4 flex justify-center">
          <button
            className="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700"
            onClick={fetchConfig}
          >
            Retry
          </button>
        </div>
      </div>
    );
  }
  
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold">Configuration</h1>
        
        {saveStatus && (
          <div className={`px-4 py-2 rounded ${
            saveStatus === 'saving' ? 'bg-blue-100 text-blue-800' :
            saveStatus === 'success' ? 'bg-green-100 text-green-800' :
            'bg-red-100 text-red-800'
          }`}>
            {saveStatus === 'saving' ? 'Saving...' :
             saveStatus === 'success' ? 'Configuration saved successfully!' :
             'Failed to save configuration'}
          </div>
        )}
      </div>
      
      <div className="bg-white rounded-lg shadow overflow-hidden">
        <div className="border-b">
          <nav className="flex">
            <button
              className={`px-6 py-3 border-b-2 font-medium text-sm transition-colors ${
                activeTab === 'general'
                  ? 'border-indigo-500 text-indigo-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
              }`}
              onClick={() => handleTabChange('general')}
            >
              General
            </button>
            <button
              className={`px-6 py-3 border-b-2 font-medium text-sm transition-colors ${
                activeTab === 'browser'
                  ? 'border-indigo-500 text-indigo-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
              }`}
              onClick={() => handleTabChange('browser')}
            >
              Browsers
            </button>
            <button
              className={`px-6 py-3 border-b-2 font-medium text-sm transition-colors ${
                activeTab === 'environment'
                  ? 'border-indigo-500 text-indigo-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
              }`}
              onClick={() => handleTabChange('environment')}
            >
              Environments
            </button>
          </nav>
        </div>
        
        <div className="p-6">
          {activeTab === 'general' && (
            <GeneralConfig 
              config={config.general} 
              saveConfig={(data) => saveConfig('general', data)} 
            />
          )}
          
          {activeTab === 'browser' && (
            <BrowserConfig 
              config={config.browser} 
              saveConfig={(data) => saveConfig('browser', data)} 
            />
          )}
          
          {activeTab === 'environment' && (
            <EnvironmentConfig 
              config={config.environment} 
              saveConfig={(data) => saveConfig('environment', data)} 
            />
          )}
        </div>
      </div>
    </div>
  );
};

export default Configuration;

// src/main/webapp/src/components/recorder/TestRecorder.jsx
import React, { useState, useEffect, useRef } from 'react';
import RecordedSteps from './RecordedSteps';
import RecorderConfig from './RecorderConfig';
import TestCodeViewer from './TestCodeViewer';
import Button from '../common/Button';
import Alert from '../common/Alert';
import Spinner from '../common/Spinner';

const TestRecorder = () => {
  const [isRecording, setIsRecording] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [recordedSteps, setRecordedSteps] = useState([]);
  const [testCase, setTestCase] = useState(null);
  const [generatingCode, setGeneratingCode] = useState(false);
  const [error, setError] = useState(null);
  const [successMessage, setSuccessMessage] = useState(null);
  const [config, setConfig] = useState({
    url: 'https://example.com',
    browser: 'chrome',
    headless: false
  });
  const websocket = useRef(null);
  
  // Handle WebSocket cleanup on component unmount
  useEffect(() => {
    return () => {
      if (websocket.current) {
        websocket.current.close();
      }
    };
  }, []);
  
  // Connect to WebSocket when starting recording
  const connectWebSocket = () => {
    try {
      setIsConnecting(true);
      setError(null);
      
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/recorder`;
      
      websocket.current = new WebSocket(wsUrl);
      
      websocket.current.onopen = () => {
        console.log('WebSocket connected');
        setIsConnecting(false);
        websocket.current.send(JSON.stringify({ type: 'START_RECORDING' }));
      };
      
      websocket.current.onmessage = (event) => {
        const message = JSON.parse(event.data);
        
        if (message.type === 'RECORDING_STARTED') {
          console.log('Recording started');
          setIsRecording(true);
        } else if (message.type === 'ACTION_RECORDED') {
          console.log('Action recorded');
        } else if (message.type === 'STEP_RECORDED') {
          console.log('Step recorded:', message.data);
          setRecordedSteps(prev => [...prev, message.data]);
        } else if (message.type === 'TEST_CASE') {
          console.log('Test case received:', message.data);
          setTestCase(message.data);
          setIsRecording(false);
        } else if (message.type === 'ERROR') {
          console.error('WebSocket error:', message.data);
          setError(`Error: ${message.data}`);
          setIsRecording(false);
          setIsConnecting(false);
        }
      };
      
      websocket.current.onerror = (error) => {
        console.error('WebSocket error:', error);
        setError('Failed to connect to the recording service. Please check if the server is running.');
        setIsRecording(false);
        setIsConnecting(false);
      };
      
      websocket.current.onclose = () => {
        console.log('WebSocket disconnected');
        if (isRecording) {
          setIsRecording(false);
        }
      };
      
      return true;
    } catch (error) {
      console.error('Error connecting to WebSocket:', error);
      setError(`Connection error: ${error.message}`);
      setIsRecording(false);
      setIsConnecting(false);
      return false;
    }
  };
  
  // Start recording
  const startRecording = () => {
    setRecordedSteps([]);
    setTestCase(null);
    setError(null);
    setSuccessMessage(null);
    
    const connected = connectWebSocket();
    if (!connected) {
      setError('Failed to start recording. Could not connect to server.');
    }
  };
  
  // Stop recording
  const stopRecording = () => {
    if (websocket.current && websocket.current.readyState === WebSocket.OPEN) {
      websocket.current.send(JSON.stringify({ type: 'STOP_RECORDING' }));
      setGeneratingCode(true);
    } else {
      setError('WebSocket is not connected. Cannot stop recording.');
    }
  };
  
  // Update configuration
  const updateConfig = (newConfig) => {
    setConfig(newConfig);
  };
  
  // Save test case
  const saveTestCase = async () => {
    if (!testCase) return;
    
    try {
      const response = await fetch('/api/recorder/save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(testCase),
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      setSuccessMessage('Test case saved successfully!');
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(null), 3000);
      
    } catch (error) {
      console.error('Error saving test case:', error);
      setError(`Failed to save test case: ${error.message}`);
    }
  };
  
  // Edit in Test Generator
  const editInGenerator = () => {
    // In a real application, this would probably redirect to the Test Generator
    // with the current test case data, or use a shared state management solution
    
    // For now, we'll simulate success to demonstrate the feature
    setSuccessMessage('Opening in Test Generator...');
    
    // Redirect to Test Generator after a short delay
    setTimeout(() => {
      window.location.href = '#/generator';
      // or using React Router: navigate('/generator');
    }, 1000);
  };
  
  // Render error alert
  const renderError = () => {
    if (!error) return null;
    
    return (
      <Alert
        type="error"
        title="Recording Error"
        onClose={() => setError(null)}
      >
        {error}
      </Alert>
    );
  };
  
  // Render success message
  const renderSuccess = () => {
    if (!successMessage) return null;
    
    return (
      <Alert
        type="success"
        title="Success"
        onClose={() => setSuccessMessage(null)}
      >
        {successMessage}
      </Alert>
    );
  };
  
  return (
    <div className="space-y-6">
      {/* Header with action buttons */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold">Test Recorder</h1>
        <div className="flex space-x-2">
          {!isRecording ? (
            <Button
              variant="primary"
              disabled={isConnecting}
              onClick={startRecording}
            >
              {isConnecting ? (
                <>
                  <Spinner size="sm" color="white" className="mr-2" />
                  Connecting...
                </>
              ) : (
                'Start Recording'
              )}
            </Button>
          ) : (
            <Button
              variant="danger"
              onClick={stopRecording}
            >
              Stop Recording
            </Button>
          )}
        </div>
      </div>
      
      {/* Error and success messages */}
      {renderError()}
      {renderSuccess()}
      
      {/* Configuration and steps */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <RecorderConfig 
          config={config} 
          updateConfig={updateConfig} 
          disabled={isRecording || isConnecting} 
        />
        
        <RecordedSteps 
          steps={recordedSteps} 
          isRecording={isRecording}
        />
      </div>
      
      {/* Generated test code */}
      {generatingCode && !testCase && (
        <div className="bg-white rounded-lg shadow p-6 flex justify-center items-center">
          <Spinner size="md" className="mr-3" />
          <span>Generating test code...</span>
        </div>
      )}
      
      {testCase && (
        <div className="bg-white rounded-lg shadow p-6">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-semibold">Generated Test</h2>
            <div className="flex space-x-2">
              <Button
                variant="outline"
                onClick={editInGenerator}
              >
                Edit in Test Generator
              </Button>
              <Button
                variant="primary"
                onClick={saveTestCase}
              >
                Save Test
              </Button>
            </div>
          </div>
          <TestCodeViewer code={testCase.code} />
        </div>
      )}
    </div>
  );
};

export default TestRecorder;

// src/main/webapp/src/components/generator/TestGenerator.jsx
import React, { useState, useEffect } from 'react';
import TestBuilder from './TestBuilder';
import DescriptionInput from './DescriptionInput';
import Alert from '../common/Alert';
import Spinner from '../common/Spinner';
import { useLocation } from 'react-router-dom';

const TestGenerator = () => {
  const [description, setDescription] = useState('');
  const [generatedTest, setGeneratedTest] = useState(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState(null);
  const [successMessage, setSuccessMessage] = useState(null);
  
  // Get location to check for imported test data (if using React Router)
  const location = useLocation();
  
  // Check for imported test from Test Recorder
  useEffect(() => {
    // If using React Router and state contains test data
    if (location?.state?.testCase) {
      const importedTest = location.state.testCase;
      setGeneratedTest(importedTest);
      setDescription(importedTest.description || '');
      setSuccessMessage('Test imported from Test Recorder');
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(null), 3000);
    }
    
    // Alternative approach using URL parameters or localStorage
    const importedTestJson = localStorage.getItem('importedTest');
    if (importedTestJson) {
      try {
        const importedTest = JSON.parse(importedTestJson);
        setGeneratedTest(importedTest);
        setDescription(importedTest.description || '');
        setSuccessMessage('Test imported from Test Recorder');
        
        // Clear from localStorage so it doesn't reappear on refresh
        localStorage.removeItem('importedTest');
        
        // Clear success message after 3 seconds
        setTimeout(() => setSuccessMessage(null), 3000);
      } catch (e) {
        console.error('Error parsing imported test:', e);
      }
    }
  }, [location]);
  
  // Generate test from description
  const generateTest = async () => {
    if (!description.trim()) {
      setError('Please enter a test description');
      return;
    }
    
    setIsGenerating(true);
    setError(null);
    
    try {
      // Call the API to generate the test
      const response = await fetch('/api/generator/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ description }),
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      setGeneratedTest(data);
      setSuccessMessage('Test generated successfully!');
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (err) {
      console.error('Error generating test:', err);
      setError(`Failed to generate test: ${err.message}`);
    } finally {
      setIsGenerating(false);
    }
  };
  
  // Save updated test
  const saveTest = async (updatedTest) => {
    try {
      setIsGenerating(true);
      
      const response = await fetch('/api/generator/save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(updatedTest),
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const savedTest = await response.json();
      setGeneratedTest(savedTest);
      setSuccessMessage('Test saved successfully!');
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (err) {
      console.error('Error saving test:', err);
      setError(`Failed to save test: ${err.message}`);
    } finally {
      setIsGenerating(false);
    }
  };
  
  // Clear current test and start over
  const clearTest = () => {
    if (window.confirm('Are you sure you want to clear the current test? All changes will be lost.')) {
      setGeneratedTest(null);
      setDescription('');
    }
  };
  
  // Run generated test
  const runTest = async () => {
    if (!generatedTest?.id) {
      setError('Please save the test before running it.');
      return;
    }
    
    try {
      setIsGenerating(true);
      
      const response = await fetch(`/api/tests/${generatedTest.id}/run`, {
        method: 'POST',
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      setSuccessMessage('Test execution started! Check Reports for results.');
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (err) {
      console.error('Error running test:', err);
      setError(`Failed to run test: ${err.message}`);
    } finally {
      setIsGenerating(false);
    }
  };
  
  // Render error alert
  const renderError = () => {
    if (!error) return null;
    
    return (
      <Alert
        type="error"
        title="Error"
        onClose={() => setError(null)}
      >
        {error}
      </Alert>
    );
  };
  
  // Render success message
  const renderSuccess = () => {
    if (!successMessage) return null;
    
    return (
      <Alert
        type="success"
        title="Success"
        onClose={() => setSuccessMessage(null)}
      >
        {successMessage}
      </Alert>
    );
  };
  
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold">Test Generator</h1>
        {generatedTest && (
          <div className="flex space-x-2">
            <button
              className="px-3 py-1 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300"
              onClick={clearTest}
            >
              New Test
            </button>
            <button
              className="px-3 py-1 bg-green-600 text-white rounded-md hover:bg-green-700"
              onClick={runTest}
              disabled={isGenerating}
            >
              Run Test
            </button>
          </div>
        )}
      </div>
      
      {/* Error and success messages */}
      {renderError()}
      {renderSuccess()}
      
      {!generatedTest ? (
        <DescriptionInput 
          description={description} 
          setDescription={setDescription} 
          generateTest={generateTest}
          isGenerating={isGenerating}
        />
      ) : (
        <TestBuilder 
          test={generatedTest} 
          onSave={saveTest}
          isProcessing={isGenerating}
        />
      )}
      
      {isGenerating && !generatedTest && (
        <div className="bg-white rounded-lg shadow p-10 flex flex-col items-center justify-center">
          <Spinner size="lg" className="mb-4" />
          <p className="text-gray-700">Generating test using AI...</p>
          <p className="text-gray-500 text-sm mt-2">This may take a few moments.</p>
        </div>
      )}
    </div>
  );
};

export default TestGenerator;

// src/main/webapp/src/components/generator/TestBuilder.jsx
import React, { useState, useEffect } from 'react';
import TestStep from './TestStep';
import Button from '../common/Button';
import TextField from '../common/TextField';
import Spinner from '../common/Spinner';
import CodeViewer from '../common/CodeViewer';

const TestBuilder = ({ test, onSave, isProcessing = false }) => {
  const [steps, setSteps] = useState(test.steps || []);
  const [testName, setTestName] = useState(test.name || 'Generated Test');
  const [testDescription, setTestDescription] = useState(test.description || '');
  const [isSaving, setIsSaving] = useState(false);
  const [showCode, setShowCode] = useState(false);
  const [isGeneratingCode, setIsGeneratingCode] = useState(false);
  const [generatedCode, setGeneratedCode] = useState(test.code || '');
  
  // Update steps if test prop changes
  useEffect(() => {
    if (test) {
      setSteps(test.steps || []);
      setTestName(test.name || 'Generated Test');
      setTestDescription(test.description || '');
      setGeneratedCode(test.code || '');
    }
  }, [test]);
  
  // Update a step
  const updateStep = (index, updatedStep) => {
    const newSteps = [...steps];
    newSteps[index] = { ...newSteps[index], ...updatedStep };
    setSteps(newSteps);
  };
  
  // Add a new step
  const addStep = () => {
    setSteps([...steps, { 
      action: 'CLICK', 
      description: 'New step', 
      element: '', 
      value: '' 
    }]);
  };
  
  // Remove a step
  const removeStep = (index) => {
    const newSteps = [...steps];
    newSteps.splice(index, 1);
    setSteps(newSteps);
  };
  
  // Move step up
  const moveStepUp = (index) => {
    if (index === 0) return;
    const newSteps = [...steps];
    [newSteps[index - 1], newSteps[index]] = [newSteps[index], newSteps[index - 1]];
    setSteps(newSteps);
  };
  
  // Move step down
  const moveStepDown = (index) => {
    if (index === steps.length - 1) return;
    const newSteps = [...steps];
    [newSteps[index], newSteps[index + 1]] = [newSteps[index + 1], newSteps[index]];
    setSteps(newSteps);
  };
  
  // Generate code from steps
  const generateCode = async () => {
    setIsGeneratingCode(true);
    
    try {
      // In a real application, this would call an API endpoint
      // to generate code based on the current steps
      
      // For now, simulate a network request
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Since we don't have a real API for code generation,
      // we'll use the existing code or a placeholder
      if (!generatedCode) {
        setGeneratedCode(
          `// Generated code for ${testName}\n` +
          `// Steps: ${steps.length}\n\n` +
          `package com.cssmart.tests.generated;\n\n` +
          `import com.cssmart.core.base.CSSmartTestBase;\n` +
          `import com.cssmart.core.annotations.CSSmartTest;\n` +
          `import org.testng.annotations.Test;\n` +
          `import org.openqa.selenium.WebElement;\n` +
          `import lombok.extern.slf4j.Slf4j;\n\n` +
          `@Slf4j\n` +
          `public class ${testName.replace(/[^a-zA-Z0-9]/g, '')}Test extends CSSmartTestBase {\n\n` +
          `    @Test\n` +
          `    @CSSmartTest(description = "${testDescription}")\n` +
          `    public void test${testName.replace(/[^a-zA-Z0-9]/g, '')}() {\n` +
          `        log.info("Starting test: ${testDescription}");\n\n` +
          steps.map(step => 
            `        // ${step.description}\n` +
            (step.action === 'NAVIGATE' ? 
              `        driver.get("${step.value}");\n` :
            step.action === 'CLICK' ?
              `        WebElement element = elementFinder.findElement("${step.element}");\n` +
              `        element.click();\n` :
            step.action === 'TYPE' ?
              `        WebElement element = elementFinder.findElement("${step.element}");\n` +
              `        element.clear();\n` +
              `        element.sendKeys("${step.value}");\n` :
            step.action === 'SELECT' ?
              `        WebElement element = elementFinder.findElement("${step.element}");\n` +
              `        new Select(element).selectByVisibleText("${step.value}");\n` :
            step.action === 'VERIFY_PRESENCE' ?
              `        WebElement element = elementFinder.findElement("${step.element}");\n` +
              `        Assert.assertTrue(element.isDisplayed(), "${step.element} should be present");\n` :
              `        // TODO: Implement ${step.action} action\n`
            ) +
            '\n'
          ).join('') +
          `        log.info("Test completed successfully");\n` +
          `    }\n` +
          `}\n`
        );
      }
      
      // Show the code tab
      setShowCode(true);
    } catch (error) {
      console.error('Error generating code:', error);
      alert('Error generating code: ' + error.message);
    } finally {
      setIsGeneratingCode(false);
    }
  };
  
  // Save the test
  const saveTest = async () => {
    if (isSaving || isProcessing) return;
    
    setIsSaving(true);
    
    try {
      // Check if we need to regenerate code first
      if (!generatedCode) {
        await generateCode();
      }
      
      // Create updated test object
      const updatedTest = {
        ...test,
        name: testName,
        description: testDescription,
        steps: steps,
        code: generatedCode
      };
      
      // Save using the provided onSave callback
      await onSave(updatedTest);
    } catch (error) {
      console.error('Error saving test:', error);
      alert('Error saving test: ' + error.message);
    } finally {
      setIsSaving(false);
    }
  };
  
  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl font-semibold">Test Builder</h2>
        <div className="flex items-center space-x-2">
          {!showCode ? (
            <Button
              variant="secondary"
              onClick={generateCode}
              disabled={isGeneratingCode || isProcessing}
            >
              {isGeneratingCode ? (
                <>
                  <Spinner size="sm" className="mr-2" />
                  Generating Code...
                </>
              ) : (
                'View Code'
              )}
            </Button>
          ) : (
            <Button
              variant="secondary"
              onClick={() => setShowCode(false)}
            >
              Edit Steps
            </Button>
          )}
          <Button
            variant="primary"
            onClick={saveTest}
            disabled={isSaving || isProcessing}
          >
            {isSaving ? (
              <>
                <Spinner size="sm" color="white" className="mr-2" />
                Saving...
              </>
            ) : (
              'Save Test'
            )}
          </Button>
        </div>
      </div>
      
      {!showCode ? (
        <>
          <div className="mb-6 space-y-4">
            <TextField
              label="Test Name"
              value={testName}
              onChange={(e) => setTestName(e.target.value)}
              required
            />
            <TextField
              label="Test Description"
              value={testDescription}
              onChange={(e) => setTestDescription(e.target.value)}
              required
              multiline
              rows={3}
            />
          </div>
          
          <div className="space-y-4">
            <div className="flex justify-between items-center">
              <h3 className="text-lg font-medium">Test Steps</h3>
              <Button
                variant="outline"
                size="sm"
                onClick={addStep}
              >
                Add Step
              </Button>
            </div>
            
            {steps.length === 0 ? (
              <div className="text-center py-8 text-gray-500 border border-dashed rounded-lg">
                No steps in this test yet. Click "Add Step" to start building your test.
              </div>
            ) : (
              steps.map((step, index) => (
                <TestStep
                  key={index}
                  step={step}
                  index={index}
                  updateStep={(updatedStep) => updateStep(index, updatedStep)}
                  removeStep={() => removeStep(index)}
                  moveUp={() => moveStepUp(index)}
                  moveDown={() => moveStepDown(index)}
                  isFirst={index === 0}
                  isLast={index === steps.length - 1}
                />
              ))
            )}
          </div>
        </>
      ) : (
        <div className="space-y-4">
          <div className="flex justify-between items-center">
            <h3 className="text-lg font-medium">Generated Code</h3>
            <div className="text-sm text-gray-500">
              {steps.length} steps • {testName}
            </div>
          </div>
          
          <CodeViewer
            code={generatedCode}
            language="java"
          />
        </div>
      )}
    </div>
  );
};

export default TestBuilder;

package com.cssmart.core.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.fasterxml.jackson.core.type.TypeReference;
import lombok.extern.slf4j.Slf4j;
import java.io.File;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.Path;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.Arrays;
import java.util.concurrent.ConcurrentHashMap;

import com.cssmart.core.config.exceptions.ConfigurationException;

@Slf4j
public class ConfigurationManager {
    private static ConfigurationManager instance;
    private final Map<String, Object> configCache;
    private final ObjectMapper yamlMapper;
    private final EnvironmentManager environmentManager;
    
    private static final String DEFAULT_CONFIG_DIR = "config";
    private static final String[] DEFAULT_CONFIG_FILES = {
        "general-config.yaml",
        "browser-config.yaml",
        "environment-config.yaml"
    };
    
    private ConfigurationManager() {
        this.configCache = new ConcurrentHashMap<>();
        this.yamlMapper = new ObjectMapper(new YAMLFactory());
        this.environmentManager = new EnvironmentManager();
        loadDefaultConfig();
    }
    
    public static ConfigurationManager getInstance() {
        if (instance == null) {
            synchronized (ConfigurationManager.class) {
                if (instance == null) {
                    instance = new ConfigurationManager();
                }
            }
        }
        return instance;
    }
    
    /**
     * Load configuration from a file path
     * @param configPath Path to configuration file
     */
    public void loadConfig(String configPath) {
        try {
            log.info("Loading configuration from: {}", configPath);
            
            File configFile = new File(configPath);
            if (!configFile.exists()) {
                log.warn("Configuration file not found: {}", configPath);
                return;
            }
            
            // Load configuration file
            Map<String, Object> config = yamlMapper.readValue(
                configFile, 
                new TypeReference<Map<String, Object>>() {}
            );
            
            // Process environment variables
            config = environmentManager.processEnvironmentVariables(config);
            
            // Extract section name from file path
            String section = getSectionFromFilePath(configPath);
            
            // Update cache with the section
            configCache.put(section, config);
            
            log.info("Successfully loaded configuration for section: {}", section);
            
        } catch (Exception e) {
            log.error("Failed to load configuration from: {}", configPath, e);
            throw new ConfigurationException("Configuration loading failed: " + e.getMessage(), e);
        }
    }
    
    /**
     * Get configuration for a specific section and type
     * @param key Section key (general, browser, environment)
     * @param type Class type to convert to
     * @return Configuration object
     */
    public <T> T getConfig(String key, Class<T> type) {
        Object value = configCache.get(key);
        if (value == null) {
            log.warn("Configuration not found for key: {}", key);
            return null;
        }
        
        try {
            return yamlMapper.convertValue(value, type);
        } catch (Exception e) {
            log.error("Failed to convert configuration value: {}", key, e);
            throw new ConfigurationException("Configuration conversion failed: " + e.getMessage(), e);
        }
    }
    
    /**
     * Update configuration section
     * @param section Section to update
     * @param config New configuration
     */
    public void updateConfig(String section, Map<String, Object> config) {
        try {
            log.info("Updating configuration for section: {}", section);
            
            // Process environment variables
            config = environmentManager.processEnvironmentVariables(config);
            
            // Update cache
            configCache.put(section, config);
            
            // Save to file
            String configPath = DEFAULT_CONFIG_DIR + "/" + section + "-config.yaml";
            saveConfigToFile(section, config, configPath);
            
            log.info("Successfully updated configuration for section: {}", section);
            
        } catch (Exception e) {
            log.error("Failed to update configuration for section: {}", section, e);
            throw new ConfigurationException("Configuration update failed: " + e.getMessage(), e);
        }
    }
    
    /**
     * Reset configuration to defaults
     */
    public void resetToDefaults() {
        try {
            log.info("Resetting configuration to defaults");
            
            // Clear current cache
            configCache.clear();
            
            // Load default configuration
            loadDefaultConfig();
            
            log.info("Successfully reset configuration to defaults");
            
        } catch (Exception e) {
            log.error("Failed to reset configuration to defaults", e);
            throw new ConfigurationException("Configuration reset failed: " + e.getMessage(), e);
        }
    }
    
    /**
     * Update configuration with environment variables
     */
    public void updateFromEnvironment() {
        try {
            log.info("Updating configuration from environment variables");
            
            // Process each section with environment variables
            for (Map.Entry<String, Object> entry : configCache.entrySet()) {
                if (entry.getValue() instanceof Map) {
                    @SuppressWarnings("unchecked")
                    Map<String, Object> sectionConfig = (Map<String, Object>) entry.getValue();
                    
                    // Process environment variables
                    Map<String, Object> processedConfig = environmentManager.processEnvironmentVariables(sectionConfig);
                    
                    // Update cache
                    configCache.put(entry.getKey(), processedConfig);
                }
            }
            
            log.info("Successfully updated configuration from environment variables");
            
        } catch (Exception e) {
            log.error("Failed to update configuration from environment", e);
            throw new ConfigurationException("Environment update failed: " + e.getMessage(), e);
        }
    }
    
    /**
     * Load default configuration
     */
    private void loadDefaultConfig() {
        try {
            log.info("Loading default configuration");
            
            // Check if config directory exists
            File configDir = new File(DEFAULT_CONFIG_DIR);
            if (!configDir.exists()) {
                log.info("Creating config directory: {}", DEFAULT_CONFIG_DIR);
                configDir.mkdirs();
            }
            
            // Load default configuration files if they exist
            for (String fileName : DEFAULT_CONFIG_FILES) {
                File configFile = new File(DEFAULT_CONFIG_DIR, fileName);
                
                if (configFile.exists()) {
                    loadConfig(configFile.getPath());
                } else {
                    // Load from classpath resources if file doesn't exist
                    String resourcePath = "/config/" + fileName;
                    try (InputStream is = getClass().getResourceAsStream(resourcePath)) {
                        if (is != null) {
                            log.info("Loading default configuration from resource: {}", resourcePath);
                            
                            Map<String, Object> config = yamlMapper.readValue(
                                is,
                                new TypeReference<Map<String, Object>>() {}
                            );
                            
                            // Process environment variables
                            config = environmentManager.processEnvironmentVariables(config);
                            
                            // Extract section name from file name
                            String section = getSectionFromFilePath(fileName);
                            
                            // Update cache
                            configCache.put(section, config);
                            
                            // Save to file if it doesn't exist
                            saveConfigToFile(section, config, configFile.getPath());
                        } else {
                            log.warn("Default configuration resource not found: {}", resourcePath);
                            
                            // Generate default configuration for this section
                            String section = getSectionFromFilePath(fileName);
                            Map<String, Object> defaultConfig = generateDefaultConfig(section);
                            
                            // Update cache
                            configCache.put(section, defaultConfig);
                            
                            // Save to file
                            saveConfigToFile(section, defaultConfig, configFile.getPath());
                        }
                    }
                }
            }
            
            log.info("Default configuration loaded successfully");
            
        } catch (Exception e) {
            log.error("Failed to load default configuration", e);
            throw new ConfigurationException("Default configuration loading failed: " + e.getMessage(), e);
        }
    }
    
    /**
     * Save configuration to file
     * @param section Configuration section
     * @param config Configuration data
     * @param filePath File path to save to
     */
    private void saveConfigToFile(String section, Map<String, Object> config, String filePath) {
        try {
            // Create parent directories if needed
            Path path = Paths.get(filePath);
            Files.createDirectories(path.getParent());
            
            // Write to file
            yamlMapper.writeValue(new File(filePath), config);
            
            log.info("Saved configuration for section '{}' to: {}", section, filePath);
            
        } catch (Exception e) {
            log.error("Failed to save configuration to file: {}", filePath, e);
            throw new ConfigurationException("Configuration save failed: " + e.getMessage(), e);
        }
    }
    
    /**
     * Extract section name from file path
     * @param filePath File path
     * @return Section name
     */
    private String getSectionFromFilePath(String filePath) {
        String fileName = new File(filePath).getName();
        
        if (fileName.contains("-config.")) {
            return fileName.substring(0, fileName.indexOf("-config."));
        }
        
        return fileName.substring(0, fileName.lastIndexOf('.'));
    }
    
    /**
     * Generate default configuration for a section
     * @param section Section name
     * @return Default configuration
     */
    private Map<String, Object> generateDefaultConfig(String section) {
        Map<String, Object> config = new HashMap<>();
        
        switch (section) {
            case "general":
                Map<String, Object> framework = new HashMap<>();
                framework.put("name", "CSSmartTest");
                framework.put("version", "1.0.0-SNAPSHOT");
                framework.put("mode", "zero-code");
                config.put("framework", framework);
                
                Map<String, Object> execution = new HashMap<>();
                execution.put("parallel", true);
                execution.put("threadCount", 5);
                execution.put("retryCount", 1);
                execution.put("timeout", 60);
                config.put("execution", execution);
                
                Map<String, Object> element = new HashMap<>();
                element.put("timeout", 15);
                element.put("polling", 500);
                config.put("element", element);
                
                Map<String, Object> reporting = new HashMap<>();
                reporting.put("format", "html");
                reporting.put("screenshots", true);
                reporting.put("video", false);
                reporting.put("outputDir", "./reports");
                config.put("reporting", reporting);
                break;
                
            case "browser":
                config.put("default", "chrome");
                
                Map<String, Object> browsers = new HashMap<>();
                
                // Chrome configuration
                Map<String, Object> chrome = new HashMap<>();
                chrome.put("driver", "webdriver.chrome.driver");
                chrome.put("headless", false);
                chrome.put("arguments", Arrays.asList(
                    "--start-maximized",
                    "--disable-notifications",
                    "--disable-infobars"
                ));
                
                Map<String, Object> chromeCapabilities = new HashMap<>();
                chromeCapabilities.put("acceptInsecureCerts", true);
                chromeCapabilities.put("pageLoadStrategy", "normal");
                chrome.put("capabilities", chromeCapabilities);
                
                // Firefox configuration
                Map<String, Object> firefox = new HashMap<>();
                firefox.put("driver", "webdriver.gecko.driver");
                firefox.put("headless", false);
                firefox.put("arguments", Arrays.asList(
                    "--start-maximized",
                    "--disable-notifications"
                ));
                
                Map<String, Object> firefoxCapabilities = new HashMap<>();
                firefoxCapabilities.put("acceptInsecureCerts", true);
                firefoxCapabilities.put("pageLoadStrategy", "normal");
                firefox.put("capabilities", firefoxCapabilities);
                
                browsers.put("chrome", chrome);
                browsers.put("firefox", firefox);
                
                config.put("browsers", browsers);
                break;
                
            case "environment":
                config.put("default", "qa");
                
                Map<String, Object> environments = new HashMap<>();
                
                // QA environment
                Map<String, Object> qa = new HashMap<>();
                
                Map<String, Object> qaBase = new HashMap<>();
                qaBase.put("url", "https://qa.example.com");
                qaBase.put("api", "https://api-qa.example.com");
                qa.put("base", qaBase);
                
                Map<String, Object> qaDb = new HashMap<>();
                qaDb.put("host", "qa-db.example.com");
                qaDb.put("port", 3306);
                qaDb.put("username", "${DB_USERNAME}");
                qaDb.put("password", "${DB_PASSWORD}");
                qaDb.put("name", "qa_testdb");
                qa.put("database", qaDb);
                
                // Staging environment
                Map<String, Object> staging = new HashMap<>();
                
                Map<String, Object> stagingBase = new HashMap<>();
                stagingBase.put("url", "https://staging.example.com");
                stagingBase.put("api", "https://api-staging.example.com");
                staging.put("base", stagingBase);
                
                Map<String, Object> stagingDb = new HashMap<>();
                stagingDb.put("host", "staging-db.example.com");
                stagingDb.put("port", 3306);
                stagingDb.put("username", "${DB_USERNAME}");
                stagingDb.put("password", "${DB_PASSWORD}");
                stagingDb.put("name", "staging_testdb");
                staging.put("database", stagingDb);
                
                environments.put("qa", qa);
                environments.put("staging", staging);
                
                config.put("environments", environments);
                break;
                
            default:
                log.warn("No default configuration available for section: {}", section);
                break;
        }
        
        return config;
    }
    
    /**
     * Get all configuration as a map
     * @return Map containing all configuration sections
     */
    public Map<String, Object> getAllConfig() {
        Map<String, Object> allConfig = new HashMap<>();
        
        // Add each section to the map
        for (Map.Entry<String, Object> entry : configCache.entrySet()) {
            allConfig.put(entry.getKey(), entry.getValue());
        }
        
        return allConfig;
    }
}

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.8</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <groupId>com.cssmart</groupId>
    <artifactId>cs-smart-test-framework</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <name>CS Smart Test Framework</name>
    <description>AI-powered automated testing solution</description>

    <properties>
        <java.version>11</java.version>
        <selenium.version>4.16.1</selenium.version>
        <webdrivermanager.version>5.5.3</webdrivermanager.version>
        <testng.version>7.7.1</testng.version>
        <lombok.version>1.18.24</lombok.version>
        <jackson.version>2.14.2</jackson.version>
        <cucumber.version>7.11.1</cucumber.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-websocket</artifactId>
        </dependency>
        
        <!-- Selenium WebDriver -->
        <dependency>
            <groupId>org.seleniumhq.selenium</groupId>
            <artifactId>selenium-java</artifactId>
            <version>${selenium.version}</version>
        </dependency>
        
        <!-- WebDriverManager -->
        <dependency>
            <groupId>io.github.bonigarcia</groupId>
            <artifactId>webdrivermanager</artifactId>
            <version>${webdrivermanager.version}</version>
        </dependency>
        
        <!-- TestNG -->
        <dependency>
            <groupId>org.testng</groupId>
            <artifactId>testng</artifactId>
            <version>${testng.version}</version>
        </dependency>
        
        <!-- Cucumber -->
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-java</artifactId>
            <version>${cucumber.version}</version>
        </dependency>
        <dependency>
            <groupId>io.cucumber</groupId>
            <artifactId>cucumber-testng</artifactId>
            <version>${cucumber.version}</version>
        </dependency>
        
        <!-- Jackson for JSON processing -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.dataformat</groupId>
            <artifactId>jackson-dataformat-yaml</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        
        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
            <scope>provided</scope>
        </dependency>
        
        <!-- Additional utilities -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.12.0</version>
        </dependency>
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.11.0</version>
        </dependency>
        
        <!-- Testing dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            
            <!-- Java compiler with -parameters flag -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <parameters>true</parameters> <!-- Enable parameter name retention -->
                    <compilerArgs>
                        <arg>-parameters</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
            
            <!-- TestNG plugin -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <configuration>
                    <suiteXmlFiles>
                        <suiteXmlFile>src/test/resources/testng.xml</suiteXmlFile>
                    </suiteXmlFiles>
                </configuration>
            </plugin>
            
            <!-- Frontend Maven Plugin for building React app -->
            <plugin>
                <groupId>com.github.eirslett</groupId>
                <artifactId>frontend-maven-plugin</artifactId>
                <version>1.12.1</version>
                <configuration>
                    <workingDirectory>src/main/webapp</workingDirectory>
                    <installDirectory>target</installDirectory>
                </configuration>
                <executions>
                    <execution>
                        <id>install node and npm</id>
                        <goals>
                            <goal>install-node-and-npm</goal>
                        </goals>
                        <configuration>
                            <nodeVersion>v16.14.0</nodeVersion>
                            <npmVersion>8.5.0</npmVersion>
                        </configuration>
                    </execution>
                    <execution>
                        <id>npm install</id>
                        <goals>
                            <goal>npm</goal>
                        </goals>
                        <configuration>
                            <arguments>install</arguments>
                        </configuration>
                    </execution>
                    <execution>
                        <id>npm run build</id>
                        <goals>
                            <goal>npm</goal>
                        </goals>
                        <configuration>
                            <arguments>run build</arguments>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            
            <!-- Copy React build to static resources -->
            <plugin>
                <artifactId>maven-resources-plugin</artifactId>
                <executions>
                    <execution>
                        <id>copy-resources</id>
                        <phase>prepare-package</phase>
                        <goals>
                            <goal>copy-resources</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>${project.build.outputDirectory}/static</outputDirectory>
                            <resources>
                                <resource>
                                    <directory>${project.basedir}/src/main/webapp/build</directory>
                                    <filtering>false</filtering>
                                </resource>
                            </resources>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>


package com.cssmart.ui.controller;

import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.service.TestRecordingService;
import com.cssmart.ui.service.TestGeneratorService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.UUID;
import java.util.List;

/**
 * REST controller for test recorder operations
 */
@Slf4j
@RestController
@RequestMapping("/api/recorder")
public class RecorderController {
    
    private final TestRecordingService testRecordingService;
    private final TestGeneratorService testGeneratorService;
    
    @Autowired
    public RecorderController(TestRecordingService testRecordingService, TestGeneratorService testGeneratorService) {
        this.testRecordingService = testRecordingService;
        this.testGeneratorService = testGeneratorService;
    }
    
    /**
     * Save a recorded test case
     * @param testCase Recorded test case
     * @return Saved test case
     */
    @PostMapping("/save")
    public ResponseEntity<TestCase> saveTestCase(@RequestBody TestCase testCase) {
        log.info("Saving recorded test case: {}", testCase.getName());
        
        try {
            // Enhance and save the test case
            TestCase enhancedTestCase = testRecordingService.enhanceTestCase(testCase);
            TestCase savedTestCase = testRecordingService.saveRecordedTest(enhancedTestCase);
            
            return ResponseEntity.ok(savedTestCase);
        } catch (Exception e) {
            log.error("Error saving test case", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Convert a recorded test case to a generated test for editing
     * @param id Test case ID
     * @return Generated test
     */
    @GetMapping("/{id}/convert")
    public ResponseEntity<GeneratedTest> convertToGeneratedTest(@PathVariable("id") String id) {
        log.info("Converting recorded test case to generated test: {}", id);
        
        try {
            // Get the recorded test case
            TestCase testCase = testRecordingService.getRecordedTest(id);
            
            if (testCase == null) {
                log.warn("Test case not found with ID: {}", id);
                return ResponseEntity.notFound().build();
            }
            
            // Convert to generated test format
            GeneratedTest generatedTest = testRecordingService.convertToGeneratedTest(testCase);
            
            return ResponseEntity.ok(generatedTest);
        } catch (Exception e) {
            log.error("Error converting test case", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Get browser configuration options
     * @return Browser configuration
     */
    @GetMapping("/browser-config")
    public ResponseEntity<BrowserConfig> getBrowserConfig() {
        log.info("Fetching browser configuration options");
        
        try {
            BrowserConfig config = new BrowserConfig();
            config.addBrowserOption("chrome", "Chrome");
            config.addBrowserOption("firefox", "Firefox");
            config.addBrowserOption("edge", "Edge");
            config.addBrowserOption("safari", "Safari");
            
            return ResponseEntity.ok(config);
        } catch (Exception e) {
            log.error("Error fetching browser configuration", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Run a test after recording
     * @param id Test ID
     * @return Execution status
     */
    @PostMapping("/{id}/run")
    public ResponseEntity<Map<String, Object>> runTest(@PathVariable("id") String id) {
        log.info("Running recorded test: {}", id);
        
        try {
            // In a real implementation, this would invoke the test execution service
            // For now, return a simple status message
            Map<String, Object> result = new java.util.HashMap<>();
            result.put("status", "success");
            result.put("message", "Test execution started");
            result.put("executionId", UUID.randomUUID().toString());
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("Error running test", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Get all recorded tests
     * @return List of recorded tests
     */
    @GetMapping
    public ResponseEntity<List<TestCase>> getAllRecordedTests() {
        log.info("Fetching all recorded tests");
        
        try {
            // In a real implementation, this would retrieve tests from a repository
            // For now, return an empty list
            List<TestCase> tests = new ArrayList<>();
            
            return ResponseEntity.ok(tests);
        } catch (Exception e) {
            log.error("Error fetching recorded tests", e);
            return ResponseEntity.status(500).body(null);
        }
    }
}

/**
 * Browser configuration options
 */
class BrowserConfig {
    private List<BrowserOption> browsers = new ArrayList<>();
    
    public void addBrowserOption(String value, String label) {
        browsers.add(new BrowserOption(value, label));
    }
    
    public List<BrowserOption> getBrowsers() {
        return browsers;
    }
    
    public void setBrowsers(List<BrowserOption> browsers) {
        this.browsers = browsers;
    }
    
    static class BrowserOption {
        private String value;
        private String label;
        
        public BrowserOption(String value, String label) {
            this.value = value;
            this.label = label;
        }
        
        public String getValue() {
            return value;
        }
        
        public void setValue(String value) {
            this.value = value;
        }
        
        public String getLabel() {
            return label;
        }
        
        public void setLabel(String label) {
            this.label = label;
        }
    }
}

// src/main/webapp/src/components/recorder/RecorderConfig.jsx
import React, { useState, useEffect } from 'react';
import TextField from '../common/TextField';
import SelectField from '../common/SelectField';
import Checkbox from '../common/Checkbox';
import Card from '../common/Card';
import Spinner from '../common/Spinner';

const RecorderConfig = ({ config, updateConfig, disabled = false }) => {
  const [browserOptions, setBrowserOptions] = useState([
    { value: 'chrome', label: 'Chrome' },
    { value: 'firefox', label: 'Firefox' },
    { value: 'edge', label: 'Edge' },
    { value: 'safari', label: 'Safari' }
  ]);
  const [loading, setLoading] = useState(false);
  
  // Fetch browser configuration options from the server
  useEffect(() => {
    const fetchBrowserConfig = async () => {
      try {
        setLoading(true);
        const response = await fetch('/api/recorder/browser-config');
        
        if (response.ok) {
          const data = await response.json();
          if (data && data.browsers && Array.isArray(data.browsers)) {
            setBrowserOptions(data.browsers);
          }
        }
      } catch (error) {
        console.error('Error fetching browser configuration:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchBrowserConfig();
  }, []);
  
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    updateConfig({
      ...config,
      [name]: type === 'checkbox' ? checked : value
    });
  };
  
  return (
    <Card title="Recording Configuration">
      {loading ? (
        <div className="flex justify-center items-center py-4">
          <Spinner size="md" />
          <span className="ml-2">Loading browser options...</span>
        </div>
      ) : (
        <div className="space-y-4">
          <TextField 
            label="URL to test"
            name="url"
            placeholder="https://example.com"
            value={config.url}
            onChange={handleChange}
            disabled={disabled}
            required
          />
          
          <SelectField
            label="Browser"
            name="browser"
            value={config.browser}
            onChange={handleChange}
            options={browserOptions}
            disabled={disabled}
            required
          />
          
          <Checkbox
            label="Run in headless mode"
            name="headless"
            checked={config.headless}
            onChange={handleChange}
            disabled={disabled}
          />
          
          <div className="text-sm text-gray-500 mt-4">
            <p>The test recorder will open a browser window and record your actions on the specified URL. Make sure the URL is accessible and the browser is installed on your system.</p>
          </div>
        </div>
      )}
    </Card>
  );
};

export default RecorderConfig;

// src/main/webapp/src/components/generator/TestGenerator.jsx
import React, { useState, useEffect } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import TestBuilder from './TestBuilder';
import DescriptionInput from './DescriptionInput';
import Button from '../common/Button';
import Alert from '../common/Alert';
import Spinner from '../common/Spinner';
import Card from '../common/Card';

const TestGenerator = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const [description, setDescription] = useState('');
  const [generatedTest, setGeneratedTest] = useState(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState(null);
  const [successMessage, setSuccessMessage] = useState(null);
  
  // Check for imported test from Test Recorder or URL parameters
  useEffect(() => {
    const checkForImportedTest = async () => {
      try {
        // Check for state from React Router
        if (location?.state?.testCase) {
          const importedTest = location.state.testCase;
          setGeneratedTest(importedTest);
          setDescription(importedTest.description || '');
          setSuccessMessage('Test imported from Test Recorder');
          
          // Clear success message after 3 seconds
          setTimeout(() => setSuccessMessage(null), 3000);
          return;
        }
        
        // Check for URL parameters
        const params = new URLSearchParams(location.search);
        const testId = params.get('testId');
        const source = params.get('source');
        
        if (testId && source === 'recorder') {
          setIsProcessing(true);
          
          // Fetch the test from the API
          const response = await fetch(`/api/recorder/${testId}/convert`);
          
          if (response.ok) {
            const test = await response.json();
            setGeneratedTest(test);
            setDescription(test.description || '');
            setSuccessMessage('Test imported from Test Recorder');
            
            // Clear success message after 3 seconds
            setTimeout(() => setSuccessMessage(null), 3000);
          } else {
            throw new Error(`Failed to import test: ${response.statusText}`);
          }
        }
      } catch (err) {
        console.error('Error importing test:', err);
        setError(`Failed to import test: ${err.message}`);
      } finally {
        setIsProcessing(false);
      }
    };
    
    checkForImportedTest();
  }, [location]);
  
  // Generate test from description
  const generateTest = async () => {
    if (!description.trim()) {
      setError('Please enter a test description');
      return;
    }
    
    setIsGenerating(true);
    setError(null);
    
    try {
      // Call the API to generate the test
      const response = await fetch('/api/generator/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ description }),
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      setGeneratedTest(data);
      setSuccessMessage('Test generated successfully!');
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (err) {
      console.error('Error generating test:', err);
      setError(`Failed to generate test: ${err.message}`);
    } finally {
      setIsGenerating(false);
    }
  };
  
  // Save updated test
  const saveTest = async (updatedTest) => {
    try {
      setIsProcessing(true);
      setError(null);
      
      const response = await fetch('/api/generator/save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(updatedTest),
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const savedTest = await response.json();
      setGeneratedTest(savedTest);
      setSuccessMessage('Test saved successfully!');
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (err) {
      console.error('Error saving test:', err);
      setError(`Failed to save test: ${err.message}`);
    } finally {
      setIsProcessing(false);
    }
  };
  
  // Clear current test and start over
  const clearTest = () => {
    if (window.confirm('Are you sure you want to clear the current test? All changes will be lost.')) {
      setGeneratedTest(null);
      setDescription('');
      setError(null);
      setSuccessMessage(null);
    }
  };
  
  // Run generated test
  const runTest = async () => {
    if (!generatedTest?.id) {
      setError('Please save the test before running it.');
      return;
    }
    
    try {
      setIsProcessing(true);
      setError(null);
      
      const response = await fetch(`/api/tests/${generatedTest.id}/run`, {
        method: 'POST',
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      setSuccessMessage(`Test execution started! Execution ID: ${result.executionId}`);
      
      // Redirect to reports page after a delay
      setTimeout(() => {
        navigate('/reports');
      }, 3000);
    } catch (err) {
      console.error('Error running test:', err);
      setError(`Failed to run test: ${err.message}`);
    } finally {
      setIsProcessing(false);
    }
  };
  
  // Render loading state
  if (isProcessing && !generatedTest) {
    return (
      <div className="space-y-6">
        <h1 className="text-2xl font-semibold">Test Generator</h1>
        
        <Card>
          <div className="flex flex-col items-center justify-center py-12">
            <Spinner size="lg" className="mb-4" />
            <p className="text-lg text-gray-700">Loading test data...</p>
          </div>
        </Card>
      </div>
    );
  }
  
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold">Test Generator</h1>
        {generatedTest && (
          <div className="flex space-x-2">
            <Button
              variant="secondary"
              onClick={clearTest}
              disabled={isProcessing}
            >
              New Test
            </Button>
            <Button
              variant="primary"
              onClick={runTest}
              disabled={isProcessing}
            >
              {isProcessing ? (
                <>
                  <Spinner size="sm" color="white" className="mr-2" />
                  Processing...
                </>
              ) : (
                'Run Test'
              )}
            </Button>
          </div>
        )}
      </div>
      
      {/* Error and success messages */}
      {error && (
        <Alert
          type="error"
          title="Error"
          onClose={() => setError(null)}
        >
          {error}
        </Alert>
      )}
      
      {successMessage && (
        <Alert
          type="success"
          title="Success"
          onClose={() => setSuccessMessage(null)}
        >
          {successMessage}
        </Alert>
      )}
      
      {!generatedTest ? (
        <DescriptionInput 
          description={description} 
          setDescription={setDescription} 
          generateTest={generateTest}
          isGenerating={isGenerating}
        />
      ) : (
        <TestBuilder 
          test={generatedTest} 
          onSave={saveTest}
          isProcessing={isProcessing}
        />
      )}
      
      {isGenerating && !generatedTest && (
        <Card>
          <div className="flex flex-col items-center justify-center py-10">
            <Spinner size="lg" className="mb-4" />
            <p className="text-lg text-gray-700">Generating test using AI...</p>
            <p className="text-gray-500 text-sm mt-2">This may take a few moments.</p>
          </div>
        </Card>
      )}
    </div>
  );
};

// src/main/webapp/src/App.jsx
import React, { useState } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, useNavigate } from 'react-router-dom';
import Navbar from './components/common/Navbar';
import Sidebar from './components/common/Sidebar';
import Dashboard from './components/dashboard/Dashboard';
import TestRecorder from './components/recorder/TestRecorder';
import TestGenerator from './components/generator/TestGenerator';
import Reports from './components/reports/Reports';
import Configuration from './components/config/Configuration';
import { NotificationProvider } from './context/NotificationContext';

// Main layout component that includes the sidebar and content
const MainLayout = ({ children }) => {
  const navigate = useNavigate();
  
  // Handler for "New Test" button
  const handleNewTest = () => {
    // Navigate to the recorder page
    navigate('/recorder');
  };
  
  return (
    <div className="flex h-screen bg-gray-100">
      <Sidebar />
      <div className="flex-1 flex flex-col overflow-hidden">
        <Navbar onNewTest={handleNewTest} />
        <main className="flex-1 overflow-x-hidden overflow-y-auto bg-gray-100 p-4">
          {children}
        </main>
      </div>
    </div>
  );
};

const App = () => {
  return (
    <Router>
      <NotificationProvider>
        <Routes>
          <Route path="/" element={
            <MainLayout>
              <Dashboard />
            </MainLayout>
          } />
          <Route path="/dashboard" element={
            <MainLayout>
              <Dashboard />
            </MainLayout>
          } />
          <Route path="/recorder" element={
            <MainLayout>
              <TestRecorder />
            </MainLayout>
          } />
          <Route path="/generator" element={
            <MainLayout>
              <TestGenerator />
            </MainLayout>
          } />
          <Route path="/reports" element={
            <MainLayout>
              <Reports />
            </MainLayout>
          } />
          <Route path="/config" element={
            <MainLayout>
              <Configuration />
            </MainLayout>
          } />
          <Route path="*" element={<Navigate to="/" replace />} />
        </Routes>
      </NotificationProvider>
    </Router>
  );
};

export default App;


// src/main/webapp/src/components/common/Sidebar.jsx
import React from 'react';
import { useLocation, useNavigate } from 'react-router-dom';

const Sidebar = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const currentPath = location.pathname;
  
  // Navigation items
  const navItems = [
    { 
      id: 'dashboard', 
      path: '/dashboard',
      label: 'Dashboard', 
      icon: 'M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6' 
    },
    { 
      id: 'recorder', 
      path: '/recorder',
      label: 'Test Recorder', 
      icon: 'M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z' 
    },
    { 
      id: 'generator', 
      path: '/generator',
      label: 'Test Generator', 
      icon: 'M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4' 
    },
    { 
      id: 'reports', 
      path: '/reports',
      label: 'Reports', 
      icon: 'M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z' 
    },
    { 
      id: 'config', 
      path: '/config',
      label: 'Configuration', 
      icon: 'M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4' 
    }
  ];

  // Navigate to the selected page
  const handleNavigation = (path) => {
    navigate(path);
  };

  return (
    <div className="bg-indigo-800 text-white w-64 space-y-6 py-7 px-2 absolute inset-y-0 left-0 transform -translate-x-full md:relative md:translate-x-0 transition duration-200 ease-in-out">
      <div className="flex items-center space-x-2 px-4">
        <svg className="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12l2 2 4-4M7.835 4.697a3.42 3.42 0 001.946-.806 3.42 3.42 0 014.438 0 3.42 3.42 0 001.946.806 3.42 3.42 0 013.138 3.138 3.42 3.42 0 00.806 1.946 3.42 3.42 0 010 4.438 3.42 3.42 0 00-.806 1.946 3.42 3.42 0 01-3.138 3.138 3.42 3.42 0 00-1.946.806 3.42 3.42 0 01-4.438 0 3.42 3.42 0 00-1.946-.806 3.42 3.42 0 01-3.138-3.138 3.42 3.42 0 00-.806-1.946 3.42 3.42 0 010-4.438 3.42 3.42 0 00.806-1.946 3.42 3.42 0 013.138-3.138z" />
        </svg>
        <span className="text-lg font-extrabold">CS Smart Test</span>
      </div>
      <nav>
        {navItems.map(item => (
          <button 
            key={item.id}
            className={`block py-2.5 px-4 rounded transition duration-200 w-full text-left ${
              currentPath === item.path || (currentPath === '/' && item.path === '/dashboard') 
                ? 'bg-indigo-700' 
                : 'hover:bg-indigo-700'
            }`}
            onClick={() => handleNavigation(item.path)}
          >
            <div className="flex items-center">
              <svg className="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d={item.icon} />
              </svg>
              {item.label}
            </div>
          </button>
        ))}
      </nav>
    </div>
  );
};

export default Sidebar;

// src/main/webapp/src/components/common/Navbar.jsx
import React from 'react';
import { useNavigate } from 'react-router-dom';
import Button from './Button';

const Navbar = ({ onNewTest }) => {
  // Use React Router's navigation
  const navigate = useNavigate();
  
  // Handle click on New Test button
  const handleNewTest = () => {
    // If onNewTest prop is provided, use it
    if (onNewTest) {
      onNewTest();
    } else {
      // Otherwise navigate to the test recorder as default
      navigate('/recorder');
    }
  };

  return (
    <header className="bg-white shadow h-16 flex items-center justify-between px-6">
      <div className="flex items-center">
        <h1 className="text-xl font-semibold">CS Smart Test Framework</h1>
      </div>
      <div className="flex items-center space-x-4">
        <Button
          variant="primary"
          onClick={handleNewTest}
        >
          New Test
        </Button>
        <div className="relative">
          <button className="p-1 rounded-full bg-gray-200 hover:bg-gray-300">
            <svg className="h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
            </svg>
          </button>
        </div>
      </div>
    </header>
  );
};

export default Navbar;

// src/main/webapp/src/components/recorder/TestRecorder.jsx
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import RecordedSteps from './RecordedSteps';
import RecorderConfig from './RecorderConfig';
import TestCodeViewer from './TestCodeViewer';
import Button from '../common/Button';
import Card from '../common/Card';
import Alert from '../common/Alert';
import Spinner from '../common/Spinner';
import { useNotification } from '../../context/NotificationContext';

const TestRecorder = () => {
  const navigate = useNavigate();
  const { addNotification } = useNotification();
  const [isRecording, setIsRecording] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [recordedSteps, setRecordedSteps] = useState([]);
  const [testCase, setTestCase] = useState(null);
  const [isGeneratingCode, setIsGeneratingCode] = useState(false);
  const [error, setError] = useState(null);
  const [successMessage, setSuccessMessage] = useState(null);
  const [config, setConfig] = useState({
    url: 'https://example.com',
    browser: 'chrome',
    headless: false
  });
  const websocket = useRef(null);
  
  // Handle WebSocket cleanup on component unmount
  useEffect(() => {
    return () => {
      if (websocket.current) {
        websocket.current.close();
      }
    };
  }, []);
  
  // Connect to WebSocket when starting recording
  const connectWebSocket = () => {
    try {
      setIsConnecting(true);
      setError(null);
      
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/recorder`;
      
      websocket.current = new WebSocket(wsUrl);
      
      websocket.current.onopen = () => {
        console.log('WebSocket connected');
        setIsConnecting(false);
        
        // Send recording configuration to the server
        websocket.current.send(JSON.stringify({ 
          type: 'START_RECORDING',
          data: config
        }));
      };
      
      websocket.current.onmessage = (event) => {
        const message = JSON.parse(event.data);
        
        if (message.type === 'RECORDING_STARTED') {
          console.log('Recording started');
          setIsRecording(true);
          addNotification('Recording started successfully!', 'success');
        } else if (message.type === 'ACTION_RECORDED') {
          console.log('Action recorded');
        } else if (message.type === 'STEP_RECORDED') {
          console.log('Step recorded:', message.data);
          setRecordedSteps(prev => [...prev, message.data]);
        } else if (message.type === 'TEST_CASE') {
          console.log('Test case received:', message.data);
          setTestCase(message.data);
          setIsRecording(false);
          setIsGeneratingCode(false);
          addNotification('Test recorded successfully!', 'success');
        } else if (message.type === 'ERROR') {
          console.error('WebSocket error:', message.data);
          setError(`Error: ${message.data}`);
          setIsRecording(false);
          setIsConnecting(false);
          setIsGeneratingCode(false);
          addNotification(`Recording error: ${message.data}`, 'error');
        }
      };
      
      websocket.current.onerror = (error) => {
        console.error('WebSocket error:', error);
        setError('Failed to connect to the recording service. Please check if the server is running.');
        setIsRecording(false);
        setIsConnecting(false);
        addNotification('Failed to connect to recording service', 'error');
      };
      
      websocket.current.onclose = () => {
        console.log('WebSocket disconnected');
        if (isRecording) {
          setIsRecording(false);
          addNotification('Recording connection closed', 'warning');
        }
      };
      
      return true;
    } catch (error) {
      console.error('Error connecting to WebSocket:', error);
      setError(`Connection error: ${error.message}`);
      setIsRecording(false);
      setIsConnecting(false);
      addNotification(`Connection error: ${error.message}`, 'error');
      return false;
    }
  };
  
  // Start recording
  const startRecording = () => {
    setRecordedSteps([]);
    setTestCase(null);
    setError(null);
    setSuccessMessage(null);
    
    const connected = connectWebSocket();
    if (!connected) {
      setError('Failed to start recording. Could not connect to server.');
    }
  };
  
  // Stop recording
  const stopRecording = () => {
    if (websocket.current && websocket.current.readyState === WebSocket.OPEN) {
      websocket.current.send(JSON.stringify({ type: 'STOP_RECORDING' }));
      setIsGeneratingCode(true);
    } else {
      setError('WebSocket is not connected. Cannot stop recording.');
      addNotification('Cannot stop recording: connection lost', 'error');
    }
  };
  
  // Update configuration
  const updateConfig = (newConfig) => {
    setConfig(newConfig);
  };
  
  // Save test case
  const saveTestCase = async () => {
    if (!testCase) return;
    
    try {
      const response = await fetch('/api/recorder/save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(testCase),
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      setSuccessMessage('Test case saved successfully!');
      addNotification('Test case saved successfully!', 'success');
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(null), 3000);
      
    } catch (error) {
      console.error('Error saving test case:', error);
      setError(`Failed to save test case: ${error.message}`);
      addNotification(`Failed to save test case: ${error.message}`, 'error');
    }
  };
  
  // Edit in Test Generator
  const editInGenerator = () => {
    if (!testCase || !testCase.id) {
      addNotification('Please save the test first', 'warning');
      return;
    }
    
    // Navigate to Test Generator with the current test
    navigate('/generator', { state: { testCase } });
  };
  
  // Run test
  const runTest = async () => {
    if (!testCase || !testCase.id) {
      setError('Please save the test first');
      return;
    }
    
    try {
      const response = await fetch(`/api/recorder/${testCase.id}/run`, {
        method: 'POST',
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      setSuccessMessage('Test execution started successfully!');
      addNotification('Test execution started. Check Reports for results.', 'success');
      
      // Redirect to reports page after a delay
      setTimeout(() => {
        navigate('/reports');
      }, 3000);
    } catch (error) {
      console.error('Error running test:', error);
      setError(`Failed to run test: ${error.message}`);
      addNotification(`Failed to run test: ${error.message}`, 'error');
    }
  };
  
  return (
    <div className="space-y-6">
      {/* Header with action buttons */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold">Test Recorder</h1>
        <div className="flex space-x-2">
          {!isRecording ? (
            <Button
              variant="primary"
              disabled={isConnecting}
              onClick={startRecording}
            >
              {isConnecting ? (
                <>
                  <Spinner size="sm" color="white" className="mr-2" />
                  Connecting...
                </>
              ) : (
                'Start Recording'
              )}
            </Button>
          ) : (
            <Button
              variant="danger"
              onClick={stopRecording}
            >
              Stop Recording
            </Button>
          )}
        </div>
      </div>
      
      {/* Error and success messages */}
      {error && (
        <Alert
          type="error"
          title="Recording Error"
          onClose={() => setError(null)}
        >
          {error}
        </Alert>
      )}
      
      {successMessage && (
        <Alert
          type="success"
          title="Success"
          onClose={() => setSuccessMessage(null)}
        >
          {successMessage}
        </Alert>
      )}
      
      {/* Configuration and steps */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <RecorderConfig 
          config={config} 
          updateConfig={updateConfig} 
          disabled={isRecording || isConnecting} 
        />
        
        <RecordedSteps 
          steps={recordedSteps} 
          isRecording={isRecording}
        />
      </div>
      
      {/* Generated test code */}
      {isGeneratingCode && !testCase && (
        <Card>
          <div className="flex justify-center items-center py-6">
            <Spinner size="md" className="mr-3" />
            <span>Generating test code...</span>
          </div>
        </Card>
      )}
      
      {testCase && (
        <Card>
          <div className="mb-4">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-semibold">Generated Test</h2>
              <div className="flex space-x-2">
                <Button
                  variant="secondary"
                  onClick={editInGenerator}
                >
                  Edit in Test Generator
                </Button>
                <Button
                  variant="primary"
                  onClick={saveTestCase}
                >
                  Save Test
                </Button>
                <Button
                  variant="outline"
                  onClick={runTest}
                >
                  Run Test
                </Button>
              </div>
            </div>
            <div className="mb-4">
              <p><strong>Test Name:</strong> {testCase.name}</p>
              <p><strong>Description:</strong> {testCase.description}</p>
            </div>
          </div>
          <TestCodeViewer code={testCase.code} />
        </Card>
      )}
      
      {/* Recording indicator */}
      {isRecording && (
        <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-red-600 text-white px-4 py-2 rounded-md shadow-lg animate-pulse">
          Recording in progress... Actions performed in the browser are being captured.
        </div>
      )}
    </div>
  );
};

export default TestRecorder;

// src/main/webapp/src/context/NotificationContext.jsx
import React, { createContext, useContext, useState, useCallback } from 'react';

// Create notification context
const NotificationContext = createContext({
  notifications: [],
  addNotification: () => {},
  removeNotification: () => {},
});

/**
 * Notification Provider component
 * Manages notifications throughout the application
 */
export function NotificationProvider({ children }) {
  const [notifications, setNotifications] = useState([]);
  
  // Add a new notification
  const addNotification = useCallback((message, type = 'info', duration = 5000) => {
    const id = Date.now();
    
    setNotifications(prev => [
      ...prev,
      { id, message, type, duration }
    ]);
    
    // Automatically remove notification after duration
    if (duration > 0) {
      setTimeout(() => {
        removeNotification(id);
      }, duration);
    }
    
    return id;
  }, []);
  
  // Remove a notification by ID
  const removeNotification = useCallback((id) => {
    setNotifications(prev => prev.filter(notification => notification.id !== id));
  }, []);
  
  return (
    <NotificationContext.Provider value={{ notifications, addNotification, removeNotification }}>
      {children}
      <NotificationDisplay />
    </NotificationContext.Provider>
  );
}

/**
 * Notification display component
 * Renders all current notifications
 */
function NotificationDisplay() {
  const { notifications, removeNotification } = useContext(NotificationContext);
  
  if (notifications.length === 0) return null;
  
  return (
    <div className="fixed bottom-4 right-4 z-50 flex flex-col space-y-2">
      {notifications.map(({ id, message, type }) => (
        <div 
          key={id}
          className={`p-4 rounded-lg shadow-lg max-w-md animate-fadeIn ${
            type === 'success' ? 'bg-green-100 text-green-800' :
            type === 'error' ? 'bg-red-100 text-red-800' :
            type === 'warning' ? 'bg-yellow-100 text-yellow-800' :
            'bg-blue-100 text-blue-800'
          }`}
        >
          <div className="flex justify-between items-start">
            <div className="flex items-start">
              <div className="flex-shrink-0">
                {type === 'success' && (
                  <svg className="h-5 w-5 text-green-400" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                  </svg>
                )}
                {type === 'error' && (
                  <svg className="h-5 w-5 text-red-400" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                  </svg>
                )}
                {type === 'warning' && (
                  <svg className="h-5 w-5 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                  </svg>
                )}
                {type === 'info' && (
                  <svg className="h-5 w-5 text-blue-400" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
                  </svg>
                )}
              </div>
              <div className="ml-3">
                <p className="text-sm">{message}</p>
              </div>
            </div>
            <button 
              className="ml-4 text-gray-500 hover:text-gray-700" 
              onClick={() => removeNotification(id)}
            >
              <svg className="h-5 w-5" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
              </svg>
            </button>
          </div>
        </div>
      ))}
    </div>
  );
}

/**
 * Custom hook for using the notification context
 */
export function useNotification() {
  return useContext(NotificationContext);
}

// src/main/webapp/src/components/recorder/RecordedSteps.jsx
import React from 'react';
import Card from '../common/Card';

const RecordedSteps = ({ steps, isRecording = false }) => {
  if (!steps || steps.length === 0) {
    return (
      <Card title="Recorded Steps">
        <div className="text-gray-500 text-center py-8">
          {isRecording 
            ? "Recording in progress... Perform actions in the browser to capture steps."
            : "No steps recorded yet. Start recording to capture test steps."}
        </div>
      </Card>
    );
  }

  return (
    <Card title="Recorded Steps">
      <div className="space-y-2 max-h-96 overflow-y-auto pr-2">
        {steps.map((step, index) => (
          <div key={index} className="p-3 border rounded-lg flex items-center hover:bg-gray-50 transition-colors">
            <div className="w-8 h-8 bg-indigo-100 text-indigo-800 rounded-full flex items-center justify-center mr-3 flex-shrink-0">
              {index + 1}
            </div>
            <div className="flex-1 min-w-0">
              <div className="font-medium truncate">{step.action}</div>
              <div className="text-sm text-gray-600 truncate">{step.description}</div>
              {step.element && (
                <div className="text-xs text-gray-500 mt-1 truncate">
                  Element: {step.element}
                </div>
              )}
              {step.value && (
                <div className="text-xs text-gray-500 truncate">
                  Value: {step.value}
                </div>
              )}
            </div>
            <div className="text-xs text-gray-400 flex-shrink-0 ml-2">
              {new Date(step.timestamp).toLocaleTimeString()}
            </div>
          </div>
        ))}
      </div>
      
      {/* Total steps counter */}
      <div className="mt-4 text-right text-sm text-gray-500">
        Total steps: {steps.length}
      </div>
    </Card>
  );
};

export default RecordedSteps;

// src/main/webapp/src/components/recorder/TestCodeViewer.jsx
import React, { useState } from 'react';
import Button from '../common/Button';

const TestCodeViewer = ({ code, language = 'java' }) => {
  const [copied, setCopied] = useState(false);
  
  if (!code) {
    return (
      <div className="border rounded-md p-4 bg-gray-50 text-gray-500 text-center">
        No code generated yet. Start recording to generate test code.
      </div>
    );
  }

  // Copy code to clipboard
  const copyToClipboard = () => {
    navigator.clipboard.writeText(code).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    });
  };

  return (
    <div className="border rounded-md overflow-hidden">
      <div className="bg-gray-800 text-white py-2 px-4 flex justify-between items-center">
        <div className="font-mono text-sm">{language.toUpperCase()}</div>
        <Button
          variant={copied ? "success" : "secondary"}
          size="sm"
          onClick={copyToClipboard}
        >
          {copied ? "Copied!" : "Copy Code"}
        </Button>
      </div>
      <div className="bg-gray-900 text-white p-4 overflow-x-auto">
        <pre className="font-mono text-sm whitespace-pre-wrap">{code}</pre>
      </div>
    </div>
  );
};

export default TestCodeViewer;

// src/main/webapp/src/components/common/Button.jsx
import React from 'react';

/**
 * Button component with different variants and sizes
 */
const Button = ({ 
  children, 
  variant = 'primary', 
  size = 'md', 
  className = '', 
  disabled = false,
  onClick,
  type = 'button',
  ...rest
}) => {
  // Base classes
  const baseClasses = 'font-medium rounded-md focus:outline-none transition-colors';
  
  // Size classes
  const sizeClasses = {
    sm: 'px-3 py-1 text-sm',
    md: 'px-4 py-2',
    lg: 'px-5 py-3 text-lg',
  };
  
  // Variant classes
  const variantClasses = {
    primary: 'bg-indigo-600 text-white hover:bg-indigo-700 disabled:bg-indigo-300',
    secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300 disabled:bg-gray-100 disabled:text-gray-400',
    danger: 'bg-red-600 text-white hover:bg-red-700 disabled:bg-red-300',
    success: 'bg-green-600 text-white hover:bg-green-700 disabled:bg-green-300',
    warning: 'bg-yellow-500 text-white hover:bg-yellow-600 disabled:bg-yellow-300',
    link: 'bg-transparent text-indigo-600 hover:text-indigo-800 disabled:text-gray-400 p-0',
    outline: 'bg-transparent border border-indigo-600 text-indigo-600 hover:bg-indigo-50 disabled:border-gray-300 disabled:text-gray-400',
  };
  
  const disabledClass = disabled ? 'cursor-not-allowed' : '';
  
  const buttonClasses = `${baseClasses} ${sizeClasses[size]} ${variantClasses[variant]} ${disabledClass} ${className}`;
  
  return (
    <button
      type={type}
      className={buttonClasses}
      disabled={disabled}
      onClick={onClick}
      {...rest}
    >
      {children}
    </button>
  );
};

export default Button;

package com.cssmart.ui.service;

import com.cssmart.ai.codegen.TestGenerator;
import com.cssmart.ai.codegen.model.TestStep;
import com.cssmart.ai.codegen.model.TestCase;
import com.cssmart.ai.engine.AIEngine;
import com.cssmart.ui.controller.GeneratedTest;
import com.cssmart.ui.controller.TestTemplate;
import com.cssmart.ui.controller.TemplateParameter;
import com.cssmart.ui.recorder.model.RecordedStep;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.ArrayList;
import java.util.stream.Collectors;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

/**
 * Service for AI-powered test generation
 */
@Slf4j
@Service
public class TestGeneratorService {
    
    private final AIEngine aiEngine;
    private final Map<String, GeneratedTest> generatedTests = new java.util.concurrent.ConcurrentHashMap<>();
    private static final String GENERATED_TESTS_DIR = "generated-tests";
    private static final String TEST_CODE_DIR = "src/main/java/com/cssmart/tests/generated";
    
    @Autowired
    public TestGeneratorService(AIEngine aiEngine) {
        this.aiEngine = aiEngine;
        
        // Ensure directories exist
        File generatedDir = new File(GENERATED_TESTS_DIR);
        if (!generatedDir.exists()) {
            generatedDir.mkdirs();
        }
        
        File codeDir = new File(TEST_CODE_DIR);
        if (!codeDir.exists()) {
            codeDir.mkdirs();
        }
    }
    
    /**
     * Generate a test from description
     * @param description Natural language description of the test
     * @return Generated test
     */
    public GeneratedTest generateTest(String description) {
        log.info("Generating test from description: {}", description);
        
        try {
            // Create a new test with basic information
            GeneratedTest generatedTest = new GeneratedTest();
            generatedTest.setId(UUID.randomUUID().toString());
            generatedTest.setName(generateTestName(description));
            generatedTest.setDescription(description);
            
            // Generate class and method names
            String className = generateClassName(generatedTest.getName());
            String methodName = generateMethodName(generatedTest.getName());
            generatedTest.setClassName(className);
            generatedTest.setMethodName(methodName);
            
            // Generate steps based on description
            List<RecordedStep> steps = generateSteps(description);
            generatedTest.setSteps(steps);
            
            // Generate code
            String code = generateCode(generatedTest);
            generatedTest.setCode(code);
            
            // Store for later reference
            generatedTests.put(generatedTest.getId(), generatedTest);
            
            // Save to file
            saveTestToFile(generatedTest);
            
            return generatedTest;
        } catch (Exception e) {
            log.error("Error generating test", e);
            throw new RuntimeException("Failed to generate test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Save a generated test
     * @param test Test to save
     * @return Saved test with ID
     */
    public GeneratedTest saveTest(GeneratedTest test) {
        log.info("Saving generated test: {}", test.getName());
        
        try {
            // Ensure the test has an ID
            if (test.getId() == null || test.getId().isEmpty()) {
                test.setId(UUID.randomUUID().toString());
            }
            
            // Regenerate code if needed
            if (test.getCode() == null || test.getCode().isEmpty()) {
                test.setCode(generateCode(test));
            }
            
            // Store in memory
            generatedTests.put(test.getId(), test);
            
            // Save to file
            saveTestToFile(test);
            
            // Save Java file
            saveJavaFile(test);
            
            return test;
        } catch (Exception e) {
            log.error("Error saving test", e);
            throw new RuntimeException("Failed to save test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Get a list of test templates
     * @return List of available test templates
     */
    public List<TestTemplate> getTemplates() {
        log.info("Fetching test templates");
        
        try {
            // Create sample templates
            List<TestTemplate> templates = new ArrayList<>();
            
            // Login test template
            TestTemplate loginTemplate = new TestTemplate();
            loginTemplate.setId("login-template");
            loginTemplate.setName("Login Test");
            loginTemplate.setDescription("Template for testing user login functionality");
            
            List<TemplateParameter> loginParams = new ArrayList<>();
            TemplateParameter usernameParam = new TemplateParameter();
            usernameParam.setName("username");
            usernameParam.setDescription("Username to use for login");
            usernameParam.setType("string");
            usernameParam.setRequired(true);
            loginParams.add(usernameParam);
            
            TemplateParameter passwordParam = new TemplateParameter();
            passwordParam.setName("password");
            passwordParam.setDescription("Password to use for login");
            passwordParam.setType("string");
            passwordParam.setRequired(true);
            loginParams.add(passwordParam);
            
            loginTemplate.setParameters(loginParams);
            templates.add(loginTemplate);
            
            // Search test template
            TestTemplate searchTemplate = new TestTemplate();
            searchTemplate.setId("search-template");
            searchTemplate.setName("Search Test");
            searchTemplate.setDescription("Template for testing search functionality");
            
            List<TemplateParameter> searchParams = new ArrayList<>();
            TemplateParameter searchTermParam = new TemplateParameter();
            searchTermParam.setName("searchTerm");
            searchTermParam.setDescription("Term to search for");
            searchTermParam.setType("string");
            searchTermParam.setRequired(true);
            searchParams.add(searchTermParam);
            
            searchTemplate.setParameters(searchParams);
            templates.add(searchTemplate);
            
            return templates;
        } catch (Exception e) {
            log.error("Error fetching templates", e);
            throw new RuntimeException("Failed to fetch templates: " + e.getMessage(), e);
        }
    }
    
    /**
     * Generate a test from a template
     * @param templateId Template ID
     * @param parameters Template parameters
     * @return Generated test
     */
    public GeneratedTest generateFromTemplate(String templateId, Map<String, Object> parameters) {
        log.info("Generating test from template: {}", templateId);
        
        try {
            // Build a description based on template and parameters
            StringBuilder description = new StringBuilder();
            
            if ("login-template".equals(templateId)) {
                String username = (String) parameters.get("username");
                String password = (String) parameters.get("password");
                
                description.append("Test user login functionality with username ")
                    .append(username)
                    .append(" and password ")
                    .append(password);
            } else if ("search-template".equals(templateId)) {
                String searchTerm = (String) parameters.get("searchTerm");
                
                description.append("Test search functionality for term ")
                    .append(searchTerm);
            } else {
                throw new IllegalArgumentException("Unknown template ID: " + templateId);
            }
            
            // Generate test using the constructed description
            return generateTest(description.toString());
        } catch (Exception e) {
            log.error("Error generating test from template", e);
            throw new RuntimeException("Failed to generate test from template: " + e.getMessage(), e);
        }
    }
    
    /**
     * Get a generated test by ID
     * @param id Test ID
     * @return Generated test or null if not found
     */
    public GeneratedTest getTest(String id) {
        return generatedTests.get(id);
    }
    
    /**
     * Generate a test name from description
     */
    private String generateTestName(String description) {
        // Simple approach: take first few words
        String[] words = description.split("\\s+");
        StringBuilder name = new StringBuilder();
        
        for (int i = 0; i < Math.min(4, words.length); i++) {
            if (words[i].length() > 0) {
                name.append(Character.toUpperCase(words[i].charAt(0)))
                    .append(words[i].substring(1).toLowerCase())
                    .append(" ");
            }
        }
        
        if (name.length() == 0) {
            return "Generated Test";
        }
        
        return name.toString().trim() + " Test";
    }
    
    /**
     * Generate a class name from test name
     */
    private String generateClassName(String testName) {
        // Remove "Test" suffix if present, then add it back later
        if (testName.endsWith(" Test")) {
            testName = testName.substring(0, testName.length() - 5);
        }
        
        // Replace spaces with nothing and keep only alphanumeric characters
        String className = testName.replaceAll("[^a-zA-Z0-9]", "");
        
        // Ensure first character is uppercase
        if (className.length() > 0) {
            className = Character.toUpperCase(className.charAt(0)) + className.substring(1);
        } else {
            className = "Generated";
        }
        
        return className + "Test";
    }
    
    /**
     * Generate a method name from test name
     */
    private String generateMethodName(String testName) {
        // Remove "Test" suffix if present
        if (testName.endsWith(" Test")) {
            testName = testName.substring(0, testName.length() - 5);
        }
        
        // Replace spaces with nothing and keep only alphanumeric characters
        String methodName = testName.replaceAll("[^a-zA-Z0-9]", "");
        
        // Ensure first character is lowercase
        if (methodName.length() > 0) {
            methodName = Character.toLowerCase(methodName.charAt(0)) + methodName.substring(1);
        } else {
            methodName = "test";
        }
        
        return "test" + methodName;
    }
    
    /**
     * Generate steps based on description
     */
    private List<RecordedStep> generateSteps(String description) {
        List<RecordedStep> steps = new ArrayList<>();
        
        // In a real implementation, this would use AI to generate steps
        // For now, we'll create some sample steps
        
        // Detect login scenario
        if (description.toLowerCase().contains("login")) {
            // Navigate to login page
            RecordedStep navigateStep = new RecordedStep();
            navigateStep.setAction("NAVIGATE");
            navigateStep.setValue("https://example.com/login");
            navigateStep.setTimestamp(java.time.LocalDateTime.now());
            navigateStep.setDescription("Navigate to login page");
            steps.add(navigateStep);
            
            // Enter username
            RecordedStep usernameStep = new RecordedStep();
            usernameStep.setAction("TYPE");
            usernameStep.setElement("username field");
            usernameStep.setValue("testuser");
            usernameStep.setTimestamp(java.time.LocalDateTime.now());
            usernameStep.setDescription("Enter username");
            steps.add(usernameStep);
            
            // Enter password
            RecordedStep passwordStep = new RecordedStep();
            passwordStep.setAction("TYPE");
            passwordStep.setElement("password field");
            passwordStep.setValue("password123");
            passwordStep.setTimestamp(java.time.LocalDateTime.now());
            passwordStep.setDescription("Enter password");
            steps.add(passwordStep);
            
            // Click login button
            RecordedStep loginStep = new RecordedStep();
            loginStep.setAction("CLICK");
            loginStep.setElement("login button");
            loginStep.setTimestamp(java.time.LocalDateTime.now());
            loginStep.setDescription("Click login button");
            steps.add(loginStep);
            
            // Verify successful login
            RecordedStep verifyStep = new RecordedStep();
            verifyStep.setAction("VERIFY_PRESENCE");
            verifyStep.setElement("welcome message");
            verifyStep.setTimestamp(java.time.LocalDateTime.now());
            verifyStep.setDescription("Verify successful login");
            steps.add(verifyStep);
        }
        // Detect search scenario
        else if (description.toLowerCase().contains("search")) {
            // Navigate to homepage
            RecordedStep navigateStep = new RecordedStep();
            navigateStep.setAction("NAVIGATE");
            navigateStep.setValue("https://example.com");
            navigateStep.setTimestamp(java.time.LocalDateTime.now());
            navigateStep.setDescription("Navigate to homepage");
            steps.add(navigateStep);
            
            // Enter search term
            RecordedStep searchStep = new RecordedStep();
            searchStep.setAction("TYPE");
            searchStep.setElement("search field");
            searchStep.setValue("test product");
            searchStep.setTimestamp(java.time.LocalDateTime.now());
            searchStep.setDescription("Enter search term");
            steps.add(searchStep);
            
            // Click search button
            RecordedStep submitStep = new RecordedStep();
            submitStep.setAction("CLICK");
            submitStep.setElement("search button");
            submitStep.setTimestamp(java.time.LocalDateTime.now());
            submitStep.setDescription("Click search button");
            steps.add(submitStep);
            
            // Verify search results
            RecordedStep verifyStep = new RecordedStep();
            verifyStep.setAction("VERIFY_PRESENCE");
            verifyStep.setElement("search results");
            verifyStep.setTimestamp(java.time.LocalDateTime.now());
            verifyStep.setDescription("Verify search results");
            steps.add(verifyStep);
        }
        // Default scenario for other descriptions
        else {
            // Navigate to homepage
            RecordedStep navigateStep = new RecordedStep();
            navigateStep.setAction("NAVIGATE");
            navigateStep.setValue("https://example.com");
            navigateStep.setTimestamp(java.time.LocalDateTime.now());
            navigateStep.setDescription("Navigate to homepage");
            steps.add(navigateStep);
            
            // Generic verification step
            RecordedStep verifyStep = new RecordedStep();
            verifyStep.setAction("VERIFY_PRESENCE");
            verifyStep.setElement("page content");
            verifyStep.setTimestamp(java.time.LocalDateTime.now());
            verifyStep.setDescription("Verify page content");
            steps.add(verifyStep);
        }
        
        return steps;
    }
    
    /**
     * Generate code from test information
     */
    private String generateCode(GeneratedTest test) {
        StringBuilder code = new StringBuilder();
        
        // Add imports and class declaration
        code.append("package com.cssmart.tests.generated;\n\n");
        code.append("import com.cssmart.core.base.CSSmartTestBase;\n");
        code.append("import com.cssmart.core.annotations.CSSmartTest;\n");
        code.append("import org.testng.annotations.Test;\n");
        code.append("import org.openqa.selenium.WebElement;\n");
        code.append("import org.testng.Assert;\n");
        code.append("import lombok.extern.slf4j.Slf4j;\n\n");
        
        code.append("/**\n");
        code.append(" * ").append(test.getDescription()).append("\n");
        code.append(" * Generated by CS Smart Test Framework\n");
        code.append(" */\n");
        code.append("@Slf4j\n");
        code.append("public class ").append(test.getClassName()).append(" extends CSSmartTestBase {\n\n");
        
        // Add test method
        code.append("    @Test\n");
        code.append("    @CSSmartTest(description = \"").append(test.getDescription()).append("\")\n");
        code.append("    public void ").append(test.getMethodName()).append("() {\n");
        code.append("        log.info(\"Starting test: ").append(test.getDescription()).append("\");\n\n");
        
        // Add test steps
        if (test.getSteps() != null && !test.getSteps().isEmpty()) {
            for (RecordedStep step : test.getSteps()) {
                code.append("        // ").append(step.getDescription()).append("\n");
                
                if ("NAVIGATE".equals(step.getAction())) {
                    code.append("        driver.get(\"").append(step.getValue()).append("\");\n");
                } else if ("CLICK".equals(step.getAction())) {
                    code.append("        WebElement element = elementFinder.findElement(\"")
                        .append(step.getElement()).append("\");\n");
                    code.append("        element.click();\n");
                } else if ("TYPE".equals(step.getAction())) {
                    code.append("        WebElement element = elementFinder.findElement(\"")
                        .append(step.getElement()).append("\");\n");
                    code.append("        element.clear();\n");
                    code.append("        element.sendKeys(\"").append(step.getValue()).append("\");\n");
                } else if ("SELECT".equals(step.getAction())) {
                    code.append("        WebElement element = elementFinder.findElement(\"")
                        .append(step.getElement()).append("\");\n");
                    code.append("        new org.openqa.selenium.support.ui.Select(element)")
                        .append(".selectByVisibleText(\"").append(step.getValue()).append("\");\n");
                } else if ("VERIFY_PRESENCE".equals(step.getAction())) {
                    code.append("        WebElement element = elementFinder.findElement(\"")
                        .append(step.getElement()).append("\");\n");
                    code.append("        Assert.assertTrue(element.isDisplayed(), \"")
                        .append(step.getElement()).append(" should be present\");\n");
                } else if ("VERIFY_VISIBILITY".equals(step.getAction())) {
                    code.append("        elementFinder.waitForElementVisible(\"")
                        .append(step.getElement()).append("\");\n");
                    code.append("        Assert.assertTrue(elementFinder.isElementVisible(\"")
                        .append(step.getElement()).append("\"), \"")
                        .append(step.getElement()).append(" should be visible\");\n");
                } else if ("VERIFY_TEXT".equals(step.getAction())) {
                    code.append("        WebElement element = elementFinder.findElement(\"")
                        .append(step.getElement()).append("\");\n");
                    code.append("        Assert.assertTrue(element.getText().contains(\"")
                        .append(step.getValue()).append("\"), \"")
                        .append(step.getElement()).append(" should contain text '")
                        .append(step.getValue()).append("'\");\n");
                } else if ("WAIT".equals(step.getAction())) {
                    code.append("        elementFinder.waitForElement(\"")
                        .append(step.getElement()).append("\");\n");
                } else {
                    code.append("        // TODO: Implement ").append(step.getAction())
                        .append(" action for ").append(step.getElement()).append("\n");
                }
                
                code.append("\n");
            }
        } else {
            code.append("        // TODO: Implement test steps\n\n");
        }
        
        code.append("        log.info(\"Test completed successfully\");\n");
        code.append("    }\n");
        code.append("}\n");
        
        return code.toString();
    }
    
    /**
     * Save test to file
     */
    private void saveTestToFile(GeneratedTest test) {
        try {
            // Save as JSON
            File testFile = new File(GENERATED_TESTS_DIR, test.getId() + ".json");
            
            // Use Jackson to serialize to JSON
            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
            objectMapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule());
            objectMapper.disable(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
            
            objectMapper.writeValue(testFile, test);
            
            log.info("Saved test to file: {}", testFile.getAbsolutePath());
        } catch (Exception e) {
            log.error("Error saving test to file", e);
            throw new RuntimeException("Failed to save test to file: " + e.getMessage(), e);
        }
    }
    
    /**
     * Save Java file
     */
    private void saveJavaFile(GeneratedTest test) {
        try {
            // Ensure directory exists
            File packageDir = new File(TEST_CODE_DIR);
            if (!packageDir.exists()) {
                packageDir.mkdirs();
            }
            
            // Save Java file
            File javaFile = new File(packageDir, test.getClassName() + ".java");
            Files.writeString(javaFile.toPath(), test.getCode());
            
            log.info("Saved Java file: {}", javaFile.getAbsolutePath());
        } catch (Exception e) {
            log.error("Error saving Java file", e);
            throw new RuntimeException("Failed to save Java file: " + e.getMessage(), e);
        }
    }
}

// src/main/webapp/src/index.js
import React from 'react';
import ReactDOM from 'react-dom';
import './styles/index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

// Mount the application
ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

// src/main/webapp/src/components/config/Configuration.jsx
import React, { useState, useEffect } from 'react';
import GeneralConfig from './GeneralConfig';
import BrowserConfig from './BrowserConfig';
import EnvironmentConfig from './EnvironmentConfig';
import Spinner from '../common/Spinner';
import Alert from '../common/Alert';
import { useNotification } from '../../context/NotificationContext';

const Configuration = () => {
  const [activeTab, setActiveTab] = useState('general');
  const [config, setConfig] = useState({
    general: {},
    browser: {},
    environment: {}
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [saveStatus, setSaveStatus] = useState('');
  const { addNotification } = useNotification();
  
  useEffect(() => {
    fetchConfig();
  }, []);
  
  const fetchConfig = async () => {
    try {
      setLoading(true);
      setError(null);
      
      // Fetch configuration from API
      const response = await fetch('/api/config');
      
      if (!response.ok) {
        throw new Error(`Failed to fetch configuration: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      setConfig(data);
      
    } catch (error) {
      console.error('Error fetching configuration:', error);
      setError(error.message || 'Failed to load configuration');
      // Set sample data for development if API fails
      setSampleConfig();
      addNotification('Using sample configuration data due to API error', 'warning');
    } finally {
      setLoading(false);
    }
  };
  
  const setSampleConfig = () => {
    setConfig({
      general: {
        framework: {
          name: 'CSSmartTest',
          version: '1.0.0-SNAPSHOT',
          mode: 'zero-code'
        },
        execution: {
          parallel: true,
          threadCount: 5,
          retryCount: 1,
          timeout: 60
        },
        element: {
          timeout: 15,
          polling: 500
        },
        reporting: {
          format: 'html',
          screenshots: true,
          video: false,
          outputDir: './reports'
        }
      },
      browser: {
        default: 'chrome',
        browsers: {
          chrome: {
            driver: 'webdriver.chrome.driver',
            headless: false,
            arguments: [
              '--start-maximized',
              '--disable-notifications',
              '--disable-infobars'
            ],
            capabilities: {
              acceptInsecureCerts: true,
              pageLoadStrategy: 'normal'
            }
          },
          firefox: {
            driver: 'webdriver.gecko.driver',
            headless: false,
            arguments: [
              '--start-maximized',
              '--disable-notifications'
            ],
            capabilities: {
              acceptInsecureCerts: true,
              pageLoadStrategy: 'normal'
            }
          }
        }
      },
      environment: {
        default: 'qa',
        environments: {
          qa: {
            base: {
              url: 'https://qa.example.com',
              api: 'https://api-qa.example.com'
            },
            database: {
              host: 'qa-db.example.com',
              port: 3306,
              username: '${DB_USERNAME}',
              password: '${DB_PASSWORD}',
              name: 'qa_testdb'
            }
          },
          staging: {
            base: {
              url: 'https://staging.example.com',
              api: 'https://api-staging.example.com'
            },
            database: {
              host: 'staging-db.example.com',
              port: 3306,
              username: '${DB_USERNAME}',
              password: '${DB_PASSWORD}',
              name: 'staging_testdb'
            }
          }
        }
      }
    });
  };
  
  const saveConfig = async (section, data) => {
    setSaveStatus('saving');
    
    try {
      // Update local state for immediate feedback
      setConfig({
        ...config,
        [section]: data
      });
      
      // Make API call to save the config
      const response = await fetch(`/api/config/${section}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });
      
      if (!response.ok) {
        throw new Error(`Failed to save ${section} configuration: ${response.status} ${response.statusText}`);
      }
      
      setSaveStatus('success');
      addNotification(`${section.charAt(0).toUpperCase() + section.slice(1)} configuration saved successfully`, 'success');
      
      // Clear success message after 3 seconds
      setTimeout(() => setSaveStatus(''), 3000);
      
    } catch (error) {
      console.error(`Error saving ${section} configuration:`, error);
      setSaveStatus('error');
      addNotification(`Error saving ${section} configuration: ${error.message}`, 'error');
      
      // Clear error message after 5 seconds
      setTimeout(() => setSaveStatus(''), 5000);
    }
  };
  
  const handleTabChange = (tab) => {
    // Only change tab if we're not in a loading state
    if (!loading) {
      setActiveTab(tab);
    }
  };
  
  const renderTabContent = () => {
    if (loading) {
      return (
        <div className="flex justify-center items-center py-12">
          <Spinner size="lg" />
          <span className="ml-4 text-gray-600">Loading configuration...</span>
        </div>
      );
    }
    
    switch (activeTab) {
      case 'general':
        return (
          <GeneralConfig 
            config={config.general} 
            saveConfig={(data) => saveConfig('general', data)} 
          />
        );
      case 'browser':
        return (
          <BrowserConfig 
            config={config.browser} 
            saveConfig={(data) => saveConfig('browser', data)} 
          />
        );
      case 'environment':
        return (
          <EnvironmentConfig 
            config={config.environment} 
            saveConfig={(data) => saveConfig('environment', data)} 
          />
        );
      default:
        return null;
    }
  };
  
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold">Configuration</h1>
        
        {saveStatus && (
          <div className={`px-4 py-2 rounded ${
            saveStatus === 'saving' ? 'bg-blue-100 text-blue-800' :
            saveStatus === 'success' ? 'bg-green-100 text-green-800' :
            'bg-red-100 text-red-800'
          }`}>
            {saveStatus === 'saving' ? 'Saving...' :
             saveStatus === 'success' ? 'Configuration saved successfully!' :
             'Failed to save configuration'}
          </div>
        )}
      </div>
      
      {error && (
        <Alert
          type="error"
          title="Configuration Error"
          onClose={() => setError(null)}
        >
          {error}
        </Alert>
      )}
      
      <div className="bg-white rounded-lg shadow overflow-hidden">
        <div className="border-b">
          <nav className="flex">
            <button
              className={`px-6 py-3 border-b-2 font-medium text-sm transition-colors ${
                activeTab === 'general'
                  ? 'border-indigo-500 text-indigo-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
              }`}
              onClick={() => handleTabChange('general')}
              disabled={loading}
            >
              General
            </button>
            <button
              className={`px-6 py-3 border-b-2 font-medium text-sm transition-colors ${
                activeTab === 'browser'
                  ? 'border-indigo-500 text-indigo-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
              }`}
              onClick={() => handleTabChange('browser')}
              disabled={loading}
            >
              Browsers
            </button>
            <button
              className={`px-6 py-3 border-b-2 font-medium text-sm transition-colors ${
                activeTab === 'environment'
                  ? 'border-indigo-500 text-indigo-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
              }`}
              onClick={() => handleTabChange('environment')}
              disabled={loading}
            >
              Environments
            </button>
          </nav>
        </div>
        
        <div className="p-6">
          {renderTabContent()}
        </div>
      </div>
    </div>
  );
};

export default Configuration;

// src/main/webapp/src/components/config/GeneralConfig.jsx
import React, { useState, useEffect } from 'react';
import Button from '../common/Button';
import Card from '../common/Card';
import TextField from '../common/TextField';
import SelectField from '../common/SelectField';
import Checkbox from '../common/Checkbox';

const GeneralConfig = ({ config, saveConfig }) => {
  const [formData, setFormData] = useState({
    framework: {
      name: 'CSSmartTest',
      version: '1.0.0-SNAPSHOT',
      mode: 'zero-code'
    },
    execution: {
      parallel: true,
      threadCount: 5,
      retryCount: 1,
      timeout: 60
    },
    element: {
      timeout: 15,
      polling: 500
    },
    reporting: {
      format: 'html',
      screenshots: true,
      video: false,
      outputDir: './reports'
    }
  });

  // Update form data when config changes
  useEffect(() => {
    if (config && Object.keys(config).length > 0) {
      setFormData(config);
    }
  }, [config]);

  // Handle input changes
  const handleChange = (section, field, value) => {
    setFormData(prev => ({
      ...prev,
      [section]: {
        ...prev[section],
        [field]: value
      }
    }));
  };

  // Handle checkbox changes
  const handleCheckboxChange = (section, field, e) => {
    const value = e.target.checked;
    handleChange(section, field, value);
  };

  // Handle text field changes
  const handleTextChange = (section, field, e) => {
    const value = e.target.value;
    handleChange(section, field, value);
  };

  // Handle numeric field changes
  const handleNumberChange = (section, field, e) => {
    let value = e.target.value;
    if (value === '') {
      value = 0;
    } else {
      value = parseInt(value, 10);
      if (isNaN(value)) return;
    }
    handleChange(section, field, value);
  };

  // Handle save
  const handleSave = (e) => {
    e.preventDefault();
    saveConfig(formData);
  };

  return (
    <form onSubmit={handleSave}>
      <div className="space-y-6">
        {/* Framework Section */}
        <Card title="Framework">
          <div className="grid grid-cols-1 gap-6 md:grid-cols-2">
            <TextField
              label="Name"
              value={formData.framework.name}
              onChange={(e) => handleTextChange('framework', 'name', e)}
            />
            <TextField
              label="Version"
              value={formData.framework.version}
              onChange={(e) => handleTextChange('framework', 'version', e)}
            />
            <SelectField
              label="Mode"
              value={formData.framework.mode}
              onChange={(e) => handleTextChange('framework', 'mode', e)}
              options={[
                { value: 'zero-code', label: 'Zero Code' },
                { value: 'code-assist', label: 'Code Assist' },
                { value: 'advanced', label: 'Advanced' }
              ]}
            />
          </div>
        </Card>

        {/* Execution Section */}
        <Card title="Execution">
          <div className="grid grid-cols-1 gap-6 md:grid-cols-2">
            <Checkbox
              label="Parallel Execution"
              checked={formData.execution.parallel}
              onChange={(e) => handleCheckboxChange('execution', 'parallel', e)}
            />
            <TextField
              label="Thread Count"
              type="number"
              value={formData.execution.threadCount}
              onChange={(e) => handleNumberChange('execution', 'threadCount', e)}
            />
            <TextField
              label="Retry Count"
              type="number"
              value={formData.execution.retryCount}
              onChange={(e) => handleNumberChange('execution', 'retryCount', e)}
            />
            <TextField
              label="Timeout (seconds)"
              type="number"
              value={formData.execution.timeout}
              onChange={(e) => handleNumberChange('execution', 'timeout', e)}
            />
          </div>
        </Card>

        {/* Element Section */}
        <Card title="Element">
          <div className="grid grid-cols-1 gap-6 md:grid-cols-2">
            <TextField
              label="Timeout (seconds)"
              type="number"
              value={formData.element.timeout}
              onChange={(e) => handleNumberChange('element', 'timeout', e)}
            />
            <TextField
              label="Polling Interval (ms)"
              type="number"
              value={formData.element.polling}
              onChange={(e) => handleNumberChange('element', 'polling', e)}
            />
          </div>
        </Card>

        {/* Reporting Section */}
        <Card title="Reporting">
          <div className="grid grid-cols-1 gap-6 md:grid-cols-2">
            <SelectField
              label="Report Format"
              value={formData.reporting.format}
              onChange={(e) => handleTextChange('reporting', 'format', e)}
              options={[
                { value: 'html', label: 'HTML' },
                { value: 'pdf', label: 'PDF' },
                { value: 'json', label: 'JSON' },
                { value: 'excel', label: 'Excel' }
              ]}
            />
            <TextField
              label="Output Directory"
              value={formData.reporting.outputDir}
              onChange={(e) => handleTextChange('reporting', 'outputDir', e)}
            />
            <Checkbox
              label="Capture Screenshots"
              checked={formData.reporting.screenshots}
              onChange={(e) => handleCheckboxChange('reporting', 'screenshots', e)}
            />
            <Checkbox
              label="Record Video"
              checked={formData.reporting.video}
              onChange={(e) => handleCheckboxChange('reporting', 'video', e)}
            />
          </div>
        </Card>

        <div className="flex justify-end">
          <Button
            type="submit"
            variant="primary"
          >
            Save Configuration
          </Button>
        </div>
      </div>
    </form>
  );
};

export default GeneralConfig;

// src/main/webapp/src/components/config/BrowserConfig.jsx
import React, { useState, useEffect } from 'react';
import Button from '../common/Button';
import Card from '../common/Card';
import TextField from '../common/TextField';
import SelectField from '../common/SelectField';
import Checkbox from '../common/Checkbox';

const BrowserConfig = ({ config, saveConfig }) => {
  const [formData, setFormData] = useState({
    default: 'chrome',
    browsers: {
      chrome: {
        driver: 'webdriver.chrome.driver',
        headless: false,
        arguments: [
          '--start-maximized',
          '--disable-notifications',
          '--disable-infobars'
        ],
        capabilities: {
          acceptInsecureCerts: true,
          pageLoadStrategy: 'normal'
        }
      },
      firefox: {
        driver: 'webdriver.gecko.driver',
        headless: false,
        arguments: [
          '--start-maximized',
          '--disable-notifications'
        ],
        capabilities: {
          acceptInsecureCerts: true,
          pageLoadStrategy: 'normal'
        }
      }
    }
  });

  // Update form data when config changes
  useEffect(() => {
    if (config && Object.keys(config).length > 0) {
      setFormData(config);
    }
  }, [config]);

  // Get list of browser names
  const browserNames = Object.keys(formData.browsers || {});

  // Handle default browser change
  const handleDefaultBrowserChange = (e) => {
    setFormData(prev => ({
      ...prev,
      default: e.target.value
    }));
  };

  // Handle browser settings change
  const handleBrowserChange = (browser, field, value) => {
    setFormData(prev => ({
      ...prev,
      browsers: {
        ...prev.browsers,
        [browser]: {
          ...prev.browsers[browser],
          [field]: value
        }
      }
    }));
  };

  // Handle browser capability change
  const handleCapabilityChange = (browser, capability, value) => {
    setFormData(prev => ({
      ...prev,
      browsers: {
        ...prev.browsers,
        [browser]: {
          ...prev.browsers[browser],
          capabilities: {
            ...prev.browsers[browser].capabilities,
            [capability]: value
          }
        }
      }
    }));
  };

  // Handle checkbox changes
  const handleCheckboxChange = (browser, field, e) => {
    const value = e.target.checked;
    handleBrowserChange(browser, field, value);
  };

  // Handle text field changes
  const handleTextChange = (browser, field, e) => {
    const value = e.target.value;
    handleBrowserChange(browser, field, value);
  };

  // Handle capability checkbox changes
  const handleCapabilityCheckboxChange = (browser, capability, e) => {
    const value = e.target.checked;
    handleCapabilityChange(browser, capability, value);
  };

  // Handle capability text changes
  const handleCapabilityTextChange = (browser, capability, e) => {
    const value = e.target.value;
    handleCapabilityChange(browser, capability, value);
  };

  // Handle argument changes (comma separated list)
  const handleArgumentsChange = (browser, e) => {
    const value = e.target.value;
    const arguments = value.split(',').map(arg => arg.trim()).filter(arg => arg);
    handleBrowserChange(browser, 'arguments', arguments);
  };

  // Format arguments for display
  const formatArguments = (args) => {
    if (!args || !Array.isArray(args)) return '';
    return args.join(', ');
  };

  // Handle save
  const handleSave = (e) => {
    e.preventDefault();
    saveConfig(formData);
  };

  // Render browser config sections
  const renderBrowserConfig = (browserName) => {
    const browser = formData.browsers[browserName];
    return (
      <Card key={browserName} title={`${browserName.charAt(0).toUpperCase() + browserName.slice(1)} Configuration`}>
        <div className="grid grid-cols-1 gap-6 md:grid-cols-2">
          <TextField
            label="Driver Path"
            value={browser.driver}
            onChange={(e) => handleTextChange(browserName, 'driver', e)}
          />
          <Checkbox
            label="Headless Mode"
            checked={browser.headless}
            onChange={(e) => handleCheckboxChange(browserName, 'headless', e)}
          />
          <div className="md:col-span-2">
            <TextField
              label="Arguments (comma separated)"
              value={formatArguments(browser.arguments)}
              onChange={(e) => handleArgumentsChange(browserName, e)}
            />
          </div>
        </div>

        <h4 className="font-medium text-gray-700 mt-4 mb-2">Capabilities</h4>
        <div className="grid grid-cols-1 gap-6 md:grid-cols-2">
          <Checkbox
            label="Accept Insecure Certificates"
            checked={browser.capabilities?.acceptInsecureCerts}
            onChange={(e) => handleCapabilityCheckboxChange(browserName, 'acceptInsecureCerts', e)}
          />
          <SelectField
            label="Page Load Strategy"
            value={browser.capabilities?.pageLoadStrategy}
            onChange={(e) => handleCapabilityTextChange(browserName, 'pageLoadStrategy', e)}
            options={[
              { value: 'normal', label: 'Normal' },
              { value: 'eager', label: 'Eager' },
              { value: 'none', label: 'None' }
            ]}
          />
        </div>
      </Card>
    );
  };

  return (
    <form onSubmit={handleSave}>
      <div className="space-y-6">
        <Card title="Browser Selection">
          <div className="grid grid-cols-1 gap-6">
            <SelectField
              label="Default Browser"
              value={formData.default}
              onChange={handleDefaultBrowserChange}
              options={browserNames.map(browser => ({
                value: browser,
                label: browser.charAt(0).toUpperCase() + browser.slice(1)
              }))}
            />
          </div>
        </Card>

        {/* Render each browser configuration */}
        {browserNames.map(browserName => renderBrowserConfig(browserName))}

        <div className="flex justify-end">
          <Button
            type="submit"
            variant="primary"
          >
            Save Configuration
          </Button>
        </div>
      </div>
    </form>
  );
};

export default BrowserConfig;

// src/main/webapp/src/components/config/EnvironmentConfig.jsx
import React, { useState, useEffect } from 'react';
import Button from '../common/Button';
import Card from '../common/Card';
import TextField from '../common/TextField';
import SelectField from '../common/SelectField';

const EnvironmentConfig = ({ config, saveConfig }) => {
  const [formData, setFormData] = useState({
    default: 'qa',
    environments: {
      qa: {
        base: {
          url: 'https://qa.example.com',
          api: 'https://api-qa.example.com'
        },
        database: {
          host: 'qa-db.example.com',
          port: 3306,
          username: '${DB_USERNAME}',
          password: '${DB_PASSWORD}',
          name: 'qa_testdb'
        }
      },
      staging: {
        base: {
          url: 'https://staging.example.com',
          api: 'https://api-staging.example.com'
        },
        database: {
          host: 'staging-db.example.com',
          port: 3306,
          username: '${DB_USERNAME}',
          password: '${DB_PASSWORD}',
          name: 'staging_testdb'
        }
      }
    }
  });

  // Update form data when config changes
  useEffect(() => {
    if (config && Object.keys(config).length > 0) {
      setFormData(config);
    }
  }, [config]);

  // Get list of environment names
  const environmentNames = Object.keys(formData.environments || {});

  // Handle default environment change
  const handleDefaultEnvironmentChange = (e) => {
    setFormData(prev => ({
      ...prev,
      default: e.target.value
    }));
  };

  // Handle environment base URL change
  const handleBaseUrlChange = (env, field, e) => {
    const value = e.target.value;
    setFormData(prev => ({
      ...prev,
      environments: {
        ...prev.environments,
        [env]: {
          ...prev.environments[env],
          base: {
            ...prev.environments[env].base,
            [field]: value
          }
        }
      }
    }));
  };

  // Handle environment database change
  const handleDbChange = (env, field, e) => {
    let value = e.target.value;
    if (field === 'port') {
      value = parseInt(value, 10);
      if (isNaN(value)) return;
    }
    
    setFormData(prev => ({
      ...prev,
      environments: {
        ...prev.environments,
        [env]: {
          ...prev.environments[env],
          database: {
            ...prev.environments[env].database,
            [field]: value
          }
        }
      }
    }));
  };

  // Add a new environment
  const addEnvironment = () => {
    let newEnvName = 'new-environment';
    let counter = 1;
    
    // Make sure the name is unique
    while (formData.environments[newEnvName]) {
      newEnvName = `new-environment-${counter}`;
      counter++;
    }
    
    setFormData(prev => ({
      ...prev,
      environments: {
        ...prev.environments,
        [newEnvName]: {
          base: {
            url: 'https://example.com',
            api: 'https://api.example.com'
          },
          database: {
            host: 'db.example.com',
            port: 3306,
            username: '${DB_USERNAME}',
            password: '${DB_PASSWORD}',
            name: 'testdb'
          }
        }
      }
    }));
  };

  // Remove an environment
  const removeEnvironment = (envName) => {
    // Don't allow removing the last environment
    if (Object.keys(formData.environments).length <= 1) {
      return;
    }
    
    // Make sure we update the default if it's the one being removed
    let newFormData = { ...formData };
    delete newFormData.environments[envName];
    
    if (formData.default === envName) {
      newFormData.default = Object.keys(newFormData.environments)[0];
    }
    
    setFormData(newFormData);
  };

  // Handle rename environment
  const renameEnvironment = (oldName, e) => {
    const newName = e.target.value.trim();
    
    // Skip if name is empty or the same
    if (!newName || newName === oldName || formData.environments[newName]) {
      return;
    }
    
    const envData = formData.environments[oldName];
    
    // Create new state with renamed environment
    let newFormData = { ...formData };
    delete newFormData.environments[oldName];
    newFormData.environments[newName] = envData;
    
    // Update default if needed
    if (formData.default === oldName) {
      newFormData.default = newName;
    }
    
    setFormData(newFormData);
  };

  // Handle save
  const handleSave = (e) => {
    e.preventDefault();
    saveConfig(formData);
  };

  // Render environment config sections
  const renderEnvironmentConfig = (envName) => {
    const env = formData.environments[envName];
    return (
      <Card 
        key={envName} 
        title={
          <div className="flex items-center justify-between">
            <TextField
              value={envName}
              onChange={(e) => renameEnvironment(envName, e)}
              className="flex-grow mr-4"
            />
            <Button
              variant="danger"
              size="sm"
              onClick={() => removeEnvironment(envName)}
              disabled={Object.keys(formData.environments).length <= 1}
            >
              Remove
            </Button>
          </div>
        }
      >
        <div className="mt-4">
          <h4 className="font-medium text-gray-700 mb-2">Base URLs</h4>
          <div className="grid grid-cols-1 gap-6 md:grid-cols-2">
            <TextField
              label="Web URL"
              value={env.base.url}
              onChange={(e) => handleBaseUrlChange(envName, 'url', e)}
            />
            <TextField
              label="API URL"
              value={env.base.api}
              onChange={(e) => handleBaseUrlChange(envName, 'api', e)}
            />
          </div>
        </div>

        <div className="mt-6">
          <h4 className="font-medium text-gray-700 mb-2">Database Configuration</h4>
          <div className="grid grid-cols-1 gap-6 md:grid-cols-2">
            <TextField
              label="Host"
              value={env.database.host}
              onChange={(e) => handleDbChange(envName, 'host', e)}
            />
            <TextField
              label="Port"
              type="number"
              value={env.database.port}
              onChange={(e) => handleDbChange(envName, 'port', e)}
            />
            <TextField
              label="Database Name"
              value={env.database.name}
              onChange={(e) => handleDbChange(envName, 'name', e)}
            />
            <TextField
              label="Username"
              value={env.database.username}
              onChange={(e) => handleDbChange(envName, 'username', e)}
            />
            <TextField
              label="Password"
              type="password"
              value={env.database.password}
              onChange={(e) => handleDbChange(envName, 'password', e)}
            />
          </div>
        </div>
      </Card>
    );
  };

  return (
    <form onSubmit={handleSave}>
      <div className="space-y-6">
        <Card title="Environment Selection">
          <div className="grid grid-cols-1 gap-6">
            <SelectField
              label="Default Environment"
              value={formData.default}
              onChange={handleDefaultEnvironmentChange}
              options={environmentNames.map(env => ({
                value: env,
                label: env.charAt(0).toUpperCase() + env.slice(1)
              }))}
            />
            <div className="flex justify-end">
              <Button
                variant="secondary"
                onClick={addEnvironment}
                type="button"
              >
                Add New Environment
              </Button>
            </div>
          </div>
        </Card>

        {/* Render each environment configuration */}
        {environmentNames.map(envName => renderEnvironmentConfig(envName))}

        <div className="flex justify-end">
          <Button
            type="submit"
            variant="primary"
          >
            Save Configuration
          </Button>
        </div>
      </div>
    </form>
  );
};

export default EnvironmentConfig;

// src/main/webapp/src/components/dashboard/Dashboard.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import Card from '../common/Card';
import Spinner from '../common/Spinner';
import Button from '../common/Button';
import Alert from '../common/Alert';
import { useNotification } from '../../context/NotificationContext';
import MetricsPanel from './MetricsPanel';
import RecentTestsPanel from './RecentTestsPanel';
import TrendsChart from './TrendsChart';
import InsightsPanel from './InsightsPanel';

const Dashboard = () => {
  const navigate = useNavigate();
  const { addNotification } = useNotification();
  const [metrics, setMetrics] = useState(null);
  const [trends, setTrends] = useState([]);
  const [recentTests, setRecentTests] = useState([]);
  const [insights, setInsights] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // Fetch dashboard data
    fetchDashboardData();
  }, []);

  const fetchDashboardData = async () => {
    setLoading(true);
    setError(null);

    try {
      // Fetch metrics
      const metricsResponse = await fetch('/api/dashboard/metrics');
      if (!metricsResponse.ok) {
        throw new Error(`Failed to fetch metrics: ${metricsResponse.status} ${metricsResponse.statusText}`);
      }
      const metricsData = await metricsResponse.json();
      setMetrics(metricsData.metrics);
      setInsights(metricsData.insights || []);

      // Fetch trends
      const trendsResponse = await fetch('/api/dashboard/trends');
      if (!trendsResponse.ok) {
        throw new Error(`Failed to fetch trends: ${trendsResponse.status} ${trendsResponse.statusText}`);
      }
      const trendsData = await trendsResponse.json();
      setTrends(trendsData);

      // Fetch recent tests
      const reportsResponse = await fetch('/api/dashboard/reports');
      if (!reportsResponse.ok) {
        throw new Error(`Failed to fetch reports: ${reportsResponse.status} ${reportsResponse.statusText}`);
      }
      const reportsData = await reportsResponse.json();
      setRecentTests(reportsData);
    } catch (err) {
      console.error('Error fetching dashboard data:', err);
      setError(err.message || 'Failed to load dashboard data');
      addNotification(`Error loading dashboard: ${err.message}`, 'error');
      
      // Set fallback data for development
      setFallbackData();
    } finally {
      setLoading(false);
    }
  };

  const setFallbackData = () => {
    // Set fallback metrics
    setMetrics({
      totalTests: 120,
      passedTests: 95,
      failedTests: 15,
      skippedTests: 10,
      successRate: 79.2,
      avgDuration: 29500,
      minDuration: 5000,
      maxDuration: 120000,
      duration: 3540000
    });

    // Set fallback insights
    setInsights([
      {
        title: 'Test Failures Detected',
        description: '15 tests failed. Review error details for troubleshooting.',
        type: 'RELIABILITY',
        confidence: 0.9
      },
      {
        title: 'Low Success Rate',
        description: 'Success rate is 79.2%. Consider reviewing test stability.',
        type: 'STABILITY',
        confidence: 0.8
      },
      {
        title: 'Performance Concern',
        description: 'Average test duration is high. Consider optimizing slow tests.',
        type: 'PERFORMANCE',
        confidence: 0.75
      }
    ]);

    // Set fallback trends
    const now = new Date();
    const trends = [];
    for (let i = 6; i >= 0; i--) {
      const date = new Date();
      date.setDate(now.getDate() - i);
      
      trends.push({
        date: date.toISOString(),
        total: 15 + Math.floor(Math.random() * 10),
        passed: 12 + Math.floor(Math.random() * 8),
        failed: 1 + Math.floor(Math.random() * 3),
        skipped: Math.floor(Math.random() * 2),
        successRate: 75 + Math.random() * 20,
        avgDuration: 20000 + Math.random() * 15000
      });
    }
    setTrends(trends);

    // Set fallback recent tests
    const statuses = ['PASSED', 'FAILED', 'SKIPPED'];
    const testNames = ['Login Test', 'Search Test', 'Checkout Test', 'Registration Test', 'Profile Update Test'];
    const recentTests = [];
    
    for (let i = 0; i < 5; i++) {
      const startTime = new Date();
      startTime.setMinutes(startTime.getMinutes() - (i * 30 + Math.random() * 30));
      const duration = 5000 + Math.random() * 30000;
      const endTime = new Date(startTime.getTime() + duration);
      
      recentTests.push({
        id: `test-${i}`,
        name: testNames[i % testNames.length],
        status: statuses[Math.floor(Math.random() * (i === 0 ? 1 : 3))], // Make first test always pass
        startTime: startTime.toISOString(),
        endTime: endTime.toISOString(),
        duration: duration,
        className: `com.cssmart.tests.web.${testNames[i % testNames.length].replace(' ', '')}`,
        browser: ['chrome', 'firefox', 'edge'][i % 3]
      });
    }
    setRecentTests(recentTests);
  };

  // Create a new test
  const handleNewTest = () => {
    navigate('/recorder');
  };

  // View all reports
  const handleViewAllReports = () => {
    navigate('/reports');
  };

  // Refresh dashboard
  const handleRefresh = () => {
    fetchDashboardData();
    addNotification('Dashboard refreshed', 'info');
  };

  // Show loading state
  if (loading) {
    return (
      <div className="flex flex-col items-center justify-center h-64">
        <Spinner size="lg" />
        <p className="mt-4 text-gray-600">Loading dashboard data...</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold">Dashboard</h1>
        <div className="flex space-x-2">
          <Button variant="secondary" onClick={handleRefresh}>
            Refresh
          </Button>
          <Button variant="primary" onClick={handleNewTest}>
            New Test
          </Button>
        </div>
      </div>

      {error && (
        <Alert type="error" title="Error Loading Dashboard" onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      {/* Metrics Cards */}
      <MetricsPanel metrics={metrics} />

      {/* Trends Chart */}
      <Card title="Test Execution Trends">
        <div className="h-80">
          <TrendsChart data={trends} />
        </div>
      </Card>

      {/* Two Column Layout for Recent Tests and Insights */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="lg:col-span-2">
          <RecentTestsPanel tests={recentTests} onViewAll={handleViewAllReports} />
        </div>
        <div className="lg:col-span-1">
          <InsightsPanel insights={insights} />
        </div>
      </div>
    </div>
  );
};

export default Dashboard;

// src/main/webapp/src/components/dashboard/MetricsPanel.jsx
import React from 'react';

const MetricsPanel = ({ metrics }) => {
  if (!metrics) return null;

  // Format duration for display (ms to readable format)
  const formatDuration = (ms) => {
    if (ms < 1000) return `${ms}ms`;
    
    const seconds = Math.floor(ms / 1000) % 60;
    const minutes = Math.floor(ms / 60000) % 60;
    const hours = Math.floor(ms / 3600000);
    
    if (hours > 0) {
      return `${hours}h ${minutes}m ${seconds}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds}s`;
    } else {
      return `${seconds}s`;
    }
  };

  // Convert to regular format with commas
  const formatNumber = (num) => {
    return num.toLocaleString();
  };

  // Format percentage
  const formatPercentage = (value) => {
    return `${value.toFixed(1)}%`;
  };

  return (
    <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
      {/* Total Tests */}
      <div className="bg-white rounded-lg shadow p-6">
        <div className="flex items-center">
          <div className="p-3 rounded-full bg-indigo-100 text-indigo-600">
            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
            </svg>
          </div>
          <div className="ml-4">
            <p className="text-sm font-medium text-gray-500">Total Tests</p>
            <p className="text-xl font-semibold text-gray-900">{formatNumber(metrics.totalTests)}</p>
          </div>
        </div>
      </div>
      
      {/* Success Rate */}
      <div className="bg-white rounded-lg shadow p-6">
        <div className="flex items-center">
          <div className={`p-3 rounded-full ${
            metrics.successRate >= 90 ? 'bg-green-100 text-green-600' :
            metrics.successRate >= 75 ? 'bg-yellow-100 text-yellow-600' :
            'bg-red-100 text-red-600'
          }`}>
            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <div className="ml-4">
            <p className="text-sm font-medium text-gray-500">Success Rate</p>
            <p className="text-xl font-semibold text-gray-900">{formatPercentage(metrics.successRate)}</p>
          </div>
        </div>
      </div>
      
      {/* Average Duration */}
      <div className="bg-white rounded-lg shadow p-6">
        <div className="flex items-center">
          <div className="p-3 rounded-full bg-blue-100 text-blue-600">
            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <div className="ml-4">
            <p className="text-sm font-medium text-gray-500">Avg. Duration</p>
            <p className="text-xl font-semibold text-gray-900">{formatDuration(metrics.avgDuration)}</p>
          </div>
        </div>
      </div>
      
      {/* Test Results Breakdown */}
      <div className="bg-white rounded-lg shadow p-6">
        <p className="text-sm font-medium text-gray-500 mb-3">Results Breakdown</p>
        <div className="space-y-2">
          <div className="flex justify-between">
            <div className="flex items-center">
              <span className="h-3 w-3 rounded-full bg-green-500 mr-2"></span>
              <span className="text-sm text-gray-600">Passed</span>
            </div>
            <span className="text-sm font-medium">{metrics.passedTests}</span>
          </div>
          <div className="flex justify-between">
            <div className="flex items-center">
              <span className="h-3 w-3 rounded-full bg-red-500 mr-2"></span>
              <span className="text-sm text-gray-600">Failed</span>
            </div>
            <span className="text-sm font-medium">{metrics.failedTests}</span>
          </div>
          <div className="flex justify-between">
            <div className="flex items-center">
              <span className="h-3 w-3 rounded-full bg-gray-400 mr-2"></span>
              <span className="text-sm text-gray-600">Skipped</span>
            </div>
            <span className="text-sm font-medium">{metrics.skippedTests}</span>
          </div>
        </div>
      </div>
    </div>
  );
};

export default MetricsPanel;

// src/main/webapp/src/components/dashboard/TrendsChart.jsx
import React from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, BarChart, Bar } from 'recharts';

const TrendsChart = ({ data }) => {
  if (!data || data.length === 0) {
    return (
      <div className="flex items-center justify-center h-full bg-gray-50 rounded-lg">
        <p className="text-gray-500">No trend data available</p>
      </div>
    );
  }

  // Format date for display
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
  };

  // Custom tooltip
  const CustomTooltip = ({ active, payload, label }) => {
    if (active && payload && payload.length) {
      return (
        <div className="bg-white p-4 border rounded shadow-lg">
          <p className="font-medium">{formatDate(label)}</p>
          <div className="mt-2 space-y-1">
            <p className="flex items-center">
              <span className="h-3 w-3 rounded-full bg-green-500 mr-2"></span>
              <span className="text-sm text-gray-600">Passed:</span>
              <span className="text-sm font-medium ml-2">{payload[1].value}</span>
            </p>
            <p className="flex items-center">
              <span className="h-3 w-3 rounded-full bg-red-500 mr-2"></span>
              <span className="text-sm text-gray-600">Failed:</span>
              <span className="text-sm font-medium ml-2">{payload[2].value}</span>
            </p>
            <p className="flex items-center">
              <span className="h-3 w-3 rounded-full bg-gray-400 mr-2"></span>
              <span className="text-sm text-gray-600">Skipped:</span>
              <span className="text-sm font-medium ml-2">{payload[3].value}</span>
            </p>
            <p className="flex items-center mt-2 pt-2 border-t">
              <span className="h-3 w-3 rounded-full bg-indigo-500 mr-2"></span>
              <span className="text-sm text-gray-600">Success Rate:</span>
              <span className="text-sm font-medium ml-2">{payload[0].value.toFixed(1)}%</span>
            </p>
          </div>
        </div>
      );
    }
    return null;
  };

  return (
    <div className="h-full">
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 h-full">
        {/* Success Rate Line Chart */}
        <div className="h-full">
          <ResponsiveContainer width="100%" height="100%">
            <LineChart data={data} margin={{ top: 10, right: 30, left: 0, bottom: 0 }}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis 
                dataKey="date" 
                tickFormatter={formatDate}
              />
              <YAxis 
                domain={[0, 100]} 
                tickFormatter={(value) => `${value}%`}
              />
              <Tooltip content={<CustomTooltip />} />
              <Legend />
              <Line 
                type="monotone" 
                dataKey="successRate" 
                name="Success Rate" 
                stroke="#6366f1" 
                activeDot={{ r: 8 }} 
                strokeWidth={2}
              />
            </LineChart>
          </ResponsiveContainer>
        </div>

        {/* Test Count Bar Chart */}
        <div className="h-full">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart data={data} margin={{ top: 10, right: 30, left: 0, bottom: 0 }}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis 
                dataKey="date" 
                tickFormatter={formatDate}
              />
              <YAxis />
              <Tooltip content={<CustomTooltip />} />
              <Legend />
              <Bar dataKey="total" name="Total" fill="#9ca3af" stackId="a" />
              <Bar dataKey="passed" name="Passed" fill="#10b981" stackId="a" />
              <Bar dataKey="failed" name="Failed" fill="#ef4444" stackId="a" />
              <Bar dataKey="skipped" name="Skipped" fill="#6b7280" stackId="a" />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </div>
    </div>
  );
};

export default TrendsChart;

// src/main/webapp/src/components/dashboard/RecentTestsPanel.jsx
import React from 'react';
import { useNavigate } from 'react-router-dom';
import Card from '../common/Card';
import Badge from '../common/Badge';
import Button from '../common/Button';

const RecentTestsPanel = ({ tests, onViewAll }) => {
  const navigate = useNavigate();

  if (!tests || tests.length === 0) {
    return (
      <Card title="Recent Tests">
        <div className="text-center py-8 text-gray-500">
          No recent test executions found
        </div>
      </Card>
    );
  }

  // Format date for display
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleString(undefined, {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  // Format duration for display
  const formatDuration = (ms) => {
    if (ms < 1000) return `${ms}ms`;
    
    const seconds = Math.floor(ms / 1000) % 60;
    const minutes = Math.floor(ms / 60000) % 60;
    const hours = Math.floor(ms / 3600000);
    
    if (hours > 0) {
      return `${hours}h ${minutes}m ${seconds}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds}s`;
    } else {
      return `${seconds}s`;
    }
  };

  // Get status badge
  const getStatusBadge = (status) => {
    switch (status) {
      case 'PASSED':
        return <Badge variant="success">Passed</Badge>;
      case 'FAILED':
        return <Badge variant="danger">Failed</Badge>;
      case 'SKIPPED':
        return <Badge variant="default">Skipped</Badge>;
      case 'RUNNING':
        return <Badge variant="primary">Running</Badge>;
      default:
        return <Badge variant="default">{status}</Badge>;
    }
  };

  // View test details
  const viewTestDetails = (testId) => {
    navigate(`/reports/${testId}`);
  };

  // Render browser icon
  const renderBrowserIcon = (browser) => {
    const browserLower = browser.toLowerCase();
    
    if (browserLower.includes('chrome')) {
      return (
        <svg className="h-4 w-4" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 0C8.21 0 4.831 1.757 2.632 4.501l3.953 6.848A5.454 5.454 0 0 1 12 6.545h10.691A12 12 0 0 0 12 0zM1.931 5.47A11.943 11.943 0 0 0 0 12c0 6.012 4.42 10.991 10.189 11.864l3.953-6.847a5.45 5.45 0 0 1-6.865-2.29zm13.342 2.166a5.446 5.446 0 0 1 1.45 7.09l.002.003h-.002l-5.344 9.257c.206.01.413.014.621.014 6.627 0 12-5.373 12-12 0-1.54-.29-3.011-.818-4.364zM12 16.364a4.364 4.364 0 1 1 0-8.728 4.364 4.364 0 0 1 0 8.728z" />
        </svg>
      );
    } else if (browserLower.includes('firefox')) {
      return (
        <svg className="h-4 w-4" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm.5 23c-4.55 0-8.816-2.28-11.353-6.063C3.323 19.792 7.286 21.5 11.5 21.5c6.454 0 8.5-3 8.5-3s-2.246 4.5-7.5 4.5zm9.5-5.458c0-.232-.168-.42-.375-.42-.232 0-.42.168-.42.376 0 .23.169.418.376.418.232 0 .419-.17.419-.377v.0024zm-17.125-.125C6.125 20 4.874 17.125 4.874 17.125S3 14.875 3 10.625 6.25 2.875 12 2.875s9 2.625 9 7.75S17.874 17.75 17.874 19s-6.726-2.125-13-1.583z" />
        </svg>
      );
    } else if (browserLower.includes('edge')) {
      return (
        <svg className="h-4 w-4" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 0C5.372 0 0 5.373 0 12c0 6.628 5.372 12 12 12 6.627 0 12-5.372 12-12 0-6.627-5.373-12-12-12zm-.5 4.5c5.523 0 10 3.582 10 8s-4.477 8-10 8c-5.522 0-10-3.582-10-8s4.478-8 10-8z" />
        </svg>
      );
    } else {
      return (
        <svg className="h-4 w-4" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm0 22C6.486 22 2 17.514 2 12S6.486 2 12 2s10 4.486 10 10-4.486 10-10 10z" />
        </svg>
      );
    }
  };

  return (
    <Card 
      title="Recent Tests" 
      footer={
        <div className="text-right">
          <Button variant="link" onClick={onViewAll}>
            View All Reports
          </Button>
        </div>
      }
    >
      <div className="overflow-hidden">
        <table className="min-w-full divide-y divide-gray-200">
          <thead className="bg-gray-50">
            <tr>
              <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Test
              </th>
              <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Status
              </th>
              <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Duration
              </th>
              <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                Date
              </th>
            </tr>
          </thead>
          <tbody className="bg-white divide-y divide-gray-200">
            {tests.slice(0, 5).map((test) => (
              <tr 
                key={test.id} 
                className="hover:bg-gray-50 cursor-pointer"
                onClick={() => viewTestDetails(test.id)}
              >
                <td className="px-3 py-3 whitespace-nowrap">
                  <div className="flex items-center">
                    <div className="flex-shrink-0 h-8 w-8 flex items-center justify-center text-gray-500">
                      {test.browser && renderBrowserIcon(test.browser)}
                    </div>
                    <div className="ml-2">
                      <div className="text-sm font-medium text-gray-900">{test.name}</div>
                      <div className="text-xs text-gray-500 truncate max-w-xs">{test.className}</div>
                    </div>
                  </div>
                </td>
                <td className="px-3 py-3 whitespace-nowrap">
                  {getStatusBadge(test.status)}
                </td>
                <td className="px-3 py-3 whitespace-nowrap">
                  <div className="text-sm text-gray-500">{formatDuration(test.duration)}</div>
                </td>
                <td className="px-3 py-3 whitespace-nowrap text-sm text-gray-500">
                  {formatDate(test.endTime)}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </Card>
  );
};

export default RecentTestsPanel;

// src/main/webapp/src/components/dashboard/InsightsPanel.jsx
import React from 'react';
import Card from '../common/Card';

const InsightsPanel = ({ insights }) => {
  if (!insights || insights.length === 0) {
    return (
      <Card title="AI Insights">
        <div className="text-center py-8 text-gray-500">
          No insights available
        </div>
      </Card>
    );
  }

  // Get icon for insight type
  const getInsightIcon = (type) => {
    switch (type) {
      case 'RELIABILITY':
        return (
          <div className="p-2 rounded-full bg-red-100 text-red-600">
            <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
          </div>
        );
      case 'STABILITY':
        return (
          <div className="p-2 rounded-full bg-yellow-100 text-yellow-600">
            <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
          </div>
        );
      case 'PERFORMANCE':
        return (
          <div className="p-2 rounded-full bg-blue-100 text-blue-600">
            <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
            </svg>
          </div>
        );
      case 'COVERAGE':
        return (
          <div className="p-2 rounded-full bg-green-100 text-green-600">
            <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
            </svg>
          </div>
        );
      default:
        return (
          <div className="p-2 rounded-full bg-indigo-100 text-indigo-600">
            <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
            </svg>
          </div>
        );
    }
  };

  // Format confidence score to percentage
  const formatConfidence = (confidence) => {
    return `${(confidence * 100).toFixed(0)}%`;
  };

  return (
    <Card title="AI Insights">
      <div className="space-y-4">
        {insights.map((insight, index) => (
          <div key={index} className="flex space-x-3 p-3 rounded-lg bg-gray-50">
            {getInsightIcon(insight.type)}
            <div className="flex-1">
              <h3 className="font-medium text-gray-900">{insight.title}</h3>
              <p className="text-sm text-gray-600 mt-1">{insight.description}</p>
              <div className="flex items-center mt-2">
                <span className="text-xs text-gray-500">Confidence: {formatConfidence(insight.confidence)}</span>
                <span className="ml-2 text-xs px-2 py-0.5 rounded-full bg-gray-200 text-gray-700">
                  {insight.type}
                </span>
              </div>
            </div>
          </div>
        ))}
      </div>
    </Card>
  );
};

export default InsightsPanel;

// src/main/webapp/src/components/common/Badge.jsx
import React from 'react';

/**
 * Badge component for showing status
 * @param {Object} props - Component props
 * @returns {JSX.Element} Badge component
 */
const Badge = ({ 
  children, 
  variant = 'default', 
  className = '', 
  ...rest 
}) => {
  // Variant classes
  const variantClasses = {
    default: 'bg-gray-100 text-gray-800',
    primary: 'bg-indigo-100 text-indigo-800',
    success: 'bg-green-100 text-green-800',
    warning: 'bg-yellow-100 text-yellow-800',
    danger: 'bg-red-100 text-red-800',
  };
  
  const badgeClasses = `inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${variantClasses[variant]} ${className}`;
  
  return (
    <span className={badgeClasses} {...rest}>
      {children}
    </span>
  );
};

export default Badge;

// src/main/webapp/src/components/reports/Reports.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import Card from '../common/Card';
import Button from '../common/Button';
import Badge from '../common/Badge';
import TextField from '../common/TextField';
import SelectField from '../common/SelectField';
import Spinner from '../common/Spinner';
import Alert from '../common/Alert';
import { useNotification } from '../../context/NotificationContext';

const Reports = () => {
  const navigate = useNavigate();
  const { addNotification } = useNotification();
  const [reports, setReports] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [filters, setFilters] = useState({
    status: '',
    dateRange: 'last7days',
    search: ''
  });

  useEffect(() => {
    fetchReports();
  }, [filters]);

  const fetchReports = async () => {
    setLoading(true);
    setError(null);

    try {
      // Build query string from filters
      const queryParams = new URLSearchParams();
      if (filters.status) queryParams.append('status', filters.status);
      if (filters.dateRange) queryParams.append('dateRange', filters.dateRange);
      if (filters.search) queryParams.append('search', filters.search);

      // Fetch reports data
      const response = await fetch(`/api/reports?${queryParams.toString()}`);
      if (!response.ok) {
        throw new Error(`Failed to fetch reports: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      setReports(data);
    } catch (err) {
      console.error('Error fetching reports:', err);
      setError(err.message || 'Failed to load reports');
      addNotification(`Error loading reports: ${err.message}`, 'error');
      
      // Set fallback data for development
      setFallbackReports();
    } finally {
      setLoading(false);
    }
  };

  const setFallbackReports = () => {
    const statuses = ['PASSED', 'FAILED', 'SKIPPED'];
    const testNames = [
      'Login Test', 'Search Test', 'Checkout Test', 'Registration Test', 
      'Profile Update Test', 'Payment Processing Test', 'Product Listing Test',
      'Admin Dashboard Test', 'User Profile Test', 'Order History Test'
    ];
    const browsers = ['chrome', 'firefox', 'edge'];
    const fallbackReports = [];
    
    for (let i = 0; i < 20; i++) {
      const startTime = new Date();
      startTime.setDate(startTime.getDate() - Math.floor(Math.random() * 7));
      startTime.setHours(startTime.getHours() - Math.floor(Math.random() * 12));
      const duration = 5000 + Math.random() * 60000;
      const endTime = new Date(startTime.getTime() + duration);
      
      fallbackReports.push({
        id: `test-${i}`,
        name: testNames[i % testNames.length],
        description: `Test for ${testNames[i % testNames.length].toLowerCase()} functionality`,
        status: statuses[Math.floor(Math.random() * 3)],
        startTime: startTime.toISOString(),
        endTime: endTime.toISOString(),
        duration: duration,
        className: `com.cssmart.tests.web.${testNames[i % testNames.length].replace(/\s+/g, '')}`,
        methodName: `test${testNames[i % testNames.length].replace(/\s+/g, '')}`,
        browser: browsers[i % browsers.length],
        environment: ['qa', 'staging', 'dev'][i % 3]
      });
    }
    
    setReports(fallbackReports);
  };

  // Format date for display
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  // Format duration for display
  const formatDuration = (ms) => {
    if (ms < 1000) return `${ms}ms`;
    
    const seconds = Math.floor(ms / 1000) % 60;
    const minutes = Math.floor(ms / 60000) % 60;
    const hours = Math.floor(ms / 3600000);
    
    if (hours > 0) {
      return `${hours}h ${minutes}m ${seconds}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds}s`;
    } else {
      return `${seconds}s`;
    }
  };

  // Get status badge
  const getStatusBadge = (status) => {
    switch (status) {
      case 'PASSED':
        return <Badge variant="success">Passed</Badge>;
      case 'FAILED':
        return <Badge variant="danger">Failed</Badge>;
      case 'SKIPPED':
        return <Badge variant="default">Skipped</Badge>;
      case 'RUNNING':
        return <Badge variant="primary">Running</Badge>;
      default:
        return <Badge variant="default">{status}</Badge>;
    }
  };

  // View test details
  const viewTestDetails = (testId) => {
    navigate(`/reports/${testId}`);
  };

  // Export reports
  const exportReports = async (format) => {
    try {
      window.open(`/api/reports/export?format=${format}`, '_blank');
      addNotification(`Exporting reports as ${format.toUpperCase()}`, 'info');
    } catch (err) {
      console.error('Error exporting reports:', err);
      addNotification(`Error exporting reports: ${err.message}`, 'error');
    }
  };

  // Handle filter changes
  const handleFilterChange = (field, value) => {
    setFilters(prev => ({
      ...prev,
      [field]: value
    }));
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold">Test Reports</h1>
        <div className="flex space-x-2">
          <div className="relative">
            <Button
              variant="secondary"
              onClick={() => {
                const exportMenu = document.getElementById('export-menu');
                exportMenu.classList.toggle('hidden');
              }}
            >
              Export
            </Button>
            <div id="export-menu" className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg hidden z-10">
              <div className="py-1">
                <button
                  className="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                  onClick={() => exportReports('pdf')}
                >
                  Export as PDF
                </button>
                <button
                  className="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                  onClick={() => exportReports('excel')}
                >
                  Export as Excel
                </button>
                <button
                  className="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                  onClick={() => exportReports('html')}
                >
                  Export as HTML
                </button>
              </div>
            </div>
          </div>
          <Button
            variant="primary"
            onClick={() => navigate('/recorder')}
          >
            New Test
          </Button>
        </div>
      </div>

      {/* Filters */}
      <Card>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <SelectField
            label="Date Range"
            value={filters.dateRange}
            onChange={(e) => handleFilterChange('dateRange', e.target.value)}
            options={[
              { value: 'today', label: 'Today' },
              { value: 'yesterday', label: 'Yesterday' },
              { value: 'last7days', label: 'Last 7 Days' },
              { value: 'last30days', label: 'Last 30 Days' },
              { value: 'thisMonth', label: 'This Month' },
              { value: 'lastMonth', label: 'Last Month' }
            ]}
          />
          <SelectField
            label="Status"
            value={filters.status}
            onChange={(e) => handleFilterChange('status', e.target.value)}
            options={[
              { value: '', label: 'All Statuses' },
              { value: 'PASSED', label: 'Passed' },
              { value: 'FAILED', label: 'Failed' },
              { value: 'SKIPPED', label: 'Skipped' }
            ]}
          />
          <TextField
            label="Search"
            value={filters.search}
            onChange={(e) => handleFilterChange('search', e.target.value)}
            placeholder="Search by name or class..."
          />
        </div>
      </Card>

      {/* Error Message */}
      {error && (
        <Alert type="error" title="Error Loading Reports" onClose={() => setError(null)}>
          {error}
        </Alert>
      )}

      {/* Reports Table */}
      <Card>
        {loading ? (
          <div className="flex justify-center items-center py-8">
            <Spinner size="lg" />
            <span className="ml-3">Loading reports...</span>
          </div>
        ) : reports.length === 0 ? (
          <div className="text-center py-8 text-gray-500">
            No reports found matching your criteria
          </div>
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Test
                  </th>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Status
                  </th>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Duration
                  </th>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Environment
                  </th>
                  <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                    Date
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {reports.map((report) => (
                  <tr 
                    key={report.id} 
                    className="hover:bg-gray-50 cursor-pointer"
                    onClick={() => viewTestDetails(report.id)}
                  >
                    <td className="px-6 py-4 whitespace-nowrap">
                      <div className="flex items-center">
                        <div className="ml-4">
                          <div className="text-sm font-medium text-gray-900">{report.name}</div>
                          <div className="text-xs text-gray-500 truncate max-w-xs">{report.className}</div>
                        </div>
                      </div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      {getStatusBadge(report.status)}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <div className="text-sm text-gray-500">{formatDuration(report.duration)}</div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <div className="text-sm text-gray-500">{report.environment}</div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                      {formatDate(report.endTime)}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </Card>
    </div>
  );
};

export default Reports;

package com.cssmart.core.config;

import lombok.extern.slf4j.Slf4j;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Handles environment variable substitution in configuration
 */
@Slf4j
public class EnvironmentManager {
    
    // Pattern for environment variables: ${ENV_VAR}
    private static final Pattern ENV_VAR_PATTERN = Pattern.compile("\\$\\{([^}]+)\\}");
    
    /**
     * Process environment variables in the configuration
     * @param config Configuration to process
     * @return Processed configuration
     */
    @SuppressWarnings("unchecked")
    public <T> T processEnvironmentVariables(T config) {
        if (config == null) {
            return null;
        }
        
        // Process map
        if (config instanceof Map) {
            Map<Object, Object> result = new HashMap<>();
            Map<Object, Object> map = (Map<Object, Object>) config;
            
            for (Map.Entry<Object, Object> entry : map.entrySet()) {
                Object key = entry.getKey();
                Object value = entry.getValue();
                
                // Process value recursively
                Object processedValue = processEnvironmentVariables(value);
                result.put(key, processedValue);
            }
            
            return (T) result;
        }
        // Process string for environment variables
        else if (config instanceof String) {
            String value = (String) config;
            return (T) replaceEnvVariables(value);
        }
        // Process lists
        else if (config instanceof Iterable) {
            // Create a new list with processed values
            Iterable<Object> list = (Iterable<Object>) config;
            java.util.List<Object> result = new java.util.ArrayList<>();
            
            for (Object item : list) {
                result.add(processEnvironmentVariables(item));
            }
            
            return (T) result;
        }
        // Return other types as is
        else {
            return config;
        }
    }
    
    /**
     * Replace environment variables in a string
     * @param value String to process
     * @return Processed string
     */
    private String replaceEnvVariables(String value) {
        if (value == null || value.isEmpty()) {
            return value;
        }
        
        Matcher matcher = ENV_VAR_PATTERN.matcher(value);
        StringBuffer sb = new StringBuffer();
        
        while (matcher.find()) {
            String envVarName = matcher.group(1);
            String envVarValue = System.getenv(envVarName);
            
            // If environment variable exists, use it, otherwise keep original
            if (envVarValue != null) {
                // Replace $ and \ in the replacement string with \$ and \\
                envVarValue = envVarValue.replace("\\", "\\\\").replace("$", "\\$");
                matcher.appendReplacement(sb, envVarValue);
                log.debug("Replaced environment variable {}={}", envVarName, envVarValue);
            } else {
                // If no environment variable found, keep original placeholder
                log.debug("Environment variable not found: {}", envVarName);
                matcher.appendReplacement(sb, matcher.group(0));
            }
        }
        
        matcher.appendTail(sb);
        return sb.toString();
    }
}

package com.cssmart.core.config.exceptions;

/**
 * Exception for configuration related errors
 */
public class ConfigurationException extends RuntimeException {
    
    /**
     * Creates a new configuration exception with a message
     * @param message Error message
     */
    public ConfigurationException(String message) {
        super(message);
    }
    
    /**
     * Creates a new configuration exception with a message and cause
     * @param message Error message
     * @param cause Cause of the exception
     */
    public ConfigurationException(String message, Throwable cause) {
        super(message, cause);
    }
}

package com.cssmart.ui.dashboard.model;

import com.cssmart.reporting.model.ExecutionMetrics;
import com.cssmart.reporting.model.Insight;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * Dashboard metrics model
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DashboardMetrics {
    
    private ExecutionMetrics metrics;
    private List<Insight> insights;
}


package com.cssmart.ui.service;

import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.controller.GeneratedTest;
import com.cssmart.ai.engine.AIEngine;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

/**
 * Service for managing recorded tests, including storing and converting between
 * recorded TestCase objects and GeneratedTest objects for the Test Generator
 */
@Slf4j
@Service
public class TestRecordingService {
    
    private final AIEngine aiEngine;
    private final Map<String, TestCase> recordedTests;
    private static final String RECORDED_TESTS_DIR = "recorded-tests";
    
    @Autowired
    public TestRecordingService(AIEngine aiEngine) {
        this.aiEngine = aiEngine;
        this.recordedTests = new ConcurrentHashMap<>();
        
        // Ensure recorded tests directory exists
        File dir = new File(RECORDED_TESTS_DIR);
        if (!dir.exists()) {
            dir.mkdirs();
        }
    }
    
    /**
     * Save a recorded test case
     * @param testCase The test case to save
     * @return The saved test case with ID
     */
    public TestCase saveRecordedTest(TestCase testCase) {
        try {
            log.info("Saving recorded test: {}", testCase.getName());
            
            // Ensure test case has an ID
            if (testCase.getId() == null || testCase.getId().isEmpty()) {
                testCase.setId(UUID.randomUUID().toString());
            }
            
            // Store in memory
            recordedTests.put(testCase.getId(), testCase);
            
            // Save to file system
            saveTestToFile(testCase);
            
            return testCase;
        } catch (Exception e) {
            log.error("Error saving recorded test", e);
            throw new RuntimeException("Failed to save recorded test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Get a recorded test by ID
     * @param id Test ID
     * @return Test case or null if not found
     */
    public TestCase getRecordedTest(String id) {
        return recordedTests.get(id);
    }
    
    /**
     * Convert a recorded TestCase to a GeneratedTest for the Test Generator
     * @param testCase The test case to convert
     * @return A GeneratedTest object
     */
    public GeneratedTest convertToGeneratedTest(TestCase testCase) {
        try {
            log.info("Converting recorded test to generated test: {}", testCase.getName());
            
            GeneratedTest generatedTest = new GeneratedTest();
            generatedTest.setId(testCase.getId());
            generatedTest.setName(testCase.getName());
            generatedTest.setDescription(testCase.getDescription());
            generatedTest.setClassName(testCase.getClassName());
            generatedTest.setMethodName(testCase.getMethodName());
            generatedTest.setCode(testCase.getCode());
            
            // Convert steps
            if (testCase.getSteps() != null) {
                generatedTest.setSteps(testCase.getSteps());
            }
            
            return generatedTest;
        } catch (Exception e) {
            log.error("Error converting recorded test to generated test", e);
            throw new RuntimeException("Failed to convert test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Convert a GeneratedTest to a TestCase
     * @param generatedTest The generated test to convert
     * @return A TestCase object
     */
    public TestCase convertToTestCase(GeneratedTest generatedTest) {
        try {
            log.info("Converting generated test to test case: {}", generatedTest.getName());
            
            TestCase testCase = new TestCase();
            testCase.setId(generatedTest.getId());
            testCase.setName(generatedTest.getName());
            testCase.setDescription(generatedTest.getDescription());
            testCase.setClassName(generatedTest.getClassName());
            testCase.setMethodName(generatedTest.getMethodName());
            testCase.setCode(generatedTest.getCode());
            
            // Convert steps
            if (generatedTest.getSteps() != null) {
                testCase.setSteps(generatedTest.getSteps());
            }
            
            return testCase;
        } catch (Exception e) {
            log.error("Error converting generated test to test case", e);
            throw new RuntimeException("Failed to convert test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Enhance a test case with AI
     * @param testCase The test case to enhance
     * @return The enhanced test case
     */
    public TestCase enhanceTestCase(TestCase testCase) {
        try {
            log.info("Enhancing test case with AI: {}", testCase.getName());
            
            // Use AI engine to enhance the test case
            // This is a placeholder for the actual AI enhancement
            if (aiEngine != null) {
                // In a real implementation, this would use AI to improve the test
                // For now, we'll just make some simple enhancements
                
                // Improve the test name if it's generic
                if (testCase.getName() == null || testCase.getName().contains("Recorded Test")) {
                    if (testCase.getSteps() != null && !testCase.getSteps().isEmpty()) {
                        // Generate a more descriptive name based on the steps
                        String firstAction = testCase.getSteps().get(0).getAction();
                        String firstElement = testCase.getSteps().get(0).getElement();
                        
                        if (firstAction != null && firstElement != null) {
                            testCase.setName("Test " + firstAction + " on " + firstElement);
                        }
                    }
                }
                
                // Improve the description
                if (testCase.getDescription() == null || testCase.getDescription().isEmpty() || 
                        testCase.getDescription().equals("Automatically recorded test case")) {
                    testCase.setDescription("Automated test to verify functionality of the application");
                }
                
                // You would call the AI engine here in a real implementation
                // testCase = aiEngine.enhanceTestCase(testCase);
            }
            
            return testCase;
        } catch (Exception e) {
            log.error("Error enhancing test case", e);
            
            // Return the original test case if enhancement fails
            return testCase;
        }
    }
    
    /**
     * Save a test case to file
     * @param testCase The test case to save
     */
    private void saveTestToFile(TestCase testCase) {
        try {
            // Save test case to file
            File testFile = new File(RECORDED_TESTS_DIR, testCase.getId() + ".json");
            
            // Use Jackson to serialize to JSON
            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
            objectMapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule());
            objectMapper.disable(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
            
            objectMapper.writeValue(testFile, testCase);
            
            log.info("Saved test case to file: {}", testFile.getAbsolutePath());
            
            // If code is present, also save it as a Java file
            if (testCase.getCode() != null && !testCase.getCode().isEmpty()) {
                String packageDir = "src/main/java/com/cssmart/tests/generated".replace('.', '/');
                File packagePath = new File(packageDir);
                if (!packagePath.exists()) {
                    packagePath.mkdirs();
                }
                
                File javaFile = new File(packageDir, testCase.getClassName() + ".java");
                Files.writeString(javaFile.toPath(), testCase.getCode());
                
                log.info("Saved test code to: {}", javaFile.getAbsolutePath());
            }
        } catch (Exception e) {
            log.error("Error saving test case to file", e);
            throw new RuntimeException("Failed to save test to file: " + e.getMessage(), e);
        }
    }
}

package com.cssmart.ui.controller;

import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.service.TestRecordingService;
import com.cssmart.ui.service.TestGeneratorService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.List;

/**
 * REST controller for test recorder operations
 */
@Slf4j
@RestController
@RequestMapping("/api/recorder")
public class RecorderController {
    
    private final TestRecordingService testRecordingService;
    private final TestGeneratorService testGeneratorService;
    
    @Autowired
    public RecorderController(TestRecordingService testRecordingService, TestGeneratorService testGeneratorService) {
        this.testRecordingService = testRecordingService;
        this.testGeneratorService = testGeneratorService;
    }
    
    /**
     * Save a recorded test case
     * @param testCase Recorded test case
     * @return Saved test case
     */
    @PostMapping("/save")
    public ResponseEntity<TestCase> saveTestCase(@RequestBody TestCase testCase) {
        log.info("Saving recorded test case: {}", testCase.getName());
        
        try {
            // Enhance and save the test case
            TestCase enhancedTestCase = testRecordingService.enhanceTestCase(testCase);
            TestCase savedTestCase = testRecordingService.saveRecordedTest(enhancedTestCase);
            
            return ResponseEntity.ok(savedTestCase);
        } catch (Exception e) {
            log.error("Error saving test case", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Convert a recorded test case to a generated test for editing
     * @param id Test case ID
     * @return Generated test
     */
    @GetMapping("/{id}/convert")
    public ResponseEntity<GeneratedTest> convertToGeneratedTest(@PathVariable("id") String id) {
        log.info("Converting recorded test case to generated test: {}", id);
        
        try {
            // Get the recorded test case
            TestCase testCase = testRecordingService.getRecordedTest(id);
            
            if (testCase == null) {
                log.warn("Test case not found with ID: {}", id);
                return ResponseEntity.notFound().build();
            }
            
            // Convert to generated test format
            GeneratedTest generatedTest = testRecordingService.convertToGeneratedTest(testCase);
            
            return ResponseEntity.ok(generatedTest);
        } catch (Exception e) {
            log.error("Error converting test case", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Get browser configuration options
     * @return Browser configuration
     */
    @GetMapping("/browser-config")
    public ResponseEntity<BrowserConfig> getBrowserConfig() {
        log.info("Fetching browser configuration options");
        
        try {
            BrowserConfig config = new BrowserConfig();
            config.addBrowserOption("chrome", "Chrome");
            config.addBrowserOption("firefox", "Firefox");
            config.addBrowserOption("edge", "Edge");
            config.addBrowserOption("safari", "Safari");
            
            return ResponseEntity.ok(config);
        } catch (Exception e) {
            log.error("Error fetching browser configuration", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Run a test after recording
     * @param id Test ID
     * @return Execution status
     */
    @PostMapping("/{id}/run")
    public ResponseEntity<Map<String, Object>> runTest(@PathVariable("id") String id) {
        log.info("Running recorded test: {}", id);
        
        try {
            // In a real implementation, this would invoke the test execution service
            // For now, return a simple status message
            Map<String, Object> result = new HashMap<>();
            result.put("status", "success");
            result.put("message", "Test execution started");
            result.put("executionId", UUID.randomUUID().toString());
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("Error running test", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Get all recorded tests
     * @return List of recorded tests
     */
    @GetMapping
    public ResponseEntity<List<TestCase>> getAllRecordedTests() {
        log.info("Fetching all recorded tests");
        
        try {
            // In a real implementation, this would retrieve tests from a repository
            // For now, return an empty list
            List<TestCase> tests = new ArrayList<>();
            
            return ResponseEntity.ok(tests);
        } catch (Exception e) {
            log.error("Error fetching recorded tests", e);
            return ResponseEntity.status(500).body(null);
        }
    }
}

/**
 * Browser configuration options
 */
class BrowserConfig {
    private List<BrowserOption> browsers = new ArrayList<>();
    
    public void addBrowserOption(String value, String label) {
        browsers.add(new BrowserOption(value, label));
    }
    
    public List<BrowserOption> getBrowsers() {
        return browsers;
    }
    
    public void setBrowsers(List<BrowserOption> browsers) {
        this.browsers = browsers;
    }
    
    static class BrowserOption {
        private String value;
        private String label;
        
        public BrowserOption(String value, String label) {
            this.value = value;
            this.label = label;
        }
        
        public String getValue() {
            return value;
        }
        
        public void setValue(String value) {
            this.value = value;
        }
        
        public String getLabel() {
            return label;
        }
        
        public void setLabel(String label) {
            this.label = label;
        }
    }
}

package com.cssmart.ai.codegen.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.time.LocalDateTime;

/**
 * Represents a single test step 
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TestStep {
    private String action;
    private String element;
    private String value;
    private String description;
    private LocalDateTime timestamp;
}

package com.cssmart.ui.service;

import com.cssmart.ai.codegen.TestGenerator;
import com.cssmart.ai.codegen.model.TestStep;
import com.cssmart.ai.codegen.model.TestCase;
import com.cssmart.ai.engine.AIEngine;
import com.cssmart.ui.controller.GeneratedTest;
import com.cssmart.ui.controller.TestTemplate;
import com.cssmart.ui.controller.TemplateParameter;
import com.cssmart.ui.recorder.model.RecordedStep;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.ArrayList;
import java.util.stream.Collectors;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

/**
 * Service for AI-powered test generation
 */
@Slf4j
@Service
public class TestGeneratorService {
    
    private final AIEngine aiEngine;
    private final Map<String, GeneratedTest> generatedTests = new java.util.concurrent.ConcurrentHashMap<>();
    private static final String GENERATED_TESTS_DIR = "generated-tests";
    private static final String TEST_CODE_DIR = "src/main/java/com/cssmart/tests/generated";
    
    @Autowired
    public TestGeneratorService(AIEngine aiEngine) {
        this.aiEngine = aiEngine;
        
        // Ensure directories exist
        File generatedDir = new File(GENERATED_TESTS_DIR);
        if (!generatedDir.exists()) {
            generatedDir.mkdirs();
        }
        
        File codeDir = new File(TEST_CODE_DIR);
        if (!codeDir.exists()) {
            codeDir.mkdirs();
        }
    }
    
    /**
     * Generate a test from description
     * @param description Natural language description of the test
     * @return Generated test
     */
    public GeneratedTest generateTest(String description) {
        log.info("Generating test from description: {}", description);
        
        try {
            // Create a new test with basic information
            GeneratedTest generatedTest = new GeneratedTest();
            generatedTest.setId(UUID.randomUUID().toString());
            generatedTest.setName(generateTestName(description));
            generatedTest.setDescription(description);
            
            // Generate class and method names
            String className = generateClassName(generatedTest.getName());
            String methodName = generateMethodName(generatedTest.getName());
            generatedTest.setClassName(className);
            generatedTest.setMethodName(methodName);
            
            // Generate steps based on description
            List<RecordedStep> recordedSteps = generateStepsAsRecorded(description);
            
            // Convert RecordedStep to TestStep
            List<TestStep> steps = convertToTestSteps(recordedSteps);
            generatedTest.setSteps(steps);
            
            // Generate code
            String code = generateCode(generatedTest);
            generatedTest.setCode(code);
            
            // Store for later reference
            generatedTests.put(generatedTest.getId(), generatedTest);
            
            // Save to file
            saveTestToFile(generatedTest);
            
            return generatedTest;
        } catch (Exception e) {
            log.error("Error generating test", e);
            throw new RuntimeException("Failed to generate test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Convert RecordedStep list to TestStep list
     * @param recordedSteps List of RecordedStep objects
     * @return List of TestStep objects
     */
    private List<TestStep> convertToTestSteps(List<RecordedStep> recordedSteps) {
        if (recordedSteps == null) {
            return new ArrayList<>();
        }
        
        return recordedSteps.stream()
            .map(this::convertToTestStep)
            .collect(Collectors.toList());
    }
    
    /**
     * Convert a single RecordedStep to TestStep
     * @param recordedStep RecordedStep object
     * @return TestStep object
     */
    private TestStep convertToTestStep(RecordedStep recordedStep) {
        return TestStep.builder()
            .action(recordedStep.getAction())
            .element(recordedStep.getElement())
            .value(recordedStep.getValue())
            .description(recordedStep.getDescription())
            .timestamp(recordedStep.getTimestamp())
            .build();
    }
    
    /**
     * Save a generated test
     * @param test Test to save
     * @return Saved test with ID
     */
    public GeneratedTest saveTest(GeneratedTest test) {
        log.info("Saving generated test: {}", test.getName());
        
        try {
            // Ensure the test has an ID
            if (test.getId() == null || test.getId().isEmpty()) {
                test.setId(UUID.randomUUID().toString());
            }
            
            // Regenerate code if needed
            if (test.getCode() == null || test.getCode().isEmpty()) {
                test.setCode(generateCode(test));
            }
            
            // Store in memory
            generatedTests.put(test.getId(), test);
            
            // Save to file
            saveTestToFile(test);
            
            // Save Java file
            saveJavaFile(test);
            
            return test;
        } catch (Exception e) {
            log.error("Error saving test", e);
            throw new RuntimeException("Failed to save test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Get a list of test templates
     * @return List of available test templates
     */
    public List<TestTemplate> getTemplates() {
        log.info("Fetching test templates");
        
        try {
            // Create sample templates
            List<TestTemplate> templates = new ArrayList<>();
            
            // Login test template
            TestTemplate loginTemplate = new TestTemplate();
            loginTemplate.setId("login-template");
            loginTemplate.setName("Login Test");
            loginTemplate.setDescription("Template for testing user login functionality");
            
            List<TemplateParameter> loginParams = new ArrayList<>();
            TemplateParameter usernameParam = new TemplateParameter();
            usernameParam.setName("username");
            usernameParam.setDescription("Username to use for login");
            usernameParam.setType("string");
            usernameParam.setRequired(true);
            loginParams.add(usernameParam);
            
            TemplateParameter passwordParam = new TemplateParameter();
            passwordParam.setName("password");
            passwordParam.setDescription("Password to use for login");
            passwordParam.setType("string");
            passwordParam.setRequired(true);
            loginParams.add(passwordParam);
            
            loginTemplate.setParameters(loginParams);
            templates.add(loginTemplate);
            
            // Search test template
            TestTemplate searchTemplate = new TestTemplate();
            searchTemplate.setId("search-template");
            searchTemplate.setName("Search Test");
            searchTemplate.setDescription("Template for testing search functionality");
            
            List<TemplateParameter> searchParams = new ArrayList<>();
            TemplateParameter searchTermParam = new TemplateParameter();
            searchTermParam.setName("searchTerm");
            searchTermParam.setDescription("Term to search for");
            searchTermParam.setType("string");
            searchTermParam.setRequired(true);
            searchParams.add(searchTermParam);
            
            searchTemplate.setParameters(searchParams);
            templates.add(searchTemplate);
            
            return templates;
        } catch (Exception e) {
            log.error("Error fetching templates", e);
            throw new RuntimeException("Failed to fetch templates: " + e.getMessage(), e);
        }
    }
    
    /**
     * Generate a test from a template
     * @param templateId Template ID
     * @param parameters Template parameters
     * @return Generated test
     */
    public GeneratedTest generateFromTemplate(String templateId, Map<String, Object> parameters) {
        log.info("Generating test from template: {}", templateId);
        
        try {
            // Build a description based on template and parameters
            StringBuilder description = new StringBuilder();
            
            if ("login-template".equals(templateId)) {
                String username = (String) parameters.get("username");
                String password = (String) parameters.get("password");
                
                description.append("Test user login functionality with username ")
                    .append(username)
                    .append(" and password ")
                    .append(password);
            } else if ("search-template".equals(templateId)) {
                String searchTerm = (String) parameters.get("searchTerm");
                
                description.append("Test search functionality for term ")
                    .append(searchTerm);
            } else {
                throw new IllegalArgumentException("Unknown template ID: " + templateId);
            }
            
            // Generate test using the constructed description
            return generateTest(description.toString());
        } catch (Exception e) {
            log.error("Error generating test from template", e);
            throw new RuntimeException("Failed to generate test from template: " + e.getMessage(), e);
        }
    }
    
    /**
     * Get a generated test by ID
     * @param id Test ID
     * @return Generated test or null if not found
     */
    public GeneratedTest getTest(String id) {
        return generatedTests.get(id);
    }
    
    /**
     * Generate a test name from description
     */
    private String generateTestName(String description) {
        // Simple approach: take first few words
        String[] words = description.split("\\s+");
        StringBuilder name = new StringBuilder();
        
        for (int i = 0; i < Math.min(4, words.length); i++) {
            if (words[i].length() > 0) {
                name.append(Character.toUpperCase(words[i].charAt(0)))
                    .append(words[i].substring(1).toLowerCase())
                    .append(" ");
            }
        }
        
        if (name.length() == 0) {
            return "Generated Test";
        }
        
        return name.toString().trim() + " Test";
    }
    
    /**
     * Generate a class name from test name
     */
    private String generateClassName(String testName) {
        // Remove "Test" suffix if present, then add it back later
        if (testName.endsWith(" Test")) {
            testName = testName.substring(0, testName.length() - 5);
        }
        
        // Replace spaces with nothing and keep only alphanumeric characters
        String className = testName.replaceAll("[^a-zA-Z0-9]", "");
        
        // Ensure first character is uppercase
        if (className.length() > 0) {
            className = Character.toUpperCase(className.charAt(0)) + className.substring(1);
        } else {
            className = "Generated";
        }
        
        return className + "Test";
    }
    
    /**
     * Generate a method name from test name
     */
    private String generateMethodName(String testName) {
        // Remove "Test" suffix if present
        if (testName.endsWith(" Test")) {
            testName = testName.substring(0, testName.length() - 5);
        }
        
        // Replace spaces with nothing and keep only alphanumeric characters
        String methodName = testName.replaceAll("[^a-zA-Z0-9]", "");
        
        // Ensure first character is lowercase
        if (methodName.length() > 0) {
            methodName = Character.toLowerCase(methodName.charAt(0)) + methodName.substring(1);
        } else {
            methodName = "test";
        }
        
        return "test" + methodName;
    }
    
    /**
     * Generate steps based on description
     * Renamed from generateSteps to clarify it returns RecordedStep objects
     */
    private List<RecordedStep> generateStepsAsRecorded(String description) {
        List<RecordedStep> steps = new ArrayList<>();
        
        // In a real implementation, this would use AI to generate steps
        // For now, we'll create some sample steps
        
        // Detect login scenario
        if (description.toLowerCase().contains("login")) {
            // Navigate to login page
            RecordedStep navigateStep = new RecordedStep();
            navigateStep.setAction("NAVIGATE");
            navigateStep.setValue("https://example.com/login");
            navigateStep.setTimestamp(java.time.LocalDateTime.now());
            navigateStep.setDescription("Navigate to login page");
            steps.add(navigateStep);
            
            // Enter username
            RecordedStep usernameStep = new RecordedStep();
            usernameStep.setAction("TYPE");
            usernameStep.setElement("username field");
            usernameStep.setValue("testuser");
            usernameStep.setTimestamp(java.time.LocalDateTime.now());
            usernameStep.setDescription("Enter username");
            steps.add(usernameStep);
            
            // Enter password
            RecordedStep passwordStep = new RecordedStep();
            passwordStep.setAction("TYPE");
            passwordStep.setElement("password field");
            passwordStep.setValue("password123");
            passwordStep.setTimestamp(java.time.LocalDateTime.now());
            passwordStep.setDescription("Enter password");
            steps.add(passwordStep);
            
            // Click login button
            RecordedStep loginStep = new RecordedStep();
            loginStep.setAction("CLICK");
            loginStep.setElement("login button");
            loginStep.setTimestamp(java.time.LocalDateTime.now());
            loginStep.setDescription("Click login button");
            steps.add(loginStep);
            
            // Verify successful login
            RecordedStep verifyStep = new RecordedStep();
            verifyStep.setAction("VERIFY_PRESENCE");
            verifyStep.setElement("welcome message");
            verifyStep.setTimestamp(java.time.LocalDateTime.now());
            verifyStep.setDescription("Verify successful login");
            steps.add(verifyStep);
        }
        // Detect search scenario
        else if (description.toLowerCase().contains("search")) {
            // Navigate to homepage
            RecordedStep navigateStep = new RecordedStep();
            navigateStep.setAction("NAVIGATE");
            navigateStep.setValue("https://example.com");
            navigateStep.setTimestamp(java.time.LocalDateTime.now());
            navigateStep.setDescription("Navigate to homepage");
            steps.add(navigateStep);
            
            // Enter search term
            RecordedStep searchStep = new RecordedStep();
            searchStep.setAction("TYPE");
            searchStep.setElement("search field");
            searchStep.setValue("test product");
            searchStep.setTimestamp(java.time.LocalDateTime.now());
            searchStep.setDescription("Enter search term");
            steps.add(searchStep);
            
            // Click search button
            RecordedStep submitStep = new RecordedStep();
            submitStep.setAction("CLICK");
            submitStep.setElement("search button");
            submitStep.setTimestamp(java.time.LocalDateTime.now());
            submitStep.setDescription("Click search button");
            steps.add(submitStep);
            
            // Verify search results
            RecordedStep verifyStep = new RecordedStep();
            verifyStep.setAction("VERIFY_PRESENCE");
            verifyStep.setElement("search results");
            verifyStep.setTimestamp(java.time.LocalDateTime.now());
            verifyStep.setDescription("Verify search results");
            steps.add(verifyStep);
        }
        // Default scenario for other descriptions
        else {
            // Navigate to homepage
            RecordedStep navigateStep = new RecordedStep();
            navigateStep.setAction("NAVIGATE");
            navigateStep.setValue("https://example.com");
            navigateStep.setTimestamp(java.time.LocalDateTime.now());
            navigateStep.setDescription("Navigate to homepage");
            steps.add(navigateStep);
            
            // Generic verification step
            RecordedStep verifyStep = new RecordedStep();
            verifyStep.setAction("VERIFY_PRESENCE");
            verifyStep.setElement("page content");
            verifyStep.setTimestamp(java.time.LocalDateTime.now());
            verifyStep.setDescription("Verify page content");
            steps.add(verifyStep);
        }
        
        return steps;
    }
    
    /**
     * Generate code from test information
     */
    private String generateCode(GeneratedTest test) {
        StringBuilder code = new StringBuilder();
        
        // Add imports and class declaration
        code.append("package com.cssmart.tests.generated;\n\n");
        code.append("import com.cssmart.core.base.CSSmartTestBase;\n");
        code.append("import com.cssmart.core.annotations.CSSmartTest;\n");
        code.append("import org.testng.annotations.Test;\n");
        code.append("import org.openqa.selenium.WebElement;\n");
        code.append("import org.testng.Assert;\n");
        code.append("import lombok.extern.slf4j.Slf4j;\n\n");
        
        code.append("/**\n");
        code.append(" * ").append(test.getDescription()).append("\n");
        code.append(" * Generated by CS Smart Test Framework\n");
        code.append(" */\n");
        code.append("@Slf4j\n");
        code.append("public class ").append(test.getClassName()).append(" extends CSSmartTestBase {\n\n");
        
        // Add test method
        code.append("    @Test\n");
        code.append("    @CSSmartTest(description = \"").append(test.getDescription()).append("\")\n");
        code.append("    public void ").append(test.getMethodName()).append("() {\n");
        code.append("        log.info(\"Starting test: ").append(test.getDescription()).append("\");\n\n");
        
        // Add test steps
        if (test.getSteps() != null && !test.getSteps().isEmpty()) {
            for (TestStep step : test.getSteps()) {
                code.append("        // ").append(step.getDescription()).append("\n");
                
                if ("NAVIGATE".equals(step.getAction())) {
                    code.append("        driver.get(\"").append(step.getValue()).append("\");\n");
                } else if ("CLICK".equals(step.getAction())) {
                    code.append("        WebElement element = elementFinder.findElement(\"")
                        .append(step.getElement()).append("\");\n");
                    code.append("        element.click();\n");
                } else if ("TYPE".equals(step.getAction())) {
                    code.append("        WebElement element = elementFinder.findElement(\"")
                        .append(step.getElement()).append("\");\n");
                    code.append("        element.clear();\n");
                    code.append("        element.sendKeys(\"").append(step.getValue()).append("\");\n");
                } else if ("SELECT".equals(step.getAction())) {
                    code.append("        WebElement element = elementFinder.findElement(\"")
                        .append(step.getElement()).append("\");\n");
                    code.append("        new org.openqa.selenium.support.ui.Select(element)")
                        .append(".selectByVisibleText(\"").append(step.getValue()).append("\");\n");
                } else if ("VERIFY_PRESENCE".equals(step.getAction())) {
                    code.append("        WebElement element = elementFinder.findElement(\"")
                        .append(step.getElement()).append("\");\n");
                    code.append("        Assert.assertTrue(element.isDisplayed(), \"")
                        .append(step.getElement()).append(" should be present\");\n");
                } else if ("VERIFY_VISIBILITY".equals(step.getAction())) {
                    code.append("        elementFinder.waitForElementVisible(\"")
                        .append(step.getElement()).append("\");\n");
                    code.append("        Assert.assertTrue(elementFinder.isElementVisible(\"")
                        .append(step.getElement()).append("\"), \"")
                        .append(step.getElement()).append(" should be visible\");\n");
                } else if ("VERIFY_TEXT".equals(step.getAction())) {
                    code.append("        WebElement element = elementFinder.findElement(\"")
                        .append(step.getElement()).append("\");\n");
                    code.append("        Assert.assertTrue(element.getText().contains(\"")
                        .append(step.getValue()).append("\"), \"")
                        .append(step.getElement()).append(" should contain text '")
                        .append(step.getValue()).append("'\");\n");
                } else if ("WAIT".equals(step.getAction())) {
                    code.append("        elementFinder.waitForElement(\"")
                        .append(step.getElement()).append("\");\n");
                } else {
                    code.append("        // TODO: Implement ").append(step.getAction())
                        .append(" action for ").append(step.getElement()).append("\n");
                }
                
                code.append("\n");
            }
        } else {
            code.append("        // TODO: Implement test steps\n\n");
        }
        
        code.append("        log.info(\"Test completed successfully\");\n");
        code.append("    }\n");
        code.append("}\n");
        
        return code.toString();
    }
    
    /**
     * Save test to file
     */
    private void saveTestToFile(GeneratedTest test) {
        try {
            // Save as JSON
            File testFile = new File(GENERATED_TESTS_DIR, test.getId() + ".json");
            
            // Use Jackson to serialize to JSON
            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
            objectMapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule());
            objectMapper.disable(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
            
            objectMapper.writeValue(testFile, test);
            
            log.info("Saved test to file: {}", testFile.getAbsolutePath());
        } catch (Exception e) {
            log.error("Error saving test to file", e);
            throw new RuntimeException("Failed to save test to file: " + e.getMessage(), e);
        }
    }
    
    /**
     * Save Java file
     */
    private void saveJavaFile(GeneratedTest test) {
        try {
            // Ensure directory exists
            File packageDir = new File(TEST_CODE_DIR);
            if (!packageDir.exists()) {
                packageDir.mkdirs();
            }
            
            // Save Java file
            File javaFile = new File(packageDir, test.getClassName() + ".java");
            Files.writeString(javaFile.toPath(), test.getCode());
            
            log.info("Saved Java file: {}", javaFile.getAbsolutePath());
        } catch (Exception e) {
            log.error("Error saving Java file", e);
            throw new RuntimeException("Failed to save Java file: " + e.getMessage(), e);
        }
    }
}

package com.cssmart.ui.recorder.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.time.LocalDateTime;

/**
 * Represents a step recorded during a test recording session
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RecordedStep {
    private String action;
    private String element;
    private String value;
    private String description;
    private LocalDateTime timestamp;
}


package com.cssmart.ui.recorder.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Represents a test case created from recorded steps
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TestCase {
    private String id;
    private String name;
    private String description;
    private List<RecordedStep> steps;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String className;
    private String methodName;
    private String code;
}


package com.cssmart.ui.controller;

import com.cssmart.ai.codegen.model.TestStep;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.util.List;

/**
 * Represents a test generated by the AI or converted from a recorded test
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class GeneratedTest {
    private String id;
    private String name;
    private String description;
    private List<TestStep> steps;
    private String className;
    private String methodName;
    private String code;
}


package com.cssmart.ui.service;

import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.controller.GeneratedTest;
import com.cssmart.ai.engine.AIEngine;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.util.Map;
import java.util.UUID;
import java.util.List;
import java.util.ArrayList;
import java.util.stream.Collectors;
import java.util.concurrent.ConcurrentHashMap;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

import com.cssmart.ai.codegen.model.TestStep;

/**
 * Service for managing recorded tests, including storing and converting between
 * recorded TestCase objects and GeneratedTest objects for the Test Generator
 */
@Slf4j
@Service
public class TestRecordingService {
    
    private final AIEngine aiEngine;
    private final Map<String, TestCase> recordedTests;
    private static final String RECORDED_TESTS_DIR = "recorded-tests";
    
    @Autowired
    public TestRecordingService(AIEngine aiEngine) {
        this.aiEngine = aiEngine;
        this.recordedTests = new ConcurrentHashMap<>();
        
        // Ensure recorded tests directory exists
        File dir = new File(RECORDED_TESTS_DIR);
        if (!dir.exists()) {
            dir.mkdirs();
        }
    }
    
    /**
     * Save a recorded test case
     * @param testCase The test case to save
     * @return The saved test case with ID
     */
    public TestCase saveRecordedTest(TestCase testCase) {
        try {
            log.info("Saving recorded test: {}", testCase.getName());
            
            // Ensure test case has an ID
            if (testCase.getId() == null || testCase.getId().isEmpty()) {
                testCase.setId(UUID.randomUUID().toString());
            }
            
            // Store in memory
            recordedTests.put(testCase.getId(), testCase);
            
            // Save to file system
            saveTestToFile(testCase);
            
            return testCase;
        } catch (Exception e) {
            log.error("Error saving recorded test", e);
            throw new RuntimeException("Failed to save recorded test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Get a recorded test by ID
     * @param id Test ID
     * @return Test case or null if not found
     */
    public TestCase getRecordedTest(String id) {
        return recordedTests.get(id);
    }
    
    /**
     * Convert a recorded TestCase to a GeneratedTest for the Test Generator
     * @param testCase The test case to convert
     * @return A GeneratedTest object
     */
    public GeneratedTest convertToGeneratedTest(TestCase testCase) {
        try {
            log.info("Converting recorded test to generated test: {}", testCase.getName());
            
            GeneratedTest generatedTest = new GeneratedTest();
            generatedTest.setId(testCase.getId());
            generatedTest.setName(testCase.getName());
            generatedTest.setDescription(testCase.getDescription());
            generatedTest.setClassName(testCase.getClassName());
            generatedTest.setMethodName(testCase.getMethodName());
            generatedTest.setCode(testCase.getCode());
            
            // Convert steps
            if (testCase.getSteps() != null) {
                generatedTest.setSteps(convertToTestSteps(testCase.getSteps()));
            }
            
            return generatedTest;
        } catch (Exception e) {
            log.error("Error converting recorded test to generated test", e);
            throw new RuntimeException("Failed to convert test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Convert a GeneratedTest to a TestCase
     * @param generatedTest The generated test to convert
     * @return A TestCase object
     */
    public TestCase convertToTestCase(GeneratedTest generatedTest) {
        try {
            log.info("Converting generated test to test case: {}", generatedTest.getName());
            
            TestCase testCase = new TestCase();
            testCase.setId(generatedTest.getId());
            testCase.setName(generatedTest.getName());
            testCase.setDescription(generatedTest.getDescription());
            testCase.setClassName(generatedTest.getClassName());
            testCase.setMethodName(generatedTest.getMethodName());
            testCase.setCode(generatedTest.getCode());
            
            // Convert steps
            if (generatedTest.getSteps() != null) {
                testCase.setSteps(convertToRecordedSteps(generatedTest.getSteps()));
            }
            
            return testCase;
        } catch (Exception e) {
            log.error("Error converting generated test to test case", e);
            throw new RuntimeException("Failed to convert test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Enhance a test case with AI
     * @param testCase The test case to enhance
     * @return The enhanced test case
     */
    public TestCase enhanceTestCase(TestCase testCase) {
        try {
            log.info("Enhancing test case with AI: {}", testCase.getName());
            
            // Use AI engine to enhance the test case
            // This is a placeholder for the actual AI enhancement
            if (aiEngine != null) {
                // In a real implementation, this would use AI to improve the test
                // For now, we'll just make some simple enhancements
                
                // Improve the test name if it's generic
                if (testCase.getName() == null || testCase.getName().contains("Recorded Test")) {
                    if (testCase.getSteps() != null && !testCase.getSteps().isEmpty()) {
                        // Generate a more descriptive name based on the steps
                        String firstAction = testCase.getSteps().get(0).getAction();
                        String firstElement = testCase.getSteps().get(0).getElement();
                        
                        if (firstAction != null && firstElement != null) {
                            testCase.setName("Test " + firstAction + " on " + firstElement);
                        }
                    }
                }
                
                // Improve the description
                if (testCase.getDescription() == null || testCase.getDescription().isEmpty() || 
                        testCase.getDescription().equals("Automatically recorded test case")) {
                    testCase.setDescription("Automated test to verify functionality of the application");
                }
                
                // You would call the AI engine here in a real implementation
                // testCase = aiEngine.enhanceTestCase(testCase);
            }
            
            return testCase;
        } catch (Exception e) {
            log.error("Error enhancing test case", e);
            
            // Return the original test case if enhancement fails
            return testCase;
        }
    }
    
    /**
     * Save a test case to file
     * @param testCase The test case to save
     */
    private void saveTestToFile(TestCase testCase) {
        try {
            // Save test case to file
            File testFile = new File(RECORDED_TESTS_DIR, testCase.getId() + ".json");
            
            // Use Jackson to serialize to JSON
            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
            objectMapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule());
            objectMapper.disable(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
            
            objectMapper.writeValue(testFile, testCase);
            
            log.info("Saved test case to file: {}", testFile.getAbsolutePath());
            
            // If code is present, also save it as a Java file
            if (testCase.getCode() != null && !testCase.getCode().isEmpty()) {
                String packageDir = "src/main/java/com/cssmart/tests/generated".replace('.', '/');
                File packagePath = new File(packageDir);
                if (!packagePath.exists()) {
                    packagePath.mkdirs();
                }
                
                File javaFile = new File(packageDir, testCase.getClassName() + ".java");
                Files.writeString(javaFile.toPath(), testCase.getCode());
                
                log.info("Saved test code to: {}", javaFile.getAbsolutePath());
            }
        } catch (Exception e) {
            log.error("Error saving test case to file", e);
            throw new RuntimeException("Failed to save test to file: " + e.getMessage(), e);
        }
    }
    
    /**
     * Convert RecordedStep list to TestStep list
     * @param recordedSteps List of RecordedStep objects
     * @return List of TestStep objects
     */
    private List<TestStep> convertToTestSteps(List<RecordedStep> recordedSteps) {
        if (recordedSteps == null) {
            return new ArrayList<>();
        }
        
        return recordedSteps.stream()
            .map(this::convertToTestStep)
            .collect(Collectors.toList());
    }
    
    /**
     * Convert a single RecordedStep to TestStep
     * @param recordedStep RecordedStep object
     * @return TestStep object
     */
    private TestStep convertToTestStep(RecordedStep recordedStep) {
        return TestStep.builder()
            .action(recordedStep.getAction())
            .element(recordedStep.getElement())
            .value(recordedStep.getValue())
            .description(recordedStep.getDescription())
            .timestamp(recordedStep.getTimestamp())
            .build();
    }
    
    /**
     * Convert TestStep list to RecordedStep list
     * @param testSteps List of TestStep objects
     * @return List of RecordedStep objects
     */
    private List<RecordedStep> convertToRecordedSteps(List<TestStep> testSteps) {
        if (testSteps == null) {
            return new ArrayList<>();
        }
        
        return testSteps.stream()
            .map(this::convertToRecordedStep)
            .collect(Collectors.toList());
    }
    
    /**
     * Convert a single TestStep to RecordedStep
     * @param testStep TestStep object
     * @return RecordedStep object
     */
    private RecordedStep convertToRecordedStep(TestStep testStep) {
        return RecordedStep.builder()
            .action(testStep.getAction())
            .element(testStep.getElement())
            .value(testStep.getValue())
            .description(testStep.getDescription())
            .timestamp(testStep.getTimestamp())
            .build();
    }
}


package com.cssmart.ui.recorder;

import lombok.extern.slf4j.Slf4j;
import java.util.List;
import java.util.ArrayList;
import java.util.UUID;
import java.time.LocalDateTime;

import com.cssmart.ai.engine.AIEngine;
import com.cssmart.ai.engine.model.Action;
import com.cssmart.ai.engine.model.ActionType;
import com.cssmart.ui.recorder.model.RecordedStep;
import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.core.driver.DriverManager;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.safari.SafariDriver;
import io.github.bonigarcia.wdm.WebDriverManager;

@Slf4j
public class TestRecorder {
    private boolean isRecording;
    private List<RecordedStep> steps;
    private final AIEngine aiEngine;
    private LocalDateTime startTime;
    private String sessionId;
    private WebDriver driver;
    private String baseUrl;
    
    public TestRecorder() {
        this.isRecording = false;
        this.steps = new ArrayList<>();
        this.aiEngine = AIEngine.getInstance();
    }
    
    public void startRecording(String browserType, String url) {
        this.isRecording = true;
        this.steps.clear();
        this.baseUrl = url;
        this.startTime = LocalDateTime.now();
        this.sessionId = UUID.randomUUID().toString();
        
        // Initialize and launch browser
        initializeBrowser(browserType);
        
        // Navigate to the base URL
        if (driver != null && baseUrl != null && !baseUrl.isEmpty()) {
            driver.get(baseUrl);
            
            // Record navigation as a step
            RecordedStep step = new RecordedStep();
            step.setAction("NAVIGATE");
            step.setValue(baseUrl);
            step.setTimestamp(LocalDateTime.now());
            step.setDescription("Navigate to " + baseUrl);
            steps.add(step);
            
            // Inject recorder script to capture user actions
            injectRecorderScript();
        }
        
        log.info("Recording started with session ID: {}", sessionId);
    }
    
    /**
     * Inject JavaScript code to capture user actions in the browser
     */
    private void injectRecorderScript() {
    if (driver instanceof JavascriptExecutor) {
        try {
            JavascriptExecutor jsExecutor = (JavascriptExecutor) driver;
            
            // Create a session ID for this recording session
            String sessionId = UUID.randomUUID().toString();
            
            // Simple recorder script with careful syntax checking
            String recorderScript = 
                "window.csSmartRecorderSessionId = '" + sessionId + "';" +
                "window.csSmartRecorderActive = true;" +
                "window.csSmartRecorderEvents = [];" +
                
                "window.csSmartRecorder = {" +
                "  sendEvent: function(actionType, element, value) {" +
                "    var xhr = new XMLHttpRequest();" +
                "    xhr.open('POST', '/api/recorder/event', true);" +
                "    xhr.setRequestHeader('Content-Type', 'application/json');" +
                "    xhr.onreadystatechange = function() {" +
                "      if (xhr.readyState === 4) {" +
                "        console.log('Event sent: ' + actionType + ', Status: ' + xhr.status);" +
                "      }" +
                "    };" +
                "    var data = JSON.stringify({" +
                "      sessionId: window.csSmartRecorderSessionId," +
                "      actionType: actionType," +
                "      element: element," +
                "      value: value" +
                "    });" +
                "    xhr.send(data);" +
                "    console.log('Sending event: ' + actionType + ' on ' + element);" +
                "  }," +
                
                "  getElementSelector: function(element) {" +
                "    if (!element) return 'unknown';" +
                "    if (element.id) return '#' + element.id;" +
                "    if (element.name) return '[name=\"' + element.name + '\"]';" +
                "    var selector = element.tagName.toLowerCase();" +
                "    if (element.className) {" +
                "      var classes = element.className.split(' ');" +
                "      for (var i = 0; i < classes.length; i++) {" +
                "        if (classes[i]) {" +
                "          selector += '.' + classes[i];" +
                "        }" +
                "      }" +
                "    }" +
                "    return selector;" +
                "  }" +
                "};" +
                
                // Click handler
                "document.addEventListener('click', function(e) {" +
                "  if (!window.csSmartRecorderActive) return;" +
                "  var selector = window.csSmartRecorder.getElementSelector(e.target);" +
                "  window.csSmartRecorder.sendEvent('CLICK', selector, '');" +
                "}, true);" +
                
                // Input handler
                "document.addEventListener('input', function(e) {" +
                "  if (!window.csSmartRecorderActive) return;" +
                "  var selector = window.csSmartRecorder.getElementSelector(e.target);" +
                "  window.csSmartRecorder.sendEvent('TYPE', selector, e.target.value);" +
                "}, true);" +
                
                // Change handler (for select elements)
                "document.addEventListener('change', function(e) {" +
                "  if (!window.csSmartRecorderActive) return;" +
                "  var selector = window.csSmartRecorder.getElementSelector(e.target);" +
                "  if (e.target.tagName.toLowerCase() === 'select') {" +
                "    window.csSmartRecorder.sendEvent('SELECT', selector, e.target.value);" +
                "  }" +
                "}, true);" +
                
                // Send init event to verify recorder is working
                "window.csSmartRecorder.sendEvent('INIT', 'recorder', 'initialized');";
            
            // Execute the script
            jsExecutor.executeScript(recorderScript);
            
            log.info("Recorder script injected successfully with session ID: {}", sessionId);
            
        } catch (Exception e) {
            log.error("Failed to inject recorder script: {}", e.getMessage(), e);
        }
    } else {
        log.error("Driver does not support JavaScript execution");
    }
}
    
    private void initializeBrowser(String browserType) {
        try {
            // Set up the WebDriver based on browser type
            switch (browserType.toLowerCase()) {
                case "chrome":
                    WebDriverManager.chromedriver().setup();
                    driver = new ChromeDriver();
                    break;
                case "firefox":
                    WebDriverManager.firefoxdriver().setup();
                    driver = new FirefoxDriver();
                    break;
                case "edge":
                    WebDriverManager.edgedriver().setup();
                    driver = new EdgeDriver();
                    break;
                case "safari":
                    driver = new SafariDriver();
                    break;
                default:
                    log.warn("Unsupported browser type: {}. Defaulting to Chrome.", browserType);
                    WebDriverManager.chromedriver().setup();
                    driver = new ChromeDriver();
            }
            
            // Maximize browser window
            driver.manage().window().maximize();
            
            log.info("Browser initialized: {}", browserType);
        } catch (Exception e) {
            log.error("Failed to initialize browser: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to initialize browser: " + e.getMessage(), e);
        }
    }
    
    public TestCase stopRecording() {
        this.isRecording = false;
        LocalDateTime endTime = LocalDateTime.now();
        log.info("Recording stopped, captured {} steps", steps.size());
        
        // Close the browser
        if (driver != null) {
            try {
                driver.quit();
                log.info("Browser closed");
            } catch (Exception e) {
                log.error("Error closing browser: {}", e.getMessage(), e);
            } finally {
                driver = null;
            }
        }
        
        // Create test case from recorded steps
        TestCase testCase = createTestCase(steps, startTime, endTime);
        
        // Clear steps
        this.steps.clear();
        
        return testCase;
    }
    
    public void recordAction(Action action, String element, String value) {
        if (!isRecording) {
            log.warn("Attempted to record action when not recording");
            return;
        }
        
        RecordedStep step = new RecordedStep();
        step.setAction(action.getType().toString());
        step.setElement(element);
        step.setValue(value);
        step.setTimestamp(LocalDateTime.now());
        
        // Generate description
        step.setDescription(generateDescription(action.getType(), element, value));
        
        steps.add(step);
        log.debug("Recorded step: {}", step);
    }
    
    public void recordBrowserAction(String browserAction, String url) {
        if (!isRecording) {
            log.warn("Attempted to record browser action when not recording");
            return;
        }
        
        RecordedStep step = new RecordedStep();
        step.setAction(browserAction);
        step.setValue(url);
        step.setTimestamp(LocalDateTime.now());
        
        // Generate description
        if ("NAVIGATE".equals(browserAction)) {
            step.setDescription("Navigate to " + url);
        } else if ("BACK".equals(browserAction)) {
            step.setDescription("Navigate back");
        } else if ("FORWARD".equals(browserAction)) {
            step.setDescription("Navigate forward");
        } else if ("REFRESH".equals(browserAction)) {
            step.setDescription("Refresh page");
        }
        
        steps.add(step);
        log.debug("Recorded browser action: {}", step);
    }
    
    private String generateDescription(ActionType actionType, String element, String value) {
        switch (actionType) {
            case CLICK:
                return "Click on " + element;
            case TYPE:
                return "Enter '" + value + "' in " + element;
            case SELECT:
                return "Select '" + value + "' from " + element;
            case VERIFY_PRESENCE:
                return "Verify " + element + " is present";
            case VERIFY_VISIBILITY:
                return "Verify " + element + " is visible";
            case VERIFY_STATE:
                return "Verify " + element + " state is '" + value + "'";
            case WAIT:
                return "Wait for " + element;
            case HOVER:
                return "Hover over " + element;
            default:
                return actionType + " on " + element;
        }
    }
    
    private TestCase createTestCase(List<RecordedStep> steps, LocalDateTime startTime, LocalDateTime endTime) {
        TestCase testCase = new TestCase();
        testCase.setId(sessionId);
        testCase.setName("Recorded Test " + startTime.toString());
        testCase.setDescription("Automatically recorded test case");
        testCase.setSteps(new ArrayList<>(steps));
        testCase.setStartTime(startTime);
        testCase.setEndTime(endTime);
        
        // Generate class and method names
        testCase.setClassName("RecordedTest" + startTime.toString().replaceAll("[^a-zA-Z0-9]", ""));
        testCase.setMethodName("test" + startTime.toString().replaceAll("[^a-zA-Z0-9]", ""));
        
        // Use AI to enhance test case
        enhanceTestCase(testCase);
        
        // Generate test code
        testCase.setCode(generateTestCode(testCase));
        
        return testCase;
    }
    
    private void enhanceTestCase(TestCase testCase) {
        // Extract pattern from steps
        List<Action> actions = new ArrayList<>();
        for (RecordedStep step : testCase.getSteps()) {
            try {
                ActionType actionType = ActionType.valueOf(step.getAction());
                Action action = new Action(actionType);
                action.setValue(step.getValue());
                actions.add(action);
            } catch (IllegalArgumentException e) {
                log.warn("Unknown action type: {}", step.getAction());
            }
        }
        
        if (!actions.isEmpty()) {
            try {
                // Detect patterns
                List<com.cssmart.ai.patterns.model.Pattern> patterns = 
                    aiEngine.recognizePatterns(actions);
                
                // Generate better name and description based on patterns
                if (!patterns.isEmpty()) {
                    // Use the highest confidence pattern for naming
                    com.cssmart.ai.patterns.model.Pattern topPattern = 
                        patterns.stream()
                            .sorted((p1, p2) -> Double.compare(p2.getConfidence(), p1.getConfidence()))
                            .findFirst()
                            .orElse(null);
                    
                    if (topPattern != null) {
                        testCase.setName(topPattern.getName() + " Test");
                        testCase.setDescription(topPattern.getDescription());
                        
                        // Update class and method names
                        testCase.setClassName(
                            topPattern.getName().replaceAll("[^a-zA-Z0-9]", "") + "Test");
                        testCase.setMethodName(
                            "test" + topPattern.getName().replaceAll("[^a-zA-Z0-9]", ""));
                    }
                }
            } catch (Exception e) {
                log.error("Error enhancing test case: {}", e.getMessage(), e);
            }
        }
    }
    
    private String generateTestCode(TestCase testCase) {
        // A simple code generation implementation
        StringBuilder code = new StringBuilder();
        
        // Add imports and class declaration
        code.append("package com.cssmart.tests.generated;\n\n");
        code.append("import com.cssmart.core.base.CSSmartTestBase;\n");
        code.append("import com.cssmart.core.annotations.CSSmartTest;\n");
        code.append("import org.testng.annotations.Test;\n");
        code.append("import org.openqa.selenium.WebElement;\n");
        code.append("import org.testng.Assert;\n");
        code.append("import lombok.extern.slf4j.Slf4j;\n\n");
        
        code.append("@Slf4j\n");
        code.append("public class ").append(testCase.getClassName()).append(" extends CSSmartTestBase {\n\n");
        
        // Add test method
        code.append("    @Test\n");
        code.append("    @CSSmartTest(description = \"").append(testCase.getDescription()).append("\")\n");
        code.append("    public void ").append(testCase.getMethodName()).append("() {\n");
        code.append("        log.info(\"Starting test: ").append(testCase.getDescription()).append("\");\n\n");
        
        // Add test steps
        for (RecordedStep step : testCase.getSteps()) {
            code.append("        // ").append(step.getDescription()).append("\n");
            
            if ("NAVIGATE".equals(step.getAction())) {
                code.append("        driver.get(\"").append(step.getValue()).append("\");\n");
            } else if ("CLICK".equals(step.getAction())) {
                code.append("        WebElement element = elementFinder.findElement(\"")
                    .append(step.getElement()).append("\");\n");
                code.append("        element.click();\n");
            } else if ("TYPE".equals(step.getAction())) {
                code.append("        WebElement element = elementFinder.findElement(\"")
                    .append(step.getElement()).append("\");\n");
                code.append("        element.clear();\n");
                code.append("        element.sendKeys(\"").append(step.getValue()).append("\");\n");
            } else if ("SELECT".equals(step.getAction())) {
                code.append("        WebElement element = elementFinder.findElement(\"")
                    .append(step.getElement()).append("\");\n");
                code.append("        new org.openqa.selenium.support.ui.Select(element)")
                    .append(".selectByVisibleText(\"").append(step.getValue()).append("\");\n");
            } else if ("VERIFY_PRESENCE".equals(step.getAction())) {
                code.append("        WebElement element = elementFinder.findElement(\"")
                    .append(step.getElement()).append("\");\n");
                code.append("        Assert.assertTrue(element.isDisplayed(), \"")
                    .append(step.getElement()).append(" should be present\");\n");
            }
            
            code.append("\n");
        }
        
        code.append("        log.info(\"Test completed successfully\");\n");
        code.append("    }\n");
        code.append("}\n");
        
        return code.toString();
    }
    
    public boolean isRecording() {
        return isRecording;
    }
    
    public List<RecordedStep> getSteps() {
        return new ArrayList<>(steps);  // Return a copy to prevent modification
    }
    
    public RecordedStep getLastRecordedStep() {
        if (steps.isEmpty()) {
            return null;
        }
        return steps.get(steps.size() - 1);
    }
    
    public WebDriver getDriver() {
        return driver;
    }
}


package com.cssmart.ui.controller;

import com.cssmart.ai.engine.model.Action;
import com.cssmart.ai.engine.model.ActionType;
import com.cssmart.ui.recorder.TestRecorder;
import com.cssmart.ui.recorder.TestRecorderHandler;
import com.cssmart.ui.recorder.model.RecordedStep;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import lombok.extern.slf4j.Slf4j;

import java.util.Map;

/**
 * Controller for handling events from the browser during recording
 */
@Slf4j
@RestController
@RequestMapping("/api/recorder")
public class RecorderEventController {
    
    private static final Logger log = LoggerFactory.getLogger(RecorderEventController.class);
    private final TestRecorderHandler recorderHandler;
    
    @Autowired
    public RecorderEventController(TestRecorderHandler recorderHandler) {
        this.recorderHandler = recorderHandler;
    }
    
    @PostMapping("/event")
    public ResponseEntity<String> handleEvent(@RequestBody RecorderEvent event) {
        log.info("Received recorder event: {}", event);
        
        try {
            // Skip INIT events as they are just for testing the connection
            if ("INIT".equals(event.getActionType())) {
                return ResponseEntity.ok("Initialization event received");
            }
            
            ActionType actionType = ActionType.valueOf(event.getActionType());
            Action action = new Action(actionType);
            
            if (event.getValue() != null) {
                action.setValue(event.getValue());
            }
            
            recorderHandler.recordAction(event.getSessionId(), action, event.getElement(), event.getValue());
            
            return ResponseEntity.ok("Event recorded");
        } catch (IllegalArgumentException e) {
            log.warn("Unknown action type: {}", event.getActionType());
            return ResponseEntity.badRequest().body("Unknown action type: " + event.getActionType());
        } catch (Exception e) {
            log.error("Error processing recorder event", e);
            return ResponseEntity.status(500).body("Error processing event: " + e.getMessage());
        }
    }
    
    public static class RecorderEvent {
        private String sessionId;
        private String actionType;
        private String element;
        private String value;
        
        // Getters and setters
        public String getSessionId() { return sessionId; }
        public void setSessionId(String sessionId) { this.sessionId = sessionId; }
        
        public String getActionType() { return actionType; }
        public void setActionType(String actionType) { this.actionType = actionType; }
        
        public String getElement() { return element; }
        public void setElement(String element) { this.element = element; }
        
        public String getValue() { return value; }
        public void setValue(String value) { this.value = value; }
        
        @Override
        public String toString() {
            return "RecorderEvent{sessionId='" + sessionId + "', actionType='" + actionType + 
                   "', element='" + element + "', value='" + value + "'}";
        }
    }
}


package com.cssmart.ui.recorder;

import com.cssmart.ai.engine.AIEngine;
import com.cssmart.ai.engine.model.Action;
import com.cssmart.ai.engine.model.ActionType;
import com.cssmart.ui.recorder.model.RecorderMessage;
import com.cssmart.ui.recorder.model.RecordedStep;
import com.cssmart.ui.recorder.model.TestCase;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * WebSocket handler for the test recorder
 * Manages real-time communication between the browser and server
 * for recording test actions
 */
@Slf4j
@Component
public class TestRecorderHandler extends TextWebSocketHandler {
    
    private final ObjectMapper objectMapper;
    private final Map<String, TestRecorder> recorders;
    private final Map<String, WebSocketSession> sessions;
    private final AIEngine aiEngine;
    
    @Autowired
    public TestRecorderHandler(ObjectMapper objectMapper, AIEngine aiEngine) {
        this.objectMapper = objectMapper;
        this.recorders = new ConcurrentHashMap<>();
        this.sessions = new ConcurrentHashMap<>();
        this.aiEngine = aiEngine;
    }
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        log.info("WebSocket connection established: {}", session.getId());
        sessions.put(session.getId(), session);
    }
    
    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
        String sessionId = session.getId();
        RecorderMessage msg = objectMapper.readValue(message.getPayload(), RecorderMessage.class);
        
        log.debug("Received recorder message: {}", msg.getType());
        
        switch (msg.getType()) {
            case "START_RECORDING":
                startRecording(session, sessionId, msg.getData());
                break;
            case "STOP_RECORDING":
                stopRecording(session, sessionId);
                break;
            case "ACTION":
                recordAction(session, sessionId, msg.getData());
                break;
            default:
                log.warn("Unknown message type: {}", msg.getType());
                sendError(session, "Unknown message type: " + msg.getType());
                break;
        }
    }
    
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
        String sessionId = session.getId();
        TestRecorder recorder = recorders.get(sessionId);
        
        // Make sure to stop recording and clean up resources
        if (recorder != null && recorder.isRecording()) {
            try {
                recorder.stopRecording();
            } catch (Exception e) {
                log.error("Error stopping recording on connection close: {}", e.getMessage(), e);
            }
            recorders.remove(sessionId);
        }
        
        sessions.remove(sessionId);
        log.info("WebSocket connection closed: {}", sessionId);
    }
    
    @Override
    public void handleTransportError(WebSocketSession session, Throwable exception) {
        log.error("WebSocket transport error for session {}: {}", 
                session.getId(), exception.getMessage(), exception);
    }
    
    /**
     * Handle events coming from the browser via HTTP endpoint
     * @param actionType The type of action (CLICK, TYPE, etc.)
     * @param element The CSS selector or element identifier
     * @param value The value (for inputs, etc.)
     */
    public void handleBrowserEvent(String actionType, String element, String value) {
        log.info("Handling browser event: {} on {} with value {}", actionType, element, value);
        
        // Since this is coming from HTTP, we need to find the active recorder
        if (recorders.isEmpty()) {
            log.warn("No active recorders found for browser event");
            return;
        }
        
        // In a real implementation, you'd have a way to identify the specific session/recorder
        // For now, we'll just use the first active recorder
        for (Map.Entry<String, TestRecorder> entry : recorders.entrySet()) {
            String sessionId = entry.getKey();
            TestRecorder recorder = entry.getValue();
            
            if (recorder.isRecording()) {
                try {
                    // If the action is INITIALIZE, we can ignore it (it's just a test event)
                    if ("INITIALIZE".equals(actionType)) {
                        log.info("Received initialization event from browser");
                        continue;
                    }
                    
                    // Convert the action type string to ActionType enum
                    ActionType type;
                    try {
                        type = ActionType.valueOf(actionType);
                    } catch (IllegalArgumentException e) {
                        // If actionType is not in the enum, default to CLICK
                        log.warn("Unknown action type: {}. Defaulting to CLICK.", actionType);
                        type = ActionType.CLICK;
                    }
                    
                    Action action = new Action(type);
                    action.setValue(value);
                    
                    // Record the action
                    recorder.recordAction(action, element, value);
                    
                    // Notify the WebSocket client about the new step
                    WebSocketSession session = sessions.get(sessionId);
                    if (session != null && session.isOpen()) {
                        RecordedStep step = recorder.getLastRecordedStep();
                        sendMessage(session, new RecorderMessage("STEP_RECORDED", step));
                    }
                    
                    break; // Only record in one session
                } catch (Exception e) {
                    log.error("Error processing browser event", e);
                }
            }
        }
    }
    
    /**
     * Start a new recording session
     */
    @SuppressWarnings("unchecked")
    private void startRecording(WebSocketSession session, String sessionId, Object configData) throws Exception {
        log.info("Starting recording session for: {}", sessionId);
        
        // Get recording configuration
        String browserType = "chrome"; // Default
        String url = "https://example.com"; // Default
        
        if (configData != null) {
            try {
                Map<String, Object> config = (Map<String, Object>) configData;
                if (config.containsKey("browser")) {
                    browserType = (String) config.get("browser");
                }
                if (config.containsKey("url")) {
                    url = (String) config.get("url");
                }
                
                log.info("Recording configuration - browser: {}, url: {}", browserType, url);
            } catch (Exception e) {
                log.error("Error parsing recording configuration: {}", e.getMessage(), e);
            }
        }
        
        // Initialize recorder
        TestRecorder recorder = new TestRecorder();
        
        try {
            // Start recording with the provided configuration
            recorder.startRecording(browserType, url);
            recorders.put(sessionId, recorder);
            
            sendMessage(session, new RecorderMessage("RECORDING_STARTED", null));
        } catch (Exception e) {
            log.error("Failed to start recording: {}", e.getMessage(), e);
            sendError(session, "Failed to start recording: " + e.getMessage());
        }
    }
    
    /**
     * Stop recording and return test case
     */
    private void stopRecording(WebSocketSession session, String sessionId) throws Exception {
        log.info("Stopping recording session for: {}", sessionId);
        
        TestRecorder recorder = recorders.get(sessionId);
        if (recorder != null) {
            TestCase testCase = recorder.stopRecording();
            
            // Enhance test case with AI
            testCase = aiEngine.enhanceTestCase(testCase);
            
            sendMessage(session, new RecorderMessage("TEST_CASE", testCase));
            
            // Cleanup
            recorders.remove(sessionId);
        } else {
            sendError(session, "No active recording session found");
        }
    }
    /**
 * Record an action from an HTTP endpoint
 * This is a public method that can be called from the controller
 * @param sessionId The session ID (if known, otherwise null)
 * @param action The action to record
 * @param element The element identifier
 * @param value The action value
 */
public void recordAction(String sessionId, Action action, String element, String value) {
    log.info("Recording action: {} on {} with value {}", action.getType(), element, value);
    
    TestRecorder recorder = null;
    
    // If we have a specific session ID
    if (sessionId != null && !sessionId.isEmpty()) {
        recorder = recorders.get(sessionId);
    } 
    // Otherwise, find the first active recorder
    else if (!recorders.isEmpty()) {
        for (Map.Entry<String, TestRecorder> entry : recorders.entrySet()) {
            if (entry.getValue().isRecording()) {
                recorder = entry.getValue();
                sessionId = entry.getKey();
                break;
            }
        }
    }
    
    if (recorder != null) {
        try {
            recorder.recordAction(action, element, value);
            
            // Notify the WebSocket client about the new step
            WebSocketSession session = sessions.get(sessionId);
            if (session != null && session.isOpen()) {
                RecordedStep step = recorder.getLastRecordedStep();
                sendMessage(session, new RecorderMessage("STEP_RECORDED", step));
            }
        } catch (Exception e) {
            log.error("Error recording action", e);
        }
    } else {
        log.warn("No active recorder found to record action");
    }
}

    /**
 * Record an action from a WebSocket message
 */
@SuppressWarnings("unchecked")
private void handleWebSocketAction(WebSocketSession session, String sessionId, Object actionData) throws Exception {
    TestRecorder recorder = recorders.get(sessionId);
    if (recorder != null) {
        try {
            Map<String, String> data = (Map<String, String>) actionData;
            
            String actionType = data.get("action");
            String element = data.get("element");
            String value = data.get("value");
            
            Action action = new Action(ActionType.valueOf(actionType));
            action.setValue(value);
            
            recorder.recordAction(action, element, value);
            
            // Send the recorded step back to client for display
            RecordedStep step = recorder.getLastRecordedStep();
            sendMessage(session, new RecorderMessage("STEP_RECORDED", step));
            
        } catch (Exception e) {
            log.error("Error recording action", e);
            sendError(session, "Failed to record action: " + e.getMessage());
        }
    } else {
        sendError(session, "No active recording session found");
    }
}
    
    /**
     * Send a message to the WebSocket client
     */
    private void sendMessage(WebSocketSession session, RecorderMessage msg) {
        try {
            String json = objectMapper.writeValueAsString(msg);
            session.sendMessage(new TextMessage(json));
        } catch (IOException e) {
            log.error("Error sending message to WebSocket client", e);
        }
    }
    
    /**
     * Send an error message to the WebSocket client
     */
    private void sendError(WebSocketSession session, String errorMessage) {
        log.warn("Sending error to client: {}", errorMessage);
        sendMessage(session, new RecorderMessage("ERROR", errorMessage));
    }
}


