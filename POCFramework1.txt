Complete CSSmart Framework Folder Structure
cssmart/
│
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── cssmart/
│   │   │           ├── ai/
│   │   │           │   ├── CSSmartAITesting.java
│   │   │           │   ├── healing/
│   │   │           │   │   └── SelfHealingLocator.java
│   │   │           │   ├── visual/
│   │   │           │   │   └── VisualAssertions.java
│   │   │           │   └── generator/
│   │   │           │       └── TestGenerator.java
│   │   │           │
│   │   │           ├── annotations/
│   │   │           │   ├── CSSmartFindBy.java
│   │   │           │   └── CSSmartTestStep.java
│   │   │           │
│   │   │           ├── api/
│   │   │           │   ├── client/
│   │   │           │   │   └── CSSmartHTTPClient.java
│   │   │           │   ├── cucumber/
│   │   │           │   │   ├── CSSmartAPIContext.java
│   │   │           │   │   └── CSSmartAPITestSteps.java
│   │   │           │   ├── response/
│   │   │           │   │   └── CSSmartAPIResponse.java
│   │   │           │   ├── utils/
│   │   │           │   │   └── CSSmartJSONUtils.java
│   │   │           │   └── validation/
│   │   │           │       └── CSSmartAPIResponseValidator.java
│   │   │           │
│   │   │           ├── browser/
│   │   │           │   └── CSSmartBrowserManager.java
│   │   │           │
│   │   │           ├── ci/
│   │   │           │   └── CSSmartAzureDevOpsIntegration.java
│   │   │           │
│   │   │           ├── config/
│   │   │           │   ├── CSSmartConfig.java
│   │   │           │   └── PropertyManager.java
│   │   │           │
│   │   │           ├── core/
│   │   │           │   ├── driver/
│   │   │           │   │   └── CSSmartDriver.java
│   │   │           │   ├── element/
│   │   │           │   │   └── CSSmartWebElement.java
│   │   │           │   └── page/
│   │   │           │       └── CSSmartBaseWebpage.java
│   │   │           │
│   │   │           ├── database/
│   │   │           │   └── CSSmartDatabaseManager.java
│   │   │           │
│   │   │           ├── exceptions/
│   │   │           │   └── CSSmartException.java
│   │   │           │
│   │   │           ├── listeners/
│   │   │           │   ├── CSSmartTestListener.java
│   │   │           │   └── CSSmartRetryAnalyzer.java
│   │   │           │
│   │   │           ├── pages/
│   │   │           │   └── CSSmartBasePage.java
│   │   │           │
│   │   │           ├── parallel/
│   │   │           │   └── CSSmartParallelExecution.java
│   │   │           │
│   │   │           ├── reporting/
│   │   │           │   ├── CSSmartReporter.java
│   │   │           │   └── CSSmartTestResult.java
│   │   │           │
│   │   │           ├── runner/
│   │   │           │   ├── CSSmartTestRunner.java
│   │   │           │   └── CSSmartSuiteRunner.java
│   │   │           │
│   │   │           ├── tests/
│   │   │           │   └── CSSmartBaseTest.java
│   │   │           │
│   │   │           └── utils/
│   │   │               ├── CSSmartLogger.java
│   │   │               ├── CSSmartDataLoader.java
│   │   │               └── CSSmartScreenshot.java
│   │   │
│   │   └── resources/
│   │       ├── log4j2.xml
│   │       └── cssmart.properties
│   │
│   └── test/
│       ├── java/
│       │   └── com/
│       │       └── cssmart/
│       │           ├── examples/
│       │           │   ├── CSSmartPipelineExample.java
│       │           │   └── CSSmartDemoTest.java
│       │           │
│       │           └── testcases/
│       │               └── [your test cases]
│       │
│       └── resources/
│           ├── features/
│           │   └── sample-api-test.feature
│           │
│           ├── schemas/
│           │   └── users-schema.json
│           │
│           ├── testdata/
│           │   ├── test-data.xlsx
│           │   └── test-data.csv
│           │
│           └── testng.xml
│
├── downloads/                                  # Default download directory
│
├── cssmart-reports/                           # Generated reports directory
│   ├── screenshots/
│   ├── cssmart-report-[timestamp].html
│   ├── cssmart-report.css
│   └── cssmart-report.js
│
├── cssmart-ai-data/                           # AI learning data directory
│   ├── element-learning.csv
│   ├── page-learning.csv
│   ├── test-execution.csv
│   └── data-patterns.csv
│
├── visual-baseline/                           # Visual testing baselines
│   └── failures/
│
├── generated-tests/                           # Test generation output
│   ├── com/                                   # Generated page objects
│   └── features/                              # Generated feature files
│
├── logs/                                       # Log files directory
│
└── pom.xml                                    # Maven project configuration
Comprehensive Framework Overview
Throughout our conversation, I've provided several key components of the CSSmart automation framework. Here's a complete summary of all the components provided:
1. Core Framework Components

CSSmartBaseTest: Base class for all test classes
CSSmartBasePage: Base class for all page objects
CSSmartFindBy: Custom annotation for element location

2. Browser Management

CSSmartBrowserManager: Dynamic browser switching capability

3. Configuration Management

CSSmartConfig: Framework configuration management
PropertyManager: Property access utility

4. Reporting System

CSSmartReporter: Advanced HTML reporting system
CSSmartTestResult: Test result representation

5. API Testing Framework

CSSmartHTTPClient: Native Java HTTP client
CSSmartAPIResponse: API response handler
CSSmartAPIResponseValidator: Response validation
CSSmartJSONUtils: JSON utilities
CSSmartAPIContext: Context sharing
CSSmartAPITestSteps: BDD step definitions

6. Database Testing

CSSmartDatabaseManager: Database connections and operations

7. CI/CD Integration

CSSmartAzureDevOpsIntegration: Azure DevOps integration

8. Parallel Execution

CSSmartParallelExecution: Parallel test execution support

9. AI-Assisted Testing

CSSmartAITesting: AI-based testing capabilities
SelfHealingLocator: Self-healing element location
VisualAssertions: Visual validation capabilities
TestGenerator: Automatic test artifact generation

10. Utilities

CSSmartLogger: Centralized logging
CSSmartDataLoader: Test data management
CSSmartScreenshot: Screenshot capture utility

Relationship Between Components
The framework follows a modular architecture where:

CSSmartBaseTest uses CSSmartBrowserManager for browser management and CSSmartReporter for reporting
CSSmartBasePage uses CSSmartFindBy for element location and SelfHealingLocator for recovery
CSSmartAITesting enhances test execution with learning capabilities
CSSmartHTTPClient provides API testing capabilities
CSSmartDatabaseManager offers database testing functions
CSSmartAzureDevOpsIntegration connects to CI/CD pipelines

All components are tied together through the configuration in CSSmartConfig and logging through CSSmartLogger.
This comprehensive framework provides a complete solution for web UI testing, API testing, database testing, and AI-assisted testing with advanced reporting capabilities.RetryClaude can make mistakes. Please double-check responses


package com.cssmart.core.driver;

import java.net.URL;
import java.util.concurrent.TimeUnit;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.safari.SafariDriver;
import org.openqa.selenium.remote.RemoteWebDriver;
import org.openqa.selenium.remote.DesiredCapabilities;
import com.cssmart.config.PropertyManager;

/**
 * Centralized driver management for CS Smart Automation Framework
 */
public class CSSmartDriver {
    
    private static ThreadLocal<WebDriver> driverThreadLocal = new ThreadLocal<>();
    private static PropertyManager propertyManager = PropertyManager.getInstance();
    
    /**
     * Initialize the WebDriver based on configuration
     * @return WebDriver instance
     */
    public static WebDriver initializeDriver() {
        String browser = propertyManager.getProperty("browser", "chrome");
        String executionMode = propertyManager.getProperty("execution.mode", "local");
        WebDriver driver;
        
        if ("remote".equalsIgnoreCase(executionMode)) {
            driver = initializeRemoteDriver(browser);
        } else {
            driver = initializeLocalDriver(browser);
        }
        
        // Configure driver settings
        int implicitWait = Integer.parseInt(propertyManager.getProperty("implicit.wait", "10"));
        driver.manage().timeouts().implicitlyWait(implicitWait, TimeUnit.SECONDS);
        driver.manage().window().maximize();
        
        driverThreadLocal.set(driver);
        return driver;
    }
    
    /**
     * Get the current WebDriver instance
     * @return WebDriver instance
     */
    public static WebDriver getDriver() {
        WebDriver driver = driverThreadLocal.get();
        if (driver == null) {
            driver = initializeDriver();
        }
        return driver;
    }
    
    /**
     * Initialize a local WebDriver instance
     * @param browser Browser type
     * @return WebDriver instance
     */
    private static WebDriver initializeLocalDriver(String browser) {
        WebDriver driver;
        
        switch (browser.toLowerCase()) {
            case "firefox":
                driver = new FirefoxDriver();
                break;
            case "edge":
                driver = new EdgeDriver();
                break;
            case "safari":
                driver = new SafariDriver();
                break;
            case "chrome":
            default:
                driver = new ChromeDriver();
                break;
        }
        
        return driver;
    }
    
    /**
     * Initialize a remote WebDriver instance
     * @param browser Browser type
     * @return RemoteWebDriver instance
     */
    private static WebDriver initializeRemoteDriver(String browser) {
        try {
            String hubUrl = propertyManager.getProperty("grid.hub.url", "http://localhost:4444/wd/hub");
            DesiredCapabilities capabilities = new DesiredCapabilities();
            capabilities.setBrowserName(browser);
            
            // Add any additional capabilities from properties
            String platform = propertyManager.getProperty("grid.platform", "");
            if (!platform.isEmpty()) {
                capabilities.setPlatform(org.openqa.selenium.Platform.valueOf(platform));
            }
            
            return new RemoteWebDriver(new URL(hubUrl), capabilities);
        } catch (Exception e) {
            throw new RuntimeException("Failed to initialize remote driver", e);
        }
    }
    
    /**
     * Quit the WebDriver instance
     */
    public static void quitDriver() {
        WebDriver driver = driverThreadLocal.get();
        if (driver != null) {
            driver.quit();
            driverThreadLocal.remove();
        }
    }
}

package com.cssmart.core.element;

import java.time.Duration;
import java.util.List;
import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;
import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.config.PropertyManager;
import com.cssmart.ai.healing.SelfHealingLocator;

/**
 * Base element implementation for CS Smart Automation Framework
 */
public class CSSmartWebElement implements WebElement {
    
    private By locator;
    private WebElement element;
    private String elementName;
    private PropertyManager propertyManager = PropertyManager.getInstance();
    private boolean selfHealingEnabled;
    
    /**
     * Constructor for CSSmartWebElement
     * @param locator Element locator
     * @param elementName Name of the element
     */
    public CSSmartWebElement(By locator, String elementName) {
        this.locator = locator;
        this.elementName = elementName;
        this.selfHealingEnabled = Boolean.parseBoolean(
            propertyManager.getProperty("self.healing.enabled", "false"));
    }
    
    /**
     * Get the underlying WebElement
     * @return WebElement instance
     */
    private WebElement getElement() {
        if (element == null) {
            try {
                element = CSSmartDriver.getDriver().findElement(locator);
            } catch (NoSuchElementException e) {
                if (selfHealingEnabled) {
                    try {
                        // Attempt to heal the locator
                        By healedLocator = SelfHealingLocator.findAlternativeLocator(locator, elementName);
                        if (healedLocator != null) {
                            element = CSSmartDriver.getDriver().findElement(healedLocator);
                            // Update the locator for future use
                            this.locator = healedLocator;
                        } else {
                            throw e;
                        }
                    } catch (Exception healingEx) {
                        throw new ElementNotFoundException(
                            "Element not found: " + elementName + " with locator: " + locator, e);
                    }
                } else {
                    throw new ElementNotFoundException(
                        "Element not found: " + elementName + " with locator: " + locator, e);
                }
            }
        }
        return element;
    }
    
    /**
     * Wait for element to be visible
     * @param timeoutSeconds Timeout in seconds
     * @return CSSmartWebElement instance
     */
    public CSSmartWebElement waitForVisible(int timeoutSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(CSSmartDriver.getDriver(), Duration.ofSeconds(timeoutSeconds));
            wait.until(ExpectedConditions.visibilityOfElementLocated(locator));
            return this;
        } catch (TimeoutException e) {
            throw new ElementWaitTimeoutException(
                "Timeout waiting for element visibility: " + elementName, e);
        }
    }
    
    /**
     * Wait for element to be clickable
     * @param timeoutSeconds Timeout in seconds
     * @return CSSmartWebElement instance
     */
    public CSSmartWebElement waitForClickable(int timeoutSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(CSSmartDriver.getDriver(), Duration.ofSeconds(timeoutSeconds));
            wait.until(ExpectedConditions.elementToBeClickable(locator));
            return this;
        } catch (TimeoutException e) {
            throw new ElementWaitTimeoutException(
                "Timeout waiting for element to be clickable: " + elementName, e);
        }
    }
    
    /**
     * Click on the element with retry logic
     */
    public void clickWithRetry() {
        int maxRetries = Integer.parseInt(propertyManager.getProperty("click.max.retries", "3"));
        int retryIntervalMs = Integer.parseInt(propertyManager.getProperty("click.retry.interval", "500"));
        
        for (int attempt = 0; attempt < maxRetries; attempt++) {
            try {
                this.click();
                return;
            } catch (WebDriverException e) {
                if (attempt == maxRetries - 1) {
                    throw new ElementInteractionException(
                        "Failed to click element after " + maxRetries + " attempts: " + elementName, e);
                }
                try {
                    Thread.sleep(retryIntervalMs);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }
    
    /**
     * Type text into the element
     * @param text Text to type
     */
    public void type(String text) {
        try {
            WebElement element = getElement();
            element.clear();
            element.sendKeys(text);
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to type text into element: " + elementName, e);
        }
    }
    
    /**
     * Check if element exists
     * @return true if element exists, false otherwise
     */
    public boolean exists() {
        try {
            CSSmartDriver.getDriver().findElement(locator);
            return true;
        } catch (NoSuchElementException e) {
            return false;
        }
    }
    
    /**
     * Get text from element with additional handling
     * @return Text from element
     */
    public String getTextSafe() {
        try {
            String visibleText = getElement().getText();
            if (visibleText == null || visibleText.isEmpty()) {
                return getElement().getAttribute("value");
            }
            return visibleText;
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to get text from element: " + elementName, e);
        }
    }
    
    // WebElement interface implementation
    
    @Override
    public void click() {
        try {
            getElement().click();
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to click element: " + elementName, e);
        }
    }

    @Override
    public void submit() {
        try {
            getElement().submit();
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to submit element: " + elementName, e);
        }
    }

    @Override
    public void sendKeys(CharSequence... keysToSend) {
        try {
            getElement().sendKeys(keysToSend);
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to send keys to element: " + elementName, e);
        }
    }

    @Override
    public void clear() {
        try {
            getElement().clear();
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to clear element: " + elementName, e);
        }
    }

    @Override
    public String getTagName() {
        try {
            return getElement().getTagName();
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to get tag name for element: " + elementName, e);
        }
    }

    @Override
    public String getAttribute(String name) {
        try {
            return getElement().getAttribute(name);
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to get attribute for element: " + elementName, e);
        }
    }

    @Override
    public boolean isSelected() {
        try {
            return getElement().isSelected();
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to check if element is selected: " + elementName, e);
        }
    }

    @Override
    public boolean isEnabled() {
        try {
            return getElement().isEnabled();
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to check if element is enabled: " + elementName, e);
        }
    }

    @Override
    public String getText() {
        try {
            return getElement().getText();
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to get text from element: " + elementName, e);
        }
    }

    @Override
    public List<WebElement> findElements(By by) {
        try {
            return getElement().findElements(by);
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to find child elements: " + elementName, e);
        }
    }

    @Override
    public WebElement findElement(By by) {
        try {
            return getElement().findElement(by);
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to find child element: " + elementName, e);
        }
    }

    @Override
    public boolean isDisplayed() {
        try {
            return getElement().isDisplayed();
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to check if element is displayed: " + elementName, e);
        }
    }

    @Override
    public Point getLocation() {
        try {
            return getElement().getLocation();
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to get location of element: " + elementName, e);
        }
    }

    @Override
    public Dimension getSize() {
        try {
            return getElement().getSize();
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to get size of element: " + elementName, e);
        }
    }

    @Override
    public Rectangle getRect() {
        try {
            return getElement().getRect();
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to get rect of element: " + elementName, e);
        }
    }

    @Override
    public String getCssValue(String propertyName) {
        try {
            return getElement().getCssValue(propertyName);
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to get CSS value of element: " + elementName, e);
        }
    }
    
    @Override
    public <X> X getScreenshotAs(OutputType<X> target) throws WebDriverException {
        try {
            return getElement().getScreenshotAs(target);
        } catch (WebDriverException e) {
            throw new ElementInteractionException(
                "Failed to get screenshot of element: " + elementName, e);
        }
    }
}

package com.cssmart.core.page;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.PageFactory;
import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.core.element.CSSmartWebElement;
import com.cssmart.annotations.processors.FindByAnnotationProcessor;

/**
 * Base page object implementation for CS Smart Automation Framework
 */
public class CSSmartBaseWebpage {
    
    protected WebDriver driver;
    private Map<String, CSSmartWebElement> elements = new HashMap<>();
    private String pageName;
    
    /**
     * Constructor for CSSmartBaseWebpage
     */
    public CSSmartBaseWebpage() {
        this.driver = CSSmartDriver.getDriver();
        this.pageName = getClass().getSimpleName();
        initializeElements();
    }
    
    /**
     * Initialize elements with @FindBy annotations
     */
    private void initializeElements() {
        // First initialize with Selenium's PageFactory
        PageFactory.initElements(driver, this);
        
        // Then process with custom annotation processor for additional functionality
        for (Field field : getClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(FindBy.class)) {
                field.setAccessible(true);
                try {
                    FindBy findBy = field.getAnnotation(FindBy.class);
                    By locator = FindByAnnotationProcessor.processAnnotation(findBy);
                    
                    if (field.getType() == CSSmartWebElement.class) {
                        String elementName = field.getName();
                        CSSmartWebElement element = new CSSmartWebElement(locator, elementName);
                        field.set(this, element);
                        elements.put(elementName, element);
                    }
                } catch (Exception e) {
                    throw new RuntimeException("Failed to initialize element: " + field.getName(), e);
                }
            }
        }
    }
    
    /**
     * Open a specific URL
     * @param url URL to open
     * @return Current page instance for chaining
     */
    public CSSmartBaseWebpage open(String url) {
        driver.get(url);
        return this;
    }
    
    /**
     * Get the page title
     * @return Page title
     */
    public String getTitle() {
        return driver.getTitle();
    }
    
    /**
     * Get element by name
     * @param elementName Element name
     * @return CSSmartWebElement instance
     */
    public CSSmartWebElement getElement(String elementName) {
        CSSmartWebElement element = elements.get(elementName);
        if (element == null) {
            throw new IllegalArgumentException("Element not found: " + elementName);
        }
        return element;
    }
    
    /**
     * Wait for page to load
     * @param timeoutSeconds Timeout in seconds
     * @return Current page instance for chaining
     */
    public CSSmartBaseWebpage waitForPageLoad(int timeoutSeconds) {
        // Implementation for waiting for page to load
        // Can be customized based on specific needs
        return this;
    }
    
    /**
     * Check if page is loaded
     * @return true if page is loaded, false otherwise
     */
    public boolean isLoaded() {
        // Implementation for checking if page is loaded
        // Can be customized based on specific needs
        return true;
    }
    
    /**
     * Get the current URL
     * @return Current URL
     */
    public String getCurrentUrl() {
        return driver.getCurrentUrl();
    }
    
    /**
     * Get the page source
     * @return Page source
     */
    public String getPageSource() {
        return driver.getPageSource();
    }
}

// Exception classes for better error handling
package com.cssmart.core.exceptions;

public class ElementNotFoundException extends RuntimeException {
    public ElementNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

public class ElementWaitTimeoutException extends RuntimeException {
    public ElementWaitTimeoutException(String message, Throwable cause) {
        super(message, cause);
    }
}

public class ElementInteractionException extends RuntimeException {
    public ElementInteractionException(String message, Throwable cause) {
        super(message, cause);
    }
}




package com.cssmart.config;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

/**
 * Property manager for CS Smart Automation Framework
 */
public class PropertyManager {
    
    private static PropertyManager instance;
    private Properties properties;
    private Map<String, String> overrideProperties;
    
    /**
     * Private constructor for singleton
     */
    private PropertyManager() {
        properties = new Properties();
        overrideProperties = new HashMap<>();
        loadDefaultProperties();
    }
    
    /**
     * Get singleton instance
     * @return PropertyManager instance
     */
    public static synchronized PropertyManager getInstance() {
        if (instance == null) {
            instance = new PropertyManager();
        }
        return instance;
    }
    
    /**
     * Load default properties
     */
    private void loadDefaultProperties() {
        try {
            // Load global properties
            loadProperties("config/cssmart.properties");
            
            // Load environment specific properties
            String env = System.getProperty("env", "dev");
            loadProperties("config/" + env + ".properties");
            
            // Load test specific properties if available
            String testSuite = System.getProperty("test.suite", "");
            if (!testSuite.isEmpty()) {
                loadProperties("config/suites/" + testSuite + ".properties");
            }
        } catch (Exception e) {
            System.err.println("Failed to load default properties: " + e.getMessage());
        }
    }
    
    /**
     * Load properties from file
     * @param filePath Path to properties file
     */
    public void loadProperties(String filePath) {
        try (FileInputStream fis = new FileInputStream(filePath)) {
            properties.load(fis);
        } catch (IOException e) {
            System.err.println("Failed to load properties from " + filePath + ": " + e.getMessage());
        }
    }
    
    /**
     * Set property
     * @param key Property key
     * @param value Property value
     */
    public void setProperty(String key, String value) {
        overrideProperties.put(key, value);
    }
    
    /**
     * Get property
     * @param key Property key
     * @param defaultValue Default value if property is not found
     * @return Property value
     */
    public String getProperty(String key, String defaultValue) {
        // Check override properties first
        if (overrideProperties.containsKey(key)) {
            return overrideProperties.get(key);
        }
        
        // Then check system properties
        String sysValue = System.getProperty(key);
        if (sysValue != null) {
            return sysValue;
        }
        
        // Finally check properties file
        return properties.getProperty(key, defaultValue);
    }
    
    /**
     * Get property
     * @param key Property key
     * @return Property value or null if not found
     */
    public String getProperty(String key) {
        return getProperty(key, null);
    }
    
    /**
     * Get property as boolean
     * @param key Property key
     * @param defaultValue Default value if property is not found
     * @return Property value as boolean
     */
    public boolean getBooleanProperty(String key, boolean defaultValue) {
        String value = getProperty(key);
        return value != null ? Boolean.parseBoolean(value) : defaultValue;
    }
    
    /**
     * Get property as int
     * @param key Property key
     * @param defaultValue Default value if property is not found
     * @return Property value as int
     */
    public int getIntProperty(String key, int defaultValue) {
        String value = getProperty(key);
        try {
            return value != null ? Integer.parseInt(value) : defaultValue;
        } catch (NumberFormatException e) {
            return defaultValue;
        }
    }
    
    /**
     * Clear all properties
     */
    public void clearProperties() {
        properties.clear();
        overrideProperties.clear();
        loadDefaultProperties();
    }
}

package com.cssmart.config;

import java.io.File;

/**
 * Environment manager for CS Smart Automation Framework
 */
public class EnvironmentManager {
    
    private static EnvironmentManager instance;
    private PropertyManager propertyManager;
    
    /**
     * Private constructor for singleton
     */
    private EnvironmentManager() {
        propertyManager = PropertyManager.getInstance();
    }
    
    /**
     * Get singleton instance
     * @return EnvironmentManager instance
     */
    public static synchronized EnvironmentManager getInstance() {
        if (instance == null) {
            instance = new EnvironmentManager();
        }
        return instance;
    }
    
    /**
     * Get base URL for current environment
     * @return Base URL
     */
    public String getBaseUrl() {
        return propertyManager.getProperty("env.base.url");
    }
    
    /**
     * Get API URL for current environment
     * @return API URL
     */
    public String getApiUrl() {
        return propertyManager.getProperty("env.api.url");
    }
    
    /**
     * Get database connection string for current environment
     * @return Database connection string
     */
    public String getDbConnectionString() {
        return propertyManager.getProperty("env.db.connection");
    }
    
    /**
     * Get database username for current environment
     * @return Database username
     */
    public String getDbUsername() {
        return propertyManager.getProperty("env.db.username");
    }
    
    /**
     * Get database password for current environment
     * @return Database password
     */
    public String getDbPassword() {
        return propertyManager.getProperty("env.db.password");
    }
    
    /**
     * Get current environment name
     * @return Environment name
     */
    public String getEnvironmentName() {
        return System.getProperty("env", "dev");
    }
    
    /**
     * Get path to test data for current environment
     * @return Path to test data
     */
    public String getTestDataPath() {
        String basePath = propertyManager.getProperty("testdata.base.path", "src/test/resources/testdata");
        String envPath = basePath + File.separator + getEnvironmentName();
        
        // Create directory if it doesn't exist
        File dir = new File(envPath);
        if (!dir.exists()) {
            dir.mkdirs();
        }
        
        return envPath;
    }
    
    /**
     * Get screenshot path for current environment
     * @return Path to screenshots
     */
    public String getScreenshotPath() {
        String basePath = propertyManager.getProperty("screenshot.path", "target/screenshots");
        String envPath = basePath + File.separator + getEnvironmentName();
        
        // Create directory if it doesn't exist
        File dir = new File(envPath);
        if (!dir.exists()) {
            dir.mkdirs();
        }
        
        return envPath;
    }
}

package com.cssmart.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for test steps in CS Smart Automation Framework
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface CSSmartTestStep {
    /**
     * Step description or Gherkin step
     */
    String value();
    
    /**
     * Step group for organization
     */
    String group() default "";
    
    /**
     * Order of execution for step
     */
    int order() default 0;
    
    /**
     * Whether to take screenshot after step execution
     */
    boolean takeScreenshot() default false;
    
    /**
     * Whether to continue execution on step failure
     */
    boolean continueOnFailure() default false;
}

/**
 * Annotation for data providers in CS Smart Automation Framework
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface CSSmartDataProvider {
    /**
     * Data provider name
     */
    String name() default "";
    
    /**
     * Data source type (e.g., excel, csv, json, db)
     */
    String source() default "";
    
    /**
     * Path to data source
     */
    String path() default "";
    
    /**
     * Sheet name for Excel data source
     */
    String sheet() default "";
    
    /**
     * SQL query for database data source
     */
    String query() default "";
    
    /**
     * Filter criteria for data
     */
    String filter() default "";
    
    /**
     * Whether to parallel execute data provider
     */
    boolean parallel() default false;
}

package com.cssmart.annotations.processors;

import java.util.HashMap;
import java.util.Map;
import org.openqa.selenium.By;
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.How;

/**
 * Processor for @FindBy annotations
 */
public class FindByAnnotationProcessor {
    
    /**
     * Process FindBy annotation to get By locator
     * @param findBy FindBy annotation
     * @return By locator
     */
    public static By processAnnotation(FindBy findBy) {
        How how = findBy.how();
        String using = findBy.using();
        
        // If how is not specified, determine it from other parameters
        if (how == How.UNSET) {
            if (!findBy.id().isEmpty()) {
                return By.id(findBy.id());
            } else if (!findBy.name().isEmpty()) {
                return By.name(findBy.name());
            } else if (!findBy.className().isEmpty()) {
                return By.className(findBy.className());
            } else if (!findBy.css().isEmpty()) {
                return By.cssSelector(findBy.css());
            } else if (!findBy.tagName().isEmpty()) {
                return By.tagName(findBy.tagName());
            } else if (!findBy.linkText().isEmpty()) {
                return By.linkText(findBy.linkText());
            } else if (!findBy.partialLinkText().isEmpty()) {
                return By.partialLinkText(findBy.partialLinkText());
            } else if (!findBy.xpath().isEmpty()) {
                return By.xpath(findBy.xpath());
            } else {
                throw new IllegalArgumentException("Cannot determine locator type from FindBy annotation");
            }
        } else {
            // Convert How enum to By locator
            switch (how) {
                case ID:
                    return By.id(using);
                case NAME:
                    return By.name(using);
                case CLASS_NAME:
                    return By.className(using);
                case CSS:
                    return By.cssSelector(using);
                case TAG_NAME:
                    return By.tagName(using);
                case LINK_TEXT:
                    return By.linkText(using);
                case PARTIAL_LINK_TEXT:
                    return By.partialLinkText(using);
                case XPATH:
                    return By.xpath(using);
                default:
                    throw new IllegalArgumentException("Unsupported locator type: " + how);
            }
        }
    }
}

/**
 * Processor for @CSSmartTestStep annotations
 */
public class CSSmartTestStepProcessor {
    
    private static Map<String, CSSmartTestStepInfo> testStepRegistry = new HashMap<>();
    
    /**
     * Register a test step
     * @param methodName Method name
     * @param className Class name
     * @param step CSSmartTestStep annotation
     */
    public static void registerTestStep(String methodName, String className, CSSmartTestStep step) {
        CSSmartTestStepInfo info = new CSSmartTestStepInfo(methodName, className, 
            step.value(), step.group(), step.order(), step.takeScreenshot(), step.continueOnFailure());
        testStepRegistry.put(step.value(), info);
    }
    
    /**
     * Get test step by description
     * @param stepDescription Step description
     * @return CSSmartTestStepInfo
     */
    public static CSSmartTestStepInfo getTestStepInfo(String stepDescription) {
        return testStepRegistry.get(stepDescription);
    }
    
    /**
     * Clear test step registry
     */
    public static void clearTestStepRegistry() {
        testStepRegistry.clear();
    }
    
    /**
     * Class to hold test step information
     */
    public static class CSSmartTestStepInfo {
        private String methodName;
        private String className;
        private String description;
        private String group;
        private int order;
        private boolean takeScreenshot;
        private boolean continueOnFailure;
        
        public CSSmartTestStepInfo(String methodName, String className, String description, 
                String group, int order, boolean takeScreenshot, boolean continueOnFailure) {
            this.methodName = methodName;
            this.className = className;
            this.description = description;
            this.group = group;
            this.order = order;
            this.takeScreenshot = takeScreenshot;
            this.continueOnFailure = continueOnFailure;
        }
        
        public String getMethodName() {
            return methodName;
        }
        
        public String getClassName() {
            return className;
        }
        
        public String getDescription() {
            return description;
        }
        
        public String getGroup() {
            return group;
        }
        
        public int getOrder() {
            return order;
        }
        
        public boolean isTakeScreenshot() {
            return takeScreenshot;
        }
        
        public boolean isContinueOnFailure() {
            return continueOnFailure;
        }
    }
}

/**
 * Processor for @CSSmartDataProvider annotations
 */
public class CSSmartDataProviderProcessor {
    
    private static Map<String, CSSmartDataProviderInfo> dataProviderRegistry = new HashMap<>();
    
    /**
     * Register a data provider
     * @param methodName Method name
     * @param className Class name
     * @param dataProvider CSSmartDataProvider annotation
     */
    public static void registerDataProvider(String methodName, String className, CSSmartDataProvider dataProvider) {
        String name = dataProvider.name().isEmpty() ? methodName : dataProvider.name();
        CSSmartDataProviderInfo info = new CSSmartDataProviderInfo(methodName, className, 
            name, dataProvider.source(), dataProvider.path(), dataProvider.sheet(), 
            dataProvider.query(), dataProvider.filter(), dataProvider.parallel());
        dataProviderRegistry.put(name, info);
    }
    
    /**
     * Get data provider by name
     * @param name Data provider name
     * @return CSSmartDataProviderInfo
     */
    public static CSSmartDataProviderInfo getDataProviderInfo(String name) {
        return dataProviderRegistry.get(name);
    }
    
    /**
     * Clear data provider registry
     */
    public static void clearDataProviderRegistry() {
        dataProviderRegistry.clear();
    }
    
    /**
     * Class to hold data provider information
     */
    public static class CSSmartDataProviderInfo {
        private String methodName;
        private String className;
        private String name;
        private String source;
        private String path;
        private String sheet;
        private String query;
        private String filter;
        private boolean parallel;
        
        public CSSmartDataProviderInfo(String methodName, String className, String name, 
                String source, String path, String sheet, String query, String filter, boolean parallel) {
            this.methodName = methodName;
            this.className = className;
            this.name = name;
            this.source = source;
            this.path = path;
            this.sheet = sheet;
            this.query = query;
            this.filter = filter;
            this.parallel = parallel;
        }
        
        public String getMethodName() {
            return methodName;
        }
        
        public String getClassName() {
            return className;
        }
        
        public String getName() {
            return name;
        }
        
        public String getSource() {
            return source;
        }
        
        public String getPath() {
            return path;
        }
        
        public String getSheet() {
            return sheet;
        }
        
        public String getQuery() {
            return query;
        }
        
        public String getFilter() {
            return filter;
        }
        
        public boolean isParallel() {
            return parallel;
        }
    }
}



package com.cssmart.bdd.parser;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Feature file parser for CS Smart Automation Framework
 */
public class FeatureFileParser {
    
    private static final String FEATURE_PATTERN = "Feature:\\s*(.+)";
    private static final String SCENARIO_PATTERN = "Scenario:\\s*(.+)";
    private static final String SCENARIO_OUTLINE_PATTERN = "Scenario Outline:\\s*(.+)";
    private static final String STEP_PATTERN = "(Given|When|Then|And|But)\\s+(.+)";
    private static final String EXAMPLES_PATTERN = "Examples:";
    private static final String TAG_PATTERN = "@([\\w\\.-]+)";
    
    /**
     * Parse feature file
     * @param filePath Path to feature file
     * @return FeatureModel
     */
    public static FeatureModel parseFeatureFile(String filePath) {
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            String line;
            FeatureModel feature = new FeatureModel();
            feature.setFilePath(filePath);
            
            List<String> featureTags = new ArrayList<>();
            boolean parsingFeature = false;
            boolean parsingScenario = false;
            boolean parsingScenarioOutline = false;
            boolean parsingExamples = false;
            
            ScenarioModel currentScenario = null;
            List<String> currentTags = new ArrayList<>();
            
            List<String> headerRow = null;
            List<Map<String, String>> examples = new ArrayList<>();
            
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                
                // Skip empty lines and comments
                if (line.isEmpty() || line.startsWith("#")) {
                    continue;
                }
                
                // Parse tags
                if (line.startsWith("@")) {
                    Matcher tagMatcher = Pattern.compile(TAG_PATTERN).matcher(line);
                    while (tagMatcher.find()) {
                        currentTags.add(tagMatcher.group(1));
                    }
                }
                
                // Parse feature
                Matcher featureMatcher = Pattern.compile(FEATURE_PATTERN).matcher(line);
                if (featureMatcher.matches()) {
                    feature.setName(featureMatcher.group(1).trim());
                    feature.setTags(new ArrayList<>(currentTags));
                    featureTags.addAll(currentTags);
                    currentTags.clear();
                    parsingFeature = true;
                    continue;
                }
                
                // Parse scenario
                Matcher scenarioMatcher = Pattern.compile(SCENARIO_PATTERN).matcher(line);
                if (scenarioMatcher.matches()) {
                    if (currentScenario != null) {
                        feature.addScenario(currentScenario);
                    }
                    
                    currentScenario = new ScenarioModel();
                    currentScenario.setName(scenarioMatcher.group(1).trim());
                    currentScenario.setTags(new ArrayList<>(currentTags));
                    // Add feature tags to scenario
                    currentScenario.getTags().addAll(featureTags);
                    currentTags.clear();
                    
                    parsingScenario = true;
                    parsingScenarioOutline = false;
                    parsingExamples = false;
                    continue;
                }
                
                // Parse scenario outline
                Matcher scenarioOutlineMatcher = Pattern.compile(SCENARIO_OUTLINE_PATTERN).matcher(line);
                if (scenarioOutlineMatcher.matches()) {
                    if (currentScenario != null) {
                        feature.addScenario(currentScenario);
                    }
                    
                    currentScenario = new ScenarioModel();
                    currentScenario.setName(scenarioOutlineMatcher.group(1).trim());
                    currentScenario.setTags(new ArrayList<>(currentTags));
                    // Add feature tags to scenario
                    currentScenario.getTags().addAll(featureTags);
                    currentScenario.setOutline(true);
                    currentTags.clear();
                    
                    parsingScenario = false;
                    parsingScenarioOutline = true;
                    parsingExamples = false;
                    examples = new ArrayList<>();
                    continue;
                }
                
                // Parse examples
                Matcher examplesMatcher = Pattern.compile(EXAMPLES_PATTERN).matcher(line);
                if (examplesMatcher.matches() && parsingScenarioOutline) {
                    parsingExamples = true;
                    continue;
                }
                
                // Parse examples table
                if (parsingExamples) {
                    if (line.startsWith("|") && line.endsWith("|")) {
                        // Split by pipe and trim
                        String[] cells = line.split("\\|");
                        List<String> rowData = new ArrayList<>();
                        
                        for (int i = 1; i < cells.length; i++) {
                            rowData.add(cells[i].trim());
                        }
                        
                        if (headerRow == null) {
                            // This is the header row
                            headerRow = rowData;
                        } else {
                            // This is a data row
                            Map<String, String> dataRow = new HashMap<>();
                            for (int i = 0; i < headerRow.size() && i < rowData.size(); i++) {
                                dataRow.put(headerRow.get(i), rowData.get(i));
                            }
                            examples.add(dataRow);
                        }
                    } else {
                        // End of examples table
                        parsingExamples = false;
                        
                        if (currentScenario != null) {
                            currentScenario.setExamples(examples);
                            headerRow = null;
                        }
                    }
                    continue;
                }
                
                // Parse steps
                Matcher stepMatcher = Pattern.compile(STEP_PATTERN).matcher(line);
                if (stepMatcher.matches() && (parsingScenario || parsingScenarioOutline)) {
                    if (currentScenario != null) {
                        StepModel step = new StepModel();
                        step.setType(stepMatcher.group(1).trim());
                        step.setText(stepMatcher.group(2).trim());
                        currentScenario.addStep(step);
                    }
                    continue;
                }
                
                // Parse background or other feature file elements as needed
            }
            
            // Add the last scenario
            if (currentScenario != null) {
                feature.addScenario(currentScenario);
            }
            
            return feature;
        } catch (IOException e) {
            throw new RuntimeException("Failed to parse feature file: " + filePath, e);
        }
    }
    
    /**
     * Feature model class
     */
    public static class FeatureModel {
        private String name;
        private String filePath;
        private List<String> tags = new ArrayList<>();
        private List<ScenarioModel> scenarios = new ArrayList<>();
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
        
        public String getFilePath() {
            return filePath;
        }
        
        public void setFilePath(String filePath) {
            this.filePath = filePath;
        }
        
        public List<String> getTags() {
            return tags;
        }
        
        public void setTags(List<String> tags) {
            this.tags = tags;
        }
        
        public List<ScenarioModel> getScenarios() {
            return scenarios;
        }
        
        public void addScenario(ScenarioModel scenario) {
            this.scenarios.add(scenario);
        }
    }
    
    /**
     * Scenario model class
     */
    public static class ScenarioModel {
        private String name;
        private List<String> tags = new ArrayList<>();
        private List<StepModel> steps = new ArrayList<>();
        private boolean isOutline;
        private List<Map<String, String>> examples = new ArrayList<>();
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
        
        public List<String> getTags() {
            return tags;
        }
        
        public void setTags(List<String> tags) {
            this.tags = tags;
        }
        
        public List<StepModel> getSteps() {
            return steps;
        }
        
        public void addStep(StepModel step) {
            this.steps.add(step);
        }
        
        public boolean isOutline() {
            return isOutline;
        }
        
        public void setOutline(boolean outline) {
            isOutline = outline;
        }
        
        public List<Map<String, String>> getExamples() {
            return examples;
        }
        
        public void setExamples(List<Map<String, String>> examples) {
            this.examples = examples;
        }
    }
    
    /**
     * Step model class
     */
    public static class StepModel {
        private String type;
        private String text;
        
        public String getType() {
            return type;
        }
        
        public void setType(String type) {
            this.type = type;
        }
        
        public String getText() {
            return text;
        }
        
        public void setText(String text) {
            this.text = text;
        }
        
        public String getFullText() {
            return type + " " + text;
        }
    }
}

package com.cssmart.bdd.runner;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import com.cssmart.annotations.CSSmartTestStep;
import com.cssmart.annotations.processors.CSSmartTestStepProcessor;
import com.cssmart.bdd.parser.FeatureFileParser;
import com.cssmart.bdd.parser.FeatureFileParser.FeatureModel;
import com.cssmart.bdd.parser.FeatureFileParser.ScenarioModel;
import com.cssmart.bdd.parser.FeatureFileParser.StepModel;
import com.cssmart.reporting.ExecutionContext;
import com.cssmart.reporting.HTMLReporter;
import com.cssmart.reporting.TestStatus;

/**
 * BDD test runner for CS Smart Automation Framework
 */
public class BDDTestRunner {
    
    private static final Map<String, Object> stepDefinitionInstances = new HashMap<>();
    private static final List<Class<?>> stepDefinitionClasses = new ArrayList<>();
    private ExecutionContext executionContext;
    private HTMLReporter reporter;
    
    /**
     * Constructor for BDDTestRunner
     */
    public BDDTestRunner() {
        executionContext = new ExecutionContext();
        reporter = new HTMLReporter(executionContext);
    }
    
    /**
     * Register step definition class
     * @param stepDefinitionClass Step definition class
     */
    public static void registerStepDefinition(Class<?> stepDefinitionClass) {
        stepDefinitionClasses.add(stepDefinitionClass);
        
        // Process all methods with @CSSmartTestStep annotation
        for (Method method : stepDefinitionClass.getDeclaredMethods()) {
            if (method.isAnnotationPresent(CSSmartTestStep.class)) {
                CSSmartTestStep annotation = method.getAnnotation(CSSmartTestStep.class);
                CSSmartTestStepProcessor.registerTestStep(
                    method.getName(), stepDefinitionClass.getName(), annotation);
            }
        }
    }
    
    /**
     * Run feature file
     * @param featureFilePath Path to feature file
     */
    public void runFeature(String featureFilePath) {
        FeatureModel feature = FeatureFileParser.parseFeatureFile(featureFilePath);
        executionContext.startFeature(feature.getName(), feature.getTags());
        reporter.startFeature(feature);
        
        for (ScenarioModel scenario : feature.getScenarios()) {
            if (scenario.isOutline()) {
                runScenarioOutline(scenario);
            } else {
                runScenario(scenario);
            }
        }
        
        executionContext.endFeature();
        reporter.endFeature();
        reporter.generateReport();
    }
    
    /**
     * Run scenario
     * @param scenario Scenario model
     */
    private void runScenario(ScenarioModel scenario) {
        executionContext.startScenario(scenario.getName(), scenario.getTags());
        reporter.startScenario(scenario);
        
        try {
            for (StepModel step : scenario.getSteps()) {
                runStep(step);
            }
            executionContext.setScenarioStatus(TestStatus.PASSED);
        } catch (Exception e) {
            executionContext.setScenarioStatus(TestStatus.FAILED);
            executionContext.setScenarioError(e);
        }
        
        executionContext.endScenario();
        reporter.endScenario();
    }
    
    /**
     * Run scenario outline
     * @param scenario Scenario outline model
     */
    private void runScenarioOutline(ScenarioModel scenario) {
        List<Map<String, String>> examples = scenario.getExamples();
        
        for (int i = 0; i < examples.size(); i++) {
            Map<String, String> example = examples.get(i);
            String scenarioName = scenario.getName() + " (Example " + (i + 1) + ")";
            
            executionContext.startScenario(scenarioName, scenario.getTags());
            reporter.startScenarioOutlineIteration(scenario, i + 1);
            
            try {
                for (StepModel step : scenario.getSteps()) {
                    // Replace parameters in step text
                    String stepText = replaceParameters(step.getText(), example);
                    StepModel replacedStep = new StepModel();
                    replacedStep.setType(step.getType());
                    replacedStep.setText(stepText);
                    
                    runStep(replacedStep);
                }
                executionContext.setScenarioStatus(TestStatus.PASSED);
            } catch (Exception e) {
                executionContext.setScenarioStatus(TestStatus.FAILED);
                executionContext.setScenarioError(e);
            }
            
            executionContext.endScenario();
            reporter.endScenarioOutlineIteration();
        }
    }
    
    /**
     * Run step
     * @param step Step model
     * @throws Exception If step execution fails
     */
    private void runStep(StepModel step) throws Exception {
        executionContext.startStep(step.getFullText());
        reporter.startStep(step);
        
        try {
            executeStep(step.getText());
            executionContext.setStepStatus(TestStatus.PASSED);
        } catch (Exception e) {
            executionContext.setStepStatus(TestStatus.FAILED);
            executionContext.setStepError(e);
            reporter.endStep();
            executionContext.endStep();
            throw e;
        }
        
        reporter.endStep();
        executionContext.endStep();
    }
    
    /**
     * Execute step
     * @param stepText Step text
     * @throws Exception If step execution fails
     */
    private void executeStep(String stepText) throws Exception {
        CSSmartTestStepProcessor.CSSmartTestStepInfo stepInfo = findMatchingStepDefinition(stepText);
        
        if (stepInfo == null) {
            throw new RuntimeException("No step definition found for: " + stepText);
        }
        
        // Get or create instance of step definition class
        Object instance = getStepDefinitionInstance(stepInfo.getClassName());
        
        // Get method and invoke
        Method method = instance.getClass().getDeclaredMethod(stepInfo.getMethodName());
        method.setAccessible(true);
        method.invoke(instance);
    }
    
    /**
     * Find matching step definition
     * @param stepText Step text
     * @return Step definition info
     */
    private CSSmartTestStepProcessor.CSSmartTestStepInfo findMatchingStepDefinition(String stepText) {
        // Direct match
        CSSmartTestStepProcessor.CSSmartTestStepInfo stepInfo = 
            CSSmartTestStepProcessor.getTestStepInfo(stepText);
        
        if (stepInfo != null) {
            return stepInfo;
        }
        
        // Regex match - this is a simplified implementation
        // In a complete framework, this would use proper regex matching
        for (Class<?> clazz : stepDefinitionClasses) {
            for (Method method : clazz.getDeclaredMethods()) {
                if (method.isAnnotationPresent(CSSmartTestStep.class)) {
                    CSSmartTestStep annotation = method.getAnnotation(CSSmartTestStep.class);
                    String pattern = annotation.value();
                    
                    if (pattern.contains("(.+)") || pattern.contains("(\\d+)")) {
                        String regex = pattern
                            .replace("(", "\\(")
                            .replace(")", "\\)")
                            .replace("(.+)", ".*")
                            .replace("(\\d+)", "\\d+");
                        
                        if (stepText.matches(regex)) {
                            return CSSmartTestStepProcessor.getTestStepInfo(pattern);
                        }
                    }
                }
            }
        }
        
        return null;
    }
    
    /**
     * Get or create instance of step definition class
     * @param className Class name
     * @return Instance of step definition class
     * @throws Exception If instance creation fails
     */
    private Object getStepDefinitionInstance(String className) throws Exception {
        Object instance = stepDefinitionInstances.get(className);
        
        if (instance == null) {
            Class<?> clazz = Class.forName(className);
            instance = clazz.getDeclaredConstructor().newInstance();
            stepDefinitionInstances.put(className, instance);
        }
        
        return instance;
    }
    
    /**
     * Replace parameters in step text
     * @param text Step text
     * @param parameters Parameters
     * @return Step text with parameters replaced
     */
    private String replaceParameters(String text, Map<String, String> parameters) {
        String result = text;
        
        for (Map.Entry<String, String> entry : parameters.entrySet()) {
            result = result.replace("<" + entry.getKey() + ">", entry.getValue());
        }
        
        return result;
    }
}

package com.cssmart.reporting;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import com.cssmart.bdd.parser.FeatureFileParser.FeatureModel;
import com.cssmart.bdd.parser.FeatureFileParser.ScenarioModel;
import com.cssmart.bdd.parser.FeatureFileParser.StepModel;
import com.cssmart.config.PropertyManager;
import com.cssmart.core.driver.CSSmartDriver;

/**
 * HTML reporter for CS Smart Automation Framework
 */
public class HTMLReporter {
    
    private final ExecutionContext context;
    private final PropertyManager propertyManager;
    private final String reportDir;
    private final String reportFile;
    private final String screenshotDir;
    private final SimpleDateFormat dateFormat;
    private final Map<String, String> screenshotMap;
    private final StringBuilder reportBuilder;
    
    /**
     * Constructor for HTMLReporter
     * @param context Execution context
     */
    public HTMLReporter(ExecutionContext context) {
        this.context = context;
        this.propertyManager = PropertyManager.getInstance();
        this.dateFormat = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss");
        this.screenshotMap = new HashMap<>();
        
        // Create report directory
        String timestamp = dateFormat.format(new Date());
        this.reportDir = propertyManager.getProperty("report.dir", "target/cssmart-reports") + 
            File.separator + timestamp;
        this.screenshotDir = reportDir + File.separator + "screenshots";
        this.reportFile = reportDir + File.separator + "report.html";
        
        createDirectories();
        
        // Initialize report builder
        this.reportBuilder = new StringBuilder();
        initReportHeader();
    }
    
    /**
     * Create directories for report and screenshots
     */
    private void createDirectories() {
        File reportDirFile = new File(reportDir);
        File screenshotDirFile = new File(screenshotDir);
        
        if (!reportDirFile.exists()) {
            reportDirFile.mkdirs();
        }
        
        if (!screenshotDirFile.exists()) {
            screenshotDirFile.mkdirs();
        }
        
        // Copy CSS and JS files to report directory
        copyResourceFiles();
    }
    
    /**
     * Copy CSS and JS resource files to report directory
     */
    private void copyResourceFiles() {
        try {
            // In a real implementation, these files would be loaded from resources
            // For this example, we'll create them directly
            
            // Create CSS file
            try (FileWriter writer = new FileWriter(reportDir + File.separator + "report.css")) {
                writer.write(getCssContent());
            }
            
            // Create JS file
            try (FileWriter writer = new FileWriter(reportDir + File.separator + "report.js")) {
                writer.write(getJsContent());
            }
        } catch (IOException e) {
            System.err.println("Failed to copy resource files: " + e.getMessage());
        }
    }
    
    /**
     * Initialize report header
     */
    private void initReportHeader() {
        reportBuilder.append("<!DOCTYPE html>\n");
        reportBuilder.append("<html lang=\"en\">\n");
        reportBuilder.append("<head>\n");
        reportBuilder.append("  <meta charset=\"UTF-8\">\n");
        reportBuilder.append("  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
        reportBuilder.append("  <title>CS Smart Automation Report</title>\n");
        reportBuilder.append("  <link rel=\"stylesheet\" href=\"report.css\">\n");
        reportBuilder.append("</head>\n");
        reportBuilder.append("<body>\n");
        reportBuilder.append("  <div class=\"report-header\">\n");
        reportBuilder.append("    <h1>CS Smart Automation Report</h1>\n");
        reportBuilder.append("    <div class=\"report-info\">\n");
        reportBuilder.append("      <div class=\"info-item\"><span>Run Date:</span> " + 
            new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()) + "</div>\n");
        reportBuilder.append("      <div class=\"info-item\"><span>Environment:</span> " + 
            propertyManager.getProperty("env", "dev") + "</div>\n");
        reportBuilder.append("      <div class=\"info-item\"><span>Browser:</span> " + 
            propertyManager.getProperty("browser", "chrome") + "</div>\n");
        reportBuilder.append("    </div>\n");
        reportBuilder.append("    <div class=\"summary-container\">\n");
        reportBuilder.append("      <div class=\"summary-box total\"><span class=\"count\">0</span><span class=\"label\">Total</span></div>\n");
        reportBuilder.append("      <div class=\"summary-box passed\"><span class=\"count\">0</span><span class=\"label\">Passed</span></div>\n");
        reportBuilder.append("      <div class=\"summary-box failed\"><span class=\"count\">0</span><span class=\"label\">Failed</span></div>\n");
        reportBuilder.append("      <div class=\"summary-box skipped\"><span class=\"count\">0</span><span class=\"label\">Skipped</span></div>\n");
        reportBuilder.append("    </div>\n");
        reportBuilder.append("  </div>\n");
        reportBuilder.append("  <div class=\"report-content\">\n");
    }
    
    /**
     * Start feature
     * @param feature Feature model
     */
    public void startFeature(FeatureModel feature) {
        reportBuilder.append("    <div class=\"feature\" id=\"feature-" + sanitizeId(feature.getName()) + "\">\n");
        reportBuilder.append("      <div class=\"feature-header\">\n");
        reportBuilder.append("        <div class=\"feature-name\">" + feature.getName() + "</div>\n");
        reportBuilder.append("        <div class=\"feature-tags\">\n");
        
        for (String tag : feature.getTags()) {
            reportBuilder.append("          <span class=\"tag\">" + tag + "</span>\n");
        }
        
        reportBuilder.append("        </div>\n");
        reportBuilder.append("      </div>\n");
        reportBuilder.append("      <div class=\"scenarios\">\n");
    }
    
    /**
     * End feature
     */
    public void endFeature() {
        reportBuilder.append("      </div>\n");
        reportBuilder.append("    </div>\n");
    }
    
    /**
     * Start scenario
     * @param scenario Scenario model
     */
    public void startScenario(ScenarioModel scenario) {
        String scenarioId = "scenario-" + sanitizeId(scenario.getName());
        reportBuilder.append("        <div class=\"scenario\" id=\"" + scenarioId + "\">\n");
        reportBuilder.append("          <div class=\"scenario-header\">\n");
        reportBuilder.append("            <div class=\"scenario-name\">" + scenario.getName() + "</div>\n");
        reportBuilder.append("            <div class=\"scenario-tags\">\n");
        
        for (String tag : scenario.getTags()) {
            reportBuilder.append("              <span class=\"tag\">" + tag + "</span>\n");
        }
        
        reportBuilder.append("            </div>\n");
        reportBuilder.append("            <div class=\"scenario-status\">" + 
            context.getCurrentScenarioStatus() + "</div>\n");
        reportBuilder.append("          </div>\n");
        reportBuilder.append("          <div class=\"steps\">\n");
    }
    
    /**
     * End scenario
     */
    public void endScenario() {
        // Update scenario status
        reportBuilder.append("          </div>\n");
        
        // Add error details if scenario failed
        if (context.getCurrentScenarioStatus() == TestStatus.FAILED && 
            context.getCurrentScenarioError() != null) {
            reportBuilder.append("          <div class=\"error-details\">\n");
            reportBuilder.append("            <div class=\"error-header\">Error Details</div>\n");
            reportBuilder.append("            <div class=\"error-message\">" + 
                escapeHtml(context.getCurrentScenarioError().getMessage()) + "</div>\n");
            reportBuilder.append("            <div class=\"error-stacktrace\">\n");
            reportBuilder.append("              <pre>" + 
                escapeHtml(getStackTrace(context.getCurrentScenarioError())) + "</pre>\n");
            reportBuilder.append("            </div>\n");
            reportBuilder.append("          </div>\n");
        }
        
        reportBuilder.append("        </div>\n");
    }
    
    /**
     * Start scenario outline iteration
     * @param scenario Scenario model
     * @param iteration Iteration number
     */
    public void startScenarioOutlineIteration(ScenarioModel scenario, int iteration) {
        String scenarioId = "scenario-" + sanitizeId(scenario.getName()) + "-" + iteration;
        reportBuilder.append("        <div class=\"scenario\" id=\"" + scenarioId + "\">\n");
        reportBuilder.append("          <div class=\"scenario-header\">\n");
        reportBuilder.append("            <div class=\"scenario-name\">" + scenario.getName() + 
            " (Example " + iteration + ")</div>\n");
        reportBuilder.append("            <div class=\"scenario-tags\">\n");
        
        for (String tag : scenario.getTags()) {
            reportBuilder.append("              <span class=\"tag\">" + tag + "</span>\n");
        }
        
        reportBuilder.append("            </div>\n");
        reportBuilder.append("            <div class=\"scenario-status\">" + 
            context.getCurrentScenarioStatus() + "</div>\n");
        reportBuilder.append("          </div>\n");
        reportBuilder.append("          <div class=\"steps\">\n");
    }
    
    /**
     * End scenario outline iteration
     */
    public void endScenarioOutlineIteration() {
        endScenario();
    }
    
    /**
     * Start step
     * @param step Step model
     */
    public void startStep(StepModel step) {
        reportBuilder.append("            <div class=\"step\">\n");
        reportBuilder.append("              <div class=\"step-text\">" + 
            escapeHtml(step.getFullText()) + "</div>\n");
        
        // Take screenshot if enabled
        boolean takeScreenshot = Boolean.parseBoolean(
            propertyManager.getProperty("screenshot.per.step", "false"));
        
        if (takeScreenshot) {
            String screenshotPath = takeScreenshot();
            if (screenshotPath != null) {
                String relativePath = "screenshots/" + new File(screenshotPath).getName();
                screenshotMap.put(step.getFullText(), relativePath);
            }
        }
    }
    
    /**
     * End step
     */
    public void endStep() {
        reportBuilder.append("              <div class=\"step-status\">" + 
            context.getCurrentStepStatus() + "</div>\n");
        
        // Add error details if step failed
        if (context.getCurrentStepStatus() == TestStatus.FAILED && 
            context.getCurrentStepError() != null) {
            
            // Take screenshot on failure
            boolean screenshotOnFailure = Boolean.parseBoolean(
                propertyManager.getProperty("screenshot.on.failure", "true"));
            
            if (screenshotOnFailure) {
                String screenshotPath = takeScreenshot();
                if (screenshotPath != null) {
                    String relativePath = "screenshots/" + new File(screenshotPath).getName();
                    reportBuilder.append("              <div class=\"step-screenshot\">\n");
                    reportBuilder.append("                <a href=\"" + relativePath + 
                        "\" target=\"_blank\">View Screenshot</a>\n");
                    reportBuilder.append("              </div>\n");
                }
            }
            
            reportBuilder.append("              <div class=\"step-error\">\n");
            reportBuilder.append("                <div class=\"error-message\">" + 
                escapeHtml(context.getCurrentStepError().getMessage()) + "</div>\n");
            reportBuilder.append("              </div>\n");
        }
        
        reportBuilder.append("            </div>\n");
    }
    
    /**
     * Generate report
     */
    public void generateReport() {
        // Finalize report content
        reportBuilder.append("  </div>\n");
        reportBuilder.append("  <script src=\"report.js\"></script>\n");
        reportBuilder.append("  <script>\n");
        reportBuilder.append("    updateSummary(")
            .append(context.getTotalScenarios()).append(", ")
            .append(context.getPassedScenarios()).append(", ")
            .append(context.getFailedScenarios()).append(", ")
            .append(context.getSkippedScenarios()).append(");\n");
        reportBuilder.append("  </script>\n");
        reportBuilder.append("</body>\n");
        reportBuilder.append("</html>\n");
        
        // Write report to file
        try (FileWriter writer = new FileWriter(reportFile)) {
            writer.write(reportBuilder.toString());
            System.out.println("Report generated: " + reportFile);
        } catch (IOException e) {
            System.err.println("Failed to write report: " + e.getMessage());
        }
    }
    
    /**
     * Take screenshot
     * @return Path to screenshot file
     */
    private String takeScreenshot() {
        try {
            TakesScreenshot ts = (TakesScreenshot) CSSmartDriver.getDriver();
            File screenshot = ts.getScreenshotAs(OutputType.FILE);
            
            String timestamp = dateFormat.format(new Date());
            String fileName = "screenshot_" + timestamp + ".png";
            String filePath = screenshotDir + File.separator + fileName;
            
            Files.copy(screenshot.toPath(), Paths.get(filePath));
            return filePath;
        } catch (Exception e) {
            System.err.println("Failed to take screenshot: " + e.getMessage());
            return null;
        }
    }
    
    /**
     * Sanitize ID for HTML
     * @param id ID to sanitize
     * @return Sanitized ID
     */
    private String sanitizeId(String id) {
        return id.replaceAll("[^a-zA-Z0-9-_]", "-").toLowerCase();
    }
    
    /**
     * Escape HTML
     * @param html HTML to escape
     * @return Escaped HTML
     */
    private String escapeHtml(String html) {
        if (html == null) {
            return "";
        }
        
        return html.replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&#39;");
    }
    
    /**
     * Get stack trace as string
     * @param throwable Throwable
     * @return Stack trace as string
     */
    private String getStackTrace(Throwable throwable) {
        if (throwable == null) {
            return "";
        }
        
        java.io.StringWriter sw = new java.io.StringWriter();
        java.io.PrintWriter pw = new java.io.PrintWriter(sw);
        throwable.printStackTrace(pw);
        return sw.toString();
    }
    
    /**
     * Get CSS content
     * @return CSS content
     */
    private String getCssContent() {
        return "/* CS Smart Automation Report CSS */\n" +
            "body {\n" +
            "  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n" +
            "  margin: 0;\n" +
            "  padding: 0;\n" +
            "  background-color: #f8f9fa;\n" +
            "  color: #343a40;\n" +
            "}\n" +
            "\n" +
            ".report-header {\n" +
            "  background-color: #3fa2f7;\n" +
            "  color: white;\n" +
            "  padding: 20px;\n" +
            "  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n" +
            "}\n" +
            "\n" +
            ".report-header h1 {\n" +
            "  margin: 0;\n" +
            "  font-size: 28px;\n" +
            "  font-weight: 600;\n" +
            "}\n" +
            "\n" +
            ".report-info {\n" +
            "  display: flex;\n" +
            "  flex-wrap: wrap;\n" +
            "  margin-top: 15px;\n" +
            "}\n" +
            "\n" +
            ".info-item {\n" +
            "  margin-right: 20px;\n" +
            "  font-size: 14px;\n" +
            "}\n" +
            "\n" +
            ".info-item span {\n" +
            "  font-weight: 600;\n" +
            "  margin-right: 5px;\n" +
            "}\n" +
            "\n" +
            ".summary-container {\n" +
            "  display: flex;\n" +
            "  flex-wrap: wrap;\n" +
            "  margin-top: 20px;\n" +
            "}\n" +
            "\n" +
            ".summary-box {\n" +
            "  background-color: white;\n" +
            "  border-radius: 5px;\n" +
            "  padding: 15px;\n" +
            "  margin-right: 15px;\n" +
            "  min-width: 100px;\n" +
            "  text-align: center;\n" +
            "  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n" +
            "}\n" +
            "\n" +
            ".summary-box .count {\n" +
            "  display: block;\n" +
            "  font-size: 24px;\n" +
            "  font-weight: 600;\n" +
            "  margin-bottom: 5px;\n" +
            "}\n" +
            "\n" +
            ".summary-box .label {\n" +
            "  font-size: 14px;\n" +
            "  color: #6c757d;\n" +
            "}\n" +
            "\n" +
            ".summary-box.total .count {\n" +
            "  color: #3fa2f7;\n" +
            "}\n" +
            "\n" +
            ".summary-box.passed .count {\n" +
            "  color: #28a745;\n" +
            "}\n" +
            "\n" +
            ".summary-box.failed .count {\n" +
            "  color: #dc3545;\n" +
            "}\n" +
            "\n" +
            ".summary-box.skipped .count {\n" +
            "  color: #ffc107;\n" +
            "}\n" +
            "\n" +
            ".report-content {\n" +
            "  padding: 20px;\n" +
            "}\n" +
            "\n" +
            ".feature {\n" +
            "  background-color: white;\n" +
            "  border-radius: 5px;\n" +
            "  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n" +
            "  margin-bottom: 20px;\n" +
            "}\n" +
            "\n" +
            ".feature-header {\n" +
            "  padding: 15px;\n" +
            "  border-bottom: 1px solid #e9ecef;\n" +
            "}\n" +
            "\n" +
            ".feature-name {\n" +
            "  font-size: 18px;\n" +
            "  font-weight: 600;\n" +
            "  margin-bottom: 5px;\n" +
            "}\n" +
            "\n" +
            ".feature-tags {\n" +
            "  display: flex;\n" +
            "  flex-wrap: wrap;\n" +
            "}\n" +
            "\n" +
            ".tag {\n" +
            "  background-color: #f1f3f5;\n" +
            "  color: #495057;\n" +
            "  border-radius: 3px;\n" +
            "  padding: 3px 8px;\n" +
            "  font-size: 12px;\n" +
            "  margin-right: 5px;\n" +
            "  margin-bottom: 5px;\n" +
            "}\n" +
            "\n" +
            ".scenarios {\n" +
            "  padding: 15px;\n" +
            "}\n" +
            "\n" +
            ".scenario {\n" +
            "  border: 1px solid #e9ecef;\n" +
            "  border-radius: 5px;\n" +
            "  margin-bottom: 15px;\n" +
            "}\n" +
            "\n" +
            ".scenario-header {\n" +
            "  padding: 10px 15px;\n" +
            "  border-bottom: 1px solid #e9ecef;\n" +
            "  display: flex;\n" +
            "  align-items: center;\n" +
            "  justify-content: space-between;\n" +
            "}\n" +
            "\n" +
            ".scenario-name {\n" +
            "  font-weight: 600;\n" +
            "  flex-grow: 1;\n" +
            "}\n" +
            "\n" +
            ".scenario-tags {\n" +
            "  display: flex;\n" +
            "  flex-wrap: wrap;\n" +
            "  margin-right: 15px;\n" +
            "}\n" +
            "\n" +
            ".scenario-status {\n" +
            "  font-weight: 600;\n" +
            "  padding: 3px 8px;\n" +
            "  border-radius: 3px;\n" +
            "}\n" +
            "\n" +
            ".steps {\n" +
            "  padding: 10px 15px;\n" +
            "}\n" +
            "\n" +
            ".step {\n" +
            "  padding: 10px 0;\n" +
            "  border-bottom: 1px solid #e9ecef;\n" +
            "}\n" +
            "\n" +
            ".step:last-child {\n" +
            "  border-bottom: none;\n" +
            "}\n" +
            "\n" +
            ".step-text {\n" +
            "  margin-bottom: 5px;\n" +
            "}\n" +
            "\n" +
            ".step-status {\n" +
            "  display: inline-block;\n" +
            "  font-size: 12px;\n" +
            "  font-weight: 600;\n" +
            "  padding: 2px 8px;\n" +
            "  border-radius: 3px;\n" +
            "  margin-top: 5px;\n" +
            "}\n" +
            "\n" +
            ".PASSED {\n" +
            "  background-color: #d4edda;\n" +
            "  color: #28a745;\n" +
            "}\n" +
            "\n" +
            ".FAILED {\n" +
            "  background-color: #f8d7da;\n" +
            "  color: #dc3545;\n" +
            "}\n" +
            "\n" +
            ".SKIPPED {\n" +
            "  background-color: #fff3cd;\n" +
            "  color: #ffc107;\n" +
            "}\n" +
            "\n" +
            ".error-details {\n" +
            "  margin-top: 10px;\n" +
            "  padding: 15px;\n" +
            "  background-color: #f8d7da;\n" +
            "  border-radius: 5px;\n" +
            "}\n" +
            "\n" +
            ".error-header {\n" +
            "  font-weight: 600;\n" +
            "  margin-bottom: 10px;\n" +
            "  color: #dc3545;\n" +
            "}\n" +
            "\n" +
            ".error-message {\n" +
            "  font-family: monospace;\n" +
            "  margin-bottom: 10px;\n" +
            "}\n" +
            "\n" +
            ".error-stacktrace {\n" +
            "  max-height: 200px;\n" +
            "  overflow-y: auto;\n" +
            "}\n" +
            "\n" +
            ".error-stacktrace pre {\n" +
            "  margin: 0;\n" +
            "  white-space: pre-wrap;\n" +
            "  font-size: 12px;\n" +
            "}\n" +
            "\n" +
            ".step-screenshot {\n" +
            "  margin-top: 10px;\n" +
            "}\n" +
            "\n" +
            ".step-screenshot a {\n" +
            "  display: inline-block;\n" +
            "  padding: 5px 10px;\n" +
            "  background-color: #e9ecef;\n" +
            "  border-radius: 3px;\n" +
            "  color: #495057;\n" +
            "  text-decoration: none;\n" +
            "  font-size: 12px;\n" +
            "}\n" +
            "\n" +
            ".step-screenshot a:hover {\n" +
            "  background-color: #dee2e6;\n" +
            "}\n" +
            "\n" +
            ".step-error {\n" +
            "  margin-top: 10px;\n" +
            "  padding: 10px;\n" +
            "  background-color: #f8d7da;\n" +
            "  border-radius: 3px;\n" +
            "  font-size: 12px;\n" +
            "}\n" +
            "\n" +
            ".step-error .error-message {\n" +
            "  color: #dc3545;\n" +
            "  font-family: monospace;\n" +
            "}\n";
    }
    
    /**
     * Get JavaScript content
     * @return JavaScript content
     */
    private String getJsContent() {
        return "/* CS Smart Automation Report JavaScript */\n" +
            "document.addEventListener('DOMContentLoaded', function() {\n" +
            "  // Initialize report\n" +
            "  initializeCollapsibleSections();\n" +
            "});\n" +
            "\n" +
            "function initializeCollapsibleSections() {\n" +
            "  // Make scenario headers collapsible\n" +
            "  document.querySelectorAll('.scenario-header').forEach(function(header) {\n" +
            "    header.addEventListener('click', function() {\n" +
            "      var content = this.nextElementSibling;\n" +
            "      if (content.style.display === 'none') {\n" +
            "        content.style.display = 'block';\n" +
            "      } else {\n" +
            "        content.style.display = 'none';\n" +
            "      }\n" +
            "    });\n" +
            "  });\n" +
            "  \n" +
            "  // Make feature headers collapsible\n" +
            "  document.querySelectorAll('.feature-header').forEach(function(header) {\n" +
            "    header.addEventListener('click', function() {\n" +
            "      var content = this.nextElementSibling;\n" +
            "      if (content.style.display === 'none') {\n" +
            "        content.style.display = 'block';\n" +
            "      } else {\n" +
            "        content.style.display = 'none';\n" +
            "      }\n" +
            "    });\n" +
            "  });\n" +
            "}\n" +
            "\n" +
            "function updateSummary(total, passed, failed, skipped) {\n" +
            "  document.querySelector('.summary-box.total .count').textContent = total;\n" +
            "  document.querySelector('.summary-box.passed .count').textContent = passed;\n" +
            "  document.querySelector('.summary-box.failed .count').textContent = failed;\n" +
            "  document.querySelector('.summary-box.skipped .count').textContent = skipped;\n" +
            "}\n";
    }
}

package com.cssmart.reporting;

import java.util.ArrayList;
import java.util.List;

/**
 * Execution context for reporting
 */
public class ExecutionContext {
    
    private String currentFeatureName;
    private List<String> currentFeatureTags;
    private String currentScenarioName;
    private List<String> currentScenarioTags;
    private String currentStepText;
    private TestStatus currentScenarioStatus;
    private TestStatus currentStepStatus;
    private Throwable currentScenarioError;
    private Throwable currentStepError;
    
    private int totalScenarios;
    private int passedScenarios;
    private int failedScenarios;
    private int skippedScenarios;
    
    /**
     * Constructor for ExecutionContext
     */
    public ExecutionContext() {
        this.currentFeatureTags = new ArrayList<>();
        this.currentScenarioTags = new ArrayList<>();
        this.totalScenarios = 0;
        this.passedScenarios = 0;
        this.failedScenarios = 0;
        this.skippedScenarios = 0;
    }
    
    /**
     * Start feature
     * @param featureName Feature name
     * @param featureTags Feature tags
     */
    public void startFeature(String featureName, List<String> featureTags) {
        this.currentFeatureName = featureName;
        this.currentFeatureTags = new ArrayList<>(featureTags);
    }
    
    /**
     * End feature
     */
    public void endFeature() {
        this.currentFeatureName = null;
        this.currentFeatureTags.clear();
    }
    
    /**
     * Start scenario
     * @param scenarioName Scenario name
     * @param scenarioTags Scenario tags
     */
    public void startScenario(String scenarioName, List<String> scenarioTags) {
        this.currentScenarioName = scenarioName;
        this.currentScenarioTags = new ArrayList<>(scenarioTags);
        this.currentScenarioStatus = TestStatus.PENDING;
        this.currentScenarioError = null;
        this.totalScenarios++;
    }
    
    /**
     * End scenario
     */
    public void endScenario() {
        // Update scenario counts
        if (this.currentScenarioStatus == TestStatus.PASSED) {
            this.passedScenarios++;
        } else if (this.currentScenarioStatus == TestStatus.FAILED) {
            this.failedScenarios++;
        } else if (this.currentScenarioStatus == TestStatus.SKIPPED) {
            this.skippedScenarios++;
        }
        
        this.currentScenarioName = null;
        this.currentScenarioTags.clear();
        this.currentScenarioStatus = null;
        this.currentScenarioError = null;
    }
    
    /**
     * Start step
     * @param stepText Step text
     */
    public void startStep(String stepText) {
        this.currentStepText = stepText;
        this.currentStepStatus = TestStatus.PENDING;
        this.currentStepError = null;
    }
    
    /**
     * End step
     */
    public void endStep() {
        this.currentStepText = null;
        this.currentStepStatus = null;
        this.currentStepError = null;
    }
    
    /**
     * Set scenario status
     * @param status Status
     */
    public void setScenarioStatus(TestStatus status) {
        this.currentScenarioStatus = status;
    }
    
    /**
     * Set scenario error
     * @param error Error
     */
    public void setScenarioError(Throwable error) {
        this.currentScenarioError = error;
    }
    
    /**
     * Set step status
     * @param status Status
     */
    public void setStepStatus(TestStatus status) {
        this.currentStepStatus = status;
    }
    
    /**
     * Set step error
     * @param error Error
     */
    public void setStepError(Throwable error) {
        this.currentStepError = error;
    }
    
    /**
     * Get current feature name
     * @return Current feature name
     */
    public String getCurrentFeatureName() {
        return currentFeatureName;
    }
    
    /**
     * Get current feature tags
     * @return Current feature tags
     */
    public List<String> getCurrentFeatureTags() {
        return new ArrayList<>(currentFeatureTags);
    }
    
    /**
     * Get current scenario name
     * @return Current scenario name
     */
    public String getCurrentScenarioName() {
        return currentScenarioName;
    }
    
    /**
     * Get current scenario tags
     * @return Current scenario tags
     */
    public List<String> getCurrentScenarioTags() {
        return new ArrayList<>(currentScenarioTags);
    }
    
    /**
     * Get current step text
     * @return Current step text
     */
    public String getCurrentStepText() {
        return currentStepText;
    }
    
    /**
     * Get current scenario status
     * @return Current scenario status
     */
    public TestStatus getCurrentScenarioStatus() {
        return currentScenarioStatus;
    }
    
    /**
     * Get current step status
     * @return Current step status
     */
    public TestStatus getCurrentStepStatus() {
        return currentStepStatus;
    }
    
    /**
     * Get current scenario error
     * @return Current scenario error
     */
    public Throwable getCurrentScenarioError() {
        return currentScenarioError;
    }
    
    /**
     * Get current step error
     * @return Current step error
     */
    public Throwable getCurrentStepError() {
        return currentStepError;
    }
    
    /**
     * Get total scenarios
     * @return Total scenarios
     */
    public int getTotalScenarios() {
        return totalScenarios;
    }
    
    /**
     * Get passed scenarios
     * @return Passed scenarios
     */
    public int getPassedScenarios() {
        return passedScenarios;
    }
    
    /**
     * Get failed scenarios
     * @return Failed scenarios
     */
    public int getFailedScenarios() {
        return failedScenarios;
    }
    
    /**
     * Get skipped scenarios
     * @return Skipped scenarios
     */
    public int getSkippedScenarios() {
        return skippedScenarios;
    }
}

/**
 * Test status enum
 */
package com.cssmart.reporting;

public enum TestStatus {
    PENDING,
    PASSED,
    FAILED,
    SKIPPED
}


package com.cssmart.ai.healing;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.config.PropertyManager;

/**
 * Self-healing locator utility for automatic element location recovery
 */
public class SelfHealingLocator {

    private static final Logger LOGGER = Logger.getLogger(SelfHealingLocator.class.getName());
    private static final PropertyManager properties = PropertyManager.getInstance();
    private static final Map<String, List<LocatorCandidate>> locatorRegistry = new HashMap<>();
    
    /**
     * Find a locator that works
     * @param originalLocator The original locator that failed
     * @return A working locator or null if none found
     */
    public static By findAlternativeLocator(By originalLocator) {
        // Check if self-healing is enabled
        boolean selfHealingEnabled = Boolean.parseBoolean(
            properties.getProperty("self.healing.enabled", "true"));
        
        if (!selfHealingEnabled) {
            return null;
        }
        
        LOGGER.info("Attempting to heal locator: " + originalLocator);
        
        String locatorString = originalLocator.toString();
        WebDriver driver = CSSmartDriver.getDriver();
        
        // Check if we already have alternative locators for this one
        if (locatorRegistry.containsKey(locatorString)) {
            List<LocatorCandidate> candidates = locatorRegistry.get(locatorString);
            
            for (LocatorCandidate candidate : candidates) {
                try {
                    WebElement element = driver.findElement(candidate.getLocator());
                    if (element != null && element.isDisplayed()) {
                        LOGGER.info("Found working alternative locator: " + candidate.getLocator());
                        return candidate.getLocator();
                    }
                } catch (Exception e) {
                    // Continue to the next candidate
                }
            }
        }
        
        // No working locator found in registry, try to generate new locators
        List<By> alternativeLocators = generateAlternativeLocators(originalLocator);
        List<LocatorCandidate> candidates = new ArrayList<>();
        
        for (By locator : alternativeLocators) {
            try {
                WebElement element = driver.findElement(locator);
                if (element != null && element.isDisplayed()) {
                    // Add to registry for future use
                    LocatorCandidate candidate = new LocatorCandidate(locator);
                    candidates.add(candidate);
                    
                    LOGGER.info("Found new working locator: " + locator);
                    
                    // Register all candidates for future use
                    locatorRegistry.put(locatorString, candidates);
                    
                    return locator;
                }
            } catch (Exception e) {
                // Continue to the next candidate
            }
        }
        
        // Try dynamic locator generation using JavaScript
        try {
            By dynamicLocator = generateDynamicLocator(driver, originalLocator);
            if (dynamicLocator != null) {
                LocatorCandidate candidate = new LocatorCandidate(dynamicLocator);
                candidates.add(candidate);
                locatorRegistry.put(locatorString, candidates);
                return dynamicLocator;
            }
        } catch (Exception e) {
            LOGGER.warning("Failed to generate dynamic locator: " + e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Generate alternative locators based on the original locator
     * @param original Original locator
     * @return List of alternative locators
     */
    private static List<By> generateAlternativeLocators(By original) {
        List<By> alternatives = new ArrayList<>();
        
        String locatorString = original.toString();
        
        if (locatorString.startsWith("By.cssSelector")) {
            // For CSS selectors
            String selector = locatorString.substring(locatorString.indexOf(": ") + 2);
            
            // Try different variations
            if (selector.contains("#")) {
                // If it's an ID selector
                String id = selector.substring(selector.indexOf("#") + 1);
                if (id.contains(" ")) {
                    id = id.substring(0, id.indexOf(" "));
                }
                
                // Add ID selector
                alternatives.add(By.id(id));
                
                // Add CSS selector with just the ID
                alternatives.add(By.cssSelector("#" + id));
            }
            
            if (selector.contains(".")) {
                // If it's a class selector
                String className = selector.substring(selector.indexOf(".") + 1);
                if (className.contains(" ")) {
                    className = className.substring(0, className.indexOf(" "));
                }
                if (className.contains(".")) {
                    className = className.substring(0, className.indexOf("."));
                }
                
                // Add class selector
                alternatives.add(By.className(className));
                
                // Add CSS selector with just the class
                alternatives.add(By.cssSelector("." + className));
            }
            
            // Try with partial match
            if (selector.contains("[")) {
                String attrSelector = selector.substring(0, selector.indexOf("["));
                alternatives.add(By.cssSelector(attrSelector));
                
                // Try with contains
                if (selector.contains("=")) {
                    String attrName = selector.substring(selector.indexOf("[") + 1, selector.indexOf("="));
                    String attrValue = selector.substring(selector.indexOf("=") + 1);
                    if (attrValue.startsWith("'") || attrValue.startsWith("\"")) {
                        attrValue = attrValue.substring(1);
                    }
                    if (attrValue.endsWith("'") || attrValue.endsWith("\"") || attrValue.endsWith("]")) {
                        attrValue = attrValue.substring(0, attrValue.length() - 1);
                    }
                    
                    alternatives.add(By.cssSelector("[" + attrName + "*='" + attrValue + "']"));
                }
            }
        } else if (locatorString.startsWith("By.xpath")) {
            // For XPath selectors
            String xpath = locatorString.substring(locatorString.indexOf(": ") + 2);
            
            if (xpath.contains("@id=")) {
                // If XPath contains ID
                String id = xpath.substring(xpath.indexOf("@id=") + 4);
                if (id.startsWith("'") || id.startsWith("\"")) {
                    id = id.substring(1);
                }
                if (id.contains("'")) {
                    id = id.substring(0, id.indexOf("'"));
                }
                if (id.contains("\"")) {
                    id = id.substring(0, id.indexOf("\""));
                }
                
                alternatives.add(By.id(id));
                alternatives.add(By.xpath("//*[@id='" + id + "']"));
                alternatives.add(By.cssSelector("#" + id));
            }
            
            if (xpath.contains("@class=")) {
                // If XPath contains class
                String className = xpath.substring(xpath.indexOf("@class=") + 7);
                if (className.startsWith("'") || className.startsWith("\"")) {
                    className = className.substring(1);
                }
                if (className.contains("'")) {
                    className = className.substring(0, className.indexOf("'"));
                }
                if (className.contains("\"")) {
                    className = className.substring(0, className.indexOf("\""));
                }
                
                alternatives.add(By.className(className));
                alternatives.add(By.xpath("//*[@class='" + className + "']"));
                alternatives.add(By.cssSelector("." + className));
                
                // Try with contains for partial class match
                alternatives.add(By.xpath("//*[contains(@class,'" + className + "')]"));
            }
            
            if (xpath.contains("@name=")) {
                // If XPath contains name
                String name = xpath.substring(xpath.indexOf("@name=") + 6);
                if (name.startsWith("'") || name.startsWith("\"")) {
                    name = name.substring(1);
                }
                if (name.contains("'")) {
                    name = name.substring(0, name.indexOf("'"));
                }
                if (name.contains("\"")) {
                    name = name.substring(0, name.indexOf("\""));
                }
                
                alternatives.add(By.name(name));
                alternatives.add(By.xpath("//*[@name='" + name + "']"));
            }
            
            // Try with contains for text
            if (xpath.contains("text()=")) {
                String text = xpath.substring(xpath.indexOf("text()=") + 7);
                if (text.startsWith("'") || text.startsWith("\"")) {
                    text = text.substring(1);
                }
                if (text.contains("'")) {
                    text = text.substring(0, text.indexOf("'"));
                }
                if (text.contains("\"")) {
                    text = text.substring(0, text.indexOf("\""));
                }
                
                alternatives.add(By.xpath("//*[contains(text(),'" + text + "')]"));
                alternatives.add(By.partialLinkText(text));
                alternatives.add(By.linkText(text));
            }
        } else if (locatorString.startsWith("By.id")) {
            // For ID locators
            String id = locatorString.substring(locatorString.indexOf(": ") + 2);
            if (id.startsWith("'") || id.startsWith("\"")) {
                id = id.substring(1, id.length() - 1);
            }
            
            alternatives.add(By.cssSelector("#" + id));
            alternatives.add(By.xpath("//*[@id='" + id + "']"));
            
            // Try with partial match
            alternatives.add(By.xpath("//*[contains(@id,'" + id + "')]"));
        } else if (locatorString.startsWith("By.className")) {
            // For class name locators
            String className = locatorString.substring(locatorString.indexOf(": ") + 2);
            if (className.startsWith("'") || className.startsWith("\"")) {
                className = className.substring(1, className.length() - 1);
            }
            
            alternatives.add(By.cssSelector("." + className));
            alternatives.add(By.xpath("//*[contains(@class,'" + className + "')]"));
        } else if (locatorString.startsWith("By.name")) {
            // For name locators
            String name = locatorString.substring(locatorString.indexOf(": ") + 2);
            if (name.startsWith("'") || name.startsWith("\"")) {
                name = name.substring(1, name.length() - 1);
            }
            
            alternatives.add(By.xpath("//*[@name='" + name + "']"));
            
            // Try with partial match
            alternatives.add(By.xpath("//*[contains(@name,'" + name + "')]"));
        } else if (locatorString.startsWith("By.linkText")) {
            // For link text locators
            String text = locatorString.substring(locatorString.indexOf(": ") + 2);
            if (text.startsWith("'") || text.startsWith("\"")) {
                text = text.substring(1, text.length() - 1);
            }
            
            alternatives.add(By.xpath("//a[text()='" + text + "']"));
            alternatives.add(By.xpath("//a[contains(text(),'" + text + "')]"));
            alternatives.add(By.partialLinkText(text));
        } else if (locatorString.startsWith("By.partialLinkText")) {
            // For partial link text locators
            String text = locatorString.substring(locatorString.indexOf(": ") + 2);
            if (text.startsWith("'") || text.startsWith("\"")) {
                text = text.substring(1, text.length() - 1);
            }
            
            alternatives.add(By.xpath("//a[contains(text(),'" + text + "')]"));
            alternatives.add(By.linkText(text));
        } else if (locatorString.startsWith("By.tagName")) {
            // For tag name locators
            String tagName = locatorString.substring(locatorString.indexOf(": ") + 2);
            if (tagName.startsWith("'") || tagName.startsWith("\"")) {
                tagName = tagName.substring(1, tagName.length() - 1);
            }
            
            alternatives.add(By.xpath("//" + tagName));
        }
        
        return alternatives;
    }
    
    /**
     * Generate dynamic locator using JavaScript
     * @param driver WebDriver instance
     * @param originalLocator Original locator
     * @return New locator or null if none found
     */
    private static By generateDynamicLocator(WebDriver driver, By originalLocator) {
        if (!(driver instanceof JavascriptExecutor)) {
            return null;
        }
        
        JavascriptExecutor jsExecutor = (JavascriptExecutor) driver;
        
        // Try to find an element with unique ID
        try {
            String script = 
                "var elements = document.querySelectorAll('*[id]');" +
                "for(var i=0; i<elements.length; i++) {" +
                "  if(document.querySelectorAll('#'+elements[i].id).length === 1) {" +
                "    return elements[i].id;" +
                "  }" +
                "}" +
                "return null;";
            
            String id = (String) jsExecutor.executeScript(script);
            if (id != null && !id.trim().isEmpty()) {
                return By.id(id);
            }
        } catch (Exception e) {
            LOGGER.warning("Failed to find element by unique ID: " + e.getMessage());
        }
        
        // Try to find elements with unique attributes
        try {
            String script = 
                "var attributes = ['name', 'data-testid', 'data-test', 'data-qa', 'data-cy', 'data-test-id', 'aria-label'];" +
                "for(var a=0; a<attributes.length; a++) {" +
                "  var attr = attributes[a];" +
                "  var elements = document.querySelectorAll('['+attr+']');" +
                "  for(var i=0; i<elements.length; i++) {" +
                "    var value = elements[i].getAttribute(attr);" +
                "    if(document.querySelectorAll('['+attr+'=\"'+value+'\"]').length === 1) {" +
                "      return {attr: attr, value: value};" +
                "    }" +
                "  }" +
                "}" +
                "return null;";
            
            Object result = jsExecutor.executeScript(script);
            if (result instanceof Map) {
                @SuppressWarnings("unchecked")
                Map<String, String> attrMap = (Map<String, String>) result;
                if (attrMap.containsKey("attr") && attrMap.containsKey("value")) {
                    String attr = attrMap.get("attr");
                    String value = attrMap.get("value");
                    
                    if ("name".equals(attr)) {
                        return By.name(value);
                    } else {
                        return By.cssSelector("[" + attr + "='" + value + "']");
                    }
                }
            }
        } catch (Exception e) {
            LOGGER.warning("Failed to find element by unique attribute: " + e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Class to store locator candidates
     */
    private static class LocatorCandidate {
        private final By locator;
        private int successCount = 0;
        private int failureCount = 0;
        
        public LocatorCandidate(By locator) {
            this.locator = locator;
        }
        
        public By getLocator() {
            return locator;
        }
        
        public void incrementSuccess() {
            successCount++;
        }
        
        public void incrementFailure() {
            failureCount++;
        }
        
        public int getSuccessCount() {
            return successCount;
        }
        
        public int getFailureCount() {
            return failureCount;
        }
        
        public double getSuccessRate() {
            if (successCount + failureCount == 0) {
                return 0;
            }
            return (double) successCount / (successCount + failureCount);
        }
    }

    /**
     * Custom exception for element not found
     */
    public static class ElementNotFoundException extends RuntimeException {
        public ElementNotFoundException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}

package com.cssmart.ai.visual;

import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.imageio.ImageIO;

import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import com.cssmart.config.PropertyManager;
import com.cssmart.core.driver.CSSmartDriver;

/**
 * Visual validation utility for AI-based visual comparison
 */
public class VisualAssertions {
    
    private static final Logger LOGGER = Logger.getLogger(VisualAssertions.class.getName());
    private static final PropertyManager properties = PropertyManager.getInstance();
    private static final String BASELINE_DIR = properties.getProperty("visual.baseline.dir", "visual-baseline");
    private static final double DEFAULT_THRESHOLD = Double.parseDouble(properties.getProperty("visual.threshold", "0.02"));
    
    // Cache for baseline images
    private static final Map<String, BufferedImage> baselineCache = new HashMap<>();
    
    /**
     * Assert that the element looks the same as the baseline
     * @param element Element to verify
     * @param elementName Name of the element (for reporting)
     * @return true if the element matches the baseline, false otherwise
     */
    public static boolean assertElementLooksTheSame(WebElement element, String elementName) {
        return assertElementLooksTheSame(element, elementName, DEFAULT_THRESHOLD);
    }
    
    /**
     * Assert that the element looks the same as the baseline
     * @param element Element to verify
     * @param elementName Name of the element (for reporting)
     * @param threshold Threshold for difference (0.0 - 1.0)
     * @return true if the element matches the baseline, false otherwise
     */
    public static boolean assertElementLooksTheSame(WebElement element, String elementName, double threshold) {
        try {
            // Take a screenshot of the element
            BufferedImage actualImage = captureElementScreenshot(element);
            if (actualImage == null) {
                LOGGER.warning("Failed to capture screenshot of element: " + elementName);
                return false;
            }
            
            // Get baseline image
            BufferedImage baselineImage = getBaselineImage(elementName);
            
            // If no baseline exists, create one
            if (baselineImage == null) {
                saveBaselineImage(elementName, actualImage);
                LOGGER.info("Created baseline image for: " + elementName);
                return true;
            }
            
            // Compare the images
            double difference = compareImages(baselineImage, actualImage);
            boolean result = difference <= threshold;
            
            if (!result) {
                LOGGER.warning("Visual validation failed for " + elementName + ". Difference: " + difference);
                saveFailedImage(elementName, actualImage);
            }
            
            return result;
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error during visual assertion", e);
            return false;
        }
    }
    
    /**
     * Capture screenshot of an element
     * @param element WebElement to capture
     * @return BufferedImage of the element
     */
    private static BufferedImage captureElementScreenshot(WebElement element) {
        try {
            // Take a screenshot of the entire page
            WebDriver driver = CSSmartDriver.getDriver();
            if (!(driver instanceof TakesScreenshot)) {
                return null;
            }
            
            TakesScreenshot screenshotDriver = (TakesScreenshot) driver;
            byte[] screenshotBytes = screenshotDriver.getScreenshotAs(OutputType.BYTES);
            BufferedImage fullImage = ImageIO.read(new ByteArrayInputStream(screenshotBytes));
            
            // Get element dimensions
            org.openqa.selenium.Rectangle rect = element.getRect();
            
            // Crop the full image to the element's dimensions
            if (rect.getX() >= 0 && rect.getY() >= 0 && 
                rect.getX() + rect.getWidth() <= fullImage.getWidth() && 
                rect.getY() + rect.getHeight() <= fullImage.getHeight()) {
                
                return fullImage.getSubimage(
                    rect.getX(), 
                    rect.getY(), 
                    rect.getWidth(), 
                    rect.getHeight()
                );
            }
            
            // If element is not fully visible in the viewport
            return null;
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Failed to capture element screenshot", e);
            return null;
        }
    }
    
    /**
     * Get baseline image for an element
     * @param elementName Name of the element
     * @return Baseline image or null if not found
     */
    private static BufferedImage getBaselineImage(String elementName) {
        // Check if the image is in cache
        if (baselineCache.containsKey(elementName)) {
            return baselineCache.get(elementName);
        }
        
        // Check if image exists in file system
        File baselineFile = new File(BASELINE_DIR, sanitizeFileName(elementName) + ".png");
        if (!baselineFile.exists()) {
            return null;
        }
        
        try {
            BufferedImage image = ImageIO.read(baselineFile);
            baselineCache.put(elementName, image);
            return image;
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, "Failed to read baseline image: " + elementName, e);
            return null;
        }
    }
    
    /**
     * Save baseline image
     * @param elementName Name of the element
     * @param image Image to save
     */
    private static void saveBaselineImage(String elementName, BufferedImage image) {
        try {
            File baselineDir = new File(BASELINE_DIR);
            if (!baselineDir.exists()) {
                baselineDir.mkdirs();
            }
            
            File outputFile = new File(baselineDir, sanitizeFileName(elementName) + ".png");
            ImageIO.write(image, "png", outputFile);
            
            // Add to cache
            baselineCache.put(elementName, image);
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, "Failed to save baseline image: " + elementName, e);
        }
    }
    
    /**
     * Save failed image for comparison
     * @param elementName Name of the element
     * @param image Failed image
     */
    private static void saveFailedImage(String elementName, BufferedImage image) {
        try {
            File failureDir = new File(BASELINE_DIR, "failures");
            if (!failureDir.exists()) {
                failureDir.mkdirs();
            }
            
            String timestamp = String.valueOf(System.currentTimeMillis());
            File outputFile = new File(failureDir, sanitizeFileName(elementName) + "_" + timestamp + ".png");
            ImageIO.write(image, "png", outputFile);
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, "Failed to save failure image: " + elementName, e);
        }
    }
    
    /**
     * Compare two images and calculate the difference percentage
     * @param baseline Baseline image
     * @param actual Actual image
     * @return Difference percentage (0.0 - 1.0)
     */
    private static double compareImages(BufferedImage baseline, BufferedImage actual) {
        // If dimensions don't match, resize the images to the same size
        BufferedImage img1 = baseline;
        BufferedImage img2 = actual;
        
        if (baseline.getWidth() != actual.getWidth() || baseline.getHeight() != actual.getHeight()) {
            // Resize to the smaller dimensions
            int width = Math.min(baseline.getWidth(), actual.getWidth());
            int height = Math.min(baseline.getHeight(), actual.getHeight());
            
            img1 = resizeImage(baseline, width, height);
            img2 = resizeImage(actual, width, height);
        }
        
        // Calculate pixel-by-pixel difference
        long diff = 0;
        int width = img1.getWidth();
        int height = img1.getHeight();
        
        // Using a simple pixel-by-pixel comparison
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                int rgb1 = img1.getRGB(x, y);
                int rgb2 = img2.getRGB(x, y);
                
                int r1 = (rgb1 >> 16) & 0xff;
                int g1 = (rgb1 >> 8) & 0xff;
                int b1 = rgb1 & 0xff;
                
                int r2 = (rgb2 >> 16) & 0xff;
                int g2 = (rgb2 >> 8) & 0xff;
                int b2 = rgb2 & 0xff;
                
                diff += Math.abs(r1 - r2);
                diff += Math.abs(g1 - g2);
                diff += Math.abs(b1 - b2);
            }
        }
        
        // Normalize difference
        double totalPixels = width * height * 3; // 3 for RGB channels
        return diff / (double) (totalPixels * 255); // 255 is max difference per channel
    }
    
    /**
     * Resize an image
     * @param original Original image
     * @param width Target width
     * @param height Target height
     * @return Resized image
     */
    private static BufferedImage resizeImage(BufferedImage original, int width, int height) {
        BufferedImage resized = new BufferedImage(width, height, original.getType());
        java.awt.Graphics2D g = resized.createGraphics();
        g.drawImage(original, 0, 0, width, height, null);
        g.dispose();
        return resized;
    }
    
    /**
     * Sanitize a filename to be filesystem-safe
     * @param filename Original filename
     * @return Sanitized filename
     */
    private static String sanitizeFileName(String filename) {
        return filename.replaceAll("[^a-zA-Z0-9.-]", "_");
    }
}

package com.cssmart.ai.generator;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import com.cssmart.core.driver.CSSmartDriver;
import com.cssmart.config.PropertyManager;

/**
 * Utility class for generating test artifacts
 */
public class TestGenerator {
    
    private static final Logger LOGGER = Logger.getLogger(TestGenerator.class.getName());
    private static final PropertyManager properties = PropertyManager.getInstance();
    private static final String OUTPUT_DIR = properties.getProperty("generator.output.dir", "generated-tests");
    
    /**
     * Generate a page object class for the current page
     * @param pageName The name of the page
     * @param packageName The package name for the generated class
     * @return True if generation was successful
     */
    public static boolean generatePageObject(String pageName, String packageName) {
        WebDriver driver = CSSmartDriver.getDriver();
        if (!(driver instanceof JavascriptExecutor)) {
            return false;
        }
        
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            
            // Get page title
            String pageTitle = (String) js.executeScript("return document.title;");
            String pageUrl = driver.getCurrentUrl();
            
            // Find significant elements on the page
            List<ElementInfo> elements = findSignificantElements(driver);
            
            // Generate the class file
            generatePageObjectClass(pageName, packageName, pageTitle, pageUrl, elements);
            
            return true;
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Failed to generate page object", e);
            return false;
        }
    }
    
    /**
     * Find significant elements on a page
     * @param driver WebDriver instance
     * @return List of element information
     */
    private static List<ElementInfo> findSignificantElements(WebDriver driver) {
        List<ElementInfo> elements = new ArrayList<>();
        JavascriptExecutor js = (JavascriptExecutor) driver;
        
        // Execute JavaScript to find significant elements
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> elementData = (List<Map<String, Object>>) js.executeScript(
            "var elements = [];" +
            "var allElements = document.querySelectorAll('input, button, select, a, textarea, [role=\"button\"], [role=\"link\"], [role=\"checkbox\"], [role=\"radio\"], [role=\"textbox\"], [role=\"combobox\"]');" +
            "for (var i = 0; i < allElements.length; i++) {" +
            "  var element = allElements[i];" +
            "  if (element.hidden || element.style.display === 'none' || element.style.visibility === 'hidden') {" +
            "    continue;" +
            "  }" +
            "  var rect = element.getBoundingClientRect();" +
            "  if (rect.width === 0 || rect.height === 0) {" +
            "    continue;" +
            "  }" +
            "  var elementInfo = {" +
            "    tagName: element.tagName.toLowerCase()," +
            "    id: element.id," +
            "    name: element.name," +
            "    type: element.type," +
            "    value: element.value," +
            "    text: element.textContent.trim()," +
            "    placeholder: element.placeholder," +
            "    classes: element.className," +
            "    attributes: {}," +
            "    xpath: getXPath(element)" +
            "  };" +
            "  for (var j = 0; j < element.attributes.length; j++) {" +
            "    var attr = element.attributes[j];" +
            "    elementInfo.attributes[attr.name] = attr.value;" +
            "  }" +
            "  elements.push(elementInfo);" +
            "}" +
            "function getXPath(element) {" +
            "  if (element.id !== '') {" +
            "    return '//*[@id=\"' + element.id + '\"]';" +
            "  }" +
            "  if (element === document.body) {" +
            "    return '/html/body';" +
            "  }" +
            "  var ix = 0;" +
            "  var siblings = element.parentNode.childNodes;" +
            "  for (var i = 0; i < siblings.length; i++) {" +
            "    var sibling = siblings[i];" +
            "    if (sibling === element) {" +
            "      return getXPath(element.parentNode) + '/' + element.tagName.toLowerCase() + '[' + (ix + 1) + ']';" +
            "    }" +
            "    if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {" +
            "      ix++;" +
            "    }" +
            "  }" +
            "}" +
            "return elements;"
        );
        
        // Process JavaScript result
        if (elementData != null) {
            for (Map<String, Object> data : elementData) {
                ElementInfo info = new ElementInfo();
                info.setTagName((String) data.get("tagName"));
                info.setId((String) data.get("id"));
                info.setName((String) data.get("name"));
                info.setType((String) data.get("type"));
                info.setValue((String) data.get("value"));
                info.setText((String) data.get("text"));
                info.setPlaceholder((String) data.get("placeholder"));
                info.setClassName((String) data.get("classes"));
                info.setXpath((String) data.get("xpath"));
                
                @SuppressWarnings("unchecked")
                Map<String, String> attributes = (Map<String, String>) data.get("attributes");
                if (attributes != null) {
                    info.setAttributes(attributes);
                }
                
                // Generate the best locator strategy
                generateBestLocator(info);
                
                elements.add(info);
            }
        }
        
        return elements;
    }
    
    /**
     * Generate the best locator strategy for an element
     * @param info Element information
     */
    private static void generateBestLocator(ElementInfo info) {
        // Priority order for locators
        // 1. ID if available and unique
        if (info.getId() != null && !info.getId().isEmpty()) {
            info.setLocatorType("ID");
            info.setLocatorValue(info.getId());
            return;
        }
        
        // 2. Name if available
        if (info.getName() != null && !info.getName().isEmpty()) {
            info.setLocatorType("NAME");
            info.setLocatorValue(info.getName());
            return;
        }
        
        // 3. Test-specific attributes
        Map<String, String> attributes = info.getAttributes();
        for (String attrKey : Arrays.asList("data-testid", "data-test", "data-qa", "data-cy", "data-automation", "data-test-id")) {
            if (attributes.containsKey(attrKey) && !attributes.get(attrKey).isEmpty()) {
                info.setLocatorType("CSS");
                info.setLocatorValue("[" + attrKey + "=\"" + attributes.get(attrKey) + "\"]");
                return;
            }
        }
        
        // 4. For links, try link text
        if ("a".equals(info.getTagName()) && info.getText() != null && !info.getText().isEmpty()) {
            info.setLocatorType("LINK_TEXT");
            info.setLocatorValue(info.getText());
            return;
        }
        
        // 5. For buttons with text, try xpath with text
        if (("button".equals(info.getTagName()) || "role=\"button\"".equals(info.getTagName())) 
                && info.getText() != null && !info.getText().isEmpty()) {
            info.setLocatorType("XPATH");
            info.setLocatorValue("//button[text()='" + info.getText() + "']");
            return;
        }
        
        // 6. For inputs with placeholder
        if ("input".equals(info.getTagName()) && info.getPlaceholder() != null && !info.getPlaceholder().isEmpty()) {
            info.setLocatorType("CSS");
            info.setLocatorValue("input[placeholder=\"" + info.getPlaceholder() + "\"]");
            return;
        }
        
        // 7. CSS with class if it's simple (not multiple classes)
        if (info.getClassName() != null && !info.getClassName().isEmpty() && !info.getClassName().contains(" ")) {
            info.setLocatorType("CLASS_NAME");
            info.setLocatorValue(info.getClassName());
            return;
        }
        
        // 8. Fallback to XPath
        info.setLocatorType("XPATH");
        info.setLocatorValue(info.getXpath());
    }
    
    /**
     * Generate the page object class file
     * @param pageName The name of the page
     * @param packageName The package name
     * @param pageTitle The page title
     * @param pageUrl The page URL
     * @param elements The list of element information
     * @throws IOException If file writing fails
     */
    private static void generatePageObjectClass(String pageName, String packageName, 
            String pageTitle, String pageUrl, List<ElementInfo> elements) throws IOException {
        // Create output directory if it doesn't exist
        File packageDir = new File(OUTPUT_DIR + File.separator + packageName.replace(".", File.separator));
        if (!packageDir.exists()) {
            packageDir.mkdirs();
        }
        
        // Create file and write class content
        File outputFile = new File(packageDir, pageName + ".java");
        
        try (PrintWriter writer = new PrintWriter(new FileWriter(outputFile))) {
            // Write package and imports
            writer.println("package " + packageName + ";");
            writer.println();
            writer.println("import org.openqa.selenium.By;");
            writer.println("import org.openqa.selenium.WebDriver;");
            writer.println("import org.openqa.selenium.support.FindBy;");
            writer.println("import com.cssmart.core.element.CSSmartWebElement;");
            writer.println("import com.cssmart.core.page.CSSmartBaseWebpage;");
            writer.println("import com.cssmart.annotations.CSSmartTestStep;");
            writer.println();
            
            // Write class javadoc and declaration
            writer.println("/**");
            writer.println(" * Page object for " + pageTitle);
            writer.println(" * Generated automatically by CS Smart Automation Framework");
            writer.println(" */");
            writer.println("public class " + pageName + " extends CSSmartBaseWebpage {");
            writer.println();
            
            // Write URL constant
            writer.println("    /**");
            writer.println("     * URL of the page");
            writer.println("     */");
            writer.println("    private static final String PAGE_URL = \"" + pageUrl + "\";");
            writer.println();
            
            // Write element declarations
            for (int i = 0; i < elements.size(); i++) {
                ElementInfo element = elements.get(i);
                String fieldName = generateFieldName(element, i);
                
                writer.println("    /**");
                if (element.getText() != null && !element.getText().isEmpty()) {
                    writer.println("     * " + element.getText());
                } else {
                    writer.println("     * " + element.getTagName() + " element");
                    if (element.getPlaceholder() != null && !element.getPlaceholder().isEmpty()) {
                        writer.println("     * Placeholder: " + element.getPlaceholder());
                    }
                }
                writer.println("     */");
                
                // Write FindBy annotation
                writer.print("    @FindBy(");
                switch (element.getLocatorType()) {
                    case "ID":
                        writer.print("id = \"" + element.getLocatorValue() + "\"");
                        break;
                    case "NAME":
                        writer.print("name = \"" + element.getLocatorValue() + "\"");
                        break;
                    case "CLASS_NAME":
                        writer.print("className = \"" + element.getLocatorValue() + "\"");
                        break;
                    case "CSS":
                        writer.print("css = \"" + element.getLocatorValue() + "\"");
                        break;
                    case "XPATH":
                        writer.print("xpath = \"" + element.getLocatorValue() + "\"");
                        break;
                    case "LINK_TEXT":
                        writer.print("linkText = \"" + element.getLocatorValue() + "\"");
                        break;
                    default:
                        writer.print("xpath = \"" + element.getXpath() + "\"");
                }
                writer.println(")");
                
                // Field declaration
                writer.println("    private CSSmartWebElement " + fieldName + ";");
                writer.println();
            }
            
            // Constructor
            writer.println("    /**");
            writer.println("     * Constructor");
            writer.println("     */");
            writer.println("    public " + pageName + "() {");
            writer.println("        super();");
            writer.println("    }");
            writer.println();
            
            // Open method
            writer.println("    /**");
            writer.println("     * Open the page");
            writer.println("     * @return The page object instance");
            writer.println("     */");
            writer.println("    @CSSmartTestStep(\"Open the " + pageName + " page\")");
            writer.println("    public " + pageName + " open() {");
            writer.println("        super.open(PAGE_URL);");
            writer.println("        return this;");
            writer.println("    }");
            writer.println();
            
            // Generate action methods based on element types
            generateActionMethods(writer, elements, pageName);
            
            // End class
            writer.println("}");
        }
        
        LOGGER.info("Generated page object class: " + outputFile.getAbsolutePath());
    }
    
    /**
     * Generate field name for an element
     * @param element Element information
     * @param index Index for uniqueness
     * @return Generated field name
     */
    private static String generateFieldName(ElementInfo element, int index) {
        String baseName = "";
        
        // Try to generate a meaningful name based on element attributes
        if (element.getId() != null && !element.getId().isEmpty()) {
            baseName = element.getId().replaceAll("[^a-zA-Z0-9]", "");
        } else if (element.getName() != null && !element.getName().isEmpty()) {
            baseName = element.getName().replaceAll("[^a-zA-Z0-9]", "");
        } else if (element.getText() != null && !element.getText().isEmpty() && element.getText().length() < 30) {
            baseName = element.getText().replaceAll("[^a-zA-Z0-9]", "");
        } else if (element.getPlaceholder() != null && !element.getPlaceholder().isEmpty()) {
            baseName = element.getPlaceholder().replaceAll("[^a-zA-Z0-9]", "");
        } else {
            // Fallback to element type
            baseName = element.getTagName() + "Element";
        }
        
        // Ensure it starts with lowercase
        if (!baseName.isEmpty()) {
            baseName = Character.toLowerCase(baseName.charAt(0)) + (baseName.length() > 1 ? baseName.substring(1) : "");
        } else {
            baseName = "element";
        }
        
        // Add index for uniqueness
        return baseName + index;
    }
    
    /**
     * Generate action methods based on element types
     * @param writer PrintWriter
     * @param elements List of element information
     * @param pageName Name of the page
     */
    private static void generateActionMethods(PrintWriter writer, List<ElementInfo> elements, String pageName) {
        // Keep track of method names to avoid duplicates
        Set<String> methodNames = new HashSet<>();
        
        for (int i = 0; i < elements.size(); i++) {
            ElementInfo element = elements.get(i);
            String fieldName = generateFieldName(element, i);
            
            // Generate methods based on element type
            switch (element.getTagName()) {
                case "input":
                    generateInputMethods(writer, element, fieldName, methodNames, pageName);
                    break;
                case "button":
                    generateButtonMethods(writer, element, fieldName, methodNames, pageName);
                    break;
                case "a":
                    generateLinkMethods(writer, element, fieldName, methodNames, pageName);
                    break;
                case "select":
                    generateSelectMethods(writer, element, fieldName, methodNames, pageName);
                    break;
                case "textarea":
                    generateTextareaMethods(writer, element, fieldName, methodNames, pageName);
                    break;
                default:
                    generateGenericMethods(writer, element, fieldName, methodNames, pageName);
                    break;
            }
        }
    }
    
    /**
     * Generate methods for input elements
     * @param writer PrintWriter
     * @param element Element information
     * @param fieldName Field name
     * @param methodNames Set of existing method names
     * @param pageName Name of the page
     */
    private static void generateInputMethods(PrintWriter writer, ElementInfo element, 
            String fieldName, Set<String> methodNames, String pageName) {
        String inputType = element.getType() != null ? element.getType().toLowerCase() : "text";
        
        switch (inputType) {
            case "text":
            case "email":
            case "password":
            case "tel":
            case "url":
            case "search":
            case "number":
                // Enter text method
                String methodBaseName = "enter" + capitalize(fieldName);
                String methodName = getUniqueMethodName(methodBaseName, methodNames);
                
                writer.println("    /**");
                writer.println("     * Enter text in " + fieldName);
                if (element.getPlaceholder() != null && !element.getPlaceholder().isEmpty()) {
                    writer.println("     * Field placeholder: " + element.getPlaceholder());
                }
                writer.println("     * @param text Text to enter");
                writer.println("     * @return The page object instance");
                writer.println("     */");
                writer.println("    @CSSmartTestStep(\"Enter text in " + 
                    (element.getPlaceholder() != null ? element.getPlaceholder() : fieldName) + "\")");
                writer.println("    public " + pageName + " " + methodName + "(String text) {");
                writer.println("        " + fieldName + ".waitForVisible(10);");
                writer.println("        " + fieldName + ".type(text);");
                writer.println("        return this;");
                writer.println("    }");
                writer.println();
                break;
                
            case "checkbox":
                // Check method
                methodBaseName = "check" + capitalize(fieldName);
                methodName = getUniqueMethodName(methodBaseName, methodNames);
                
                writer.println("    /**");
                writer.println("     * Check " + fieldName);
                writer.println("     * @return The page object instance");
                writer.println("     */");
                writer.println("    @CSSmartTestStep(\"Check " + fieldName + "\")");
                writer.println("    public " + pageName + " " + methodName + "() {");
                writer.println("        " + fieldName + ".waitForVisible(10);");
                writer.println("        if (!" + fieldName + ".isSelected()) {");
                writer.println("            " + fieldName + ".click();");
                writer.println("        }");
                writer.println("        return this;");
                writer.println("    }");
                writer.println();
                
                // Uncheck method
                methodBaseName = "uncheck" + capitalize(fieldName);
                methodName = getUniqueMethodName(methodBaseName, methodNames);
                
                writer.println("    /**");
                writer.println("     * Uncheck " + fieldName);
                writer.println("     * @return The page object instance");
                writer.println("     */");
                writer.println("    @CSSmartTestStep(\"Uncheck " + fieldName + "\")");
                writer.println("    public " + pageName + " " + methodName + "() {");
                writer.println("        " + fieldName + ".waitForVisible(10);");
                writer.println("        if (" + fieldName + ".isSelected()) {");
                writer.println("            " + fieldName + ".click();");
                writer.println("        }");
                writer.println("        return this;");
                writer.println("    }");
                writer.println();
                break;
                
            case "radio":
                // Select radio method
                methodBaseName = "select" + capitalize(fieldName);
                methodName = getUniqueMethodName(methodBaseName, methodNames);
                
                writer.println("    /**");
                writer.println("     * Select " + fieldName + " radio button");
                writer.println("     * @return The page object instance");
                writer.println("     */");
                writer.println("    @CSSmartTestStep(\"Select " + fieldName + " radio button\")");
                writer.println("    public " + pageName + " " + methodName + "() {");
                writer.println("        " + fieldName + ".waitForVisible(10);");
                writer.println("        " + fieldName + ".click();");
                writer.println("        return this;");
                writer.println("    }");
                writer.println();
                break;
                
            default:
                // Generic click method for other input types
                methodBaseName = "click" + capitalize(fieldName);
                methodName = getUniqueMethodName(methodBaseName, methodNames);
                
                writer.println("    /**");
                writer.println("     * Click on " + fieldName);
                writer.println("     * @return The page object instance");
                writer.println("     */");
                writer.println("    @CSSmartTestStep(\"Click on " + fieldName + "\")");
                writer.println("    public " + pageName + " " + methodName + "() {");
                writer.println("        " + fieldName + ".waitForClickable(10);");
                writer.println("        " + fieldName + ".click();");
                writer.println("        return this;");
                writer.println("    }");
                writer.println();
                break;
        }
    }
    
    /**
     * Generate methods for button elements
     * @param writer PrintWriter
     * @param element Element information
     * @param fieldName Field name
     * @param methodNames Set of existing method names
     * @param pageName Name of the page
     */
    private static void generateButtonMethods(PrintWriter writer, ElementInfo element, 
            String fieldName, Set<String> methodNames, String pageName) {
        // Click button method
        String buttonText = element.getText() != null && !element.getText().isEmpty() ? 
            element.getText() : fieldName;
        String methodBaseName = "click" + capitalize(fieldName);
        String methodName = getUniqueMethodName(methodBaseName, methodNames);
        
        writer.println("    /**");
        writer.println("     * Click on " + buttonText + " button");
        writer.println("     * @return The page object instance");
        writer.println("     */");
        writer.println("    @CSSmartTestStep(\"Click on " + buttonText + " button\")");
        writer.println("    public " + pageName + " " + methodName + "() {");
        writer.println("        " + fieldName + ".waitForClickable(10);");
        writer.println("        " + fieldName + ".click();");
        writer.println("        return this;");
        writer.println("    }");
        writer.println();
    }
    
    /**
     * Generate methods for link elements
     * @param writer PrintWriter
     * @param element Element information
     * @param fieldName Field name
     * @param methodNames Set of existing method names
     * @param pageName Name of the page
     */
    private static void generateLinkMethods(PrintWriter writer, ElementInfo element, 
            String fieldName, Set<String> methodNames, String pageName) {
        // Click link method
        String linkText = element.getText() != null && !element.getText().isEmpty() ? 
            element.getText() : fieldName;
        String methodBaseName = "click" + capitalize(fieldName);
        String methodName = getUniqueMethodName(methodBaseName, methodNames);
        
        writer.println("    /**");
        writer.println("     * Click on " + linkText + " link");
        writer.println("     * @return The page object instance");
        writer.println("     */");
        writer.println("    @CSSmartTestStep(\"Click on " + linkText + " link\")");
        writer.println("    public " + pageName + " " + methodName + "() {");
        writer.println("        " + fieldName + ".waitForClickable(10);");
        writer.println("        " + fieldName + ".click();");
        writer.println("        return this;");
        writer.println("    }");
        writer.println();
    }
    
    /**
     * Generate methods for select elements
     * @param writer PrintWriter
     * @param element Element information
     * @param fieldName Field name
     * @param methodNames Set of existing method names
     * @param pageName Name of the page
     */
    private static void generateSelectMethods(PrintWriter writer, ElementInfo element, 
            String fieldName, Set<String> methodNames, String pageName) {
        // Select by visible text method
        String methodBaseName = "select" + capitalize(fieldName) + "ByText";
        String methodName = getUniqueMethodName(methodBaseName, methodNames);
        
        writer.println("    /**");
        writer.println("     * Select option by visible text from " + fieldName);
        writer.println("     * @param text Text of the option to select");
        writer.println("     * @return The page object instance");
        writer.println("     */");
        writer.println("    @CSSmartTestStep(\"Select {0} from " + fieldName + "\")");
        writer.println("    public " + pageName + " " + methodName + "(String text) {");
        writer.println("        " + fieldName + ".waitForVisible(10);");
        writer.println("        org.openqa.selenium.support.ui.Select select = new org.openqa.selenium.support.ui.Select(" + fieldName + ");");
        writer.println("        select.selectByVisibleText(text);");
        writer.println("        return this;");
        writer.println("    }");
        writer.println();
        
        // Select by value method
        methodBaseName = "select" + capitalize(fieldName) + "ByValue";
        methodName = getUniqueMethodName(methodBaseName, methodNames);
        
        writer.println("    /**");
        writer.println("     * Select option by value from " + fieldName);
        writer.println("     * @param value Value of the option to select");
        writer.println("     * @return The page object instance");
        writer.println("     */");
        writer.println("    @CSSmartTestStep(\"Select option with value {0} from " + fieldName + "\")");
        writer.println("    public " + pageName + " " + methodName + "(String value) {");
        writer.println("        " + fieldName + ".waitForVisible(10);");
        writer.println("        org.openqa.selenium.support.ui.Select select = new org.openqa.selenium.support.ui.Select(" + fieldName + ");");
        writer.println("        select.selectByValue(value);");
        writer.println("        return this;");
        writer.println("    }");
        writer.println();
    }
    
    /**
     * Generate methods for textarea elements
     * @param writer PrintWriter
     * @param element Element information
     * @param fieldName Field name
     * @param methodNames Set of existing method names
     * @param pageName Name of the page
     */
    private static void generateTextareaMethods(PrintWriter writer, ElementInfo element, 
            String fieldName, Set<String> methodNames, String pageName) {
        // Enter text method
        String methodBaseName = "enter" + capitalize(fieldName);
        String methodName = getUniqueMethodName(methodBaseName, methodNames);
        
        writer.println("    /**");
        writer.println("     * Enter text in " + fieldName);
        if (element.getPlaceholder() != null && !element.getPlaceholder().isEmpty()) {
            writer.println("     * Field placeholder: " + element.getPlaceholder());
        }
        writer.println("     * @param text Text to enter");
        writer.println("     * @return The page object instance");
        writer.println("     */");
        writer.println("    @CSSmartTestStep(\"Enter text in " + 
            (element.getPlaceholder() != null ? element.getPlaceholder() : fieldName) + "\")");
        writer.println("    public " + pageName + " " + methodName + "(String text) {");
        writer.println("        " + fieldName + ".waitForVisible(10);");
        writer.println("        " + fieldName + ".type(text);");
        writer.println("        return this;");
        writer.println("    }");
        writer.println();
    }
    
    /**
     * Generate generic methods for other elements
     * @param writer PrintWriter
     * @param element Element information
     * @param fieldName Field name
     * @param methodNames Set of existing method names
     * @param pageName Name of the page
     */
    private static void generateGenericMethods(PrintWriter writer, ElementInfo element, 
            String fieldName, Set<String> methodNames, String pageName) {
        // Generic click method
        String methodBaseName = "click" + capitalize(fieldName);
        String methodName = getUniqueMethodName(methodBaseName, methodNames);
        
        writer.println("    /**");
        writer.println("     * Click on " + fieldName);
        writer.println("     * @return The page object instance");
        writer.println("     */");
        writer.println("    @CSSmartTestStep(\"Click on " + fieldName + "\")");
        writer.println("    public " + pageName + " " + methodName + "() {");
        writer.println("        " + fieldName + ".waitForClickable(10);");
        writer.println("        " + fieldName + ".click();");
        writer.println("        return this;");
        writer.println("    }");
        writer.println();
        
        // Is displayed method
        methodBaseName = "is" + capitalize(fieldName) + "Displayed";
        methodName = getUniqueMethodName(methodBaseName, methodNames);
        
        writer.println("    /**");
        writer.println("     * Check if " + fieldName + " is displayed");
        writer.println("     * @return true if the element is displayed, false otherwise");
        writer.println("     */");
        writer.println("    public boolean " + methodName + "() {");
        writer.println("        return " + fieldName + ".exists() && " + fieldName + ".isDisplayed();");
        writer.println("    }");
        writer.println();
    }
    
    /**
     * Capitalize first letter of a string
     * @param str Input string
     * @return Capitalized string
     */
    private static String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return Character.toUpperCase(str.charAt(0)) + str.substring(1);
    }
    
    /**
     * Get a unique method name
     * @param baseName Base method name
     * @param methodNames Set of existing method names
     * @return Unique method name
     */
    private static String getUniqueMethodName(String baseName, Set<String> methodNames) {
        String methodName = baseName;
        int counter = 1;
        
        while (methodNames.contains(methodName)) {
            methodName = baseName + counter;
            counter++;
        }
        
        methodNames.add(methodName);
        return methodName;
    }
    
    /**
     * Generate feature file with test scenario for a page
     * @param pageName The name of the page
     * @param pageTitle The page title
     * @param elements The list of element information
     * @return True if the generation was successful
     */
    public static boolean generateFeatureFile(String pageName, String pageTitle, List<ElementInfo> elements) {
        try {
            // Create output directory if it doesn't exist
            File featureDir = new File(OUTPUT_DIR + File.separator + "features");
            if (!featureDir.exists()) {
                featureDir.mkdirs();
            }
            
            // Create feature file
            File outputFile = new File(featureDir, pageName + ".feature");
            
            try (PrintWriter writer = new PrintWriter(new FileWriter(outputFile))) {
                // Write feature header
                writer.println("Feature: " + pageTitle);
                writer.println("  As a user");
                writer.println("  I want to interact with the " + pageName + " page");
                writer.println("  So that I can perform necessary actions");
                writer.println();
                
                // Write a basic scenario for navigating to the page
                writer.println("  @smoke");
                writer.println("  Scenario: Navigate to " + pageName + " page");
                writer.println("    Given I am on the " + pageName + " page");
                writer.println("    Then the page title should be \"" + pageTitle + "\"");
                writer.println();
                
                // Generate scenarios based on element types
                generateInputScenarios(writer, elements, pageName);
                generateButtonScenarios(writer, elements, pageName);
                generateLinkScenarios(writer, elements, pageName);
                
                // Add more scenarios as needed
            }
            
            LOGGER.info("Generated feature file: " + outputFile.getAbsolutePath());
            return true;
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Failed to generate feature file", e);
            return false;
        }
    }
    
    /**
     * Generate scenarios for input elements
     * @param writer PrintWriter
     * @param elements List of element information
     * @param pageName Name of the page
     */
    private static void generateInputScenarios(PrintWriter writer, List<ElementInfo> elements, String pageName) {
        // Collect input fields
        List<ElementInfo> textInputs = new ArrayList<>();
        List<ElementInfo> checkboxes = new ArrayList<>();
        List<ElementInfo> radioButtons = new ArrayList<>();
        
        for (ElementInfo element : elements) {
            if ("input".equals(element.getTagName())) {
                String inputType = element.getType() != null ? element.getType().toLowerCase() : "text";
                
                switch (inputType) {
                    case "text":
                    case "email":
                    case "password":
                    case "tel":
                    case "url":
                    case "search":
                    case "number":
                        textInputs.add(element);
                        break;
                    case "checkbox":
                        checkboxes.add(element);
                        break;
                    case "radio":
                        radioButtons.add(element);
                        break;
                }
            } else if ("textarea".equals(element.getTagName())) {
                textInputs.add(element);
            }
        }
        
        // Generate a form submission scenario if there are input fields
        if (!textInputs.isEmpty()) {
            writer.println("  @regression");
            writer.println("  Scenario: Enter data in form fields on " + pageName + " page");
            writer.println("    Given I am on the " + pageName + " page");
            
            for (ElementInfo input : textInputs) {
                String fieldName = input.getPlaceholder() != null && !input.getPlaceholder().isEmpty() ? 
                    input.getPlaceholder() : 
                    (input.getName() != null && !input.getName().isEmpty() ? input.getName() : "the field");
                
                // Determine sample data based on field type
                String sampleData = getSampleDataForField(input);
                
                writer.println("    When I enter \"" + sampleData + "\" in " + fieldName);
            }
            
            // Add checkbox interactions
            for (ElementInfo checkbox : checkboxes) {
                String fieldName = checkbox.getText() != null && !checkbox.getText().isEmpty() ? 
                    checkbox.getText() : 
                    (checkbox.getName() != null && !checkbox.getName().isEmpty() ? checkbox.getName() : "the checkbox");
                
                writer.println("    And I check " + fieldName);
            }
            
            // Add radio button interactions
            for (ElementInfo radio : radioButtons) {
                String fieldName = radio.getText() != null && !radio.getText().isEmpty() ? 
                    radio.getText() : 
                    (radio.getName() != null && !radio.getName().isEmpty() ? radio.getName() : "the radio button");
                
                writer.println("    And I select " + fieldName + " radio button");
            }
            
            // Look for a submit button
            ElementInfo submitButton = findSubmitButton(elements);
            if (submitButton != null) {
                String buttonText = submitButton.getText() != null && !submitButton.getText().isEmpty() ? 
                    submitButton.getText() : "the submit button";
                    
                writer.println("    And I click on " + buttonText);
                writer.println("    Then I should see a confirmation message");
            }
            
            writer.println();
        }
    }
    
    /**
     * Generate scenarios for button elements
     * @param writer PrintWriter
     * @param elements List of element information
     * @param pageName Name of the page
     */
    private static void generateButtonScenarios(PrintWriter writer, List<ElementInfo> elements, String pageName) {
        // Find non-submit buttons
        List<ElementInfo> actionButtons = new ArrayList<>();
        
        for (ElementInfo element : elements) {
            if ("button".equals(element.getTagName())) {
                String type = element.getType() != null ? element.getType().toLowerCase() : "";
                if (!"submit".equals(type)) {
                    actionButtons.add(element);
                }
            }
        }
        
        // Generate scenarios for action buttons
        if (!actionButtons.isEmpty()) {
            writer.println("  @regression");
            writer.println("  Scenario: Interact with buttons on " + pageName + " page");
            writer.println("    Given I am on the " + pageName + " page");
            
            for (ElementInfo button : actionButtons) {
                String buttonText = button.getText() != null && !button.getText().isEmpty() ? 
                    button.getText() : 
                    (button.getName() != null && !button.getName().isEmpty() ? button.getName() : "the button");
                
                writer.println("    When I click on " + buttonText);
                writer.println("    Then I should see the relevant content");
            }
            
            writer.println();
        }
    }
    
    /**
     * Generate scenarios for link elements
     * @param writer PrintWriter
     * @param elements List of element information
     * @param pageName Name of the page
     */
    private static void generateLinkScenarios(PrintWriter writer, List<ElementInfo> elements, String pageName) {
        // Collect links
        List<ElementInfo> links = new ArrayList<>();
        
        for (ElementInfo element : elements) {
            if ("a".equals(element.getTagName())) {
                links.add(element);
            }
        }
        
        // Generate a navigation scenario if there are links
        if (!links.isEmpty()) {
            writer.println("  @navigation @regression");
            writer.println("  Scenario: Navigate using links on " + pageName + " page");
            writer.println("    Given I am on the " + pageName + " page");
            
            for (int i = 0; i < Math.min(links.size(), 5); i++) { // Limit to max 5 links
                ElementInfo link = links.get(i);
                String linkText = link.getText() != null && !link.getText().isEmpty() ? 
                    link.getText() : 
                    (link.getName() != null && !link.getName().isEmpty() ? link.getName() : "the link");
                
                writer.println("    When I click on " + linkText + " link");
                writer.println("    And I navigate back");
            }
            
            writer.println("    Then I should be on the " + pageName + " page");
            writer.println();
        }
    }
    
    /**
     * Find a submit button among elements
     * @param elements List of element information
     * @return Submit button element or null if not found
     */
    private static ElementInfo findSubmitButton(List<ElementInfo> elements) {
        for (ElementInfo element : elements) {
            // Check for input type="submit"
            if ("input".equals(element.getTagName()) && 
                "submit".equals(element.getType())) {
                return element;
            }
            
            // Check for button type="submit"
            if ("button".equals(element.getTagName()) && 
                "submit".equals(element.getType())) {
                return element;
            }
            
            // Check for button with submit-like text
            if ("button".equals(element.getTagName()) && 
                element.getText() != null) {
                String text = element.getText().toLowerCase();
                if (text.contains("submit") || text.contains("save") || text.contains("next") || 
                    text.contains("continue") || text.contains("login") || text.contains("sign in") ||
                    text.contains("register") || text.contains("sign up")) {
                    return element;
                }
            }
        }
        
        return null;
    }
    
    /**
     * Get sample data based on field type
     * @param element Element information
     * @return Sample data
     */
    private static String getSampleDataForField(ElementInfo element) {
        if ("input".equals(element.getTagName()) && element.getType() != null) {
            String inputType = element.getType().toLowerCase();
            String fieldName = "";
            
            if (element.getName() != null && !element.getName().isEmpty()) {
                fieldName = element.getName().toLowerCase();
            } else if (element.getPlaceholder() != null && !element.getPlaceholder().isEmpty()) {
                fieldName = element.getPlaceholder().toLowerCase();
            } else if (element.getId() != null && !element.getId().isEmpty()) {
                fieldName = element.getId().toLowerCase();
            }
            
            switch (inputType) {
                case "email":
                    return "test@example.com";
                case "password":
                    return "Password123!";
                case "tel":
                    return "1234567890";
                case "url":
                    return "https://example.com";
                case "number":
                    return "42";
                case "date":
                    return "2023-01-01";
                case "text":
                default:
                    // Check field name for hints
                    if (fieldName.contains("email")) {
                        return "test@example.com";
                    } else if (fieldName.contains("name")) {
                        if (fieldName.contains("first") || fieldName.contains("fname")) {
                            return "John";
                        } else if (fieldName.contains("last") || fieldName.contains("lname")) {
                            return "Doe";
                        } else {
                            return "John Doe";
                        }
                    } else if (fieldName.contains("password")) {
                        return "Password123!";
                    } else if (fieldName.contains("phone") || fieldName.contains("mobile")) {
                        return "1234567890";
                    } else if (fieldName.contains("address")) {
                        return "123 Test Street";
                    } else if (fieldName.contains("city")) {
                        return "Test City";
                    } else if (fieldName.contains("zip") || fieldName.contains("postal")) {
                        return "12345";
                    } else if (fieldName.contains("country")) {
                        return "Test Country";
                    } else if (fieldName.contains("search")) {
                        return "search term";
                    } else {
                        return "Test data";
                    }
            }
        } else if ("textarea".equals(element.getTagName())) {
            return "This is a test message with multiple words to test textarea input.";
        }
        
        return "Test data";
    }
    
    /**
     * Element information class
     */
    public static class ElementInfo {
        private String tagName;
        private String id;
        private String name;
        private String type;
        private String value;
        private String text;
        private String placeholder;
        private String className;
        private String xpath;
        private Map<String, String> attributes = new HashMap<>();
        private String locatorType;
        private String locatorValue;
        
        public String getTagName() {
            return tagName;
        }
        
        public void setTagName(String tagName) {
            this.tagName = tagName;
        }
        
        public String getId() {
            return id;
        }
        
        public void setId(String id) {
            this.id = id;
        }
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
        
        public String getType() {
            return type;
        }
        
        public void setType(String type) {
            this.type = type;
        }
        
        public String getValue() {
            return value;
        }
        
        public void setValue(String value) {
            this.value = value;
        }
        
        public String getText() {
            return text;
        }
        
        public void setText(String text) {
            this.text = text;
        }
        
        public String getPlaceholder() {
            return placeholder;
        }
        
        public void setPlaceholder(String placeholder) {
            this.placeholder = placeholder;
        }
        
        public String getClassName() {
            return className;
        }
        
        public void setClassName(String className) {
            this.className = className;
        }
        
        public String getXpath() {
            return xpath;
        }
        
        public void setXpath(String xpath) {
            this.xpath = xpath;
        }
        
        public Map<String, String> getAttributes() {
            return attributes;
        }
        
        public void setAttributes(Map<String, String> attributes) {
            this.attributes = attributes;
        }
        
        public String getLocatorType() {
            return locatorType;
        }
        
        public void setLocatorType(String locatorType) {
            this.locatorType = locatorType;
        }
        
        public String getLocatorValue() {
            return locatorValue;
        }
        
        public void setLocatorValue(String locatorValue) {
            this.locatorValue = locatorValue;
        }
    }
}


package com.cssmart.ai.optimizer;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import com.cssmart.config.PropertyManager;
import com.cssmart.reporting.TestStatus;

/**
 * AI-based test optimization utility
 */
public class TestOptimizer {
    
    private static final Logger LOGGER = Logger.getLogger(TestOptimizer.class.getName());
    private static final PropertyManager properties = PropertyManager.getInstance();
    
    // Test execution data
    private static Map<String, TestExecutionData> testExecutionHistory = new HashMap<>();
    private static Map<String, List<String>> testDependencies = new HashMap<>();
    private static Set<String> flakyCandidates = new HashSet<>();
    
    /**
     * Record test execution
     * @param testId Test identifier
     * @param status Test status
     * @param executionTime Execution time in milliseconds
     * @param dependencies List of dependencies (e.g., other tests that were executed before this one)
     */
    public static void recordTestExecution(String testId, TestStatus status, long executionTime, List<String> dependencies) {
        TestExecutionData data = testExecutionHistory.getOrDefault(testId, new TestExecutionData(testId));
        data.addExecution(status, executionTime);
        testExecutionHistory.put(testId, data);
        
        // Record dependencies
        if (dependencies != null && !dependencies.isEmpty()) {
            testDependencies.put(testId, new ArrayList<>(dependencies));
        }
        
        // Check for flakiness
        if (data.getExecutionCount() > 1) {
            List<TestStatus> lastStatuses = data.getLastStatuses(2);
            if (lastStatuses.size() == 2 && !lastStatuses.get(0).equals(lastStatuses.get(1))) {
                flakyCandidates.add(testId);
            }
        }
        
        // Save data periodically
        if (testExecutionHistory.size() % 10 == 0) {
            saveTestExecutionData();
        }
    }
    
    /**
     * Save test execution data to file
     */
    private static void saveTestExecutionData() {
        try {
            File dataDir = new File(properties.getProperty("optimizer.data.dir", "optimizer-data"));
            if (!dataDir.exists()) {
                dataDir.mkdirs();
            }
            
            // Save execution history
            try (PrintWriter writer = new PrintWriter(new FileWriter(new File(dataDir, "execution-history.csv")))) {
                writer.println("TestId,ExecutionCount,SuccessRate,AvgExecutionTime,LastExecutionStatus");
                
                for (TestExecutionData data : testExecutionHistory.values()) {
                    writer.println(String.format("%s,%d,%.2f,%d,%s",
                        data.getTestId(),
                        data.getExecutionCount(),
                        data.getSuccessRate(),
                        data.getAverageExecutionTime(),
                        data.getLastStatus()));
                }
            }
            
            // Save dependencies
            try (PrintWriter writer = new PrintWriter(new FileWriter(new File(dataDir, "dependencies.csv")))) {
                writer.println("TestId,Dependencies");
                
                for (Map.Entry<String, List<String>> entry : testDependencies.entrySet()) {
                    writer.println(String.format("%s,%s",
                        entry.getKey(),
                        String.join("|", entry.getValue())));
                }
            }
            
            // Save flaky candidates
            try (PrintWriter writer = new PrintWriter(new FileWriter(new File(dataDir, "flaky-candidates.txt")))) {
                for (String testId : flakyCandidates) {
                    writer.println(testId);
                }
            }
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, "Failed to save test execution data", e);
        }
    }
    
    /**
     * Get optimized test execution order
     * @param tests List of tests to execute
     * @return Optimized order of tests
     */
    public static List<String> getOptimizedExecutionOrder(List<String> tests) {
        // If we don't have enough history, return the original order
        if (testExecutionHistory.isEmpty() || tests.size() <= 1) {
            return tests;
        }
        
        List<String> availableTests = new ArrayList<>(tests);
        List<String> executionOrder = new ArrayList<>();
        
        // First, add tests that have been failing recently to detect issues earlier
        List<String> failingTests = availableTests.stream()
            .filter(testId -> {
                TestExecutionData data = testExecutionHistory.get(testId);
                return data != null && data.getLastStatus() == TestStatus.FAILED;
            })
            .sorted(Comparator.comparing(testId -> -testExecutionHistory.get(testId).getExecutionCount()))
            .collect(Collectors.toList());
        
        executionOrder.addAll(failingTests);
        availableTests.removeAll(failingTests);
        
        // Then, add flaky tests for early detection
        List<String> flakyTests = availableTests.stream()
            .filter(flakyCandidates::contains)
            .collect(Collectors.toList());
        
        executionOrder.addAll(flakyTests);
        availableTests.removeAll(flakyTests);
        
        // Sort remaining tests by execution time (fastest first) to get quick feedback
        List<String> sortedByExecutionTime = availableTests.stream()
            .sorted(Comparator.comparing(testId -> {
                TestExecutionData data = testExecutionHistory.get(testId);
                return data != null ? data.getAverageExecutionTime() : Long.MAX_VALUE;
            }))
            .collect(Collectors.toList());
        
        executionOrder.addAll(sortedByExecutionTime);
        
        // Finally, ensure dependency order is maintained
        executionOrder = reorderBasedOnDependencies(executionOrder);
        
        return executionOrder;
    }
    
    /**
     * Reorder tests based on dependencies
     * @param tests List of tests to reorder
     * @return Reordered list of tests
     */
    private static List<String> reorderBasedOnDependencies(List<String> tests) {
        // Build dependency graph
        Map<String, Set<String>> dependencyGraph = new HashMap<>();
        Set<String> visited = new HashSet<>();
        List<String> result = new ArrayList<>();
        
        // Initialize graph
        for (String test : tests) {
            dependencyGraph.put(test, new HashSet<>());
        }
        
        // Add dependencies
        for (String test : tests) {
            List<String> dependencies = testDependencies.get(test);
            if (dependencies != null) {
                for (String dependency : dependencies) {
                    if (tests.contains(dependency)) {
                        dependencyGraph.get(test).add(dependency);
                    }
                }
            }
        }
        
        // Topological sort
        for (String test : tests) {
            if (!visited.contains(test)) {
                topologicalSort(test, dependencyGraph, visited, result);
            }
        }
        
        return result;
    }
    
    /**
     * Topological sort for dependency ordering
     * @param test Current test
     * @param dependencyGraph Dependency graph
     * @param visited Set of visited tests
     * @param result Result list
     */
    private static void topologicalSort(String test, Map<String, Set<String>> dependencyGraph,
            Set<String> visited, List<String> result) {
        visited.add(test);
        
        Set<String> dependencies = dependencyGraph.get(test);
        if (dependencies != null) {
            for (String dependency : dependencies) {
                if (!visited.contains(dependency)) {
                    topologicalSort(dependency, dependencyGraph, visited, result);
                }
            }
        }
        
        result.add(0, test);
    }
    
    /**
     * Get test recommendations based on execution history
     * @return List of recommendations
     */
    public static List<TestRecommendation> getTestRecommendations() {
        List<TestRecommendation> recommendations = new ArrayList<>();
        
        // Identify flaky tests
        for (String testId : flakyCandidates) {
            TestExecutionData data = testExecutionHistory.get(testId);
            if (data != null && data.getExecutionCount() > 3 && data.getSuccessRate() < 0.9) {
                recommendations.add(new TestRecommendation(
                    TestRecommendationType.FLAKY_TEST,
                    testId,
                    "Test is showing flaky behavior with success rate of " + 
                        String.format("%.1f%%", data.getSuccessRate() * 100) + 
                        ". Consider stabilizing the test or its environment."
                ));
            }
        }
        
        // Identify slow tests
        long averageExecutionTime = testExecutionHistory.values().stream()
            .mapToLong(TestExecutionData::getAverageExecutionTime)
            .filter(time -> time > 0)
            .average()
            .orElse(0);
        
        if (averageExecutionTime > 0) {
            long threshold = (long) (averageExecutionTime * 3); // 3x the average
            for (TestExecutionData data : testExecutionHistory.values()) {
                if (data.getAverageExecutionTime() > threshold && data.getExecutionCount() > 2) {
                    recommendations.add(new TestRecommendation(
                        TestRecommendationType.SLOW_TEST,
                        data.getTestId(),
                        "Test is executing slowly (avg: " + 
                            formatDuration(data.getAverageExecutionTime()) + 
                            "). Consider optimizing or splitting this test."
                    ));
                }
            }
        }
        
        // Identify redundant tests based on execution patterns
        identifyRedundantTests().forEach(pair -> {
            recommendations.add(new TestRecommendation(
                TestRecommendationType.REDUNDANT_TEST,
                pair.getLeft(),
                "Test may be redundant with " + pair.getRight() + 
                    ". Consider merging or removing one of these tests."
            ));
        });
        
        return recommendations;
    }
    
    /**
     * Identify potentially redundant tests
     * @return List of redundant test pairs (left is redundant, right is keeper)
     */
    private static List<Pair<String, String>> identifyRedundantTests() {
        List<Pair<String, String>> redundantTests = new ArrayList<>();
        
        // Simple heuristic: if two tests always have the same results, one might be redundant
        List<String> tests = new ArrayList<>(testExecutionHistory.keySet());
        
        for (int i = 0; i < tests.size(); i++) {
            for (int j = i + 1; j < tests.size(); j++) {
                String test1 = tests.get(i);
                String test2 = tests.get(j);
                
                TestExecutionData data1 = testExecutionHistory.get(test1);
                TestExecutionData data2 = testExecutionHistory.get(test2);
                
                // Skip if either test doesn't have enough executions
                if (data1.getExecutionCount() < 3 || data2.getExecutionCount() < 3) {
                    continue;
                }
                
                // Check if test results have same pattern in recent executions
                boolean sameResults = true;
                List<TestStatus> statuses1 = data1.getLastStatuses(3);
                List<TestStatus> statuses2 = data2.getLastStatuses(3);
                
                if (statuses1.size() != statuses2.size()) {
                    continue;
                }
                
                for (int k = 0; k < statuses1.size(); k++) {
                    if (statuses1.get(k) != statuses2.get(k)) {
                        sameResults = false;
                        break;
                    }
                }
                
                if (sameResults) {
                    // Determine which test might be redundant (shorter execution time is keeper)
                    if (data1.getAverageExecutionTime() > data2.getAverageExecutionTime()) {
                        redundantTests.add(new Pair<>(test1, test2));
                    } else {
                        redundantTests.add(new Pair<>(test2, test1));
                    }
                }
            }
        }
        
        return redundantTests;
    }
    
    /**
     * Format duration in milliseconds to a human-readable string
     * @param durationMs Duration in milliseconds
     * @return Formatted duration string
     */
    private static String formatDuration(long durationMs) {
        if (durationMs < 1000) {
            return durationMs + "ms";
        } else if (durationMs < 60000) {
            return String.format("%.1fs", durationMs / 1000.0);
        } else {
            long minutes = TimeUnit.MILLISECONDS.toMinutes(durationMs);
            long seconds = TimeUnit.MILLISECONDS.toSeconds(durationMs) - TimeUnit.MINUTES.toSeconds(minutes);
            return String.format("%dm %ds", minutes, seconds);
        }
    }
    
    /**
     * Pair class for holding two related items
     */
    public static class Pair<L, R> {
        private final L left;
        private final R right;
        
        public Pair(L left, R right) {
            this.left = left;
            this.right = right;
        }
        
        public L getLeft() {
            return left;
        }
        
        public R getRight() {
            return right;
        }
    }
    
    /**
     * Test execution data class
     */
    public static class TestExecutionData {
        private final String testId;
        private int executionCount;
        private int successCount;
        private long totalExecutionTime;
        private final LinkedList<TestStatus> lastStatuses;
        
        public TestExecutionData(String testId) {
            this.testId = testId;
            this.executionCount = 0;
            this.successCount = 0;
            this.totalExecutionTime = 0;
            this.lastStatuses = new LinkedList<>();
        }
        
        public void addExecution(TestStatus status, long executionTime) {
            executionCount++;
            if (status == TestStatus.PASSED) {
                successCount++;
            }
            totalExecutionTime += executionTime;
            
            // Keep only last 5 statuses
            if (lastStatuses.size() >= 5) {
                lastStatuses.removeFirst();
            }
            lastStatuses.addLast(status);
        }
        
        public String getTestId() {
            return testId;
        }
        
        public int getExecutionCount() {
            return executionCount;
        }
        
        public double getSuccessRate() {
            return executionCount > 0 ? (double) successCount / executionCount : 0;
        }
        
        public long getAverageExecutionTime() {
            return executionCount > 0 ? totalExecutionTime / executionCount : 0;
        }
        
        public TestStatus getLastStatus() {
            return lastStatuses.isEmpty() ? null : lastStatuses.getLast();
        }
        
        public List<TestStatus> getLastStatuses(int count) {
            int size = Math.min(count, lastStatuses.size());
            return new ArrayList<>(lastStatuses.subList(lastStatuses.size() - size, lastStatuses.size()));
        }
    }
    
    /**
     * Test recommendation type enum
     */
    public enum TestRecommendationType {
        FLAKY_TEST,
        SLOW_TEST,
        REDUNDANT_TEST,
        COVERAGE_GAP,
        DEPENDENCY_ISSUE
    }
    
    /**
     * Test recommendation class
     */
    public static class TestRecommendation {
        private final TestRecommendationType type;
        private final String testId;
        private final String message;
        
        public TestRecommendation(TestRecommendationType type, String testId, String message) {
            this.type = type;
            this.testId = testId;
            this.message = message;
        }
        
        public TestRecommendationType getType() {
            return type;
        }
        
        public String getTestId() {
            return testId;
        }
        
        public String getMessage() {
            return message;
        }
    }
}



/**
 * Sample project structure for CS Smart Automation Framework
 */

// pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.cssmart</groupId>
    <artifactId>cssmart-automation-framework</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <selenium.version>4.13.0</selenium.version>
        <webdrivermanager.version>5.5.3</webdrivermanager.version>
        <testng.version>7.8.0</testng.version>
        <jackson.version>2.15.2</jackson.version>
        <commons-io.version>2.13.0</commons-io.version>
        <commons-lang3.version>3.12.0</commons-lang3.version>
        <log4j.version>2.20.0</log4j.version>
        <slf4j.version>2.0.9</slf4j.version>
        <javacv.version>1.5.9</javacv.version>
    </properties>

    <dependencies>
        <!-- Selenium -->
        <dependency>
            <groupId>org.seleniumhq.selenium</groupId>
            <artifactId>selenium-java</artifactId>
            <version>${selenium.version}</version>
        </dependency>
        
        <!-- WebDriverManager -->
        <dependency>
            <groupId>io.github.bonigarcia</groupId>
            <artifactId>webdrivermanager</artifactId>
            <version>${webdrivermanager.version}</version>
        </dependency>
        
        <!-- TestNG -->
        <dependency>
            <groupId>org.testng</groupId>
            <artifactId>testng</artifactId>
            <version>${testng.version}</version>
        </dependency>
        
        <!-- Jackson for JSON processing -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>${jackson.version}</version>
        </dependency>
        
        <!-- Apache Commons -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>${commons-io.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>${commons-lang3.version}</version>
        </dependency>
        
        <!-- Logging -->
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>${log4j.version}</version>
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>${log4j.version}</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-simple</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        
        <!-- For AI Visual Testing -->
        <dependency>
            <groupId>org.bytedeco</groupId>
            <artifactId>javacv-platform</artifactId>
            <version>${javacv.version}</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${maven.compiler.source}</source>
                    <target>${maven.compiler.target}</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.1.2</version>
                <configuration>
                    <suiteXmlFiles>
                        <suiteXmlFile>src/test/resources/testng.xml</suiteXmlFile>
                    </suiteXmlFiles>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

// Configuration properties
// src/main/resources/config/cssmart.properties
# CS Smart Automation Framework Base Configuration

# Driver Configuration
browser=chrome
execution.mode=local
implicit.wait=10
page.load.timeout=30
script.timeout=30
element.wait.timeout=15

# Web Driver Paths
webdriver.chrome.driver=drivers/chromedriver
webdriver.gecko.driver=drivers/geckodriver
webdriver.edge.driver=drivers/msedgedriver

# Remote Execution
grid.hub.url=http://localhost:4444/wd/hub
grid.platform=WINDOWS

# Screenshot Configuration
screenshot.path=target/screenshots
screenshot.on.failure=true
screenshot.per.step=false

# Reporting Configuration
report.dir=target/cssmart-reports

# Element Interaction
click.max.retries=3
click.retry.interval=500

# AI Features
self.healing.enabled=true
self.healing.tolerance=0.8
visual.baseline.dir=visual-baseline
visual.threshold=0.02
generator.output.dir=generated-tests
optimizer.data.dir=optimizer-data

# Test Data
testdata.base.path=src/test/resources/testdata

# Environment
env.base.url=https://demo.cssmart.com
env.api.url=https://api.cssmart.com
env.db.connection=jdbc:mysql://localhost:3306/cssmart
env.db.username=cssmart
env.db.password=password123

// Environment properties
// src/main/resources/config/dev.properties
# Development Environment Configuration
env.base.url=https://dev.cssmart.com
env.api.url=https://dev-api.cssmart.com
env.db.connection=jdbc:mysql://dev-db:3306/cssmart
env.db.username=dev_user
env.db.password=dev_password

// src/main/resources/config/qa.properties
# QA Environment Configuration
env.base.url=https://qa.cssmart.com
env.api.url=https://qa-api.cssmart.com
env.db.connection=jdbc:mysql://qa-db:3306/cssmart
env.db.username=qa_user
env.db.password=qa_password

// src/main/resources/config/prod.properties
# Production Environment Configuration
env.base.url=https://www.cssmart.com
env.api.url=https://api.cssmart.com
env.db.connection=jdbc:mysql://prod-db:3306/cssmart
env.db.username=prod_user
env.db.password=prod_password

// Logging configuration
// src/main/resources/log4j2.xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
    <Appenders>
        <Console name="Console" target="SYSTEM_OUT">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </Console>
        <File name="File" fileName="logs/cssmart.log">
            <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
        </File>
    </Appenders>
    <Loggers>
        <Root level="info">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="File"/>
        </Root>
        <Logger name="com.cssmart" level="debug" additivity="false">
            <AppenderRef ref="Console"/>
            <AppenderRef ref="File"/>
        </Logger>
    </Loggers>
</Configuration>

// TestNG configuration
// src/test/resources/testng.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="CS Smart Automation Suite" parallel="tests" thread-count="2">
    <listeners>
        <listener class-name="com.cssmart.testng.CSSmartTestListener"/>
        <listener class-name="com.cssmart.testng.CSSmartReportListener"/>
    </listeners>
    
    <test name="Login Tests">
        <parameter name="browser" value="chrome"/>
        <classes>
            <class name="com.cssmart.tests.login.LoginTests"/>
        </classes>
    </test>
    
    <test name="Dashboard Tests">
        <parameter name="browser" value="chrome"/>
        <classes>
            <class name="com.cssmart.tests.dashboard.DashboardTests"/>
        </classes>
    </test>
</suite>

// Sample BDD Feature File
// src/test/resources/features/login.feature
Feature: User Authentication
  As a user
  I want to authenticate with the system
  So that I can access my account

  @smoke @regression
  Scenario: Successful login with valid credentials
    Given I am on the login page
    When I enter "username" in the username field
    And I enter "password" in the password field
    And I click on the login button
    Then I should be redirected to the dashboard
    And I should see the welcome message

  @regression
  Scenario Outline: Login with invalid credentials
    Given I am on the login page
    When I enter "<username>" in the username field
    And I enter "<password>" in the password field
    And I click on the login button
    Then I should see the error message "<error_message>"

    Examples:
      | username  | password  | error_message                   |
      | invalid   | password  | Invalid username or password    |
      | username  | invalid   | Invalid username or password    |
      |           | password  | Username cannot be empty        |
      | username  |           | Password cannot be empty        |


package com.cssmart.core.element;

import java.util.List;
import java.util.function.Function;
import org.openqa.selenium.*;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;
import java.time.Duration;

import com.cssmart.ai.healing.SelfHealingLocator;
import com.cssmart.ai.visual.VisualAssertions;
import com.cssmart.config.PropertyManager;
import com.cssmart.core.driver.CSSmartDriverFactory;

/**
 * Enhanced element implementation with AI capabilities built-in
 * This serves as a higher-level abstraction over CSSmartWebElement
 */
public class CSSmartElement {

    private By locator;
    private String elementName;
    private CSSmartWebElement element;
    private PropertyManager propertyManager = PropertyManager.getInstance();
    
    /**
     * Create a new smart element
     * @param locator The locator
     * @param elementName Descriptive name of the element
     */
    public CSSmartElement(By locator, String elementName) {
        this.locator = locator;
        this.elementName = elementName;
    }
    
    /**
     * Get the underlying CSSmartWebElement
     * @return The CSSmartWebElement
     */
    public CSSmartWebElement getElement() {
        if (element == null) {
            element = new CSSmartWebElement(locator, elementName);
        }
        return element;
    }
    
    /**
     * Type text into the element with automatic visibility wait
     * @param text Text to type
     * @return This element for chaining
     */
    public CSSmartElement type(String text) {
        waitVisible();
        getElement().type(text);
        return this;
    }
    
    /**
     * Clear and type text into the element
     * @param text Text to type
     * @return This element for chaining
     */
    public CSSmartElement clearAndType(String text) {
        waitVisible();
        getElement().clear();
        getElement().type(text);
        return this;
    }
    
    /**
     * Click the element with automatic clickability wait
     * @return This element for chaining
     */
    public CSSmartElement click() {
        waitClickable();
        getElement().click();
        return this;
    }
    
    /**
     * Click with retry logic for unstable elements
     * @return This element for chaining
     */
    public CSSmartElement clickWithRetry() {
        waitClickable();
        getElement().clickWithRetry();
        return this;
    }
    
    /**
     * Wait for element to be visible
     * @return This element for chaining
     */
    public CSSmartElement waitVisible() {
        int timeout = propertyManager.getIntProperty("element.wait.timeout", 15);
        getElement().waitForVisible(timeout);
        return this;
    }
    
    /**
     * Wait for element to be clickable
     * @return This element for chaining
     */
    public CSSmartElement waitClickable() {
        int timeout = propertyManager.getIntProperty("element.wait.timeout", 15);
        getElement().waitForClickable(timeout);
        return this;
    }
    
    /**
     * Wait for element with custom condition
     * @param condition The wait condition
     * @return This element for chaining
     */
    public CSSmartElement waitFor(Function<WebDriver, Boolean> condition) {
        int timeout = propertyManager.getIntProperty("element.wait.timeout", 15);
        WebDriverWait wait = new WebDriverWait(CSSmartDriverFactory.getDriver(), Duration.ofSeconds(timeout));
        wait.until(condition);
        return this;
    }
    
    /**
     * Get text from element
     * @return Text content
     */
    public String getText() {
        waitVisible();
        return getElement().getTextSafe();
    }
    
    /**
     * Check if element exists
     * @return true if element exists
     */
    public boolean exists() {
        return getElement().exists();
    }
    
    /**
     * Check if element is displayed
     * @return true if element is displayed
     */
    public boolean isDisplayed() {
        if (!exists()) {
            return false;
        }
        return getElement().isDisplayed();
    }
    
    /**
     * Verify element visually matches baseline
     * @return true if visual match
     */
    public boolean visuallyMatches() {
        waitVisible();
        return VisualAssertions.assertElementLooksTheSame(getElement(), elementName);
    }
    
    /**
     * Verify element visually matches baseline with custom threshold
     * @param threshold Difference threshold (0.0-1.0)
     * @return true if visual match
     */
    public boolean visuallyMatches(double threshold) {
        waitVisible();
        return VisualAssertions.assertElementLooksTheSame(getElement(), elementName, threshold);
    }
    
    /**
     * Get child element
     * @param childLocator Locator for child
     * @param childName Name of child element
     * @return Child element
     */
    public CSSmartElement getChild(By childLocator, String childName) {
        WebElement childWebElement = getElement().findElement(childLocator);
        CSSmartWebElement child = new CSSmartWebElement(childLocator, childName);
        return new CSSmartElement(childLocator, childName);
    }
    
    /**
     * Get child elements
     * @param childLocator Locator for children
     * @return List of WebElements
     */
    public List<WebElement> getChildren(By childLocator) {
        return getElement().findElements(childLocator);
    }
    
    /**
     * Get attribute value
     * @param attribute Attribute name
     * @return Attribute value
     */
    public String getAttribute(String attribute) {
        return getElement().getAttribute(attribute);
    }
    
    /**
     * Check if element has attribute
     * @param attribute Attribute name 
     * @return True if attribute exists
     */
    public boolean hasAttribute(String attribute) {
        return getAttribute(attribute) != null;
    }
    
    /**
     * Check if element has class
     * @param className Class name to check
     * @return True if element has class
     */
    public boolean hasClass(String className) {
        String classes = getAttribute("class");
        if (classes == null) {
            return false;
        }
        for (String cls : classes.split("\\s+")) {
            if (cls.equals(className)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Scroll element into view
     * @return This element for chaining
     */
    public CSSmartElement scrollIntoView() {
        WebDriver driver = CSSmartDriverFactory.getDriver();
        if (driver instanceof JavascriptExecutor) {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            js.executeScript("arguments[0].scrollIntoView(true);", getElement());
            try {
                // Allow time for scrolling animation
                Thread.sleep(500);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        return this;
    }
    
    /**
     * Highlight the element for debugging
     * @return This element for chaining
     */
    public CSSmartElement highlight() {
        WebDriver driver = CSSmartDriverFactory.getDriver();
        if (driver instanceof JavascriptExecutor) {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            String originalStyle = getElement().getAttribute("style");
            js.executeScript(
                "arguments[0].setAttribute('style', 'border: 2px solid red; background: yellow;');",
                getElement());
            
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            // Restore original style
            js.executeScript(
                "arguments[0].setAttribute('style', arguments[1]);", 
                getElement(), originalStyle);
        }
        return this;
    }
    
    /**
     * Take screenshot of this element
     * @param fileName Filename to save screenshot
     * @return This element for chaining
     */
    public CSSmartElement takeScreenshot(String fileName) {
        try {
            getElement().waitForVisible(5);
            File screenshot = getElement().getScreenshotAs(OutputType.FILE);
            String screenshotDir = propertyManager.getProperty("screenshot.path", "target/screenshots");
            File directory = new File(screenshotDir);
            if (!directory.exists()) {
                directory.mkdirs();
            }
            
            File dest = new File(directory, fileName);
            org.apache.commons.io.FileUtils.copyFile(screenshot, dest);
        } catch (Exception e) {
            System.err.println("Failed to take element screenshot: " + e.getMessage());
        }
        return this;
    }
}


package com.cssmart.core.driver;

import io.github.bonigarcia.wdm.WebDriverManager;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.edge.EdgeOptions;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.firefox.FirefoxOptions;
import org.openqa.selenium.safari.SafariDriver;
import org.openqa.selenium.safari.SafariOptions;
import org.openqa.selenium.remote.RemoteWebDriver;
import org.openqa.selenium.Capabilities;
import org.openqa.selenium.Platform;
import java.net.URL;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

import com.cssmart.config.PropertyManager;

/**
 * Factory for WebDriver creation with automatic driver management
 */
public class CSSmartDriverFactory {
    private static final ThreadLocal<WebDriver> driverThreadLocal = new ThreadLocal<>();
    private static final PropertyManager propertyManager = PropertyManager.getInstance();
    
    /**
     * Private constructor to prevent instantiation
     */
    private CSSmartDriverFactory() {
        // Prevent instantiation
    }
    
    /**
     * Get the current driver instance or create a new one
     * @return WebDriver instance
     */
    public static WebDriver getDriver() {
        if (driverThreadLocal.get() == null) {
            initializeDriver();
        }
        return driverThreadLocal.get();
    }
    
    /**
     * Initialize a new WebDriver instance with automatic configuration
     * @return WebDriver instance
     */
    public static WebDriver initializeDriver() {
        String browser = propertyManager.getProperty("browser", "chrome").toLowerCase();
        String mode = propertyManager.getProperty("execution.mode", "local").toLowerCase();
        WebDriver driver;
        
        if ("remote".equals(mode)) {
            driver = createRemoteDriver(browser);
        } else {
            driver = createLocalDriver(browser);
        }
        
        // Configure timeouts
        configureTimeouts(driver);
        
        // Store in ThreadLocal
        driverThreadLocal.set(driver);
        return driver;
    }
    
    /**
     * Create a local WebDriver instance
     * @param browser Browser type
     * @return WebDriver instance
     */
    private static WebDriver createLocalDriver(String browser) {
        WebDriver driver;
        boolean headless = Boolean.parseBoolean(propertyManager.getProperty("headless", "false"));
        
        switch (browser) {
            case "chrome":
                setupChromeDriver();
                ChromeOptions chromeOptions = new ChromeOptions();
                if (headless) chromeOptions.addArguments("--headless=new");
                
                // Add user-defined chrome arguments
                String chromeArgs = propertyManager.getProperty("chrome.args", "");
                if (!chromeArgs.isEmpty()) {
                    for (String arg : chromeArgs.split(",")) {
                        chromeOptions.addArguments(arg.trim());
                    }
                }
                
                driver = new ChromeDriver(chromeOptions);
                break;
                
            case "firefox":
                setupFirefoxDriver();
                FirefoxOptions firefoxOptions = new FirefoxOptions();
                if (headless) firefoxOptions.addArguments("-headless");
                driver = new FirefoxDriver(firefoxOptions);
                break;
                
            case "edge":
                setupEdgeDriver();
                EdgeOptions edgeOptions = new EdgeOptions();
                if (headless) edgeOptions.addArguments("--headless=new");
                driver = new EdgeDriver(edgeOptions);
                break;
                
            case "safari":
                setupSafariDriver();
                SafariOptions safariOptions = new SafariOptions();
                driver = new SafariDriver(safariOptions);
                break;
                
            default:
                // Default to Chrome
                setupChromeDriver();
                driver = new ChromeDriver();
        }
        
        // Maximize window unless mobile emulation
        boolean isMobile = Boolean.parseBoolean(propertyManager.getProperty("mobile.emulation", "false"));
        if (!isMobile) {
            driver.manage().window().maximize();
        }
        
        return driver;
    }
    
    /**
     * Create a remote WebDriver instance
     * @param browser Browser type
     * @return WebDriver instance
     */
    private static WebDriver createRemoteDriver(String browser) {
        try {
            String gridUrl = propertyManager.getProperty("grid.hub.url", "http://localhost:4444/wd/hub");
            Capabilities capabilities;
            
            switch (browser) {
                case "chrome":
                    ChromeOptions chromeOptions = new ChromeOptions();
                    configureBrowserOptions(chromeOptions);
                    capabilities = chromeOptions;
                    break;
                    
                case "firefox":
                    FirefoxOptions firefoxOptions = new FirefoxOptions();
                    configureBrowserOptions(firefoxOptions);
                    capabilities = firefoxOptions;
                    break;
                    
                case "edge":
                    EdgeOptions edgeOptions = new EdgeOptions();
                    configureBrowserOptions(edgeOptions);
                    capabilities = edgeOptions;
                    break;
                    
                case "safari":
                    SafariOptions safariOptions = new SafariOptions();
                    configureBrowserOptions(safariOptions);
                    capabilities = safariOptions;
                    break;
                    
                default:
                    ChromeOptions defaultOptions = new ChromeOptions();
                    configureBrowserOptions(defaultOptions);
                    capabilities = defaultOptions;
            }
            
            return new RemoteWebDriver(new URL(gridUrl), capabilities);
        } catch (Exception e) {
            throw new RuntimeException("Failed to initialize remote driver: " + e.getMessage(), e);
        }
    }
    
    /**
     * Configure common browser options
     * @param options The browser options object
     */
    private static void configureBrowserOptions(Object options) {
        // Add platform if specified
        String platformName = propertyManager.getProperty("grid.platform", "");
        if (!platformName.isEmpty()) {
            try {
                Platform platform = Platform.valueOf(platformName.toUpperCase());
                
                // This approach avoids direct class casting which might not work for all browser options
                if (options instanceof ChromeOptions) {
                    ((ChromeOptions) options).setPlatformName(platformName);
                } else if (options instanceof FirefoxOptions) {
                    ((FirefoxOptions) options).setPlatformName(platformName);
                } else if (options instanceof EdgeOptions) {
                    ((EdgeOptions) options).setPlatformName(platformName);
                } else if (options instanceof SafariOptions) {
                    ((SafariOptions) options).setPlatformName(platformName);
                }
            } catch (IllegalArgumentException e) {
                System.err.println("Invalid platform name: " + platformName);
            }
        }
        
        // Add browser version if specified
        String browserVersion = propertyManager.getProperty("browser.version", "");
        if (!browserVersion.isEmpty()) {
            if (options instanceof ChromeOptions) {
                ((ChromeOptions) options).setBrowserVersion(browserVersion);
            } else if (options instanceof FirefoxOptions) {
                ((FirefoxOptions) options).setBrowserVersion(browserVersion);
            } else if (options instanceof EdgeOptions) {
                ((EdgeOptions) options).setBrowserVersion(browserVersion);
            } else if (options instanceof SafariOptions) {
                ((SafariOptions) options).setBrowserVersion(browserVersion);
            }
        }
        
        // Add custom capabilities
        String capabilitiesString = propertyManager.getProperty("capabilities", "");
        if (!capabilitiesString.isEmpty()) {
            Map<String, Object> caps = parseCapabilities(capabilitiesString);
            
            if (options instanceof ChromeOptions) {
                caps.forEach(((ChromeOptions) options)::setCapability);
            } else if (options instanceof FirefoxOptions) {
                caps.forEach(((FirefoxOptions) options)::setCapability);
            } else if (options instanceof EdgeOptions) {
                caps.forEach(((EdgeOptions) options)::setCapability);
            } else if (options instanceof SafariOptions) {
                caps.forEach(((SafariOptions) options)::setCapability);
            }
        }
    }
    
    /**
     * Parse capabilities string into a map
     * @param capabilitiesString Capabilities in format: key1=value1,key2=value2
     * @return Map of capability key-values
     */
    private static Map<String, Object> parseCapabilities(String capabilitiesString) {
        Map<String, Object> result = new HashMap<>();
        String[] pairs = capabilitiesString.split(",");
        
        for (String pair : pairs) {
            String[] keyValue = pair.split("=", 2);
            if (keyValue.length == 2) {
                result.put(keyValue[0].trim(), parseValue(keyValue[1].trim()));
            }
        }
        
        return result;
    }
    
    /**
     * Parse capability values into appropriate types
     * @param value Value string
     * @return Parsed value
     */
    private static Object parseValue(String value) {
        if (value.equalsIgnoreCase("true")) {
            return Boolean.TRUE;
        } else if (value.equalsIgnoreCase("false")) {
            return Boolean.FALSE;
        } else {
            try {
                return Integer.parseInt(value);
            } catch (NumberFormatException e1) {
                try {
                    return Double.parseDouble(value);
                } catch (NumberFormatException e2) {
                    return value;
                }
            }
        }
    }
    
    /**
     * Configure timeouts for WebDriver
     * @param driver WebDriver instance
     */
    private static void configureTimeouts(WebDriver driver) {
        int implicitWait = propertyManager.getIntProperty("implicit.wait", 0);
        int pageLoadTimeout = propertyManager.getIntProperty("page.load.timeout", 60);
        int scriptTimeout = propertyManager.getIntProperty("script.timeout", 30);
        
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(implicitWait));
        driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(pageLoadTimeout));
        driver.manage().timeouts().scriptTimeout(Duration.ofSeconds(scriptTimeout));
    }
    
    /**
     * Setup Chrome driver with WebDriverManager
     */
    private static void setupChromeDriver() {
        String driverPath = propertyManager.getProperty("webdriver.chrome.driver", "");
        if (driverPath.isEmpty()) {
            WebDriverManager.chromedriver().setup();
        } else {
            System.setProperty("webdriver.chrome.driver", driverPath);
        }
    }
    
    /**
     * Setup Firefox driver with WebDriverManager
     */
    private static void setupFirefoxDriver() {
        String driverPath = propertyManager.getProperty("webdriver.gecko.driver", "");
        if (driverPath.isEmpty()) {
            WebDriverManager.firefoxdriver().setup();
        } else {
            System.setProperty("webdriver.gecko.driver", driverPath);
        }
    }
    
    /**
     * Setup Edge driver with WebDriverManager
     */
    private static void setupEdgeDriver() {
        String driverPath = propertyManager.getProperty("webdriver.edge.driver", "");
        if (driverPath.isEmpty()) {
            WebDriverManager.edgedriver().setup();
        } else {
            System.setProperty("webdriver.edge.driver", driverPath);
        }
    }
    
    /**
     * Setup Safari driver with WebDriverManager
     */
    private static void setupSafariDriver() {
        String driverPath = propertyManager.getProperty("webdriver.safari.driver", "");
        if (driverPath.isEmpty()) {
            // SafariDriver is typically bundled with macOS
            // But we'll still try to use WebDriverManager
            WebDriverManager.safaridriver().setup();
        } else {
            System.setProperty("webdriver.safari.driver", driverPath);
        }
    }
    
    /**
     * Quit the current driver instance
     */
    public static void quitDriver() {
        WebDriver driver = driverThreadLocal.get();
        if (driver != null) {
            try {
                driver.quit();
            } catch (Exception e) {
                System.err.println("Error quitting driver: " + e.getMessage());
            } finally {
                driverThreadLocal.remove();
            }
        }
    }
    
    /**
     * Quit all driver instances and clean up
     */
    public static void quitAllDrivers() {
        quitDriver();
        
        // Additional cleanup if needed
        try {
            // Windows-specific WebDriver process cleanup
            if (System.getProperty("os.name").toLowerCase().contains("win")) {
                Runtime.getRuntime().exec("taskkill /F /IM chromedriver.exe /T");
                Runtime.getRuntime().exec("taskkill /F /IM geckodriver.exe /T");
                Runtime.getRuntime().exec("taskkill /F /IM msedgedriver.exe /T");
            }
        } catch (Exception e) {
            // Ignore cleanup errors
        }
    }
}


package com.cssmart.bdd;

import java.io.File;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.testng.ITestContext;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;
import org.testng.xml.XmlTest;

import com.cssmart.annotations.CSSmartTestStep;
import com.cssmart.bdd.parser.FeatureFileParser;
import com.cssmart.bdd.parser.FeatureFileParser.FeatureModel;
import com.cssmart.bdd.parser.FeatureFileParser.ScenarioModel;
import com.cssmart.bdd.runner.BDDTestRunner;
import com.cssmart.config.PropertyManager;
import com.cssmart.core.driver.CSSmartDriverFactory;

/**
 * Base TestNG class for running BDD feature files
 * Extend this class to create a test that runs feature files
 */
public class CSSmartBDDTest {

    private static final PropertyManager propertyManager = PropertyManager.getInstance();
    protected BDDTestRunner bddRunner;
    
    /**
     * Initialize the BDD test setup
     * @param context TestNG context
     */
    @BeforeClass(alwaysRun = true)
    public void setupBDD(ITestContext context) {
        // Initialize driver (will be done automatically if needed)
        CSSmartDriverFactory.getDriver();
        
        // Create BDD runner
        bddRunner = new BDDTestRunner();
        
        // Register step definitions
        registerStepDefinitions();
    }
    
    /**
     * Register step definition classes automatically or from configuration
     */
    protected void registerStepDefinitions() {
        // Check for explicit step definition classes in configuration
        String stepDefClasses = propertyManager.getProperty("bdd.stepdefs", "");
        if (!stepDefClasses.isEmpty()) {
            for (String className : stepDefClasses.split(",")) {
                try {
                    Class<?> stepDefClass = Class.forName(className.trim());
                    BDDTestRunner.registerStepDefinition(stepDefClass);
                } catch (ClassNotFoundException e) {
                    System.err.println("Step definition class not found: " + className);
                }
            }
        } else {
            // Auto-discover step definition classes
            // This is a simplified approach - in a real implementation, 
            // we'd use ClassLoader or reflection utilities to scan packages
            autoDiscoverStepDefinitions();
        }
    }
    
    /**
     * Auto-discover step definition classes based on annotation scanning
     */
    private void autoDiscoverStepDefinitions() {
        String stepDefPackage = propertyManager.getProperty("bdd.stepdef.package", "com.cssmart.stepdefinitions");
        
        // In a real implementation, we'd scan the package for classes with methods that have @CSSmartTestStep
        // For this example, we'll log that auto-discovery is happening but would need implementation
        System.out.println("Auto-discovering step definitions in package: " + stepDefPackage);
        
        // Sample code to register specific step definition classes - would be replaced with auto-discovery
        try {
            // Default step definition registrations - you'd replace this with proper classpath scanning
            String[] defaultClasses = new String[] {
                "com.cssmart.stepdefinitions.LoginSteps",
                "com.cssmart.stepdefinitions.NavigationSteps",
                "com.cssmart.stepdefinitions.CommonSteps"
            };
            
            for (String className : defaultClasses) {
                try {
                    Class<?> stepDefClass = Class.forName(className);
                    BDDTestRunner.registerStepDefinition(stepDefClass);
                } catch (ClassNotFoundException e) {
                    // Ignore if class doesn't exist
                }
            }
        } catch (Exception e) {
            System.err.println("Error registering step definitions: " + e.getMessage());
        }
    }
    
    /**
     * Provides feature files and scenarios to test method
     * @param context TestNG test context
     * @return Array of feature/scenario data
     */
    @DataProvider(name = "featureScenarios", parallel = true)
    public Object[][] getFeatureScenarios(ITestContext context) {
        XmlTest xmlTest = context.getCurrentXmlTest();
        
        // Get feature files path from parameter or property
        String featuresPath = xmlTest.getParameter("featuresPath");
        if (featuresPath == null) {
            featuresPath = propertyManager.getProperty("features.path", "src/test/resources/features");
        }
        
        // Get feature file pattern from parameter or property
        String featurePattern = xmlTest.getParameter("featurePattern");
        if (featurePattern == null) {
            featurePattern = propertyManager.getProperty("feature.pattern", "*.feature");
        }
        
        // Get tag filter from parameter or property
        String tagFilter = xmlTest.getParameter("tagFilter");
        if (tagFilter == null) {
            tagFilter = propertyManager.getProperty("tag.filter", "");
        }
        
        List<Object[]> scenarios = new ArrayList<>();
        
        // Find all feature files
        File featuresDir = new File(featuresPath);
        if (featuresDir.exists() && featuresDir.isDirectory()) {
            findFeatureFiles(featuresDir, featurePattern, tagFilter, scenarios);
        } else {
            System.err.println("Features directory not found: " + featuresPath);
        }
        
        return scenarios.toArray(new Object[0][]);
    }
    
    /**
     * Recursively find feature files in directory
     * @param directory Directory to search
     * @param pattern File pattern to match
     * @param tagFilter Tag filter expression
     * @param scenarios Output list to populate
     */
    private void findFeatureFiles(File directory, String pattern, String tagFilter, List<Object[]> scenarios) {
        File[] files = directory.listFiles();
        if (files == null) return;
        
        for (File file : files) {
            if (file.isDirectory()) {
                findFeatureFiles(file, pattern, tagFilter, scenarios);
            } else if (file.getName().endsWith(".feature") && 
                      (pattern.equals("*.feature") || file.getName().matches(pattern))) {
                processFeatureFile(file, tagFilter, scenarios);
            }
        }
    }
    
    /**
     * Process a feature file and extract scenarios
     * @param featureFile Feature file
     * @param tagFilter Tag filter expression
     * @param scenarios Output list to populate
     */
    private void processFeatureFile(File featureFile, String tagFilter, List<Object[]> scenarios) {
        try {
            FeatureModel feature = FeatureFileParser.parseFeatureFile(featureFile.getAbsolutePath());
            
            for (ScenarioModel scenario : feature.getScenarios()) {
                // Skip if scenario doesn't match tag filter
                if (!tagFilter.isEmpty() && !matchesTagFilter(scenario.getTags(), tagFilter)) {
                    continue;
                }
                
                // Store feature file and scenario
                scenarios.add(new Object[] { featureFile.getAbsolutePath(), scenario.getName() });
            }
        } catch (Exception e) {
            System.err.println("Error processing feature file " + featureFile.getName() + ": " + e.getMessage());
        }
    }
    
    /**
     * Check if tags match the filter expression
     * @param tags List of tags
     * @param tagFilter Tag filter expression
     * @return true if matches
     */
    private boolean matchesTagFilter(List<String> tags, String tagFilter) {
        if (tagFilter.isEmpty()) {
            return true;
        }
        
        // Simple tag filtering - in a real implementation, would support AND/OR logic
        String[] filterTags = tagFilter.split(",");
        for (String filterTag : filterTags) {
            filterTag = filterTag.trim();
            boolean exclude = filterTag.startsWith("~");
            
            if (exclude) {
                filterTag = filterTag.substring(1);
                if (tags.contains(filterTag)) {
                    return false;
                }
            } else {
                if (tags.contains(filterTag)) {
                    return true;
                }
            }
        }
        
        // If we have OR logic, we'd return false here
        // If we have AND logic for excludes, we'd return true here
        return false;
    }
    
    /**
     * Test method that runs scenarios from feature files
     * @param featureFile Feature file path
     * @param scenarioName Scenario name
     */
    @Test(dataProvider = "featureScenarios", description = "Execute BDD Scenarios")
    public void runScenario(String featureFile, String scenarioName) {
        System.out.println("Running scenario: " + scenarioName + " from " + featureFile);
        
        // Run the specific scenario
        bddRunner.runScenario(featureFile, scenarioName);
    }
}

// Custom TestNG listener for automatic driver initialization and cleanup
package com.cssmart.testng;

import org.testng.ISuite;
import org.testng.ISuiteListener;
import org.testng.ITestContext;
import org.testng.ITestListener;
import org.testng.ITestResult;

import com.cssmart.core.driver.CSSmartDriverFactory;

/**
 * TestNG listener for driver management
 */
public class CSSmartDriverListener implements ITestListener, ISuiteListener {

    @Override
    public void onStart(ISuite suite) {
        // Initialize any suite-level resources if needed
    }

    @Override
    public void onFinish(ISuite suite) {
        // Clean up all drivers at the end of the suite
        CSSmartDriverFactory.quitAllDrivers();
    }

    @Override
    public void onTestStart(ITestResult result) {
        // Ensure driver is initialized when test starts
        CSSmartDriverFactory.getDriver();
    }

    @Override
    public void onTestSuccess(ITestResult result) {
        // No special handling needed
    }

    @Override
    public void onTestFailure(ITestResult result) {
        // No special handling needed - screenshots will be taken by the base test class
    }

    @Override
    public void onTestSkipped(ITestResult result) {
        // No special handling needed
    }

    @Override
    public void onTestFailedButWithinSuccessPercentage(ITestResult result) {
        // No special handling needed
    }

    @Override
    public void onStart(ITestContext context) {
        // No special handling needed
    }

    @Override
    public void onFinish(ITestContext context) {
        // No special handling needed
    }
}

// Sample testng.xml configuration:
/*
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="CS Smart BDD Suite" parallel="tests" thread-count="2">
    <listeners>
        <listener class-name="com.cssmart.testng.CSSmartTestListener"/>
        <listener class-name="com.cssmart.testng.CSSmartDriverListener"/>
    </listeners>
    
    <test name="Login Features">
        <parameter name="browser" value="chrome"/>
        <parameter name="featuresPath" value="src/test/resources/features/login"/>
        <parameter name="tagFilter" value="smoke,regression"/>
        <classes>
            <class name="com.myproject.tests.LoginBDDTest"/>
        </classes>
    </test>
    
    <test name="Checkout Features">
        <parameter name="browser" value="firefox"/>
        <parameter name="featuresPath" value="src/test/resources/features/checkout"/>
        <parameter name="tagFilter" value="regression,~flaky"/>
        <classes>
            <class name="com.myproject.tests.CheckoutBDDTest"/>
        </classes>
    </test>
</suite>
*/

// Sample Test Implementation
/*
package com.myproject.tests;

import com.cssmart.bdd.CSSmartBDDTest;
import com.myproject.stepdefinitions.LoginSteps;
import com.myproject.stepdefinitions.CommonSteps;

public class LoginBDDTest extends CSSmartBDDTest {
    package com.cssmart.core.page;

import java.lang.reflect.Field;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.TimeoutException;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.PageFactory;
import org.openqa.selenium.support.ui.ExpectedCondition;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import com.cssmart.annotations.processors.FindByAnnotationProcessor;
import com.cssmart.config.EnvironmentManager;
import com.cssmart.config.PropertyManager;
import com.cssmart.core.driver.CSSmartDriverFactory;
import com.cssmart.core.element.CSSmartElement;
import com.cssmart.core.element.CSSmartWebElement;

/**
 * Enhanced base page object with improved element handling and navigation
 */
public class CSSmartBasePage {
    protected WebDriver driver;
    protected PropertyManager propertyManager;
    protected EnvironmentManager envManager;
    private Map<String, CSSmartElement> elementCache = new HashMap<>();
    private String pageName;
    
    /**
     * Default constructor
     */
    public CSSmartBasePage() {
        this.driver = CSSmartDriverFactory.getDriver();
        this.propertyManager = PropertyManager.getInstance();
        this.envManager = EnvironmentManager.getInstance();
        this.pageName = getClass().getSimpleName();
        initElements();
    }
    
    /**
     * Initialize page elements with enhanced handling
     */
    protected void initElements() {
        // First use standard PageFactory for WebElement initialization
        PageFactory.initElements(driver, this);
        
        // Then process and enhance elements
        for (Field field : getClass().getDeclaredFields()) {
            field.setAccessible(true);
            
            // Process @FindBy annotations
            if (field.isAnnotationPresent(FindBy.class)) {
                try {
                    FindBy findBy = field.getAnnotation(FindBy.class);
                    By locator = FindByAnnotationProcessor.processAnnotation(findBy);
                    String elementName = field.getName();
                    
                    // Convert to enhanced elements
                    if (field.getType() == CSSmartElement.class) {
                        CSSmartElement element = new CSSmartElement(locator, elementName);
                        field.set(this, element);
                        elementCache.put(elementName, element);
                    } else if (field.getType() == CSSmartWebElement.class) {
                        CSSmartWebElement webElement = new CSSmartWebElement(locator, elementName);
                        field.set(this, webElement);
                        // Also create a SmartElement version for the cache
                        elementCache.put(elementName, new CSSmartElement(locator, elementName));
                    }
                } catch (Exception e) {
                    System.err.println("Failed to initialize element " + field.getName() + ": " + e.getMessage());
                }
            }
        }
    }
    
    /**
     * Get an element by name from the cache
     * @param elementName Element name
     * @return CSSmartElement instance
     */
    public CSSmartElement getElement(String elementName) {
        CSSmartElement element = elementCache.get(elementName);
        if (element == null) {
            throw new NoSuchElementException("Element not found in cache: " + elementName);
        }
        return element;
    }
    
    /**
     * Create a new element on-the-fly
     * @param locator Element locator
     * @param elementName Element name
     * @return CSSmartElement instance
     */
    public CSSmartElement createElement(By locator, String elementName) {
        CSSmartElement element = new CSSmartElement(locator, elementName);
        elementCache.put(elementName, element);
        return element;
    }
    
    /**
     * Open the page with the specified URL
     * @param url URL to open
     * @return This page instance
     */
    public CSSmartBasePage open(String url) {
        driver.get(url);
        return this;
    }
    
    /**
     * Open the page with base URL + path
     * @param path Path to append to base URL
     * @return This page instance
     */
    public CSSmartBasePage openPath(String path) {
        String baseUrl = envManager.getBaseUrl();
        if (baseUrl.endsWith("/") && path.startsWith("/")) {
            path = path.substring(1);
        }
        
        driver.get(baseUrl + path);
        return this;
    }
    
    /**
     * Refresh the current page
     * @return This page instance
     */
    public CSSmartBasePage refresh() {
        driver.navigate().refresh();
        return this;
    }
    
    /**
     * Navigate back in browser history
     * @return This page instance
     */
    public CSSmartBasePage back() {
        driver.navigate().back();
        return this;
    }
    
    /**
     * Navigate forward in browser history
     * @return This page instance
     */
    public CSSmartBasePage forward() {
        driver.navigate().forward();
        return this;
    }
    
    /**
     * Get the page title
     * @return Page title
     */
    public String getTitle() {
        return driver.getTitle();
    }
    
    /**
     * Get the current URL
     * @return Current URL
     */
    public String getCurrentUrl() {
        return driver.getCurrentUrl();
    }
    
    /**
     * Check if the page URL contains text
     * @param text Text to check
     * @return true if URL contains text
     */
    public boolean urlContains(String text) {
        return getCurrentUrl().contains(text);
    }
    
    /**
     * Check if the page URL matches a regex pattern
     * @param pattern Regex pattern
     * @return true if URL matches pattern
     */
    public boolean urlMatches(String pattern) {
        return getCurrentUrl().matches(pattern);
    }
    
    /**
     * Get the page source
     * @return Page source
     */
    public String getPageSource() {
        return driver.getPageSource();
    }
    
    /**
     * Wait for page to load with default timeout
     * @return This page instance
     */
    public CSSmartBasePage waitForPageLoad() {
        int timeout = propertyManager.getIntProperty("page.load.timeout", 60);
        return waitForPageLoad(timeout);
    }
    
    /**
     * Wait for page to load with specified timeout
     * @param timeoutSeconds Timeout in seconds
     * @return This page instance
     */
    public CSSmartBasePage waitForPageLoad(int timeoutSeconds) {
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        
        // Wait for document.readyState to be complete
        wait.until((ExpectedCondition<Boolean>) driver -> {
            boolean ready = false;
            try {
                ready = ((JavascriptExecutor) driver).executeScript("return document.readyState").equals("complete");
            } catch (Exception e) {
                // If JS execution fails, assume page is not ready
            }
            return ready;
        });
        
        // Wait for jQuery to be loaded and inactive (if present)
        wait.until((ExpectedCondition<Boolean>) driver -> {
            boolean jQueryDefined = false;
            boolean jQueryActive = true;
            try {
                jQueryDefined = (Boolean) ((JavascriptExecutor) driver).executeScript("return typeof jQuery != 'undefined'");
                if (jQueryDefined) {
                    jQueryActive = (Long) ((JavascriptExecutor) driver).executeScript("return jQuery.active") > 0;
                } else {
                    // If jQuery is not defined, we consider this condition satisfied
                    jQueryActive = false;
                }
            } catch (Exception e) {
                // If JS execution fails, assume jQuery is not active
                jQueryActive = false;
            }
            return !jQueryActive;
        });
        
        // Wait for Angular (if present)
        wait.until((ExpectedCondition<Boolean>) driver -> {
            boolean angularDefined = false;
            boolean angularIdle = false;
            try {
                angularDefined = (Boolean) ((JavascriptExecutor) driver).executeScript(
                    "return typeof window.angular !== 'undefined' || " +
                    "typeof window.getAllAngularTestabilities !== 'undefined'");
                
                if (angularDefined) {
                    angularIdle = (Boolean) ((JavascriptExecutor) driver).executeScript(
                        "if (typeof window.getAllAngularTestabilities !== 'undefined') {" +
                        "  var testabilities = window.getAllAngularTestabilities();" +
                        "  if (testabilities.length > 0) {" +
                        "    for (var i = 0; i < testabilities.length; i++) {" +
                        "      if (!testabilities[i].isStable()) return false;" +
                        "    }" +
                        "    return true;" +
                        "  }" +
                        "}" +
                        "if (window.angular) {" +
                        "  var injector = window.angular.element(document.body).injector();" +
                        "  if (injector) {" +
                        "    var $http = injector.get('$http');" +
                        "    return $http.pendingRequests.length === 0;" +
                        "  }" +
                        "}" +
                        "return true;");
                } else {
                    // If Angular is not defined, we consider this condition satisfied
                    angularIdle = true;
                }
            } catch (Exception e) {
                // If JS execution fails, assume Angular is idle
                angularIdle = true;
            }
            return angularIdle;
        });
        
        return this;
    }
    
    /**
     * Wait for an element to be visible
     * @param locator Element locator
     * @param timeoutSeconds Timeout in seconds
     * @return The found element
     */
    public WebElement waitForVisible(By locator, int timeoutSeconds) {
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        return wait.until(ExpectedConditions.visibilityOfElementLocated(locator));
    }
    
    /**
     * Wait for a condition with custom message
     * @param condition The condition to wait for
     * @param message Error message if timeout occurs
     * @param timeoutSeconds Timeout in seconds
     * @return This page instance
     */
    public CSSmartBasePage waitFor(ExpectedCondition<?> condition, String message, int timeoutSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
            wait.withMessage(message).until(condition);
        } catch (TimeoutException e) {
            // Optionally add additional error handling here
            throw e;
        }
        return this;
    }
    
    /**
     * Execute JavaScript
     * @param script Script to execute
     * @param args Script arguments
     * @return Result of script execution
     */
    public Object executeScript(String script, Object... args) {
        if (driver instanceof JavascriptExecutor) {
            return ((JavascriptExecutor) driver).executeScript(script, args);
        }
        throw new UnsupportedOperationException("Driver does not support JavaScript execution");
    }
    
    /**
     * Check if an element exists
     * @param locator Element locator
     * @return true if element exists
     */
    public boolean exists(By locator) {
        try {
            driver.findElement(locator);
            return true;
        } catch (NoSuchElementException e) {
            return false;
        }
    }
    
    /**
     * Switch to an iframe
     * @param frameLocator Frame locator
     * @return This page instance
     */
    public CSSmartBasePage switchToFrame(By frameLocator) {
        waitForVisible(frameLocator, 10);
        driver.switchTo().frame(driver.findElement(frameLocator));
        return this;
    }
    
    /**
     * Switch to default content (out of frames)
     * @return This page instance
     */
    public CSSmartBasePage switchToDefaultContent() {
        driver.switchTo().defaultContent();
        return this;
    }
    
    /**
     * Accept an alert
     * @return This page instance
     */
    public CSSmartBasePage acceptAlert() {
        driver.switchTo().alert().accept();
        return this;
    }
    
    /**
     * Dismiss an alert
     * @return This page instance
     */
    public CSSmartBasePage dismissAlert() {
        driver.switchTo().alert().dismiss();
        return this;
    }
    
    /**
     * Take a screenshot of the page
     * @param fileName File name for the screenshot
     * @return This page instance
     */
    public CSSmartBasePage takeScreenshot(String fileName) {
        try {
            org.openqa.selenium.TakesScreenshot takesScreenshot = (org.openqa.selenium.TakesScreenshot) driver;
            byte[] screenshotBytes = takesScreenshot.getScreenshotAs(org.openqa.selenium.OutputType.BYTES);
            java.io.File screenshot = takesScreenshot.getScreenshotAs(org.openqa.selenium.OutputType.FILE);
            
            String screenshotDir = propertyManager.getProperty("screenshot.path", "target/screenshots");
            java.io.File directory = new java.io.File(screenshotDir);
            if (!directory.exists()) {
                directory.mkdirs();
            }
            
            java.io.File dest = new java.io.File(directory, fileName);
            org.apache.commons.io.FileUtils.copyFile(screenshot, dest);
            System.out.println("Screenshot saved: " + dest.getAbsolutePath());
        } catch (Exception e) {
            System.err.println("Failed to take screenshot: " + e.getMessage());
        }
        return this;
    }
    
    /**
     * Scroll to the top of the page
     * @return This page instance
     */
    public CSSmartBasePage scrollToTop() {
        executeScript("window.scrollTo(0, 0);");
        return this;
    }
    
    /**
     * Scroll to the bottom of the page
     * @return This page instance
     */
    public CSSmartBasePage scrollToBottom() {
        executeScript("window.scrollTo(0, document.body.scrollHeight);");
        return this;
    }
    
    /**
     * Scroll to an element
     * @param locator Element locator
     * @return This page instance
     */
    public CSSmartBasePage scrollToElement(By locator) {
        WebElement element = driver.findElement(locator);
        executeScript("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", element);
        // Small pause to allow scroll animation to complete
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return this;
    }
    
    /**
     * Get the name of this page
     * @return Page name
     */
    public String getPageName() {
        return pageName;
    }
    
    /**
     * Check if the current page is loaded based on title
     * @param expectedTitle Expected page title
     * @return true if page is loaded
     */
    public boolean isPageLoaded(String expectedTitle) {
        return driver.getTitle().equals(expectedTitle);
    }
    
    /**
     * Check if the current page is loaded based on URL pattern
     * @param urlPattern URL pattern to match
     * @return true if page is loaded
     */
    public boolean isPageLoaded(Pattern urlPattern) {
        return urlPattern.matcher(driver.getCurrentUrl()).matches();
    }
    
    /**
     * Wait for the current page to be loaded
     * @param expectedTitle Expected page title
     * @param timeoutSeconds Timeout in seconds
     * @return This page instance
     */
    public CSSmartBasePage waitForPageLoaded(String expectedTitle, int timeoutSeconds) {
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        wait.until(ExpectedConditions.titleIs(expectedTitle));
        return this;
    }
    
    /**
     * Get cookies as a map
     * @return Map of cookie name-value pairs
     */
    public Map<String, String> getCookies() {
        Map<String, String> cookieMap = new HashMap<>();
        driver.manage().getCookies().forEach(cookie -> cookieMap.put(cookie.getName(), cookie.getValue()));
        return cookieMap;
    }
    
    /**
     * Add a cookie
     * @param name Cookie name
     * @param value Cookie value
     * @return This page instance
     */
    public CSSmartBasePage addCookie(String name, String value) {
        org.openqa.selenium.Cookie cookie = new org.openqa.selenium.Cookie(name, value);
        driver.manage().addCookie(cookie);
        return this;
    }
    
    /**
     * Delete a cookie
     * @param name Cookie name
     * @return This page instance
     */
    public CSSmartBasePage deleteCookie(String name) {
        driver.manage().deleteCookieNamed(name);
        return this;
    }
    
    /**
     * Delete all cookies
     * @return This page instance
     */
    public CSSmartBasePage deleteAllCookies() {
        driver.manage().deleteAllCookies();
        return this;
    }
}


# src/main/resources/cssmart.properties
# ===================================
# CS Smart Automation Framework - Core Configuration
# ===================================

# Browser Configuration
# Available options: chrome, firefox, edge, safari
browser=chrome
headless=false

# AI Features
ai.self.healing=true
ai.visual.testing=true
ai.test.optimization=true

# Test Locations
features.path=src/test/resources/features
testdata.path=src/test/resources/testdata

# Environment
# Automatically selects the appropriate env.properties file
environment=dev

# src/main/resources/env/dev.properties
# ===================================
# Development Environment Configuration
# ===================================
base.url=https://dev.example.com
api.url=https://dev-api.example.com

# Admin user
admin.username=admin
admin.password=admin123

# src/main/resources/env/test.properties
# ===================================
# Test Environment Configuration
# ===================================
base.url=https://test.example.com
api.url=https://test-api.example.com

# Admin user
admin.username=testadmin
admin.password=test123

# Sample TestNG XML configuration
# src/test/resources/testng.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="CS Smart Automation Suite" parallel="tests" thread-count="2">
    <!-- Listeners for automatic driver management and reporting -->
    <listeners>
        <listener class-name="com.cssmart.testng.CSSmartDriverListener"/>
        <listener class-name="com.cssmart.testng.CSSmartReportListener"/>
    </listeners>
    
    <!-- Global Parameters -->
    <parameter name="environment" value="dev"/>
    
    <!-- BDD Feature Tests -->
    <test name="Login Features">
        <parameter name="browser" value="chrome"/>
        <parameter name="featuresPath" value="src/test/resources/features/login"/>
        <parameter name="tagFilter" value="smoke,regression"/>
        <classes>
            <class name="com.example.tests.LoginBDDTests"/>
        </classes>
    </test>
    
    <!-- API Tests -->
    <test name="API Tests">
        <parameter name="run.in.parallel" value="true"/>
        <classes>
            <class name="com.example.tests.api.UserAPITests"/>
            <class name="com.example.tests.api.ProductAPITests"/>
        </classes>
    </test>
</suite>

# Sample User Test Class
# src/test/java/com/example/tests/LoginBDDTests.java
package com.example.tests;

import com.cssmart.bdd.CSSmartBDDTest;
import com.cssmart.bdd.runner.BDDTestRunner;
import com.example.stepdefinitions.LoginSteps;
import com.example.stepdefinitions.NavigationSteps;

/**
 * Login BDD Tests
 * This class uses the CS Smart BDD infrastructure to run feature files
 */
public class LoginBDDTests extends CSSmartBDDTest {
    
    @Override
    protected void registerStepDefinitions() {
        // Register specific step definitions
        BDDTestRunner.registerStepDefinition(LoginSteps.class);
        BDDTestRunner.registerStepDefinition(NavigationSteps.class);
    }
}

# Sample Page Object
# src/test/java/com/example/pages/LoginPage.java
package com.example.pages;

import org.openqa.selenium.By;
import org.openqa.selenium.support.FindBy;

import com.cssmart.annotations.CSSmartTestStep;
import com.cssmart.core.element.CSSmartElement;
import com.cssmart.core.page.CSSmartBasePage;

public class LoginPage extends CSSmartBasePage {
    
    @FindBy(id = "username")
    private CSSmartElement usernameField;
    
    @FindBy(id = "password")
    private CSSmartElement passwordField;
    
    @FindBy(id = "loginBtn")
    private CSSmartElement loginButton;
    
    @FindBy(css = ".error-message")
    private CSSmartElement errorMessage;
    
    /**
     * Open the login page
     * @return This page
     */
    @CSSmartTestStep("I am on the login page")
    public LoginPage open() {
        // Notice how we use the built-in methods to handle base URLs
        openPath("/login");
        waitForPageLoad();
        return this;
    }
    
    /**
     * Enter username
     * @param username Username to enter
     * @return This page
     */
    @CSSmartTestStep("I enter {0} in the username field")
    public LoginPage enterUsername(String username) {
        // Notice how the CSSmartElement automatically handles visibility wait
        usernameField.clearAndType(username);
        return this;
    }
    
    /**
     * Enter password
     * @param password Password to enter
     * @return This page
     */
    @CSSmartTestStep("I enter {0} in the password field")
    public LoginPage enterPassword(String password) {
        passwordField.clearAndType(password);
        return this;
    }
    
    /**
     * Click login button
     * @return Dashboard page
     */
    @CSSmartTestStep("I click on the login button")
    public DashboardPage clickLoginButton() {
        // Notice how CSSmartElement automatically handles clickability wait
        loginButton.click();
        // Return the next page in the flow
        return new DashboardPage();
    }
    
    /**
     * Check if error message is displayed
     * @param expectedMessage Expected error message
     * @return true if message matches
     */
    @CSSmartTestStep("I should see the error message {0}")
    public boolean isErrorMessageDisplayed(String expectedMessage) {
        if (!errorMessage.exists()) {
            return false;
        }
        return errorMessage.getText().contains(expectedMessage);
    }
    
    /**
     * Log in with credentials
     * @param username Username
     * @param password Password
     * @return Dashboard page
     */
    @CSSmartTestStep("I log in with username {0} and password {1}")
    public DashboardPage login(String username, String password) {
        enterUsername(username);
        enterPassword(password);
        return clickLoginButton();
    }
}

# Sample Step Definition
# src/test/java/com/example/stepdefinitions/LoginSteps.java
package com.example.stepdefinitions;

import org.testng.Assert;

import com.cssmart.annotations.CSSmartTestStep;
import com.example.pages.DashboardPage;
import com.example.pages.LoginPage;

public class LoginSteps {
    
    private LoginPage loginPage;
    private DashboardPage dashboardPage;
    
    @CSSmartTestStep("I am on the login page")
    public void iAmOnTheLoginPage() {
        loginPage = new LoginPage();
        loginPage.open();
    }
    
    @CSSmartTestStep("I enter {0} in the username field")
    public void iEnterUsername(String username) {
        loginPage.enterUsername(username);
    }
    
    @CSSmartTestStep("I enter {0} in the password field")
    public void iEnterPassword(String password) {
        loginPage.enterPassword(password);
    }
    
    @CSSmartTestStep("I click on the login button")
    public void iClickLoginButton() {
        dashboardPage = loginPage.clickLoginButton();
    }
    
    @CSSmartTestStep("I should be logged in successfully")
    public void iShouldBeLoggedInSuccessfully() {
        Assert.assertTrue(dashboardPage.isLoaded(), "Dashboard page is not loaded");
        Assert.assertTrue(dashboardPage.isWelcomeMessageDisplayed(), "Welcome message is not displayed");
    }
    
    @CSSmartTestStep("I should see the error message {0}")
    public void iShouldSeeErrorMessage(String expectedMessage) {
        Assert.assertTrue(loginPage.isErrorMessageDisplayed(expectedMessage), 
            "Error message does not match: " + expectedMessage);
    }
    
    @CSSmartTestStep("I log in with username {0} and password {1}")
    public void iLoginWithCredentials(String username, String password) {
        loginPage.enterUsername(username);
        loginPage.enterPassword(password);
        dashboardPage = loginPage.clickLoginButton();
    }
}

# Sample Feature File
# src/test/resources/features/login/login.feature
Feature: User Authentication
  As a user
  I want to authenticate with the system
  So that I can access my account

  @smoke @regression
  Scenario: Successful login with valid credentials
    Given I am on the login page
    When I enter "validUser" in the username field
    And I enter "validPass" in the password field
    And I click on the login button
    Then I should be logged in successfully

  @regression
  Scenario Outline: Login with invalid credentials
    Given I am on the login page
    When I enter "<username>" in the username field
    And I enter "<password>" in the password field
    And I click on the login button
    Then I should see the error message "<error_message>"

    Examples:
      | username  | password  | error_message                   |
      | invalid   | validPass | Invalid username or password    |
      | validUser | invalid   | Invalid username or password    |
      |           | validPass | Username cannot be empty        |
      | validUser |           | Password cannot be empty        |



package com.cssmart.bdd;

import java.io.File;
import java.lang.reflect.Method;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;

import org.reflections.Reflections;
import org.reflections.scanners.MethodAnnotationsScanner;
import org.reflections.scanners.SubTypesScanner;
import org.reflections.scanners.TypeAnnotationsScanner;
import org.reflections.util.ClasspathHelper;
import org.reflections.util.ConfigurationBuilder;
import org.testng.ITestContext;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;
import org.testng.xml.XmlSuite;
import org.testng.xml.XmlTest;

import com.cssmart.annotations.CSSmartTestStep;
import com.cssmart.bdd.parser.FeatureFileParser;
import com.cssmart.bdd.parser.FeatureFileParser.FeatureModel;
import com.cssmart.bdd.parser.FeatureFileParser.ScenarioModel;
import com.cssmart.bdd.runner.BDDTestRunner;
import com.cssmart.config.PropertyManager;
import com.cssmart.core.driver.CSSmartDriverFactory;

/**
 * Auto BDD Runner System - No need to create individual BDD test classes
 */
public class CSSmartAutoBDDRunner {
    
    private static final PropertyManager propertyManager = PropertyManager.getInstance();
    private static BDDTestRunner bddRunner;
    private static boolean stepsRegistered = false;
    private static final Set<Class<?>> stepDefinitionClasses = new HashSet<>();
    
    /**
     * Initialize the BDD test runner
     */
    public static synchronized void initialize() {
        if (bddRunner == null) {
            bddRunner = new BDDTestRunner();
        }
        
        if (!stepsRegistered) {
            registerAllStepDefinitions();
            stepsRegistered = true;
        }
    }
    
    /**
     * Auto-discover and register all step definition classes
     */
    private static void registerAllStepDefinitions() {
        List<String> stepDefPackages = getStepDefinitionPackages();
        
        for (String packageName : stepDefPackages) {
            try {
                registerStepDefinitionsFromPackage(packageName);
            } catch (Exception e) {
                System.err.println("Error scanning package " + packageName + ": " + e.getMessage());
            }
        }
        
        System.out.println("Registered " + stepDefinitionClasses.size() + " step definition classes.");
    }
    
    /**
     * Get list of packages to scan for step definitions
     * @return List of package names
     */
    private static List<String> getStepDefinitionPackages() {
        String packageList = propertyManager.getProperty("bdd.stepdef.packages");
        if (packageList != null && !packageList.isEmpty()) {
            return Arrays.asList(packageList.split(","));
        }
        
        // Auto-detect step definition packages - convention-based
        List<String> packages = new ArrayList<>();
        String basePackage = getBasePackage();
        
        // Common step definition package patterns
        packages.add(basePackage + ".stepdefinitions");
        packages.add(basePackage + ".stepdefs");
        packages.add(basePackage + ".steps");
        packages.add(basePackage + ".bdd.steps");
        
        return packages;
    }
    
    /**
     * Get base package for the project
     * @return Base package name
     */
    private static String getBasePackage() {
        String basePackage = propertyManager.getProperty("project.base.package");
        if (basePackage != null && !basePackage.isEmpty()) {
            return basePackage;
        }
        
        // Try to determine base package by scanning class path
        // This is a simplified approach - a more robust implementation would be needed for production
        return "com.cssmart";
    }
    
    /**
     * Register step definitions from a package
     * @param packageName Package to scan
     */
    private static void registerStepDefinitionsFromPackage(String packageName) {
        System.out.println("Scanning package for step definitions: " + packageName);
        
        Reflections reflections = new Reflections(new ConfigurationBuilder()
            .setUrls(ClasspathHelper.forPackage(packageName))
            .setScanners(
                new MethodAnnotationsScanner(), 
                new TypeAnnotationsScanner(),
                new SubTypesScanner(false)
            ));
        
        // Find all methods annotated with @CSSmartTestStep
        Set<Method> methods = reflections.getMethodsAnnotatedWith(CSSmartTestStep.class);
        for (Method method : methods) {
            Class<?> stepClass = method.getDeclaringClass();
            if (!stepDefinitionClasses.contains(stepClass)) {
                BDDTestRunner.registerStepDefinition(stepClass);
                stepDefinitionClasses.add(stepClass);
                System.out.println("Registered step definition class: " + stepClass.getName());
            }
        }
    }
    
    /**
     * Find all feature files in a directory
     * @param featuresPath Base path to features
     * @param tagFilter Tag filter (comma-separated)
     * @return List of feature file paths
     */
    public static List<String> findAllFeatureFiles(String featuresPath, String tagFilter) {
        List<String> featureFiles = new ArrayList<>();
        File featuresDir = new File(featuresPath);
        
        if (featuresDir.exists() && featuresDir.isDirectory()) {
            try {
                Files.walkFileTree(featuresDir.toPath(), new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                        if (file.toString().endsWith(".feature")) {
                            String featurePath = file.toAbsolutePath().toString();
                            if (matchesTagFilter(featurePath, tagFilter)) {
                                featureFiles.add(featurePath);
                            }
                        }
                        return FileVisitResult.CONTINUE;
                    }
                });
            } catch (IOException e) {
                System.err.println("Error walking features directory: " + e.getMessage());
            }
        } else {
            System.err.println("Features directory not found: " + featuresPath);
        }
        
        return featureFiles;
    }
    
    /**
     * Check if feature file matches tag filter
     * @param featurePath Feature file path
     * @param tagFilter Tag filter
     * @return true if matching
     */
    private static boolean matchesTagFilter(String featurePath, String tagFilter) {
        if (tagFilter == null || tagFilter.isEmpty()) {
            return true;
        }
        
        try {
            FeatureModel feature = FeatureFileParser.parseFeatureFile(featurePath);
            
            // Check if any scenario matches the tag filter
            for (ScenarioModel scenario : feature.getScenarios()) {
                if (matchesTagFilter(scenario.getTags(), tagFilter)) {
                    return true;
                }
            }
            
            // Check if feature itself matches the tag filter
            return matchesTagFilter(feature.getTags(), tagFilter);
        } catch (Exception e) {
            System.err.println("Error parsing feature file " + featurePath + ": " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Check if tags match the filter expression
     * @param tags List of tags
     * @param tagFilter Tag filter expression
     * @return true if matches
     */
    private static boolean matchesTagFilter(List<String> tags, String tagFilter) {
        if (tagFilter == null || tagFilter.isEmpty()) {
            return true;
        }
        
        // Support AND and OR logic in tag filtering
        // ~tag means exclude this tag, tag1+tag2 means AND, tag1,tag2 means OR
        
        // Handle OR logic first - comma-separated tags
        String[] orParts = tagFilter.split(",");
        for (String orPart : orParts) {
            orPart = orPart.trim();
            
            // Handle AND logic - plus-separated tags
            String[] andParts = orPart.split("\\+");
            boolean matchesAndCondition = true;
            
            for (String andPart : andParts) {
                andPart = andPart.trim();
                boolean exclude = andPart.startsWith("~");
                
                if (exclude) {
                    andPart = andPart.substring(1);
                    if (tags.contains(andPart)) {
                        matchesAndCondition = false;
                        break;
                    }
                } else {
                    if (!tags.contains(andPart)) {
                        matchesAndCondition = false;
                        break;
                    }
                }
            }
            
            if (matchesAndCondition) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Run all feature files in a directory
     * @param featuresPath Path to features directory
     * @param tagFilter Optional tag filter
     */
    public static void runFeatures(String featuresPath, String tagFilter) {
        initialize();
        List<String> featureFiles = findAllFeatureFiles(featuresPath, tagFilter);
        
        System.out.println("Found " + featureFiles.size() + " feature files to run.");
        for (String featureFile : featureFiles) {
            System.out.println("Running feature file: " + featureFile);
            bddRunner.runFeature(featureFile);
        }
    }
    
    /**
     * Run a specific feature file
     * @param featureFile Path to feature file
     */
    public static void runFeature(String featureFile) {
        initialize();
        bddRunner.runFeature(featureFile);
    }
    
    /**
     * Run a specific scenario from a feature file
     * @param featureFile Path to feature file
     * @param scenarioName Name of scenario
     */
    public static void runScenario(String featureFile, String scenarioName) {
        initialize();
        bddRunner.runScenario(featureFile, scenarioName);
    }
}

package com.cssmart.testng;

import java.util.Arrays;
import java.util.List;

import org.testng.IAlterSuiteListener;
import org.testng.ITestContext;
import org.testng.ITestListener;
import org.testng.ITestResult;
import org.testng.TestNG;
import org.testng.xml.XmlClass;
import org.testng.xml.XmlSuite;
import org.testng.xml.XmlTest;

import com.cssmart.bdd.CSSmartAutoBDDRunner;
import com.cssmart.config.PropertyManager;
import com.cssmart.core.driver.CSSmartDriverFactory;

/**
 * TestNG listener that automatically detects and runs BDD features
 */
public class CSSmartBDDListener implements IAlterSuiteListener, ITestListener {
    
    private final PropertyManager propertyManager = PropertyManager.getInstance();
    
    @Override
    public void alter(List<XmlSuite> suites) {
        if (suites.isEmpty()) {
            return;
        }
        
        XmlSuite mainSuite = suites.get(0);
        
        // Check if we need to auto-run features
        boolean autoRunBdd = Boolean.parseBoolean(propertyManager.getProperty("bdd.autorun", "true"));
        if (!autoRunBdd) {
            return;
        }
        
        // Get features path and tag filter
        String featuresPath = propertyManager.getProperty("features.path", "src/test/resources/features");
        String tagFilter = propertyManager.getProperty("tag.filter", "");
        
        // Find all feature files matching the criteria
        List<String> featureFiles = CSSmartAutoBDDRunner.findAllFeatureFiles(featuresPath, tagFilter);
        
        if (featureFiles.isEmpty()) {
            System.out.println("No feature files found matching criteria. Path: " + featuresPath + ", Tags: " + tagFilter);
            return;
        }
        
        // Create a test for each feature file
        for (String featureFile : featureFiles) {
            String featureName = new java.io.File(featureFile).getName().replace(".feature", "");
            
            XmlTest test = new XmlTest(mainSuite);
            test.setName("Feature: " + featureName);
            
            // Add parameters
            test.addParameter("featureFile", featureFile);
            
            // Create dummy class to run the feature
            XmlClass xmlClass = new XmlClass(BDDFeatureRunner.class.getName());
            test.setXmlClasses(Arrays.asList(xmlClass));
        }
    }

    @Override
    public void onTestStart(ITestResult result) {
        // No special handling needed
    }

    @Override
    public void onTestSuccess(ITestResult result) {
        // No special handling needed
    }

    @Override
    public void onTestFailure(ITestResult result) {
        // No special handling needed
    }

    @Override
    public void onTestSkipped(ITestResult result) {
        // No special handling needed
    }

    @Override
    public void onTestFailedButWithinSuccessPercentage(ITestResult result) {
        // No special handling needed
    }

    @Override
    public void onStart(ITestContext context) {
        CSSmartDriverFactory.getDriver();
    }

    @Override
    public void onFinish(ITestContext context) {
        // No special handling needed
    }
    
    /**
     * Dummy class used to execute BDD features
     */
    public static class BDDFeatureRunner {
        
        @org.testng.annotations.Parameters({"featureFile"})
        @org.testng.annotations.Test
        public void runFeature(String featureFile) {
            CSSmartAutoBDDRunner.runFeature(featureFile);
        }
    }
}



    @Override
    protected void registerStepDefinitions() {
        // Register specific step definitions
        BDDTestRunner.registerStepDefinition(LoginSteps.class);
        BDDTestRunner.registerStepDefinition(CommonSteps.class);
        
        // Alternatively, let the base class handle auto-discovery
        // super.registerStepDefinitions();
    }
}
*/


