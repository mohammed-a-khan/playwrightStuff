import { BeforeAll, AfterAll, Before, After, Status, setDefaultTimeout } from '@cucumber/cucumber';
import apiClient from '../api/apiClient';
import { logger } from '../helpers/loggerHelper';
import reportHelper from '../helpers/reportHelper';
import * as fs from 'fs-extra';
import * as path from 'path';
import { configHelper } from '../../config/config';
import { TimeoutUtils } from '../utils/timeoutUtils';
import { World, ScenarioContext } from '../models/worldModels';

// Set a higher default timeout for all steps (in milliseconds)
// This is crucial for API testing where responses may take longer than the default 5 seconds
setDefaultTimeout(60 * 1000); // 60 seconds

// Ensure reports directories exist
const reportsDir = path.join(process.cwd(), 'reports');
const jsonReportsDir = path.join(reportsDir, 'json');
const htmlReportsDir = path.join(reportsDir, 'html');
const screenshotsDir = path.join(reportsDir, 'screenshots');
const logsDir = path.join(reportsDir, 'logs');

fs.ensureDirSync(jsonReportsDir);
fs.ensureDirSync(htmlReportsDir);
fs.ensureDirSync(screenshotsDir);
fs.ensureDirSync(logsDir);

// Store test context in module-level variable to avoid global variable issues
const testContextMap: Record<string, ScenarioContext> = {};

BeforeAll(async function() {
  logger.info('üöÄ Test execution started');
  // Note: The report is also initialized by the cucumber formatter
  // but we call it here as well to ensure it runs even without the formatter
  reportHelper.startTestRun();
  
  // Initialize API client and wait for completion
  await apiClient.initialize();
  
  // Log environment information
  logger.info(`Environment: ${configHelper.getEnvironment()}`);
  logger.info(`Base URL: ${configHelper.getBaseUrl()}`);
  logger.info(`Debug Mode: ${configHelper.isDebugMode()}`);
  logger.info(`Timeout: ${configHelper.getTimeout()}ms`);
  logger.info(`Retry Attempts: ${configHelper.getRetryAttempts()}`);
});

AfterAll(async function() {
  try {
    logger.info('üèÅ Test execution completed');
    
    // Wait for any pending operations to complete
    await TimeoutUtils.sleep(1000);
    
    // Cleanup
    await apiClient.dispose();
    
    // Generate report
    // Note: The report is also generated by the cucumber formatter
    // but we call it here as well to ensure it runs even without the formatter
    reportHelper.endTestRun();
    
    // Use a hardcoded name to avoid issues with string manipulation
    try {
      await reportHelper.generateReport('api-test-report');
      logger.info('Report generation completed successfully');
    } catch (reportError) {
      logger.error(`Error generating report: ${reportError}`);
    }
    
    // Clear test context
    for (const key of Object.keys(testContextMap)) {
      delete testContextMap[key];
    }
    
    logger.info('AfterAll hook completed successfully');
  } catch (error) {
    logger.error(`Error in AfterAll hook: ${error}`);
  }
});

Before(async function(this: World, scenario) {
  try {
    // Safely get the feature name from the URI if it exists
    let featureName = 'Unknown';
    if (scenario.pickle.uri && typeof scenario.pickle.uri === 'string') {
      const uriParts = scenario.pickle.uri.split('/');
      const featureFile = uriParts[uriParts.length - 1];
      featureName = featureFile.replace('.feature', '');
    }
    
    const scenarioName = scenario.pickle.name || 'Unnamed Scenario';
    
    logger.info(`‚ñ∂Ô∏è Starting scenario: ${scenarioName} [${featureName}]`);
    
    // Initialize scenario context
    this.context = {
      scenarioName,
      scenarioId: scenario.pickle.id || '',
      featureName,
      startTime: new Date(),
      responses: {},
      data: {},
      screenshots: []
    };
    
    // Add to test context map
    testContextMap[scenarioName] = this.context;
  } catch (error) {
    logger.error(`Error in Before hook: ${error}`);
    throw error;
  }
});

After(async function(this: World, scenario) {
  try {
    if (!this.context || !this.context.startTime) {
      logger.error('Context or startTime is missing in After hook');
      return;
    }
    
    const duration = new Date().getTime() - this.context.startTime.getTime();
    const status = scenario.result?.status || 'unknown';
    
    logger.info(`‚èπÔ∏è Completed scenario: ${this.context.scenarioName} with status: ${status.toUpperCase()} (${duration}ms)`);
    
    let error = undefined;
    const screenshots: string[] = this.context.screenshots || [];
    
    if (scenario.result?.status === Status.FAILED) {
      error = scenario.result.message;
      logger.error(`Scenario failed: ${error}`);
      
      // Take screenshot on failure if configured
      if (configHelper.shouldTakeScreenshotOnFailure()) {
        try {
          const screenshotName = `${this.context.featureName}_${this.context.scenarioName}_failure`;
          const screenshotPath = path.join(screenshotsDir, `${screenshotName}.txt`);
          
          // For API testing, save error details as a text file instead of screenshot
          await fs.writeFile(
            screenshotPath,
            `Error: ${error}\n\nContext: ${JSON.stringify(this.context, null, 2)}`,
            'utf8'
          );
          
          screenshots.push(screenshotPath);
          logger.info(`Error details saved to: ${screenshotPath}`);
        } catch (screenshotError) {
          logger.error(`Failed to save error details: ${screenshotError}`);
        }
      }
    }
    
    // Add test result to the report
    reportHelper.addTestResult(
      this.context.featureName,
      this.context.scenarioName,
      status,
      duration,
      error,
      { 
        scenarioId: this.context.scenarioId,
        responses: Object.keys(this.context.responses)
      },
      screenshots
    );
    
    // Remove from test context map
    if (this.context.scenarioName && testContextMap[this.context.scenarioName]) {
      delete testContextMap[this.context.scenarioName];
    }
  } catch (error) {
    logger.error(`Error in After hook: ${error}`);
  }
});
