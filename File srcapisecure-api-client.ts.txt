CertificateHelper.js
-----------------------

import * as fs from 'fs-extra';
import * as path from 'path';
import * as pem from 'pem';
import { configHelper } from '../../config/config';
import { logger } from './loggerHelper';
import { RetryHelper } from './retryHelper';

export class CertificateHelper {
  private static instance: CertificateHelper;
  private certificateCache: Map<string, Buffer> = new Map();

  private constructor() {}

  public static getInstance(): CertificateHelper {
    if (!CertificateHelper.instance) {
      CertificateHelper.instance = new CertificateHelper();
    }
    return CertificateHelper.instance;
  }

  /**
   * Validate and read certificate file
   * @returns Detailed certificate information
   */
  public async validateCertificate(): Promise<{
    valid: boolean;
    details?: any;
    error?: string;
  }> {
    try {
      const certPath = path.resolve(configHelper.getCertPath());
      const passphrase = configHelper.getCertPassphrase();

      // Check file existence
      if (!fs.existsSync(certPath)) {
        logger.error(`Certificate file not found at: ${certPath}`);
        return { 
          valid: false, 
          error: `Certificate file not found at: ${certPath}` 
        };
      }

      // Read file
      const certBuffer = await fs.readFile(certPath);

      // Detailed certificate information extraction
      return new Promise((resolve, reject) => {
        pem.readPkcs12(certBuffer, { p12Password: passphrase }, (err, cert) => {
          if (err) {
            logger.error('Certificate parsing error', {
              error: err.message,
              path: certPath
            });
            resolve({ 
              valid: false, 
              error: `Certificate parsing error: ${err.message}` 
            });
            return;
          }

          // Extract certificate details
          pem.getPublicKey(cert.key, (keyErr, publicKey) => {
            if (keyErr) {
              logger.error('Public key extraction error', {
                error: keyErr.message
              });
              resolve({ 
                valid: false, 
                error: `Public key extraction error: ${keyErr.message}` 
              });
              return;
            }

            // Detailed logging of certificate information
            logger.info('Certificate Validation Details', {
              certPath,
              certSize: `${certBuffer.length} bytes`,
              hasKey: !!cert.key,
              hasCertificate: !!cert.cert,
              publicKeyLength: publicKey.length
            });

            resolve({
              valid: true,
              details: {
                certPath,
                certSize: certBuffer.length,
                publicKeyLength: publicKey.length,
                pemCert: cert.cert
              }
            });
          });
        });
      });
    } catch (error) {
      logger.error(`Comprehensive certificate validation error: ${error}`);
      return { 
        valid: false, 
        error: `Comprehensive certificate validation error: ${error}` 
      };
    }
  }

  /**
   * Get certificate options for API client
   * @returns Certificate options object
   */
  public async getCertificateOptions(): Promise<any> {
    try {
      const certPath = path.resolve(configHelper.getCertPath());
      const passphrase = configHelper.getCertPassphrase();
      
      // Validate certificate first
      const validationResult = await this.validateCertificate();
      
      if (!validationResult.valid) {
        logger.error(`Certificate validation failed: ${validationResult.error}`);
        return {};
      }

      // Read certificate file
      const pfxBuffer = await fs.readFile(certPath);
      
      return {
        httpsOptions: {
          pfx: pfxBuffer,
          passphrase
        }
      };
    } catch (error) {
      logger.error(`Comprehensive certificate loading error: ${error}`, {
        certPath: configHelper.getCertPath(),
        hasPassphrase: !!configHelper.getCertPassphrase()
      });
      throw error;
    }
  }

  /**
   * Diagnose certificate issues
   */
  public async diagnoseCertificateIssues(): Promise<void> {
    try {
      const certPath = path.resolve(configHelper.getCertPath());
      
      // Basic file system checks
      logger.info('Certificate Diagnostic Information');
      logger.info(`Certificate Path: ${certPath}`);
      
      // Check file existence and permissions
      const stats = await fs.stat(certPath);
      logger.info('File Statistics', {
        size: stats.size,
        isFile: stats.isFile(),
        canRead: stats.mode & 0o400 ? 'Yes' : 'No'
      });

      // Attempt to read file contents
      const fileBuffer = await fs.readFile(certPath);
      logger.info(`File read successfully, size: ${fileBuffer.length} bytes`);

      // Additional validation
      await this.validateCertificate();
    } catch (error) {
      logger.error('Certificate Diagnosis Failed', {
        error: error.message,
        stack: error.stack
      });
    }
  }
}

export const certificateHelper = CertificateHelper.getInstance();

certificateDiagnostic.ts
--------------------------
#!/usr/bin/env node
const path = require('path');
const fs = require('fs');
const { certificateHelper } = require('./dist/src/helpers/certificateHelper');
const { configHelper } = require('./dist/config/config');

async function runCertificateDiagnostics() {
  try {
    console.log('=== Certificate Diagnostics ===');
    
    // Get certificate path
    const certPath = path.resolve(configHelper.getCertPath());
    console.log(`Certificate Path: ${certPath}`);

    // Check file existence
    if (!fs.existsSync(certPath)) {
      console.error(`ERROR: Certificate file does not exist at ${certPath}`);
      return;
    }

    // Get file stats
    const stats = fs.statSync(certPath);
    console.log('File Statistics:');
    console.log(`- Size: ${stats.size} bytes`);
    console.log(`- Readable: ${stats.mode & 0o400 ? 'Yes' : 'No'}`);

    // Validate certificate
    console.log('\nValidating Certificate...');
    const validationResult = await certificateHelper.validateCertificate();
    
    if (validationResult.valid) {
      console.log('Certificate is VALID');
      console.log('Details:', JSON.stringify(validationResult.details, null, 2));
    } else {
      console.error('Certificate INVALID');
      console.error('Error:', validationResult.error);
    }

    // Try to get certificate options
    console.log('\nTesting Certificate Options...');
    const certOptions = await certificateHelper.getCertificateOptions();
    console.log('Certificate Options Generated Successfully');

  } catch (error) {
    console.error('CRITICAL ERROR during certificate diagnostics:');
    console.error(error);
  }
}

runCertificateDiagnostics();

"cert:diagnose": "ts-node scripts/certificateDiagnostics.ts"
