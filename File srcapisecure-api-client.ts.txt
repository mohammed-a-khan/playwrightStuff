// debug-asset-request.ts
// A standalone script to debug the Asset API request without using BDD

import axios from 'axios';
import fs from 'fs';
import path from 'path';
import https from 'https';

/**
 * Simple logger for debugging
 */
class SimpleLogger {
  log(level: string, message: string): void {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] [${level.toUpperCase()}] ${message}`);
  }

  info(message: string): void {
    this.log('info', message);
  }

  debug(message: string): void {
    this.log('debug', message);
  }

  error(message: string): void {
    this.log('error', message);
  }

  warn(message: string): void {
    this.log('warn', message);
  }
}

/**
 * Configuration loader
 */
function loadConfig(): Record<string, any> {
  try {
    // Try to load from .env.debug file first
    const configPath = path.resolve(process.cwd(), '.env.debug');
    if (fs.existsSync(configPath)) {
      const configData = fs.readFileSync(configPath, 'utf8');
      const config: Record<string, any> = {};
      
      configData.split('\n').forEach(line => {
        const match = line.match(/^([^#=]+)=(.*)$/);
        if (match) {
          const key = match[1].trim();
          const value = match[2].trim().replace(/^["']|["']$/g, ''); // Remove quotes
          config[key] = value;
        }
      });
      
      return config;
    }
    
    // Fallback to hardcoded config
    return {
      API_BASE_URL: 'https://khanapi-test.example.com/api/v1',
      KHAN_API_CERT_PATH: './certs/khanapicert.pfx',
      KHAN_API_CERT_PASSPHRASE: 'khanapipwd',
      PROXY_URL: '',
      DEFAULT_TIMEOUT: '120000'
    };
  } catch (error) {
    console.error('Error loading config:', error);
    return {};
  }
}

/**
 * Function to make a direct asset API request
 */
async function makeAssetRequest(logger: SimpleLogger, config: Record<string, any>): Promise<void> {
  // Create request body
  const requestBody = {
    messageId: '999',
    dealId: 2223,
    reportDate: '2024-03-31'
  };
  
  // Set up request options
  const baseUrl = config.API_BASE_URL || 'https://khanapi-test.example.com/api/v1';
  const url = new URL('/assets', baseUrl).toString();
  
  // Configure certificate if available
  let httpsAgent;
  const certPath = config.KHAN_API_CERT_PATH;
  const certPassphrase = config.KHAN_API_CERT_PASSPHRASE;
  
  if (certPath && fs.existsSync(certPath)) {
    try {
      const pfx = fs.readFileSync(certPath);
      httpsAgent = new https.Agent({
        pfx,
        passphrase: certPassphrase,
        rejectUnauthorized: true
      });
      logger.info(`Using PFX certificate from: ${certPath}`);
    } catch (error) {
      logger.error(`Error loading PFX certificate: ${error.message}`);
    }
  }
  
  // Configure proxy if available
  let proxy;
  const proxyUrl = config.PROXY_URL;
  
  if (proxyUrl) {
    try {
      // Ensure proxy URL has a protocol
      const formattedProxyUrl = proxyUrl.startsWith('http') 
        ? proxyUrl 
        : `http://${proxyUrl}`;
      
      const parsedUrl = new URL(formattedProxyUrl);
      
      proxy = {
        host: parsedUrl.hostname,
        port: parseInt(parsedUrl.port || '80'),
        protocol: parsedUrl.protocol.replace(':', '')
      };
      
      logger.info(`Using proxy: ${formattedProxyUrl}`);
    } catch (error) {
      logger.error(`Invalid proxy URL: ${proxyUrl}`);
    }
  }
  
  // Configure request config
  const requestConfig = {
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    timeout: parseInt(config.DEFAULT_TIMEOUT || '120000'),
    withCredentials: true,
    httpsAgent,
    proxy
  };
  
  logger.info(`Making POST request to: ${url}`);
  logger.debug(`Request body: ${JSON.stringify(requestBody, null, 2)}`);
  
  try {
    // Start timer
    const startTime = Date.now();
    
    // Make the request
    const response = await axios.post(url, requestBody, requestConfig);
    
    // Calculate duration
    const duration = Date.now() - startTime;
    logger.info(`Request completed in ${duration}ms`);
    
    // Log response
    logger.info(`Response status: ${response.status}`);
    logger.debug(`Response headers: ${JSON.stringify(response.headers, null, 2)}`);
    
    // Save response to file
    const responsesDir = path.resolve(process.cwd(), 'responses');
    if (!fs.existsSync(responsesDir)) {
      fs.mkdirSync(responsesDir, { recursive: true });
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const responseFile = path.join(responsesDir, `asset-response-${timestamp}.json`);
    fs.writeFileSync(responseFile, JSON.stringify(response.data, null, 2));
    logger.info(`Response saved to: ${responseFile}`);
    
    // Analyze response
    if (response.data) {
      if (response.data.assetLayouts && Array.isArray(response.data.assetLayouts)) {
        logger.info(`Response contains ${response.data.assetLayouts.length} asset layouts`);
      } else {
        logger.warn('Response has no asset layouts or they are not in an array');
      }
      
      // Check for errors
      if (response.data.systemError) {
        logger.error(`System error: ${response.data.systemError}`);
      }
      
      if (response.data.errorMessage) {
        logger.error(`Error message: ${response.data.errorMessage}`);
      }
      
      if (response.data.validationErrorMessage) {
        logger.error(`Validation error: ${response.data.validationErrorMessage}`);
      }
    } else {
      logger.error('Response has no data');
    }
  } catch (error) {
    logger.error(`Request failed: ${error.message}`);
    
    if (error.response) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx
      logger.error(`Response error: ${error.response.status}`);
      logger.debug(`Error response data: ${JSON.stringify(error.response.data)}`);
      logger.debug(`Error response headers: ${JSON.stringify(error.response.headers)}`);
    } else if (error.request) {
      // The request was made but no response was received
      logger.error('No response received');
    } else {
      // Something happened in setting up the request that triggered an Error
      logger.error(`Request configuration error: ${error.message}`);
    }
  }
}

/**
 * Implement polling for long-running requests
 */
async function makeAssetRequestWithPolling(logger: SimpleLogger, config: Record<string, any>): Promise<void> {
  // Create request body
  const requestBody = {
    messageId: '999',
    dealId: 2223,
    reportDate: '2024-03-31'
  };
  
  // Set up request options
  const baseUrl = config.API_BASE_URL || 'https://khanapi-test.example.com/api/v1';
  const url = new URL('/assets', baseUrl).toString();
  
  // Configure certificate if available
  let httpsAgent;
  const certPath = config.KHAN_API_CERT_PATH;
  const certPassphrase = config.KHAN_API_CERT_PASSPHRASE;
  
  if (certPath && fs.existsSync(certPath)) {
    try {
      const pfx = fs.readFileSync(certPath);
      httpsAgent = new https.Agent({
        pfx,
        passphrase: certPassphrase,
        rejectUnauthorized: true
      });
      logger.info(`Using PFX certificate from: ${certPath}`);
    } catch (error) {
      logger.error(`Error loading PFX certificate: ${error.message}`);
    }
  }
  
  // Configure proxy if available
  let proxy;
  const proxyUrl = config.PROXY_URL;
  
  if (proxyUrl) {
    try {
      // Ensure proxy URL has a protocol
      const formattedProxyUrl = proxyUrl.startsWith('http') 
        ? proxyUrl 
        : `http://${proxyUrl}`;
      
      const parsedUrl = new URL(formattedProxyUrl);
      
      proxy = {
        host: parsedUrl.hostname,
        port: parseInt(parsedUrl.port || '80'),
        protocol: parsedUrl.protocol.replace(':', '')
      };
      
      logger.info(`Using proxy: ${formattedProxyUrl}`);
    } catch (error) {
      logger.error(`Invalid proxy URL: ${proxyUrl}`);
    }
  }
  
  // Configure request config
  const requestConfig = {
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    timeout: parseInt(config.DEFAULT_TIMEOUT || '120000'),
    withCredentials: true,
    httpsAgent,
    proxy
  };
  
  // Poll options
  const pollOptions = {
    maxAttempts: parseInt(config.API_POLLING_MAX_ATTEMPTS || '12'),
    interval: parseInt(config.API_POLLING_INTERVAL || '5000'),
    timeoutPerAttempt: parseInt(config.API_POLLING_TIMEOUT_PER_ATTEMPT || '15000')
  };
  
  logger.info(`Making POST request to: ${url}`);
  logger.debug(`Request body: ${JSON.stringify(requestBody, null, 2)}`);
  
  // Start timer for overall request
  const startTime = Date.now();
  
  try {
    // Make the initial request
    logger.info('Making initial request');
    let response = await axios.post(url, requestBody, requestConfig);
    
    // Function to check if response is complete
    const isResponseComplete = (data: any) => {
      if (!data) return false;
      
      // Check if assetLayouts is present and not empty
      if (!data.assetLayouts) return false;
      
      // If assetLayouts is present but empty, check for errors
      if (Array.isArray(data.assetLayouts) && data.assetLayouts.length === 0) {
        // If there are no assets but there's an error message, the response is complete
        if (data.systemError || data.errorMessage || data.validationErrorMessage) {
          return true;
        }
        return false;
      }
      
      // If we have assets, the response is complete
      if (Array.isArray(data.assetLayouts) && data.assetLayouts.length > 0) {
        return true;
      }
      
      return false;
    };
    
    // Check if initial response is complete
    if (isResponseComplete(response.data)) {
      logger.info('Initial response is complete, no polling needed');
    } else {
      logger.info('Initial response incomplete, starting polling...');
      
      // Start polling for complete response
      for (let attempt = 1; attempt <= pollOptions.maxAttempts; attempt++) {
        logger.info(`Waiting ${pollOptions.interval}ms before polling attempt ${attempt}/${pollOptions.maxAttempts}`);
        await new Promise(resolve => setTimeout(resolve, pollOptions.interval));
        
        try {
          // Create fresh config for polling with shorter timeout
          const pollConfig = {
            ...requestConfig,
            timeout: pollOptions.timeoutPerAttempt
          };
          
          logger.info(`Polling attempt ${attempt}/${pollOptions.maxAttempts}`);
          response = await axios.post(url, requestBody, pollConfig);
          
          // Check if the response is now complete
          if (isResponseComplete(response.data)) {
            logger.info(`Polling successful after ${attempt} attempts`);
            break;
          }
          
          logger.debug(`Polling attempt ${attempt}/${pollOptions.maxAttempts} - data still incomplete`);
        } catch (error) {
          logger.warn(`Polling attempt ${attempt} failed: ${error.message}`);
        }
      }
    }
    
    // Calculate total duration
    const totalDuration = Date.now() - startTime;
    logger.info(`Request (including polling) completed in ${totalDuration}ms`);
    
    // Save final response to file
    const responsesDir = path.resolve(process.cwd(), 'responses');
    if (!fs.existsSync(responsesDir)) {
      fs.mkdirSync(responsesDir, { recursive: true });
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const responseFile = path.join(responsesDir, `asset-response-with-polling-${timestamp}.json`);
    fs.writeFileSync(responseFile, JSON.stringify(response.data, null, 2));
    logger.info(`Response saved to: ${responseFile}`);
    
    // Analyze final response
    if (response.data) {
      if (response.data.assetLayouts && Array.isArray(response.data.assetLayouts)) {
        logger.info(`Response contains ${response.data.assetLayouts.length} asset layouts`);
      } else {
        logger.warn('Response has no asset layouts or they are not in an array');
      }
      
      // Check for errors
      if (response.data.systemError) {
        logger.error(`System error: ${response.data.systemError}`);
      }
      
      if (response.data.errorMessage) {
        logger.error(`Error message: ${response.data.errorMessage}`);
      }
      
      if (response.data.validationErrorMessage) {
        logger.error(`Validation error: ${response.data.validationErrorMessage}`);
      }
    } else {
      logger.error('Response has no data');
    }
  } catch (error) {
    const totalDuration = Date.now() - startTime;
    logger.error(`Request failed after ${totalDuration}ms: ${error.message}`);
    
    if (error.response) {
      logger.error(`Response error: ${error.response.status}`);
      logger.debug(`Error response data: ${JSON.stringify(error.response.data, null, 2)}`);
    } else if (error.request) {
      logger.error('No response received');
    } else {
      logger.error(`Request configuration error: ${error.message}`);
    }
  }
}

// Main execution
async function main(): Promise<void> {
  const logger = new SimpleLogger();
  const config = loadConfig();
  
  logger.info('Starting asset API debug script');
  logger.info(`Using API Base URL: ${config.API_BASE_URL}`);
  
  // Choose which method to run
  const usePolling = process.argv.includes('--polling');
  
  if (usePolling) {
    logger.info('Using polling method for long-running request');
    await makeAssetRequestWithPolling(logger, config);
  } else {
    logger.info('Using direct request method');
    await makeAssetRequest(logger, config);
  }
  
  logger.info('Debug script completed');
}

// Run the main function
main().catch(error => {
  console.error('Unhandled error:', error);
  process.exit(1);
});

// How to run:
// For direct request: ts-node debug-asset-request.ts
// For polling request: ts-node debug-asset-request.ts --polling
