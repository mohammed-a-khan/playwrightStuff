// src/api/enhanced-api-client.ts
import { BaseApiClient, ApiRequestOptions } from '../framework/base-api-client';
import * as fs from 'fs';
import * as https from 'https';

/**
 * Enhanced API client with support for cookies, certificates, and proxy
 */
export class EnhancedApiClient extends BaseApiClient {
  private pfxPath?: string;
  private pfxPassphrase?: string;
  private proxyUrl?: string;

  /**
   * Constructor for the EnhancedApiClient
   * @param apiBaseUrl - Base URL for API requests
   * @param pfxOptions - PFX certificate options (optional)
   * @param proxyUrl - Proxy URL (optional)
   */
  constructor(
    apiBaseUrl?: string,
    pfxOptions?: { path: string; passphrase: string },
    proxyUrl?: string
  ) {
    super(apiBaseUrl);
    
    if (pfxOptions) {
      this.pfxPath = pfxOptions.path;
      this.pfxPassphrase = pfxOptions.passphrase;
    }
    
    this.proxyUrl = proxyUrl;
  }

  /**
   * Set cookie for API requests
   * @param cookieValue - Cookie value (e.g., "JSESSIONID=abc123; other=value")
   */
  setCookie(cookieValue: string): void {
    // Update defaultHeaders with the cookie
    this.defaultHeaders['Cookie'] = cookieValue;
    this.logger.info(`Set cookie header: ${cookieValue}`);
  }

  /**
   * Make a GET request with certificate and proxy support
   * @param endpoint - API endpoint
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  async get<T = any>(endpoint: string, options?: ApiRequestOptions): Promise<any> {
    return this.makeRequest('get', endpoint, undefined, options);
  }

  /**
   * Make a POST request with certificate and proxy support
   * @param endpoint - API endpoint
   * @param data - Request data
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  async post<T = any>(endpoint: string, data?: any, options?: ApiRequestOptions): Promise<any> {
    return this.makeRequest('post', endpoint, data, options);
  }

  /**
   * Make a PUT request with certificate and proxy support
   * @param endpoint - API endpoint
   * @param data - Request data
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  async put<T = any>(endpoint: string, data?: any, options?: ApiRequestOptions): Promise<any> {
    return this.makeRequest('put', endpoint, data, options);
  }

  /**
   * Make a DELETE request with certificate and proxy support
   * @param endpoint - API endpoint
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  async delete<T = any>(endpoint: string, options?: ApiRequestOptions): Promise<any> {
    return this.makeRequest('delete', endpoint, undefined, options);
  }

  /**
   * Make a request with certificate and proxy support
   * @param method - HTTP method
   * @param endpoint - API endpoint
   * @param data - Request data (for POST, PUT)
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  private async makeRequest<T = any>(
    method: 'get' | 'post' | 'put' | 'delete',
    endpoint: string,
    data?: any,
    options?: ApiRequestOptions
  ): Promise<any> {
    const url = new URL(endpoint, this.apiBaseUrl).toString();
    this.logger.info(`Making ${method.toUpperCase()} request to: ${url}`);
    
    const config: any = {
      headers: { ...this.defaultHeaders, ...options?.headers },
      params: options?.params || {},
      timeout: options?.timeout || this.defaultTimeout,
      validateStatus: options?.validateStatus !== false ? undefined : () => true
    };

    // Add PFX certificate if provided
    if (this.pfxPath) {
      const pfx = fs.readFileSync(this.pfxPath);
      config.httpsAgent = new https.Agent({ 
        pfx,
        passphrase: this.pfxPassphrase,
        rejectUnauthorized: false // Set to true in production
      });
    }

    // Add proxy if provided
    if (this.proxyUrl) {
      config.proxy = {
        host: new URL(this.proxyUrl).hostname,
        port: Number(new URL(this.proxyUrl).port),
        protocol: new URL(this.proxyUrl).protocol.replace(':', '')
      };
    }

    try {
      // Create a timestamp for request timing
      const startTime = Date.now();
      
      let response;
      switch (method) {
        case 'get':
          response = await super.get(endpoint, { ...options, ...config });
          break;
        case 'post':
          response = await super.post(endpoint, data, { ...options, ...config });
          break;
        case 'put':
          response = await super.put(endpoint, data, { ...options, ...config });
          break;
        case 'delete':
          response = await super.delete(endpoint, { ...options, ...config });
          break;
      }
      
      return response;
    } catch (error) {
      this.logger.error(`Request failed: ${error.message}`);
      throw error;
    }
  }
}
