// File: src/support/hooks.ts
import { Before, After, BeforeAll, AfterAll, setDefaultTimeout, ITestCaseHookParameter } from '@cucumber/cucumber';
import { TestContext } from './test-context';
import { Logger } from '../framework/utils/logger';
import { BrowserManager } from '../framework/browser-manager';
import { ConfigManager } from '../framework/utils/config-manager';
import path from 'path';
import fs from 'fs';

// Load configuration once at the start
const config = ConfigManager.getInstance();

// Set default timeout
setDefaultTimeout(30000);

// Get the default timeout asynchronously and update it later
(async () => {
  try {
    const defaultTimeout = await config.getNumber('DEFAULT_TIMEOUT', 30000);
    setDefaultTimeout(defaultTimeout);
  } catch (error) {
    console.error('Error setting default timeout:', error);
  }
})();

// Create a BrowserManager instance
const browserManager = BrowserManager.getInstance();

// Before all scenarios
BeforeAll(async function() {
  const globalLogger = new Logger('GlobalSetup');
  globalLogger.info('Starting test execution');
  
  // Ensure report directories exist
  const dirs = ['reports/screenshots', 'reports/videos', 'reports/logs', 'reports/html', 'reports/json'];
  dirs.forEach(dir => {
    const dirPath = path.join(process.cwd(), dir);
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
      globalLogger.info(`Created directory: ${dirPath}`);
    }
  });
  
  // For web tests, initialize the browser once
  try {
    const preLaunchBrowser = process.env.PRELAUNCH_BROWSER === 'true';
    if (preLaunchBrowser) {
      globalLogger.info('Pre-launching browser');
      await browserManager.initialize();
      globalLogger.info('Browser pre-launched successfully');
    }
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    globalLogger.error(`Failed to pre-launch browser: ${errorMessage}`);
  }
});

// After all scenarios
AfterAll(async function() {
  const globalLogger = new Logger('GlobalTeardown');
  globalLogger.info('Finishing test execution');
  
  // Close the browser if it's open
  try {
    await browserManager.closeBrowser();
    globalLogger.info('All resources cleaned up');
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    globalLogger.error(`Error during cleanup: ${errorMessage}`);
  }
});

// Before each scenario
Before(async function(this: TestContext, scenario: ITestCaseHookParameter) {
  this.startTime = Date.now();
  this.scenarioName = scenario.pickle.name;
  this.scenarioTags = scenario.pickle.tags.map(tag => tag.name);
  
  // Create a unique test ID based on scenario name and timestamp
  const testId = `${scenario.pickle.name.replace(/[^a-zA-Z0-9]/g, '-')}-${Date.now()}`;
  
  // Initialize logger with test ID
  this.logger = new Logger(testId);
  this.logger.info(`Starting scenario: ${scenario.pickle.name}`);
  
  // Log tags
  if (this.scenarioTags.length > 0) {
    this.logger.info(`Tags: ${this.scenarioTags.join(', ')}`);
  }
  
  // Create test data object for sharing data between steps
  this.testData = {};
  
  // For UI tests, initialize browser context and page
  if (this.scenarioTags.some(tag => tag === '@web' || tag === '@ui')) {
    this.logger.info('Initializing web test');
    
    try {
      // Create a new context with default options
      // We'll adjust these based on configuration values
      const contextOptions: Record<string, any> = {};
      
      // Get recording options - note that we need to handle promises carefully
      try {
        const recordVideo = await config.getBoolean('VIDEO_RECORD', false);
        if (recordVideo) {
          contextOptions.recordVideo = {
            dir: 'videos/',
            size: { 
              width: 1280, 
              height: 720 
            }
          };
          
          // Try to get video dimensions
          try {
            const videoWidth = await config.getNumber('VIDEO_WIDTH', 1280);
            const videoHeight = await config.getNumber('VIDEO_HEIGHT', 720);
            contextOptions.recordVideo.size.width = videoWidth;
            contextOptions.recordVideo.size.height = videoHeight;
          } catch (e) {
            // Use defaults if config fails
          }
        }
      } catch (e) {
        // Use defaults if config fails
      }
      
      this.context = await browserManager.createContext(contextOptions);
      
      // Add ability to set breakpoints if needed
      if (process.env.DEBUG === 'true') {
        this.context.setDefaultTimeout(0); // No timeout during debugging
      }
      
      // Create a new page
      this.page = await this.context.newPage();
      this.logger.info('Browser context and page initialized');
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(`Failed to initialize browser: ${errorMessage}`);
      throw error;
    }
  } 
  // For API tests, we don't need browser initialization
  else if (this.scenarioTags.some(tag => tag === '@api')) {
    this.logger.info('Initializing API test');
    // API clients will be initialized in step definitions when needed
  }
});

// After each scenario
After(async function(this: TestContext, scenario: ITestCaseHookParameter) {
  this.endTime = Date.now();
  const executionTime = this.endTime - (this.startTime || this.endTime);
  
  // Store result status for use in clean-up
  this.result = { status: scenario.result?.status || 'UNKNOWN' };
  
  // Log scenario result
  if (this.logger) {
    this.logger.info(`Scenario ${this.result.status}: ${scenario.pickle.name} (${executionTime}ms)`);
    
    // Take screenshot on failure for UI tests
    if (this.result.status === 'FAILED' && this.page) {
      try {
        const screenshotName = `failed-${this.scenarioName?.replace(/[^a-zA-Z0-9]/g, '-')}-${Date.now()}`;
        const screenshotPath = `./reports/screenshots/${screenshotName}.png`;
        const screenshot = await this.page.screenshot({ 
          path: screenshotPath,
          fullPage: true 
        });
        this.logger.info(`Screenshot captured: ${screenshotPath}`);
        if (this.attach) {
          this.attach(screenshot, 'image/png');
        }
      } catch (error: unknown) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        this.logger.error(`Failed to take screenshot: ${errorMessage}`);
      }
    }
  }
  
  // Generic cleanup for browser resources
  if (this.context) {
    try {
      // Close context (and associated page)
      if (this.logger) {
        this.logger.info('Closing browser context');
      }
      await browserManager.closeContext(this.context);
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      if (this.logger) {
        this.logger.error(`Error closing browser context: ${errorMessage}`);
      }
    }
  }
  
  // Add logs to Cucumber report
  if (this.logger && this.attach) {
    const logs = this.logger.getLogs();
    if (logs.length > 0) {
      try {
        this.attach(logs.join('\n'), 'text/plain');
      } catch (error: unknown) {
        console.error('Error attaching logs:', error);
      }
    }
  }
  
  // Explicitly clean up references to help garbage collection
  delete this.page;
  delete this.context;
});
