import { Given, When, Then } from '@cucumber/cucumber';
import { expect } from '@playwright/test';
import { TradeApiClient } from '../../api/trade-api-client';
import { TestContext } from '../../support/test-context';
import axios, { AxiosResponse } from 'axios';

Given('I have a Trade API client', async function(this: TestContext) {
  // Initialize the trade API client
  this.tradeApiClient = new TradeApiClient();
  expect(this.tradeApiClient).toBeDefined();
});

When('I search for trades with the following filters', async function(this: TestContext, dataTable) {
  // Ensure trade API client exists
  if (!this.tradeApiClient) {
    throw new Error('Trade API client is not initialized');
  }

  // Initialize testData if it doesn't exist
  if (!this.testData) {
    this.testData = {};
  }

  const filters: Record<string, any> = dataTable.rowsHash();
  
  // Convert comma-separated values to arrays
  if (filters.accountNumFilter) {
    filters.accountNumFilter = filters.accountNumFilter.split(',');
  }
  if (filters.tradeStatusFilter) {
    filters.tradeStatusFilter = filters.tradeStatusFilter.split(',');
  }
  if (filters.tradeTypeFilter) {
    filters.tradeTypeFilter = filters.tradeTypeFilter.split(',');
  }
  
  // Convert string to boolean for priorityOrder
  if (filters.priorityOrder) {
    filters.priorityOrder = filters.priorityOrder === 'true';
  }
  
  // Store filters for later assertions
  this.testData.tradeFilters = filters;
  
  // Execute the search
  if (this.logger) {
    this.logger.info(`Searching trades with filters: ${JSON.stringify(filters)}`);
  }

  try {
    const searchResult = await this.tradeApiClient.searchTrades(filters);
    
    // Store the response for later access
    this.response = {
      data: searchResult,
      status: 200,
      statusText: 'OK',
      headers: {},
      config: {} as any,
    };
  } catch (error: unknown) {
    if (axios.isAxiosError(error) && error.response) {
      this.response = error.response;
    } else {
      throw error;
    }
  }
});

Then('the API should return a successful response', async function(this: TestContext) {
  expect(this.response).toBeDefined();
  expect(this.response?.status).toBe(200);
  
  if (this.logger && this.response?.data) {
    this.logger.info(`Response received with ${this.response.data.trades?.length || 0} trades`);
  }
});

Then('the response should contain trades matching the filters', async function(this: TestContext) {
  // Ensure response data exists
  expect(this.response).toBeDefined();
  expect(this.response?.data).toBeDefined();
  
  const filters = this.testData?.tradeFilters;
  const trades = this.response?.data?.trades;
  
  expect(filters).toBeDefined();
  expect(trades).toBeDefined();
  expect(Array.isArray(trades)).toBeTruthy();
  
  // Check that trades match the filters (if we have trades)
  if (trades && trades.length > 0) {
    if (this.logger) {
      this.logger.info(`Verifying ${trades.length} trades match the filters`);
    }
    
    // Verify account numbers if filter was provided
    if (filters.accountNumFilter && filters.accountNumFilter.length > 0) {
      for (const trade of trades) {
        if (trade.accountNum) {
          expect(filters.accountNumFilter).toContain(trade.accountNum);
        }
      }
    }
    
    // Verify trade status if filter was provided
    if (filters.tradeStatusFilter && filters.tradeStatusFilter.length > 0) {
      for (const trade of trades) {
        if (trade.tradeStatus) {
          expect(filters.tradeStatusFilter).toContain(trade.tradeStatus);
        }
      }
    }
    
    // Verify trade type if filter was provided
    if (filters.tradeTypeFilter && filters.tradeTypeFilter.length > 0) {
      for (const trade of trades) {
        if (trade.tradeType) {
          expect(filters.tradeTypeFilter).toContain(trade.tradeType);
        }
      }
    }
  }
});
