package.json
----------------------
{
  "name": "enhanced-playwright-framework",
  "version": "2.0.0",
  "description": "Advanced enterprise-level API test automation framework using Playwright, TypeScript, and Cucumber BDD",
  "main": "index.js",
  "scripts": {
    "clean": "rimraf reports/* dist/*",
    "build": "tsc",
    "pretest": "npm run clean",
    "test": "cucumber-js --require-module ts-node/register --require 'tests/step-definitions/**/*.ts' --require 'src/hooks/hooks.ts'",
    "test:sit": "cross-env NODE_ENV=sit cucumber-js --require-module ts-node/register --require 'tests/step-definitions/**/*.ts' --require 'src/hooks/hooks.ts'",
    "test:uat": "cross-env NODE_ENV=uat cucumber-js --require-module ts-node/register --require 'tests/step-definitions/**/*.ts' --require 'src/hooks/hooks.ts'",
    "test:prod": "cross-env NODE_ENV=prod cucumber-js --require-module ts-node/register --require 'tests/step-definitions/**/*.ts' --require 'src/hooks/hooks.ts'",
    "test:debug": "cross-env DEBUG=true cucumber-js --require-module ts-node/register --require 'tests/step-definitions/**/*.ts' --require 'src/hooks/hooks.ts'",
    "test:parallel": "cross-env PARALLEL=true cucumber-js --require-module ts-node/register --require 'tests/step-definitions/**/*.ts' --require 'src/hooks/hooks.ts' --parallel 2",
    "test:tags": "cucumber-js --require-module ts-node/register --require 'tests/step-definitions/**/*.ts' --require 'src/hooks/hooks.ts' --tags",
    "report": "node ./src/helpers/reportHelper.js",
    "lint": "eslint . --ext .ts",
    "format": "prettier --write .",
    "compile": "tsc --project tsconfig.json"
  },
  "keywords": [
    "playwright",
    "typescript",
    "cucumber",
    "api",
    "testing",
    "bdd"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@cucumber/cucumber": "^9.3.0",
    "@playwright/test": "^1.40.0",
    "ajv": "^8.12.0",
    "axios": "^1.5.0",
    "axios-retry": "^3.6.0",
    "chai": "^4.3.7",
    "chai-as-promised": "^7.1.1",
    "chalk": "^4.1.2",
    "cross-env": "^7.0.3",
    "cucumber-html-reporter": "^7.1.0",
    "dayjs": "^1.11.9",
    "dotenv": "^16.3.1",
    "fs-extra": "^11.1.1",
    "handlebars": "^4.7.8",
    "https-proxy-agent": "^7.0.0",
    "node-fetch": "^2.6.12",
    "p-limit": "^3.1.0",
    "pem": "^1.14.8",
    "pino": "^8.15.0",
    "pino-pretty": "^10.2.0",
    "rxjs": "^7.8.1",
    "ts-node": "^10.9.1",
    "typescript": "^5.1.6",
    "uuid": "^9.0.0",
    "winston": "^3.10.0",
    "winston-daily-rotate-file": "^4.7.1"
  },
  "devDependencies": {
    "@types/chai": "^4.3.5",
    "@types/chai-as-promised": "^7.1.5",
    "@types/cucumber-html-reporter": "^5.0.1",
    "@types/fs-extra": "^11.0.1",
    "@types/node": "^20.4.1",
    "@types/uuid": "^9.0.2",
    "@typescript-eslint/eslint-plugin": "^6.2.1",
    "@typescript-eslint/parser": "^6.2.1",
    "eslint": "^8.46.0",
    "eslint-config-prettier": "^8.10.0",
    "eslint-plugin-prettier": "^5.0.0",
    "prettier": "^3.0.0",
    "rimraf": "^5.0.1"
  }
}

tsconfig.json
---------------
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["es2020", "dom"],
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": ".",
    "paths": {
      "@config/*": ["./config/*"],
      "@src/*": ["./src/*"],
      "@tests/*": ["./tests/*"],
      "@models/*": ["./src/models/*"],
      "@api/*": ["./src/api/*"],
      "@helpers/*": ["./src/helpers/*"],
      "@utils/*": ["./src/utils/*"]
    },
    "allowJs": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitThis": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true
  },
  "include": ["**/*.ts"],
  "exclude": ["node_modules", "dist", "reports"]
}

cucumber.js
----------------
const common = {
  require: [
    'ts-node/register',
    './src/hooks/hooks.ts',
    './tests/step-definitions/**/*.ts'
  ],
  paths: ['./tests/features/'],
  format: [
    'progress-bar',
    'json:reports/json/cucumber-report.json',
    './src/helpers/reportHelper.ts'
  ],
  formatOptions: { snippetInterface: 'async-await' },
  publishQuiet: true,
  retry: 0
};

module.exports = {
  default: {
    ...common,
    parallel: process.env.PARALLEL === 'true' ? 2 : 0
  },
  rerun: {
    ...common,
    format: ['progress-bar'],
    retry: 1
  }
};

playwright.config.ts
------------------------
import { PlaywrightTestConfig } from '@playwright/test';
import { configHelper } from './config/config';

// Load environment variables
const config: PlaywrightTestConfig = {
  timeout: configHelper.getTimeout(),
  retries: configHelper.getRetryAttempts(),
  use: {
    extraHTTPHeaders: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
    ignoreHTTPSErrors: true,
    trace: 'on-first-retry',
    screenshot: 'only-on-failure'
  },
  reporter: [
    ['html', { outputFolder: 'reports/playwright' }],
    ['json', { outputFile: 'reports/playwright/results.json' }]
  ],
  workers: process.env.CI ? 1 : undefined,
  fullyParallel: false, // Disable parallel execution to prevent race conditions
  forbidOnly: !!process.env.CI,
  outputDir: 'reports/screenshots',
  preserveOutput: 'failures-only',
  reportSlowTests: { max: 5, threshold: 60000 },
  globalTimeout: 5400000 // 90 minutes
};

export default config;

config.ts
---------------
import * as dotenv from 'dotenv';
import * as path from 'path';
import * as fs from 'fs-extra';
import { logger } from '../src/helpers/loggerHelper';

export class ConfigHelper {
  private static instance: ConfigHelper;
  private config: Record<string, string> = {};
  
  private constructor() {
    this.initializeConfig();
  }

  private initializeConfig(): void {
    try {
      // Load environment variables based on NODE_ENV
      const env = process.env.NODE_ENV || 'sit';
      const envPath = path.join(__dirname, `environments/.env.${env}`);
      
      if (fs.existsSync(envPath)) {
        const result = dotenv.config({ path: envPath });
        if (result.error) {
          throw new Error(`Error loading environment variables: ${result.error.message}`);
        }
        this.config = { ...process.env } as Record<string, string>;
        logger.info(`Environment loaded: ${env} from ${envPath}`);
      } else {
        throw new Error(`Environment file not found: ${envPath}`);
      }
    } catch (error) {
      logger.error(`Config initialization error: ${error}`);
      throw error;
    }
  }

  public static getInstance(): ConfigHelper {
    if (!ConfigHelper.instance) {
      ConfigHelper.instance = new ConfigHelper();
    }
    return ConfigHelper.instance;
  }

  public get(key: string): string {
    const value = this.config[key];
    if (value === undefined) {
      logger.warn(`Configuration key not found: ${key}`);
      return '';
    }
    return value;
  }

  public getBaseUrl(): string {
    return this.get('API_BASE_URL');
  }

  public getCertPath(): string {
    return this.get('CERT_PATH');
  }

  public getCertPassphrase(): string {
    return this.get('CERT_PASSPHRASE');
  }

  public getEnvironment(): string {
    return this.get('NODE_ENV') || 'sit';
  }
  
  public isDebugMode(): boolean {
    return this.get('DEBUG') === 'true';
  }

  public getTimeout(): number {
    const timeout = parseInt(this.get('TIMEOUT'), 10);
    return isNaN(timeout) ? 30000 : timeout;
  }

  public getRetryAttempts(): number {
    const retries = parseInt(this.get('RETRY_ATTEMPTS'), 10);
    return isNaN(retries) ? 2 : retries;
  }

  public getRequestTimeout(): number {
    const timeout = parseInt(this.get('REQUEST_TIMEOUT'), 10);
    return isNaN(timeout) ? 30000 : timeout;
  }

  public getMaxConcurrentRequests(): number {
    const maxRequests = parseInt(this.get('MAX_CONCURRENT_REQUESTS'), 10);
    return isNaN(maxRequests) ? 1 : maxRequests; // Default to 1 for sequential execution
  }

  public shouldTakeScreenshotOnFailure(): boolean {
    return this.get('SCREENSHOT_ON_FAILURE') !== 'false';
  }

  public getProxyUrl(): string | undefined {
    const proxyUrl = this.get('PROXY_URL');
    return proxyUrl === '' ? undefined : proxyUrl;
  }
}

export const configHelper = ConfigHelper.getInstance();

.env.sit
----------------------
API_BASE_URL=https://katapi-sit.k8s.americas.ishare.net
CERT_PATH=./certs/certificates/kpfxPROD.pfx
CERT_PASSPHRASE=khan#123!
DEBUG=false
TIMEOUT=30000
RETRY_ATTEMPTS=2
REQUEST_TIMEOUT=30000
MAX_CONCURRENT_REQUESTS=1
SCREENSHOT_ON_FAILURE=true
PROXY_URL=
REQUEST_RETRY_COUNT=3
REQUEST_RETRY_DELAY=1000
DETAILED_LOGGING=true

loggerHelper.ts
-------------------

import winston from 'winston';
import 'winston-daily-rotate-file';
import * as path from 'path';
import * as fs from 'fs-extra';
import { configHelper } from '../../config/config';
import chalk from 'chalk';

// Create logs directory
const logsDir = path.join(process.cwd(), 'reports', 'logs');
fs.ensureDirSync(logsDir);

// Custom log format with colors and detailed information
const customFormat = winston.format.printf(({ level, message, timestamp, ...metadata }) => {
  const metaStr = Object.keys(metadata).length ? 
    `\n${JSON.stringify(metadata, null, 2)}` : '';
  
  let colorizedLevel;
  switch (level) {
    case 'error':
      colorizedLevel = chalk.red.bold(level.toUpperCase());
      break;
    case 'warn':
      colorizedLevel = chalk.yellow.bold(level.toUpperCase());
      break;
    case 'info':
      colorizedLevel = chalk.green.bold(level.toUpperCase());
      break;
    case 'debug':
      colorizedLevel = chalk.blue.bold(level.toUpperCase());
      break;
    default:
      colorizedLevel = chalk.white.bold(level.toUpperCase());
  }
  
  return `${timestamp} [${colorizedLevel}]: ${message}${metaStr}`;
});

// Create daily rotating file transports
const fileRotateTransport = new winston.transports.DailyRotateFile({
  filename: path.join(logsDir, 'application-%DATE%.log'),
  datePattern: 'YYYY-MM-DD',
  maxSize: '20m',
  maxFiles: '14d',
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
    winston.format.json()
  )
});

const errorFileRotateTransport = new winston.transports.DailyRotateFile({
  filename: path.join(logsDir, 'error-%DATE%.log'),
  datePattern: 'YYYY-MM-DD',
  maxSize: '20m',
  maxFiles: '14d',
  level: 'error',
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
    winston.format.json()
  )
});

// Create the logger instance
export const logger = winston.createLogger({
  level: configHelper.isDebugMode() ? 'debug' : 'info',
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
    winston.format.metadata({ fillExcept: ['message', 'level', 'timestamp'] }),
    winston.format.json()
  ),
  defaultMeta: { service: 'api-automation' },
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
        winston.format.metadata({ fillExcept: ['message', 'level', 'timestamp'] }),
        customFormat
      )
    }),
    fileRotateTransport,
    errorFileRotateTransport
  ]
});

// Function to log HTTP requests and responses in detailed mode
export const logHttpDetails = (
  method: string,
  url: string,
  requestHeaders?: Record<string, string>,
  requestData?: any,
  responseStatus?: number,
  responseHeaders?: Record<string, string>,
  responseData?: any,
  error?: any
) => {
  if (!configHelper.get('DETAILED_LOGGING')) {
    return;
  }

  const logObj: any = {
    request: {
      method,
      url
    }
  };

  if (requestHeaders) {
    logObj.request.headers = { ...requestHeaders };
    // Mask sensitive headers
    if (logObj.request.headers.Authorization) {
      logObj.request.headers.Authorization = '[REDACTED]';
    }
  }

  if (requestData) {
    logObj.request.data = requestData;
  }

  if (responseStatus !== undefined) {
    logObj.response = {
      status: responseStatus
    };

    if (responseHeaders) {
      logObj.response.headers = responseHeaders;
    }

    if (responseData) {
      logObj.response.data = responseData;
    }
  }

  if (error) {
    logObj.error = error.message || error;
    logger.error(`HTTP Request Failed: ${method} ${url}`, logObj);
  } else {
    logger.debug(`HTTP Transaction: ${method} ${url}`, logObj);
  }
};

timeoutUtils.ts
----------------------

import { logger } from '../helpers/loggerHelper';

export class TimeoutUtils {
  /**
   * Executes a function with a timeout
   * @param fn Function to execute
   * @param timeoutMs Timeout in milliseconds
   * @param errorMessage Error message if timeout occurs
   * @returns Promise resolving to the function result
   */
  public static async withTimeout<T>(
    fn: () => Promise<T>,
    timeoutMs: number,
    errorMessage: string
  ): Promise<T> {
    return new Promise<T>(async (resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error(`Timeout after ${timeoutMs}ms: ${errorMessage}`));
      }, timeoutMs);

      try {
        const result = await fn();
        clearTimeout(timeoutId);
        resolve(result);
      } catch (error) {
        clearTimeout(timeoutId);
        reject(error);
      }
    });
  }

  /**
   * Sleep function with proper cancellation handling
   * @param ms Milliseconds to sleep
   * @returns Promise that resolves after the specified time
   */
  public static sleep(ms: number): Promise<void> {
    logger.debug(`Sleeping for ${ms} milliseconds`);
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

retryHelper.ts
-------------------

import { TimeoutUtils } from '../utils/timeoutUtils';
import { logger } from './loggerHelper';

export class RetryHelper {
  /**
   * Retries a function with exponential backoff
   * @param fn Function to retry
   * @param maxRetries Maximum number of retries
   * @param initialDelayMs Initial delay in milliseconds
   * @param maxDelayMs Maximum delay in milliseconds
   * @param shouldRetry Function to determine if retry should be attempted
   * @returns Promise resolving to the function result
   */
  public static async withRetry<T>(
    fn: () => Promise<T>,
    maxRetries: number = 3,
    initialDelayMs: number = 1000,
    maxDelayMs: number = 10000,
    shouldRetry: (error: any) => boolean = () => true
  ): Promise<T> {
    let retries = 0;
    let delay = initialDelayMs;
    
    while (true) {
      try {
        return await fn();
      } catch (error) {
        retries++;
        
        if (retries > maxRetries || !shouldRetry(error)) {
          logger.error(`Retry failed after ${retries} attempts: ${error}`);
          throw error;
        }
        
        // Calculate delay with exponential backoff
        delay = Math.min(delay * 2, maxDelayMs);
        
        logger.warn(`Retry attempt ${retries}/${maxRetries} after ${delay}ms: ${error}`);
        await TimeoutUtils.sleep(delay);
      }
    }
  }
}

Certificatehelper.ts
--------------------------
import * as fs from 'fs-extra';
import * as path from 'path';
import { configHelper } from '../../config/config';
import { logger } from './loggerHelper';
import { RetryHelper } from './retryHelper';

export class CertificateHelper {
  private static instance: CertificateHelper;
  private certificateCache: Map<string, Buffer> = new Map();

  private constructor() {}

  public static getInstance(): CertificateHelper {
    if (!CertificateHelper.instance) {
      CertificateHelper.instance = new CertificateHelper();
    }
    return CertificateHelper.instance;
  }

  /**
   * Get certificate options for API client
   * @returns Certificate options object
   */
  public async getCertificateOptions(): Promise<any> {
    try {
      const certPath = path.resolve(configHelper.getCertPath());
      const passphrase = configHelper.getCertPassphrase();
      
      if (!fs.existsSync(certPath)) {
        logger.warn(`Certificate file not found at: ${certPath}`);
        return {};
      }

      logger.debug(`Using certificate at: ${certPath}`);
      
      // Try to get from cache first
      let pfxBuffer = this.certificateCache.get(certPath);
      
      if (!pfxBuffer) {
        // Read the certificate with retry for file system issues
        pfxBuffer = await RetryHelper.withRetry(
          async () => fs.readFile(certPath),
          3,
          1000,
          5000
        );
        
        // Cache the certificate
        this.certificateCache.set(certPath, pfxBuffer);
      }
      
      return {
        httpsOptions: {
          pfx: pfxBuffer,
          passphrase
        }
      };
    } catch (error) {
      logger.error(`Error loading certificate: ${error}`);
      throw error;
    }
  }

  /**
   * Clear the certificate cache
   */
  public clearCache(): void {
    this.certificateCache.clear();
    logger.debug('Certificate cache cleared');
  }
}

export const certificateHelper = CertificateHelper.getInstance();

apiClient.ts
---------------

import { request, APIRequestContext, APIResponse } from '@playwright/test';
import { configHelper } from '../../config/config';
import { logger, logHttpDetails } from '../helpers/loggerHelper';
import { certificateHelper } from '../helpers/certificateHelper';
import { RetryHelper } from '../helpers/retryHelper';
import { TimeoutUtils } from '../utils/timeoutUtils';
import { ProxyAgent } from 'https-proxy-agent';

export interface RequestOptions {
  headers?: Record<string, string>;
  timeout?: number;
  retries?: number;
  retryDelay?: number;
  retryCondition?: (response: APIResponse) => boolean;
}

export class ApiClient {
  private static instance: ApiClient;
  private context: APIRequestContext | null = null;
  private isInitializing: boolean = false;
  private initializePromise: Promise<void> | null = null;

  private constructor() {}

  public static getInstance(): ApiClient {
    if (!ApiClient.instance) {
      ApiClient.instance = new ApiClient();
    }
    return ApiClient.instance;
  }

  /**
   * Initialize the API client
   * @returns Promise resolving when initialization is complete
   */
  public async initialize(): Promise<void> {
    // If already initializing, return the existing promise
    if (this.isInitializing && this.initializePromise) {
      return this.initializePromise;
    }

    // If already initialized, return immediately
    if (this.context) {
      return Promise.resolve();
    }

    this.isInitializing = true;
    this.initializePromise = this.doInitialize();
    
    try {
      await this.initializePromise;
    } finally {
      this.isInitializing = false;
      this.initializePromise = null;
    }
  }

  private async doInitialize(): Promise<void> {
    try {
      const baseURL = configHelper.getBaseUrl();
      const certOptions = await certificateHelper.getCertificateOptions();
      const proxyUrl = configHelper.getProxyUrl();
      
      const requestOptions: any = {
        baseURL,
        extraHTTPHeaders: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        ignoreHTTPSErrors: true,
        timeout: configHelper.getTimeout(),
        ...certOptions
      };
      
      // Add proxy if configured
      if (proxyUrl) {
        requestOptions.proxy = {
          server: proxyUrl
        };
      }
      
      this.context = await request.newContext(requestOptions);
      
      logger.info(`API Client initialized with base URL: ${baseURL}`);
    } catch (error) {
      logger.error(`Failed to initialize API client: ${error}`);
      this.context = null;
      throw error;
    }
  }

  private async ensureContext(): Promise<APIRequestContext> {
    if (!this.context) {
      await this.initialize();
    }
    return this.context!;
  }

  /**
   * Perform a GET request
   * @param url The URL to request
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async get(url: string, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('GET', url, undefined, options);
  }

  /**
   * Perform a POST request
   * @param url The URL to request
   * @param data The data to send
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async post(url: string, data: any, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('POST', url, data, options);
  }

  /**
   * Perform a PUT request
   * @param url The URL to request
   * @param data The data to send
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async put(url: string, data: any, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('PUT', url, data, options);
  }

  /**
   * Perform a DELETE request
   * @param url The URL to request
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async delete(url: string, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('DELETE', url, undefined, options);
  }

  /**
   * Perform a PATCH request
   * @param url The URL to request
   * @param data The data to send
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async patch(url: string, data: any, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('PATCH', url, data, options);
  }

  /**
   * Execute a request with retries and timeouts
   * @param method The HTTP method
   * @param url The URL to request
   * @param data The data to send (for POST, PUT, PATCH)
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  private async executeRequest(
    method: string,
    url: string,
    data?: any,
    options: RequestOptions = {}
  ): Promise<APIResponse> {
    const headers = options.headers || {};
    const timeout = options.timeout || configHelper.getRequestTimeout();
    const retries = options.retries || parseInt(configHelper.get('REQUEST_RETRY_COUNT'), 10) || 3;
    const retryDelay = options.retryDelay || parseInt(configHelper.get('REQUEST_RETRY_DELAY'), 10) || 1000;
    
    // Log request details
    logHttpDetails(method, url, headers, data);
    
    return RetryHelper.withRetry(
      async () => {
        const context = await this.ensureContext();
        
        // Execute request with timeout
        const response = await TimeoutUtils.withTimeout(
          async () => {
            let requestConfig: any = { headers };
            
            switch (method.toUpperCase()) {
              case 'GET':
                return await context.get(url, requestConfig);
              case 'POST':
                return await context.post(url, { ...requestConfig, data });
              case 'PUT':
                return await context.put(url, { ...requestConfig, data });
              case 'DELETE':
                return await context.delete(url, requestConfig);
              case 'PATCH':
                return await context.patch(url, { ...requestConfig, data });
              default:
                throw new Error(`Unsupported HTTP method: ${method}`);
            }
          },
          timeout,
          `Request ${method} ${url} timed out after ${timeout}ms`
        );
        
        // Log response details
        logHttpDetails(
          method,
          url,
          headers,
          data,
          response.status(),
          response.headers(),
          await response.json().catch(() => null)
        );
        
        // Check if retry is needed based on status code
        const shouldRetryStatus = options.retryCondition ? 
          options.retryCondition(response) : 
          response.status() >= 500;
        
        if (shouldRetryStatus) {
          throw new Error(`Request failed with status: ${response.status()}`);
        }
        
        return response;
      },
      retries,
      retryDelay,
      (error) => {
        // Retry on network errors and server errors (indicated by the custom error above)
        logger.warn(`Request ${method} ${url} failed, will retry: ${error.message}`);
        return true;
      }
    );
  }

  /**
   * Dispose the API client
   */
  public async dispose(): Promise<void> {
    if (this.context) {
      await this.context.dispose();
      this.context = null;
      logger.info('API Client disposed');
    }
  }
}

export default ApiClient.getInstance();

apiexecutor.ts
-----------------
import { logger } from '../helpers/loggerHelper';
import { TimeoutUtils } from '../utils/timeoutUtils';
import { configHelper } from '../../config/config';
import { v4 as uuidv4 } from 'uuid';
import * as pLimit from 'p-limit';

/**
 * API execution queue item
 */
interface QueueItem<T> {
  id: string;
  name: string;
  execute: () => Promise<T>;
  timestamp: number;
}

/**
 * API Executor for sequential API execution
 * This ensures that requests are executed in order without race conditions
 */
export class ApiExecutor {
  private static instance: ApiExecutor;
  private queue: QueueItem<any>[] = [];
  private processing: boolean = false;
  private limit: pLimit.Limit;

  private constructor() {
    // Initialize concurrency limiter
    const maxConcurrency = configHelper.getMaxConcurrentRequests();
    this.limit = pLimit.default(maxConcurrency);
    logger.info(`API Executor initialized with max concurrency: ${maxConcurrency}`);
  }

  public static getInstance(): ApiExecutor {
    if (!ApiExecutor.instance) {
      ApiExecutor.instance = new ApiExecutor();
    }
    return ApiExecutor.instance;
  }

  /**
   * Add a function to the execution queue with sequential execution
   * @param name Name for logging
   * @param fn Function to execute
   * @returns Promise resolving to the function result
   */
  public async execute<T>(name: string, fn: () => Promise<T>): Promise<T> {
    const taskId = uuidv4();
    logger.debug(`Queuing task: ${name} (${taskId})`);
    
    // Create queue item
    const queueItem: QueueItem<T> = {
      id: taskId,
      name,
      execute: fn,
      timestamp: Date.now()
    };
    
    // Add to queue
    this.queue.push(queueItem);
    
    // Start processing if not already processing
    if (!this.processing) {
      this.processQueue();
    }
    
    // Return a promise that resolves when the task is executed
    return new Promise<T>((resolve, reject) => {
      const checkQueue = async () => {
        // If our item is no longer in the queue, it's completed
        const itemIndex = this.queue.findIndex(item => item.id === taskId);
        if (itemIndex === -1) {
          try {
            // Execute the function
            const result = await this.limit(() => fn());
            resolve(result);
          } catch (error) {
            reject(error);
          }
          return;
        }
        
        // If still in queue, check again after a delay
        setTimeout(checkQueue, 100);
      };
      
      checkQueue();
    });
  }

  /**
   * Process items in the queue sequentially
   */
  private async processQueue(): Promise<void> {
    if (this.processing || this.queue.length === 0) {
      return;
    }
    
    this.processing = true;
    
    try {
      // Process all items in the queue
      while (this.queue.length > 0) {
        const item = this.queue.shift()!;
        logger.debug(`Processing task: ${item.name} (${item.id})`);
        
        try {
          await item.execute();
          logger.debug(`Completed task: ${item.name} (${item.id})`);
        } catch (error) {
          logger.error(`Error executing task ${item.name} (${item.id}): ${error}`);
        }
      }
    } finally {
      this.processing = false;
    }
  }

  /**
   * Clear the execution queue
   */
  public clearQueue(): void {
    this.queue = [];
    logger.info('API Executor queue cleared');
  }
}

export const apiExecutor = ApiExecutor.getInstance();

endpoints.ts
---------------

export const Endpoints = {
  ASSET_LAYOUT: '/v1/assets/assetlayout',
  // Add more endpoints as needed
};

apimodels.ts
---------------------

// API Request/Response Models

// Asset Layout Models
export interface AssetLayoutRequest {
  messageId: number;
  dealId: number;
  reportDate: string;
}

export interface AssetLayout {
  dealId: number;
  entityId: number;
  // Add other fields as needed
  [key: string]: any; // This allows for additional fields
}

export interface AssetLayoutResponse {
  assetLayouts: AssetLayout[];
  systemError: string | null;
  responseMessageId: string;
  validationErrorMessage: string | null;
  errorMessage: string | null;
}

// Generic API Response Model
export interface ApiResponse<T> {
  statusCode: number;
  headers: Record<string, string>;
  data: T;
  ok: boolean;
}

reportmodel.ts
----------------------

// Reporting Models

export interface TestResult {
  id: string;
  feature: string;
  scenario: string;
  status: string;
  duration: number;
  error?: string;
  timestamp: string;
  metadata?: Record<string, any>;
  screenshots?: string[];
}

export interface TestSummary {
  environment: string;
  baseUrl: string;
  startTime: string;
  endTime: string;
  totalDuration: number;
  totalTests: number;
  passedTests: number;
  failedTests: number;
  skippedTests: number;
  pendingTests: number;
}

export interface TestReport {
  summary: TestSummary;
  results: TestResult[];
}

assetLayoutservice.ts
-------------------------

import apiClient from '../apiClient';
import { apiExecutor } from '../apiExecutor';
import { Endpoints } from '../endpoints';
import { AssetLayoutRequest, AssetLayoutResponse } from '../../models/apiModels';
import { logger } from '../../helpers/loggerHelper';
import { ApiResponse } from '../../models/apiModels';
import { configHelper } from '../../../config/config';

export class AssetLayoutService {
  private static instance: AssetLayoutService;

  private constructor() {}

  public static getInstance(): AssetLayoutService {
    if (!AssetLayoutService.instance) {
      AssetLayoutService.instance = new AssetLayoutService();
    }
    return AssetLayoutService.instance;
  }

  /**
   * Get asset layout with guaranteed sequential execution
   * @param request Asset layout request
   * @returns Promise resolving to API response
   */
  public async getAssetLayout(request: AssetLayoutRequest): Promise<ApiResponse<AssetLayoutResponse>> {
    return apiExecutor.execute(
      `GetAssetLayout-${request.dealId}`,
      async () => {
        try {
          logger.info(`Fetching asset layout for dealId: ${request.dealId}`);
          
          const response = await apiClient.post(Endpoints.ASSET_LAYOUT, request, {
            retries: parseInt(configHelper.get('REQUEST_RETRY_COUNT'), 10) || 3,
            retryDelay: parseInt(configHelper.get('REQUEST_RETRY_DELAY'), 10) || 1000
          });
          
          const apiResponse: ApiResponse<AssetLayoutResponse> = {
            statusCode: response.status(),
            headers: response.headers(),
            data: await response.json() as AssetLayoutResponse,
            ok: response.ok()
          };
          
          logger.info(`Asset layout response received with status: ${apiResponse.statusCode}`);
          return apiResponse;
        } catch (error) {
          logger.error(`Error fetching asset layout: ${error}`);
          throw error;
        }
      }
    );
  }
}

export default AssetLayoutService.getInstance();

dataHelper.ts
-------------------

import * as fs from 'fs-extra';
import * as path from 'path';
import { logger } from './loggerHelper';
import { RetryHelper } from './retryHelper';

export class DataHelper {
  private static instance: DataHelper;
  private dataCache: Map<string, any> = new Map();

  private constructor() {}

  public static getInstance(): DataHelper {
    if (!DataHelper.instance) {
      DataHelper.instance = new DataHelper();
    }
    return DataHelper.instance;
  }

  /**
   * Load JSON data from file with caching
   * @param filePath Path to JSON file
   * @param useCache Whether to use cache
   * @returns Parsed JSON data
   */
  public async loadJsonData<T>(filePath: string, useCache: boolean = true): Promise<T> {
    try {
      const absolutePath = path.resolve(filePath);
      logger.debug(`Loading JSON data from: ${absolutePath}, useCache: ${useCache}`);
      
      // Check cache first if enabled
      if (useCache && this.dataCache.has(absolutePath)) {
        logger.debug(`Using cached data for: ${absolutePath}`);
        return this.dataCache.get(absolutePath) as T;
      }
      
      if (!fs.existsSync(absolutePath)) {
        throw new Error(`File not found: ${absolutePath}`);
      }
      
      // Read file with retry for file system issues
      const fileContent = await RetryHelper.withRetry(
        async () => fs.readFile(absolutePath, 'utf8'),
        3,
        1000,
        5000
      );
      
      const parsedData = JSON.parse(fileContent) as T;
      
      // Cache the data if enabled
      if (useCache) {
        this.dataCache.set(absolutePath, parsedData);
      }
      
      return parsedData;
    } catch (error) {
      logger.error(`Error loading JSON data: ${error}`);
      throw error;
    }
  }

  /**
   * Save JSON data to file
   * @param filePath Path to save JSON file
   * @param data Data to save
   * @param updateCache Whether to update cache
   */
  public async saveJsonData<T>(filePath: string, data: T, updateCache: boolean = true): Promise<void> {
    try {
      const absolutePath = path.resolve(filePath);
      logger.debug(`Saving JSON data to: ${absolutePath}`);
      
      const dirPath = path.dirname(absolutePath);
      await fs.ensureDir(dirPath);
      
      // Write file with retry for file system issues
      await RetryHelper.withRetry(
        async () => fs.writeFile(absolutePath, JSON.stringify(data, null, 2), 'utf8'),
        3,
        1000,
        5000
      );
      
      // Update cache if enabled
      if (updateCache) {
        this.dataCache.set(absolutePath, data);
      }
      
      logger.debug('JSON data saved successfully');
    } catch (error) {
      logger.error(`Error saving JSON data: ${error}`);
      throw error;
    }
  }

  /**
   * Get payload from test data
   * @param payloadName Name of payload file
   * @returns Parsed payload data
   */
  public async getPayload<T>(payloadName: string): Promise<T> {
    const payloadPath = path.resolve(`tests/testData/payloads/${payloadName}.json`);
    return this.loadJsonData<T>(payloadPath);
  }

  /**
   * Clear the data cache
   */
  public clearCache(): void {
    this.dataCache.clear();
    logger.debug('Data cache cleared');
  }
}

export default DataHelper.getInstance();

reportHelpers.ts
--------------------
import * as fs from 'fs-extra';
import * as path from 'path';
import * as dayjs from 'dayjs';
import { logger } from './loggerHelper';
import { configHelper } from '../../config/config';
import { TestResult, TestSummary, TestReport } from '../models/reportModels';
import * as handlebars from 'handlebars';
import { v4 as uuidv4 } from 'uuid';

// Register handlebars helpers
handlebars.registerHelper('formatDate', (date: string, format?: string) => {
  if (!date) return '';
  return format ? 
    dayjs(date).format(format) : 
    dayjs(date).format('YYYY-MM-DD HH:mm:ss');
});

handlebars.registerHelper('formatDuration', (ms: number) => {
  if (ms < 1000) return `${ms}ms`;
  const seconds = Math.floor(ms / 1000);
  const remainingMs = ms % 1000;
  return seconds > 0 ? 
    `${seconds}.${remainingMs.toString().padStart(3, '0')}s` : 
    `${ms}ms`;
});

handlebars.registerHelper('passPercentage', (passed: number, total: number) => {
  if (total === 0) return 0;
  return Math.round((passed / total) * 100);
});

export class ReportHelper {
  private static instance: ReportHelper;
  private testResults: TestResult[] = [];
  private startTime: Date | null = null;
  private endTime: Date | null = null;
  private reportDir: string;
  private screenshotDir: string;

  private constructor() {
    this.reportDir = path.join(process.cwd(), 'reports', 'html');
    this.screenshotDir = path.join(process.cwd(), 'reports', 'screenshots');
    fs.ensureDirSync(this.reportDir);
    fs.ensureDirSync(this.screenshotDir);
  }

  public static getInstance(): ReportHelper {
    if (!ReportHelper.instance) {
      ReportHelper.instance = new ReportHelper();
    }
    return ReportHelper.instance;
  }

  /**
   * Start a test run
   */
  public startTestRun(): void {
    this.startTime = new Date();
    this.testResults = [];
    logger.info(`Test run started at ${this.startTime.toISOString()}`);
  }

  /**
   * Add test result to the report
   * @param feature Feature name
   * @param scenario Scenario name
   * @param status Test status
   * @param duration Test duration
   * @param error Error message
   * @param metadata Additional metadata
   * @param screenshots Array of screenshot paths
   */
  public addTestResult(
    feature: string,
    scenario: string,
    status: string,
    duration: number,
    error?: string,
    metadata?: Record<string, any>,
    screenshots?: string[]
  ): void {
    const testResult: TestResult = {
      id: uuidv4(),
      feature,
      scenario,
      status,
      duration,
      error,
      timestamp: new Date().toISOString(),
      metadata,
      screenshots
    };
    
    this.testResults.push(testResult);
    
    logger.info(`Test result added: ${scenario} - ${status} (${duration}ms)`);
  }

  /**
   * End a test run
   */
  public endTestRun(): void {
    this.endTime = new Date();
    logger.info(`Test run ended at ${this.endTime.toISOString()}`);
  }

  /**
   * Take a screenshot
   * @param name Screenshot name
   * @param content Screenshot content (base64 encoded)
   * @returns Path to saved screenshot
   */
  public async takeScreenshot(name: string, content: string): Promise<string> {
    try {
      const timestamp = dayjs().format('YYYYMMDD_HHmmss');
      const sanitizedName = name.replace(/[^a-zA-Z0-9]/g, '_');
      const filename = `${sanitizedName}_${timestamp}.png`;
      const filePath = path.join(this.screenshotDir, filename);
      
      // Convert base64 to buffer
      const data = Buffer.from(content, 'base64');
      
      // Save screenshot
      await fs.writeFile(filePath, data);
      
      logger.debug(`Screenshot saved: ${filePath}`);
      return filePath;
    } catch (error) {
      logger.error(`Error saving screenshot: ${error}`);
      return '';
    }
  }

  /**
   * Generate test report
   * @param customReportName Optional custom report name
   * @returns Path to generated report
   */
  public async generateReport(customReportName?: string): Promise<string> {
    if (!this.startTime || !this.endTime) {
      logger.error('Cannot generate report: Test run not properly started or ended');
      throw new Error('Test run not properly started or ended');
    }

    const timestamp = dayjs().format('YYYYMMDD_HHmmss');
    const reportName = customReportName || `report_${timestamp}`;
    const reportPath = path.join(this.reportDir, `${reportName}.html`);
    const jsonReportPath = path.join(this.reportDir, `${reportName}.json`);

    // Calculate summary
    const totalDuration = this.endTime.getTime() - this.startTime.getTime();
    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(test => test.status === 'passed').length;
    const failedTests = this.testResults.filter(test => test.status === 'failed').length;
    const skippedTests = this.testResults.filter(test => test.status === 'skipped').length;
    const pendingTests = this.testResults.filter(test => test.status === 'pending').length;

    const environment = configHelper.getEnvironment();
    const baseUrl = configHelper.getBaseUrl();

    // Create summary
    const summary: TestSummary = {
      environment,
      baseUrl,
      startTime: this.startTime.toISOString(),
      endTime: this.endTime.toISOString(),
      totalDuration,
      totalTests,
      passedTests,
      failedTests,
      skippedTests,
      pendingTests
    };

    // Create report data
    const reportData: TestReport = {
      summary,
      results: this.testResults
    };

    // Generate HTML report from template
    const templatePath = path.join(__dirname, '../templates/report-template.hbs');
    let template: string;
    
    try {
      template = await fs.readFile(templatePath, 'utf8');
    } catch (error) {
      // If template is not found, use embedded template
      template = this.getEmbeddedTemplate();
    }

    // Compile and apply template
    const compiledTemplate = handlebars.compile(template);
    const html = compiledTemplate(reportData);

    // Write HTML report
    await fs.writeFile(reportPath, html, 'utf8');
    logger.info(`HTML report generated: ${reportPath}`);

    // Write JSON report
    await fs.writeFile(jsonReportPath, JSON.stringify(reportData, null, 2), 'utf8');
    logger.info(`JSON report generated: ${jsonReportPath}`);

    return reportPath;
  }

  /**
   * Get embedded HTML template as fallback
   * @returns HTML template string
   */
  private getEmbeddedTemplate(): string {
    return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>API Test Report</title>
      <style>
        body {
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          margin: 0;
          padding: 0;
          background-color: #f5f7fa;
          color: #333;
          line-height: 1.6;
        }
        .container {
          max-width: 1200px;
          margin: 0 auto;
          padding: 20px;
        }
        .report-header {
          background-color: #fff;
          padding: 30px;
          border-radius: 8px;
          margin-bottom: 30px;
          box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        .report-title {
          margin: 0;
          color: #2c3e50;
          font-size: 28px;
          border-bottom: 2px solid #eaeaea;
          padding-bottom: 15px;
          margin-bottom: 20px;
        }
        .report-info {
          display: flex;
          flex-wrap: wrap;
          gap: 20px;
        }
        .info-item {
          flex: 1 1 200px;
        }
        .info-label {
          font-weight: 600;
          color: #7f8c8d;
          font-size: 14px;
          margin-bottom: 5px;
        }
        .info-value {
          font-size: 16px;
        }
        .report-summary {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
          gap: 20px;
          margin-bottom: 30px;
        }
        .summary-item {
          background-color: #fff;
          padding: 20px;
          border-radius: 8px;
          box-shadow: 0 4px 6px rgba(0,0,0,0.05);
          text-align: center;
        }
        .summary-item.total { border-top: 4px solid #3498db; }
        .summary-item.passed { border-top: 4px solid #2ecc71; }
        .summary-item.failed { border-top: 4px solid #e74c3c; }
        .summary-item.skipped { border-top: 4px solid #f39c12; }
        .summary-item.pending { border-top: 4px solid #9b59b6; }
        .summary-title {
          font-size: 14px;
          font-weight: 600;
          color: #7f8c8d;
          margin: 0 0 10px 0;
        }
        .summary-value {
          font-size: 36px;
          font-weight: 700;
          margin: 0;
        }
        .summary-value.passed { color: #2ecc71; }
        .summary-value.failed { color: #e74c3c; }
        .summary-value.skipped { color: #f39c12; }
        .summary-value.pending { color: #9b59b6; }
        .progress-container {
          height: 10px;
          background-color: #ecf0f1;
          border-radius: 5px;
          overflow: hidden;
          margin: 20px 0;
        }
        .progress-bar {
          height: 100%;
          background-color: #2ecc71;
          border-radius: 5px;
        }
        .test-results {
          background-color: #fff;
          border-radius: 8px;
          box-shadow: 0 4px 6px rgba(0,0,0,0.05);
          overflow: hidden;
        }
        .section-title {
          padding: 20px;
          margin: 0;
          background-color: #f8f9fa;
          border-bottom: 1px solid #eaeaea;
          font-size: 20px;
          color: #2c3e50;
        }
        .results-table {
          width: 100%;
          border-collapse: collapse;
        }
        .results-table th,
        .results-table td {
          padding: 15px;
          text-align: left;
          border-bottom: 1px solid #eaeaea;
        }
        .results-table th {
          background-color: #f8f9fa;
          font-weight: 600;
          color: #7f8c8d;
        }
        .results-table tr:hover {
          background-color: #f9f9f9;
        }
        .results-table tr:last-child td {
          border-bottom: none;
        }
        .status-pill {
          display: inline-block;
          padding: 5px 12px;
          border-radius: 20px;
          font-weight: 600;
          font-size: 12px;
          text-transform: uppercase;
        }
        .status-pill.passed { background-color: #e8f8f0; color: #2ecc71; }
        .status-pill.failed { background-color: #fdedeb; color: #e74c3c; }
        .status-pill.skipped { background-color: #fef5e8; color: #f39c12; }
        .status-pill.pending { background-color: #f4ecf7; color: #9b59b6; }
        .error-details {
          padding: 15px;
          background-color: #fdedeb;
          color: #c0392b;
          border-radius: 5px;
          margin-top: 10px;
          font-family: monospace;
          white-space: pre-wrap;
          display: none;
        }
        .toggle-error {
          cursor: pointer;
          color: #3498db;
          text-decoration: underline;
          display: inline-block;
          margin-top: 10px;
          font-size: 14px;
        }
        .duration {
          font-family: monospace;
          color: #7f8c8d;
        }
        .screenshot-link {
          display: inline-block;
          padding: 5px 10px;
          background-color: #3498db;
          color: white;
          border-radius: 4px;
          text-decoration: none;
          margin-top: 10px;
          font-size: 12px;
        }
        .screenshot-link:hover {
          background-color: #2980b9;
        }
        .footer {
          text-align: center;
          margin-top: 40px;
          padding: 20px;
          color: #7f8c8d;
          font-size: 14px;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="report-header">
          <h1 class="report-title">API Test Automation Report</h1>
          <div class="report-info">
            <div class="info-item">
              <div class="info-label">Environment</div>
              <div class="info-value">{{summary.environment}}</div>
            </div>
            <div class="info-item">
              <div class="info-label">Base URL</div>
              <div class="info-value">{{summary.baseUrl}}</div>
            </div>
            <div class="info-item">
              <div class="info-label">Start Time</div>
              <div class="info-value">{{formatDate summary.startTime}}</div>
            </div>
            <div class="info-item">
              <div class="info-label">End Time</div>
              <div class="info-value">{{formatDate summary.endTime}}</div>
            </div>
            <div class="info-item">
              <div class="info-label">Duration</div>
              <div class="info-value">{{formatDuration summary.totalDuration}}</div>
            </div>
          </div>
        </div>
        
        <div class="report-summary">
          <div class="summary-item total">
            <div class="summary-title">TOTAL TESTS</div>
            <div class="summary-value">{{summary.totalTests}}</div>
          </div>
          <div class="summary-item passed">
            <div class="summary-title">PASSED</div>
            <div class="summary-value passed">{{summary.passedTests}}</div>
          </div>
          <div class="summary-item failed">
            <div class="summary-title">FAILED</div>
            <div class="summary-value failed">{{summary.failedTests}}</div>
          </div>
          <div class="summary-item skipped">
            <div class="summary-title">SKIPPED</div>
            <div class="summary-value skipped">{{summary.skippedTests}}</div>
          </div>
          {{#if summary.pendingTests}}
          <div class="summary-item pending">
            <div class="summary-title">PENDING</div>
            <div class="summary-value pending">{{summary.pendingTests}}</div>
          </div>
          {{/if}}
        </div>
        
        <div class="progress-container">
          <div class="progress-bar" style="width: {{passPercentage summary.passedTests summary.totalTests}}%"></div>
        </div>
        
        <div class="test-results">
          <h2 class="section-title">Test Results</h2>
          <table class="results-table">
            <thead>
              <tr>
                <th>Feature</th>
                <th>Scenario</th>
                <th>Status</th>
                <th>Duration</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {{#each results}}
              <tr>
                <td>{{this.feature}}</td>
                <td>{{this.scenario}}</td>
                <td><span class="status-pill {{this.status}}">{{this.status}}</span></td>
                <td><span class="duration">{{formatDuration this.duration}}</span></td>
                <td>
                  {{#if this.error}}
                  <span class="toggle-error" onclick="toggleError('{{this.id}}')">Show/Hide Error</span>
                  <div id="error-{{this.id}}" class="error-details">{{this.error}}</div>
                  {{/if}}
                  
                  {{#if this.screenshots}}
                  <div>
                    {{#each this.screenshots}}
                    <a href="{{this}}" target="_blank" class="screenshot-link">Screenshot {{@index}}</a>
                    {{/each}}
                  </div>
                  {{/if}}
                </td>
              </tr>
              {{/each}}
            </tbody>
          </table>
        </div>
        
        <div class="footer">
          <p>Generated on {{formatDate summary.endTime 'full'}} by Enhanced Playwright API Automation Framework</p>
        </div>
      </div>
      
      <script>
        function toggleError(id) {
          const element = document.getElementById('error-' + id);
          if (element.style.display === 'block') {
            element.style.display = 'none';
          } else {
            element.style.display = 'block';
          }
        }
      </script>
    </body>
    </html>
    `;
  }
}

export default ReportHelper.getInstance();

assertionUtils.ts
-------------------------

import { expect } from 'chai';
import { logger } from '../helpers/loggerHelper';
import { ApiResponse } from '../models/apiModels';

export class AssertionUtils {
  private static instance: AssertionUtils;

  private constructor() {}

  public static getInstance(): AssertionUtils {
    if (!AssertionUtils.instance) {
      AssertionUtils.instance = new AssertionUtils();
    }
    return AssertionUtils.instance;
  }

  /**
   * Assert response status code
   * @param response API response
   * @param expectedStatus Expected status code
   */
  public assertStatusCode(response: ApiResponse<any>, expectedStatus: number): void {
    logger.debug(`Asserting status code: ${response.statusCode} === ${expectedStatus}`);
    expect(response.statusCode, `Expected status code ${expectedStatus}, but got ${response.statusCode}`).to.equal(expectedStatus);
  }

  /**
   * Assert response contains a specific field
   * @param response API response
   * @param field Field to check
   */
  public assertFieldExists(response: ApiResponse<any>, field: string): void {
    logger.debug(`Asserting field exists: ${field}`);
    expect(response.data, `Response data is undefined or null`).to.not.be.undefined;
    expect(response.data).to.have.property(field);
  }

  /**
   * Assert field equals value
   * @param response API response
   * @param field Field to check
   * @param value Expected value
   */
  public assertFieldEquals(response: ApiResponse<any>, field: string, value: any): void {
    this.assertFieldExists(response, field);
    logger.debug(`Asserting field equals: ${field} === ${value}`);
    expect(response.data[field], `Field ${field} expected to be ${value}, but got ${response.data[field]}`).to.deep.equal(value);
  }

  /**
   * Assert array field contains items
   * @param response API response
   * @param field Array field
   * @param minLength Minimum expected length
   */
  public assertArrayHasItems(response: ApiResponse<any>, field: string, minLength: number = 1): void {
    this.assertFieldExists(response, field);
    logger.debug(`Asserting array has items: ${field} (min: ${minLength})`);
    expect(response.data[field], `Field ${field} expected to be an array`).to.be.an('array');
    expect(response.data[field].length, `Field ${field} expected to have at least ${minLength} item(s), but has ${response.data[field].length}`).to.be.at.least(minLength);
  }

  /**
   * Assert response does not contain error
   * @param response API response
   */
  public assertNoError(response: ApiResponse<any>): void {
    logger.debug(`Asserting no error in response`);
    
    // First check if response is OK
    expect(response.ok, `Response status should be OK, but got ${response.statusCode}`).to.be.true;
    
    // Check common error fields
    const errorFields = ['error', 'errorMessage', 'systemError', 'validationErrorMessage'];
    
    for (const field of errorFields) {
      if (response.data && response.data[field] !== undefined) {
        expect(response.data[field], `Error field '${field}' should be null/empty, but got: ${response.data[field]}`).to.be.oneOf([null, '']);
      }
    }
  }

  /**
   * Assert response contains error
   * @param response API response
   * @param errorField Error field to check
   */
  public assertHasError(response: ApiResponse<any>, errorField: string = 'errorMessage'): void {
    logger.debug(`Asserting error in response`);
    this.assertFieldExists(response, errorField);
    expect(response.data[errorField], `Error field '${errorField}' should not be null/empty`).to.not.be.oneOf([null, '']);
  }

  /**
   * Assert response schema matches expected
   * @param response API response
   * @param schema Schema to validate against
   */
  public assertSchema(response: ApiResponse<any>, schema: any): void {
    logger.debug(`Asserting schema validation`);
    
    // Note: This is a simplified schema validation.
    // In a real implementation, you might use a library like Ajv
    for (const [key, type] of Object.entries(schema)) {
      expect(response.data).to.have.property(key);
      expect(typeof response.data[key]).to.equal(type);
    }
  }

  /**
   * Assert response time is within expected limits
   * @param actualTime Actual response time in milliseconds
   * @param maxTime Maximum allowed time in milliseconds
   */
  public assertResponseTime(actualTime: number, maxTime: number): void {
    logger.debug(`Asserting response time: ${actualTime}ms <= ${maxTime}ms`);
    expect(actualTime, `Response time ${actualTime}ms exceeds maximum allowed time ${maxTime}ms`).to.be.at.most(maxTime);
  }

  /**
   * Assert response headers contain expected value
   * @param response API response
   * @param headerName Header name
   * @param expectedValue Expected header value
   */
  public assertHeader(response: ApiResponse<any>, headerName: string, expectedValue?: string): void {
    logger.debug(`Asserting header: ${headerName}`);
    expect(response.headers, `Response headers are undefined`).to.not.be.undefined;
    
    if (expectedValue) {
      expect(response.headers[headerName.toLowerCase()], `Header ${headerName} expected to be ${expectedValue}, but got ${response.headers[headerName.toLowerCase()]}`).to.equal(expectedValue);
    } else {
      expect(response.headers).to.have.property(headerName.toLowerCase());
    }
  }

  /**
   * Assert response body matches expected object
   * @param response API response
   * @param expectedBody Expected response body
   * @param partial Whether to do a partial match
   */
  public assertBody(response: ApiResponse<any>, expectedBody: any, partial: boolean = false): void {
    logger.debug(`Asserting response body`);
    
    if (partial) {
      // For partial match, check if expected properties exist with same values
      for (const [key, value] of Object.entries(expectedBody)) {
        this.assertFieldEquals(response, key, value);
      }
    } else {
      // For exact match, use deep equal
      expect(response.data, `Response body does not match expected`).to.deep.equal(expectedBody);
    }
  }

  /**
   * Assert value is one of expected values
   * @param value Value to check
   * @param expectedValues Array of expected values
   * @param message Custom error message
   */
  public assertOneOf(value: any, expectedValues: any[], message?: string): void {
    logger.debug(`Asserting value is one of: ${JSON.stringify(expectedValues)}`);
    const errorMsg = message || `Value ${value} is not one of expected values: ${JSON.stringify(expectedValues)}`;
    expect(value, errorMsg).to.be.oneOf(expectedValues);
  }

  /**
   * Assert value exists and is not empty
   * @param value Value to check
   * @param message Custom error message
   */
  public assertNotEmpty(value: any, message?: string): void {
    logger.debug(`Asserting value is not empty`);
    const errorMsg = message || `Value is empty or undefined`;
    
    expect(value, errorMsg).to.not.be.undefined;
    expect(value, errorMsg).to.not.be.null;
    
    if (typeof value === 'string') {
      expect(value.trim(), errorMsg).to.not.equal('');
    } else if (Array.isArray(value)) {
      expect(value.length, errorMsg).to.be.greaterThan(0);
    } else if (typeof value === 'object') {
      expect(Object.keys(value).length, errorMsg).to.be.greaterThan(0);
    }
  }
}

export default AssertionUtils.getInstance();

commonUtils.ts
---------------

import { logger } from '../helpers/loggerHelper';
import { v4 as uuidv4 } from 'uuid';
import * as dayjs from 'dayjs';

export class CommonUtils {
  private static instance: CommonUtils;

  private constructor() {}

  public static getInstance(): CommonUtils {
    if (!CommonUtils.instance) {
      CommonUtils.instance = new CommonUtils();
    }
    return CommonUtils.instance;
  }

  /**
   * Sleep for a specified duration
   * @param ms Milliseconds to sleep
   * @returns Promise that resolves after the specified time
   */
  public async sleep(ms: number): Promise<void> {
    logger.debug(`Sleeping for ${ms} milliseconds`);
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Generate a random ID
   * @param prefix Prefix for the ID
   * @param length Length of the random part
   * @returns Random ID string
   */
  public generateRandomId(prefix: string = 'auto', length: number = 6): string {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = prefix;
    
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    
    return result;
  }

  /**
   * Generate a UUID
   * @returns UUID string
   */
  public generateUuid(): string {
    return uuidv4();
  }

  /**
   * Format date according to the specified format
   * @param date Date to format
   * @param format Format string
   * @returns Formatted date string
   */
  public formatDate(date: Date = new Date(), format: string = 'YYYY-MM-DD'): string {
    return dayjs(date).format(format);
  }

  /**
   * Parse date string to Date object
   * @param dateString Date string
   * @param format Format string
   * @returns Date object
   */
  public parseDate(dateString: string, format: string = 'YYYY-MM-DD'): Date {
    return dayjs(dateString, format).toDate();
  }

  /**
   * Deep clone an object
   * @param obj Object to clone
   * @returns Cloned object
   */
  public deepClone<T>(obj: T): T {
    return JSON.parse(JSON.stringify(obj));
  }

  /**
   * Compare two objects for deep equality
   * @param obj1 First object
   * @param obj2 Second object
   * @returns True if objects are equal
   */
  public deepEquals(obj1: any, obj2: any): boolean {
    return JSON.stringify(obj1) === JSON.stringify(obj2);
  }

  /**
   * Sanitize a string for safe usage in filenames
   * @param str String to sanitize
   * @returns Sanitized string
   */
  public sanitizeString(str: string): string {
    return str.replace(/[^a-zA-Z0-9]/g, '_');
  }

  /**
   * Format bytes to human-readable string
   * @param bytes Bytes
   * @param decimals Decimal places
   * @returns Formatted string
   */
  public formatBytes(bytes: number, decimals: number = 2): string {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  }
}

export default CommonUtils.getInstance();

fileUtils.ts
-----------------
import * as fs from 'fs-extra';
import * as path from 'path';
import { logger } from '../helpers/loggerHelper';
import { RetryHelper } from '../helpers/retryHelper';

export class FileUtils {
  private static instance: FileUtils;

  private constructor() {}

  public static getInstance(): FileUtils {
    if (!FileUtils.instance) {
      FileUtils.instance = new FileUtils();
    }
    return FileUtils.instance;
  }

  /**
   * Read file with retry mechanism
   * @param filePath Path to file
   * @param encoding File encoding
   * @returns File content
   */
  public async readFile(filePath: string, encoding: BufferEncoding = 'utf8'): Promise<string> {
    try {
      const absolutePath = path.resolve(filePath);
      logger.debug(`Reading file: ${absolutePath}`);
      
      if (!fs.existsSync(absolutePath)) {
        throw new Error(`File not found: ${absolutePath}`);
      }
      
      return RetryHelper.withRetry(
        async () => fs.readFile(absolutePath, encoding),
        3,
        1000,
        5000
      );
    } catch (error) {
      logger.error(`Error reading file: ${error}`);
      throw error;
    }
  }

  /**
   * Write file with retry mechanism
   * @param filePath Path to file
   * @param data Data to write
   * @param encoding File encoding
   */
  public async writeFile(filePath: string, data: string, encoding: BufferEncoding = 'utf8'): Promise<void> {
    try {
      const absolutePath = path.resolve(filePath);
      const dirPath = path.dirname(absolutePath);
      
      logger.debug(`Writing file: ${absolutePath}`);
      await fs.ensureDir(dirPath);
      
      return RetryHelper.withRetry(
        async () => fs.writeFile(absolutePath, data, encoding),
        3,
        1000,
        5000
      );
    } catch (error) {
      logger.error(`Error writing file: ${error}`);
      throw error;
    }
  }

  /**
   * Copy file with retry mechanism
   * @param source Source path
   * @param destination Destination path
   */
  public async copyFile(source: string, destination: string): Promise<void> {
    try {
      const absoluteSource = path.resolve(source);
      const absoluteDestination = path.resolve(destination);
      
      if (!fs.existsSync(absoluteSource)) {
        throw new Error(`Source file not found: ${absoluteSource}`);
      }
      
      const dirPath = path.dirname(absoluteDestination);
      await fs.ensureDir(dirPath);
      
      logger.debug(`Copying file from ${absoluteSource} to ${absoluteDestination}`);
      return RetryHelper.withRetry(
        async () => fs.copy(absoluteSource, absoluteDestination),
        3,
        1000,
        5000
      );
    } catch (error) {
      logger.error(`Error copying file: ${error}`);
      throw error;
    }
  }

  /**
   * Check if file exists
   * @param filePath Path to file
   * @returns True if file exists
   */
  public async fileExists(filePath: string): Promise<boolean> {
    try {
      const absolutePath = path.resolve(filePath);
      return fs.existsSync(absolutePath);
    } catch (error) {
      logger.error(`Error checking file existence: ${error}`);
      return false;
    }
  }

  /**
   * Create directory if it doesn't exist
   * @param dirPath Path to directory
   */
  public async ensureDir(dirPath: string): Promise<void> {
    try {
      const absolutePath = path.resolve(dirPath);
      logger.debug(`Ensuring directory exists: ${absolutePath}`);
      return fs.ensureDir(absolutePath);
    } catch (error) {
      logger.error(`Error ensuring directory: ${error}`);
      throw error;
    }
  }

  /**
   * Get file stats
   * @param filePath Path to file
   * @returns File stats
   */
  public async getFileStats(filePath: string): Promise<fs.Stats> {
    try {
      const absolutePath = path.resolve(filePath);
      logger.debug(`Getting file stats: ${absolutePath}`);
      
      if (!fs.existsSync(absolutePath)) {
        throw new Error(`File not found: ${absolutePath}`);
      }
      
      return fs.stat(absolutePath);
    } catch (error) {
      logger.error(`Error getting file stats: ${error}`);
      throw error;
    }
  }
}

export default FileUtils.getInstance();

hooks.ts
--------------
import { BeforeAll, AfterAll, Before, After, Status, World } from '@cucumber/cucumber';
import apiClient from '../api/apiClient';
import { logger } from '../helpers/loggerHelper';
import reportHelper from '../helpers/reportHelper';
import * as fs from 'fs-extra';
import * as path from 'path';
import { configHelper } from '../../config/config';
import { TimeoutUtils } from '../utils/timeoutUtils';

// Ensure reports directories exist
const reportsDir = path.join(process.cwd(), 'reports');
const jsonReportsDir = path.join(reportsDir, 'json');
const htmlReportsDir = path.join(reportsDir, 'html');
const screenshotsDir = path.join(reportsDir, 'screenshots');
const logsDir = path.join(reportsDir, 'logs');

fs.ensureDirSync(jsonReportsDir);
fs.ensureDirSync(htmlReportsDir);
fs.ensureDirSync(screenshotsDir);
fs.ensureDirSync(logsDir);

// Define custom World interface
declare global {
  namespace NodeJS {
    interface Global {
      testContext: any;
    }
  }
}

// Initialize test context
let testContext: Record<string, any> = {};

BeforeAll(async function() {
  logger.info(' Test execution started');
  reportHelper.startTestRun();
  
  // Initialize API client and wait for completion
  await apiClient.initialize();
  
  // Set global test context
  global.testContext = {};
  
  // Log environment information
  logger.info(`Environment: ${configHelper.getEnvironment()}`);
  logger.info(`Base URL: ${configHelper.getBaseUrl()}`);
  logger.info(`Debug Mode: ${configHelper.isDebugMode()}`);
  logger.info(`Timeout: ${configHelper.getTimeout()}ms`);
  logger.info(`Retry Attempts: ${configHelper.getRetryAttempts()}`);
});

AfterAll(async function() {
  logger.info(' Test execution completed');
  
  // Wait for any pending operations to complete
  await TimeoutUtils.sleep(1000);
  
  // Cleanup
  await apiClient.dispose();
  
  // Generate report
  reportHelper.endTestRun();
  await reportHelper.generateReport();
  
  // Clear global test context
  global.testContext = {};
});

Before(async function(this: World, scenario) {
  const featureName = scenario.pickle.uri?.split('/').pop()?.replace('.feature', '') || 'Unknown';
  const scenarioName = scenario.pickle.name;
  
  logger.info(` Starting scenario: ${scenarioName} [${featureName}]`);
  
  // Initialize scenario context
  this.context = {
    scenarioName,
    scenarioId: scenario.pickle.id,
    featureName,
    startTime: new Date(),
    responses: {},
    data: {},
    screenshots: []
  };
  
  // Add to global test context
  global.testContext[scenarioName] = this.context;
});

After(async function(this: World, scenario) {
  const duration = new Date().getTime() - this.context.startTime.getTime();
  const status = scenario.result?.status || 'unknown';
  
  logger.info(` Completed scenario: ${this.context.scenarioName} with status: ${status.toUpperCase()} (${duration}ms)`);
  
  let error = undefined;
  const screenshots: string[] = this.context.screenshots || [];
  
  if (scenario.result?.status === Status.FAILED) {
    error = scenario.result.message;
    logger.error(`Scenario failed: ${error}`);
    
    // Take screenshot on failure if configured
    if (configHelper.shouldTakeScreenshotOnFailure()) {
      try {
        const screenshotName = `${this.context.featureName}_${this.context.scenarioName}_failure`;
        const screenshotPath = path.join(screenshotsDir, `${screenshotName}.png`);
        
        // Note: In a real API test framework, we might want to capture the last request/response
        // instead of a screenshot since there's no UI. This is just a placeholder.
        
        // For now, we'll just log the error to a file as a "screenshot"
        await fs.writeFile(
          screenshotPath,
          `Error: ${error}\n\nContext: ${JSON.stringify(this.context, null, 2)}`,
          'utf8'
        );
        
        screenshots.push(screenshotPath);
        logger.info(`Error details saved to: ${screenshotPath}`);
      } catch (screenshotError) {
        logger.error(`Failed to save error details: ${screenshotError}`);
      }
    }
  }
  
  // Add test result to the report
  reportHelper.addTestResult(
    this.context.featureName,
    this.context.scenarioName,
    status,
    duration,
    error,
    { 
      scenarioId: this.context.scenarioId,
      responses: Object.keys(this.context.responses)
    },
    screenshots
  );
  
  // Remove from global test context
  delete global.testContext[this.context.scenarioName];
});

assetLayout.feature
----------------
Feature: Asset Layout API Tests
  As a user
  I want to test the Asset Layout API
  So that I can ensure it works correctly

  Background:
    Given the API is available

  @smoke @critical
  Scenario: Get asset layout with valid data
    When I send a request to get asset layout with the following data:
      | messageId | dealId | reportDate  |
      | 1234      | 34384  | 2024-03-31  |
    Then the response status code should be 200
    And the response should contain valid asset layout data
    And the response should not contain any errors

  @regression
  Scenario: Get asset layout with invalid deal ID
    When I send a request to get asset layout with the following data:
      | messageId | dealId | reportDate  |
      | 1234      | 99999  | 2024-03-31  |
    Then the response status code should be 404
    And the response should contain an error message

  @regression
  Scenario: Get asset layout with invalid report date
    When I send a request to get asset layout with the following data:
      | messageId | dealId | reportDate   |
      | 1234      | 34384  | invalid-date |
    Then the response status code should be 400
    And the response should contain a validation error

  @performance
  Scenario: Asset layout API responds within acceptable time
    When I send a request to get asset layout with the following data:
      | messageId | dealId | reportDate  |
      | 1234      | 34384  | 2024-03-31  |
    Then the response time should be less than 2 seconds

assetLayout-steps.ts
------------------------------
import { Given, When, Then } from '@cucumber/cucumber';
import assertionUtils from '../../src/utils/assertionUtils';
import AssetLayoutService from '../../src/api/services/assetLayoutService';
import { AssetLayoutRequest } from '../../src/models/apiModels';
import { logger } from '../../src/helpers/loggerHelper';
import commonUtils from '../../src/utils/commonUtils';

Given('the API is available', async function() {
  logger.info('Verifying API availability');
  // In a real implementation, we might do a health check here
  // For now, we'll assume the API is available
});

When('I send a request to get asset layout with the following data:', async function(dataTable) {
  try {
    // Convert the data table to our request object
    const rows = dataTable.hashes();
    if (rows.length === 0) {
      throw new Error('No data provided in the data table');
    }

    const row = rows[0];
    const request: AssetLayoutRequest = {
      messageId: parseInt(row.messageId),
      dealId: parseInt(row.dealId),
      reportDate: row.reportDate
    };

    logger.info(`Sending asset layout request with dealId: ${request.dealId}`);
    
    // Record the start time for performance measurements
    this.context.requestStartTime = Date.now();
    
    // Send the request and store the response in the world context
    this.context.assetLayoutResponse = await AssetLayoutService.getAssetLayout(request);
    
    // Calculate and store the response time
    this.context.responseTime = Date.now() - this.context.requestStartTime;
    
    logger.info(`Received response with status: ${this.context.assetLayoutResponse.statusCode} in ${this.context.responseTime}ms`);
  } catch (error) {
    logger.error(`Error during asset layout request: ${error}`);
    throw error;
  }
});

Then('the response status code should be {int}', function(expectedStatusCode) {
  assertionUtils.assertStatusCode(this.context.assetLayoutResponse, expectedStatusCode);
});

Then('the response should contain valid asset layout data', function() {
  // Verify response structure
  assertionUtils.assertFieldExists(this.context.assetLayoutResponse, 'data');
  assertionUtils.assertFieldExists(this.context.assetLayoutResponse.data, 'assetLayouts');
  assertionUtils.assertArrayHasItems(this.context.assetLayoutResponse.data, 'assetLayouts');
  
  // Verify first asset layout
  const firstAssetLayout = this.context.assetLayoutResponse.data.assetLayouts[0];
  expect(firstAssetLayout).to.have.property('dealId');
  expect(firstAssetLayout).to.have.property('entityId');
  expect(firstAssetLayout.dealId).to.be.a('number');
  expect(firstAssetLayout.entityId).to.be.a('number');
});

Then('the response should not contain any errors', function() {
  assertionUtils.assertNoError(this.context.assetLayoutResponse);
});

Then('the response should contain an error message', function() {
  assertionUtils.assertHasError(this.context.assetLayoutResponse, 'errorMessage');
});

Then('the response should contain a validation error', function() {
  assertionUtils.assertHasError(this.context.assetLayoutResponse, 'validationErrorMessage');
});

Then('the response time should be less than {int} seconds', function(expectedSeconds) {
  const expectedMs = expectedSeconds * 1000;
  assertionUtils.assertResponseTime(this.context.responseTime, expectedMs);
});

assetLayoutPayload.ts
------------------------

{
  "messageId": 1234,
  "dealId": 34384,
  "reportDate": "2024-03-31"
}

README.md
--------------

# Enhanced Playwright API Automation Framework

A robust, high-performance test automation framework for API testing using Playwright, TypeScript, and Cucumber BDD.

## Key Features

- **Sequential Execution**: Eliminates race conditions and timing issues
- **Robust Error Handling**: Built-in retry mechanisms for unstable connections
- **Enhanced Reporting**: Detailed and attractive HTML reports
- **Strong Typing**: Full TypeScript support with strict type checking
- **Environment Management**: Support for multiple test environments
- **Certificate Management**: Secure API authentication
- **Performance Tracking**: Response time measurements for SLA verification
- **Code Quality**: Linting and formatting rules for consistent code
- **Test Organization**: Support for tagging and filtering tests
- **Debugging Support**: Detailed logging with configurable levels

## Prerequisites

- Node.js (v16 or higher)
- npm (v8 or higher)

## Installation

1. Clone this repository
2. Install dependencies:

```bash
npm install
```

## Configuration

Configuration is managed through environment-specific `.env` files in the `config/environments` directory:

- `.env.sit` - System Integration Testing environment
- `.env.uat` - User Acceptance Testing environment
- `.env.prod` - Production environment

Key configuration options:

- `API_BASE_URL` - Base URL for API requests
- `CERT_PATH` - Path to certificate file
- `TIMEOUT` - Default timeout for test operations
- `RETRY_ATTEMPTS` - Number of retry attempts for failed tests
- `MAX_CONCURRENT_REQUESTS` - Maximum concurrent requests (set to 1 for sequential execution)
- `REQUEST_RETRY_COUNT` - Number of retry attempts for failed API requests
- `SCREENSHOT_ON_FAILURE` - Whether to capture details on test failure

## Running Tests

```bash
# Run all tests in the SIT environment
npm run test:sit

# Run all tests in the UAT environment
npm run test:uat

# Run all tests in the PROD environment
npm run test:prod

# Run tests with debug logging
npm run test:debug

# Run tests with specific tags
npm run test:tags "@smoke"

# Run tests in parallel (NOT recommended for avoiding race conditions)
npm run test:parallel
```

## Project Structure

```
enhanced-playwright-framework/
 config/                         # Configuration
 certs/                          # Certificate storage
 src/
    api/                        # API communication
       apiClient.ts            # HTTP client
       apiExecutor.ts          # Sequential execution
       services/               # API services
    helpers/                    # Helper functions
    models/                     # Data models
    hooks/                      # Cucumber hooks
    utils/                      # Utility functions
 tests/
    features/                   # Cucumber feature files
    step-definitions/           # Step implementations
    testData/                   # Test data files
 reports/                        # Test reports
 package.json                    # Project dependencies
 tsconfig.json                   # TypeScript configuration
```

## How It Works

### 1. Sequential Execution

The framework ensures sequential execution of API requests to prevent race conditions through the `apiExecutor` class. This guarantees that each request completes fully before the next one begins.

```typescript
// Example of sequential execution
public async getAssetLayout(request: AssetLayoutRequest): Promise<ApiResponse<AssetLayoutResponse>> {
  return apiExecutor.execute(
    `GetAssetLayout-${request.dealId}`,
    async () => {
      // API request logic
    }
  );
}
```

### 2. Robust Error Handling

Built-in retry mechanisms for API requests and file operations:

```typescript
// Retry with exponential backoff
const response = await RetryHelper.withRetry(
  async () => makeApiCall(),
  3,  // max retries
  1000,  // initial delay (ms)
  5000  // max delay (ms)
);
```

### 3. Enhanced Reporting

Detailed HTML reports with test statistics, error details, and performance metrics.

## Extending the Framework

### Adding a New API Service

1. Create a model in `src/models/apiModels.ts`
2. Add an endpoint in `src/api/endpoints.ts`
3. Create a service in `src/api/services/yourService.ts`
4. Write feature files in `tests/features/`
5. Implement step definitions in `tests/step-definitions/`

### Example: Creating a New API Service

```typescript
import apiClient from '../apiClient';
import { apiExecutor } from '../apiExecutor';
import { Endpoints } from '../endpoints';
import { YourRequest, YourResponse } from '../../models/apiModels';
import { logger } from '../../helpers/loggerHelper';
import { ApiResponse } from '../../models/apiModels';

export class YourService {
  private static instance: YourService;

  private constructor() {}

  public static getInstance(): YourService {
    if (!YourService.instance) {
      YourService.instance = new YourService();
    }
    return YourService.instance;
  }

  public async yourMethod(request: YourRequest): Promise<ApiResponse<YourResponse>> {
    return apiExecutor.execute(
      `YourMethod-${request.id}`,
      async () => {
        try {
          logger.info(`Calling your method with id: ${request.id}`);
          
          const response = await apiClient.post(Endpoints.YOUR_ENDPOINT, request);
          
          const apiResponse: ApiResponse<YourResponse> = {
            statusCode: response.status(),
            headers: response.headers(),
            data: await response.json() as YourResponse,
            ok: response.ok()
          };
          
          return apiResponse;
        } catch (error) {
          logger.error(`Error in your method: ${error}`);
          throw error;
        }
      }
    );
  }
}

export default YourService.getInstance();
```

## Contributing

Please follow the existing code style and patterns when contributing. This framework is designed to prioritize reliability, readability, and maintainability.

