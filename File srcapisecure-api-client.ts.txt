cucumber.js
------------

const common = {
  require: [
    'ts-node/register',
    './src/hooks/hooks.ts',
    './tests/step-definitions/**/*.ts'
  ],
  paths: ['./tests/features/'],
  format: [
    'progress-bar',
    'json:reports/json/cucumber-report.json'
  ],
  formatOptions: { snippetInterface: 'async-await' },
  publishQuiet: true,
  retry: 0
};

module.exports = {
  default: {
    ...common,
    parallel: process.env.PARALLEL === 'true' ? 2 : 0
  },
  rerun: {
    ...common,
    format: ['progress-bar'],
    retry: 1
  }
};

cucumberFormatter.ts
-----------------------

import { Formatter, IFormatterOptions } from '@cucumber/cucumber';
import reportHelper from './reportHelper';
import { logger } from './loggerHelper';

/**
 * Custom Cucumber formatter that integrates with the report helper
 */
export default class CustomFormatter extends Formatter {
  constructor(options: IFormatterOptions) {
    super(options);
    
    // Register event handlers
    options.eventBroadcaster.on('test-run-started', () => {
      logger.info('Test run started, initializing report');
      reportHelper.startTestRun();
    });
    
    options.eventBroadcaster.on('test-run-finished', async () => {
      logger.info('Test run finished, generating report');
      reportHelper.endTestRun();
      try {
        const reportPath = await reportHelper.generateReport();
        logger.info(`Report generated at: ${reportPath}`);
      } catch (error) {
        logger.error(`Failed to generate report: ${error}`);
      }
    });
  }
}

package.json
--------------

{
  "name": "enhanced-playwright-framework",
  "version": "2.0.0",
  "description": "Advanced enterprise-level API test automation framework using Playwright, TypeScript, and Cucumber BDD",
  "main": "index.js",
  "scripts": {
    "clean": "rimraf reports/* dist/*",
    "build": "tsc",
    "pretest": "npm run clean",
    "test": "cucumber-js --require-module ts-node/register --require 'tests/step-definitions/**/*.ts' --require 'src/hooks/hooks.ts'",
    "test:sit": "cross-env NODE_ENV=sit cucumber-js --require-module ts-node/register --require 'tests/step-definitions/**/*.ts' --require 'src/hooks/hooks.ts'",
    "test:uat": "cross-env NODE_ENV=uat cucumber-js --require-module ts-node/register --require 'tests/step-definitions/**/*.ts' --require 'src/hooks/hooks.ts'",
    "test:prod": "cross-env NODE_ENV=prod cucumber-js --require-module ts-node/register --require 'tests/step-definitions/**/*.ts' --require 'src/hooks/hooks.ts'",
    "test:debug": "cross-env DEBUG=true cucumber-js --require-module ts-node/register --require 'tests/step-definitions/**/*.ts' --require 'src/hooks/hooks.ts'",
    "test:parallel": "cross-env PARALLEL=true cucumber-js --require-module ts-node/register --require 'tests/step-definitions/**/*.ts' --require 'src/hooks/hooks.ts' --parallel 2",
    "test:tags": "cucumber-js --require-module ts-node/register --require 'tests/step-definitions/**/*.ts' --require 'src/hooks/hooks.ts' --tags",
    "report": "node -e \"require('./src/helpers/reportHelper').default.generateReport()\"",
    "lint": "eslint . --ext .ts",
    "format": "prettier --write .",
    "compile": "tsc --project tsconfig.json"
  },
  "keywords": [
    "playwright",
    "typescript",
    "cucumber",
    "api",
    "testing",
    "bdd"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@cucumber/cucumber": "^9.3.0",
    "@playwright/test": "^1.40.0",
    "ajv": "^8.12.0",
    "axios": "^1.5.0",
    "axios-retry": "^3.6.0",
    "chai": "^4.3.7",
    "chai-as-promised": "^7.1.1",
    "chalk": "^4.1.2",
    "cross-env": "^7.0.3",
    "cucumber-html-reporter": "^7.1.0",
    "dayjs": "^1.11.9",
    "dotenv": "^16.3.1",
    "fs-extra": "^11.1.1",
    "handlebars": "^4.7.8",
    "https-proxy-agent": "^7.0.0",
    "node-fetch": "^2.6.12",
    "p-limit": "^3.1.0",
    "pem": "^1.14.8",
    "pino": "^8.15.0",
    "pino-pretty": "^10.2.0",
    "rxjs": "^7.8.1",
    "ts-node": "^10.9.1",
    "typescript": "^5.1.6",
    "uuid": "^9.0.0",
    "winston": "^3.10.0",
    "winston-daily-rotate-file": "^4.7.1"
  },
  "devDependencies": {
    "@types/chai": "^4.3.5",
    "@types/chai-as-promised": "^7.1.5",
    "@types/cucumber-html-reporter": "^5.0.1",
    "@types/fs-extra": "^11.0.1",
    "@types/node": "^20.4.1",
    "@types/uuid": "^9.0.2",
    "@typescript-eslint/eslint-plugin": "^6.2.1",
    "@typescript-eslint/parser": "^6.2.1",
    "eslint": "^8.46.0",
    "eslint-config-prettier": "^8.10.0",
    "eslint-plugin-prettier": "^5.0.0",
    "prettier": "^3.0.0",
    "rimraf": "^5.0.1"
  }
}

hooks.ts
-------------

import { BeforeAll, AfterAll, Before, After, Status } from '@cucumber/cucumber';
import apiClient from '../api/apiClient';
import { logger } from '../helpers/loggerHelper';
import reportHelper from '../helpers/reportHelper';
import * as fs from 'fs-extra';
import * as path from 'path';
import { configHelper } from '../../config/config';
import { TimeoutUtils } from '../utils/timeoutUtils';
import { World, ScenarioContext } from '../models/worldModels';

// Ensure reports directories exist
const reportsDir = path.join(process.cwd(), 'reports');
const jsonReportsDir = path.join(reportsDir, 'json');
const htmlReportsDir = path.join(reportsDir, 'html');
const screenshotsDir = path.join(reportsDir, 'screenshots');
const logsDir = path.join(reportsDir, 'logs');

fs.ensureDirSync(jsonReportsDir);
fs.ensureDirSync(htmlReportsDir);
fs.ensureDirSync(screenshotsDir);
fs.ensureDirSync(logsDir);

// Store test context in module-level variable to avoid global variable issues
const testContextMap: Record<string, ScenarioContext> = {};

BeforeAll(async function() {
  logger.info('üöÄ Test execution started');
  // Note: The report is also initialized by the cucumber formatter
  // but we call it here as well to ensure it runs even without the formatter
  reportHelper.startTestRun();
  
  // Initialize API client and wait for completion
  await apiClient.initialize();
  
  // Log environment information
  logger.info(`Environment: ${configHelper.getEnvironment()}`);
  logger.info(`Base URL: ${configHelper.getBaseUrl()}`);
  logger.info(`Debug Mode: ${configHelper.isDebugMode()}`);
  logger.info(`Timeout: ${configHelper.getTimeout()}ms`);
  logger.info(`Retry Attempts: ${configHelper.getRetryAttempts()}`);
});

AfterAll(async function() {
  logger.info('üèÅ Test execution completed');
  
  // Wait for any pending operations to complete
  await TimeoutUtils.sleep(1000);
  
  // Cleanup
  await apiClient.dispose();
  
  // Generate report
  // Note: The report is also generated by the cucumber formatter
  // but we call it here as well to ensure it runs even without the formatter
  reportHelper.endTestRun();
  await reportHelper.generateReport('test-report');
  
  // Clear test context
  Object.keys(testContextMap).forEach(key => delete testContextMap[key]);
});

Before(async function(this: World, scenario) {
  const featureName = scenario.pickle.uri?.split('/').pop()?.replace('.feature', '') || 'Unknown';
  const scenarioName = scenario.pickle.name;
  
  logger.info(`‚ñ∂Ô∏è Starting scenario: ${scenarioName} [${featureName}]`);
  
  // Initialize scenario context
  this.context = {
    scenarioName,
    scenarioId: scenario.pickle.id,
    featureName,
    startTime: new Date(),
    responses: {},
    data: {},
    screenshots: []
  };
  
  // Add to test context map
  testContextMap[scenarioName] = this.context;
});

After(async function(this: World, scenario) {
  const duration = new Date().getTime() - this.context.startTime.getTime();
  const status = scenario.result?.status || 'unknown';
  
  logger.info(`‚èπÔ∏è Completed scenario: ${this.context.scenarioName} with status: ${status.toUpperCase()} (${duration}ms)`);
  
  let error = undefined;
  const screenshots: string[] = this.context.screenshots || [];
  
  if (scenario.result?.status === Status.FAILED) {
    error = scenario.result.message;
    logger.error(`Scenario failed: ${error}`);
    
    // Take screenshot on failure if configured
    if (configHelper.shouldTakeScreenshotOnFailure()) {
      try {
        const screenshotName = `${this.context.featureName}_${this.context.scenarioName}_failure`;
        const screenshotPath = path.join(screenshotsDir, `${screenshotName}.txt`);
        
        // For API testing, save error details as a text file instead of screenshot
        await fs.writeFile(
          screenshotPath,
          `Error: ${error}\n\nContext: ${JSON.stringify(this.context, null, 2)}`,
          'utf8'
        );
        
        screenshots.push(screenshotPath);
        logger.info(`Error details saved to: ${screenshotPath}`);
      } catch (screenshotError) {
        logger.error(`Failed to save error details: ${screenshotError}`);
      }
    }
  }
  
  // Add test result to the report
  reportHelper.addTestResult(
    this.context.featureName,
    this.context.scenarioName,
    status,
    duration,
    error,
    { 
      scenarioId: this.context.scenarioId,
      responses: Object.keys(this.context.responses)
    },
    screenshots
  );
  
  // Remove from test context map
  delete testContextMap[this.context.scenarioName];
});
