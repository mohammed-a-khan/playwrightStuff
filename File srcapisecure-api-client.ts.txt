CertificateHelper.ts
----------------------

import * as fs from 'fs-extra';
import * as path from 'path';
import { configHelper } from '../../config/config';
import { logger } from './loggerHelper';
import { RetryHelper } from './retryHelper';

export class CertificateHelper {
  private static instance: CertificateHelper;
  private certificateCache: Map<string, Buffer> = new Map();

  private constructor() {}

  public static getInstance(): CertificateHelper {
    if (!CertificateHelper.instance) {
      CertificateHelper.instance = new CertificateHelper();
    }
    return CertificateHelper.instance;
  }

  /**
   * Get certificate options for API client
   * @returns Certificate options object
   */
  public async getCertificateOptions(): Promise<any> {
    try {
      const certPath = configHelper.getCertPath();
      if (!certPath) {
        logger.info('No certificate path configured, skipping certificate setup');
        return {};
      }

      const resolvedCertPath = path.resolve(certPath);
      const passphrase = configHelper.getCertPassphrase();
      
      if (!fs.existsSync(resolvedCertPath)) {
        logger.warn(`Certificate file not found at: ${resolvedCertPath}`);
        return {};
      }

      logger.debug(`Using certificate at: ${resolvedCertPath}`);
      
      // Try to get from cache first
      let pfxBuffer = this.certificateCache.get(resolvedCertPath);
      
      if (!pfxBuffer) {
        try {
          // Read the certificate with retry for file system issues
          pfxBuffer = await RetryHelper.withRetry(
            async () => fs.readFile(resolvedCertPath),
            3,
            1000,
            5000
          );
          
          // Cache the certificate
          this.certificateCache.set(resolvedCertPath, pfxBuffer);
          logger.debug(`Certificate loaded successfully: ${resolvedCertPath}`);
        } catch (error) {
          logger.error(`Failed to read certificate file: ${error}`);
          return {};
        }
      }
      
      // Log certificate info for debugging
      logger.debug(`Certificate buffer size: ${pfxBuffer.length} bytes`);
      logger.debug(`Using passphrase: ${passphrase ? 'Yes (value hidden)' : 'No'}`);
      
      return {
        httpsOptions: {
          pfx: pfxBuffer,
          passphrase: passphrase || undefined,
          rejectUnauthorized: false // Add this to handle self-signed certificates
        }
      };
    } catch (error) {
      logger.error(`Error loading certificate: ${error}`);
      // Return empty object instead of throwing to allow API client to function without cert
      return {};
    }
  }

  /**
   * Clear the certificate cache
   */
  public clearCache(): void {
    this.certificateCache.clear();
    logger.debug('Certificate cache cleared');
  }
}

export const certificateHelper = CertificateHelper.getInstance();

apiClient.ts
---------------

import { request, APIRequestContext, APIResponse } from '@playwright/test';
import { configHelper } from '../../config/config';
import { logger, logHttpDetails } from '../helpers/loggerHelper';
import { certificateHelper } from '../helpers/certificateHelper';
import { RetryHelper } from '../helpers/retryHelper';
import { TimeoutUtils } from '../utils/timeoutUtils';

export interface RequestOptions {
  headers?: Record<string, string>;
  timeout?: number;
  retries?: number;
  retryDelay?: number;
  retryCondition?: (response: APIResponse) => boolean;
}

export class ApiClient {
  private static instance: ApiClient;
  private context: APIRequestContext | null = null;
  private isInitializing: boolean = false;
  private initializePromise: Promise<void> | null = null;

  private constructor() {}

  public static getInstance(): ApiClient {
    if (!ApiClient.instance) {
      ApiClient.instance = new ApiClient();
    }
    return ApiClient.instance;
  }

  /**
   * Initialize the API client
   * @returns Promise resolving when initialization is complete
   */
  public async initialize(): Promise<void> {
    // If already initializing, return the existing promise
    if (this.isInitializing && this.initializePromise) {
      return this.initializePromise;
    }

    // If already initialized, return immediately
    if (this.context) {
      return Promise.resolve();
    }

    this.isInitializing = true;
    this.initializePromise = this.doInitialize();
    
    try {
      await this.initializePromise;
    } finally {
      this.isInitializing = false;
      this.initializePromise = null;
    }
  }

  private async doInitialize(): Promise<void> {
    try {
      const baseURL = configHelper.getBaseUrl();
      logger.info(`Initializing API client with base URL: ${baseURL}`);
      
      // Get certificate options with enhanced error handling
      let certOptions = {};
      try {
        certOptions = await certificateHelper.getCertificateOptions();
        logger.info(`Certificate options loaded: ${Object.keys(certOptions).length > 0 ? 'Yes' : 'No'}`);
      } catch (certError) {
        logger.warn(`Failed to load certificate options: ${certError}. Continuing without certificate.`);
      }
      
      const proxyUrl = configHelper.getProxyUrl();
      if (proxyUrl) {
        logger.info(`Using proxy: ${proxyUrl}`);
      }
      
      const requestOptions: any = {
        baseURL,
        extraHTTPHeaders: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Connection': 'keep-alive' // Helps prevent ECONNRESET
        },
        ignoreHTTPSErrors: true, // Important for handling certificate issues
        timeout: configHelper.getTimeout(),
        ...certOptions
      };
      
      // Add proxy if configured
      if (proxyUrl) {
        requestOptions.proxy = {
          server: proxyUrl
        };
      }
      
      // Debug log the complete request options (without sensitive data)
      const debugOptions = { ...requestOptions };
      if (debugOptions.httpsOptions && debugOptions.httpsOptions.pfx) {
        debugOptions.httpsOptions.pfx = `[Buffer of ${debugOptions.httpsOptions.pfx.length} bytes]`;
      }
      if (debugOptions.httpsOptions && debugOptions.httpsOptions.passphrase) {
        debugOptions.httpsOptions.passphrase = '[REDACTED]';
      }
      logger.debug(`API Client request options: ${JSON.stringify(debugOptions, null, 2)}`);
      
      this.context = await request.newContext(requestOptions);
      
      logger.info(`API Client successfully initialized with base URL: ${baseURL}`);
    } catch (error) {
      logger.error(`Failed to initialize API client: ${error}`);
      this.context = null;
      throw error;
    }
  }

  private async ensureContext(): Promise<APIRequestContext> {
    if (!this.context) {
      await this.initialize();
    }
    return this.context!;
  }

  /**
   * Perform a GET request
   * @param url The URL to request
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async get(url: string, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('GET', url, undefined, options);
  }

  /**
   * Perform a POST request
   * @param url The URL to request
   * @param data The data to send
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async post(url: string, data: any, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('POST', url, data, options);
  }

  /**
   * Perform a PUT request
   * @param url The URL to request
   * @param data The data to send
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async put(url: string, data: any, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('PUT', url, data, options);
  }

  /**
   * Perform a DELETE request
   * @param url The URL to request
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async delete(url: string, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('DELETE', url, undefined, options);
  }

  /**
   * Perform a PATCH request
   * @param url The URL to request
   * @param data The data to send
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async patch(url: string, data: any, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('PATCH', url, data, options);
  }

  /**
   * Execute a request with retries and timeouts
   * @param method The HTTP method
   * @param url The URL to request
   * @param data The data to send (for POST, PUT, PATCH)
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  private async executeRequest(
    method: string,
    url: string,
    data?: any,
    options: RequestOptions = {}
  ): Promise<APIResponse> {
    const headers = {
      'Connection': 'keep-alive', // Important for preventing ECONNRESET
      ...(options.headers || {})
    };
    
    const timeout = options.timeout || configHelper.getRequestTimeout();
    const retries = options.retries || parseInt(configHelper.get('REQUEST_RETRY_COUNT'), 10) || 3;
    const retryDelay = options.retryDelay || parseInt(configHelper.get('REQUEST_RETRY_DELAY'), 10) || 1000;
    
    // Only log if detailed logging is enabled
    if (configHelper.isDetailedLogging()) {
      logHttpDetails(method, url, headers, data);
    }
    
    return RetryHelper.withRetry(
      async () => {
        try {
          // Ensure context is initialized or re-initialize if needed
          let context;
          try {
            context = await this.ensureContext();
          } catch (contextError) {
            logger.error(`Context initialization failed, attempting to re-initialize: ${contextError}`);
            this.context = null; // Force re-initialization
            context = await this.ensureContext();
          }
          
          // Execute request with timeout
          const response = await TimeoutUtils.withTimeout(
            async () => {
              let requestConfig: any = { headers };
              
              // Add data to requestConfig for methods that need it
              if (data !== undefined && ['POST', 'PUT', 'PATCH'].includes(method.toUpperCase())) {
                requestConfig.data = data;
              }
              
              // Debug log the actual request being made
              logger.debug(`Executing ${method} request to ${url}`);
              logger.debug(`Request config: ${JSON.stringify(requestConfig, null, 2)}`);
              
              switch (method.toUpperCase()) {
                case 'GET':
                  return await context.get(url, requestConfig);
                case 'POST':
                  return await context.post(url, requestConfig);
                case 'PUT':
                  return await context.put(url, requestConfig);
                case 'DELETE':
                  return await context.delete(url, requestConfig);
                case 'PATCH':
                  return await context.patch(url, requestConfig);
                default:
                  throw new Error(`Unsupported HTTP method: ${method}`);
              }
            },
            timeout,
            `Request ${method} ${url} timed out after ${timeout}ms`
          );
          
          // Log response
          const status = response.status();
          logger.debug(`Received response with status: ${status}`);
          
          // Only log detailed response if enabled
          if (configHelper.isDetailedLogging()) {
            let responseData = null;
            try {
              responseData = await response.json();
            } catch (e) {
              // Ignore JSON parsing errors for logging
              logger.debug(`Could not parse response as JSON: ${e}`);
            }
            
            logHttpDetails(
              method,
              url,
              headers,
              data,
              status,
              response.headers(),
              responseData
            );
          }
          
          // Check if retry is needed based on status code
          const shouldRetryStatus = options.retryCondition ? 
            options.retryCondition(response) : 
            response.status() >= 500;
          
          if (shouldRetryStatus) {
            throw new Error(`Request failed with status: ${response.status()}`);
          }
          
          return response;
        } catch (error: any) {
          // Enhanced error logging with network error details
          if (error.message && (
              error.message.includes('ECONNRESET') || 
              error.message.includes('ETIMEDOUT') || 
              error.message.includes('ECONNREFUSED')
          )) {
            logger.error(`Network error (will retry): ${error.message}`);
          } else {
            logger.error(`Request error (will retry): ${error}`);
          }
          
          // If the error is ECONNRESET, force context re-initialization on next try
          if (error.message && error.message.includes('ECONNRESET')) {
            logger.info('Connection reset detected. Will reinitialize context on next try.');
            this.context = null;
          }
          
          throw error; // Re-throw to trigger retry
        }
      },
      retries,
      retryDelay
    );
  }

  /**
   * Dispose the API client
   */
  public async dispose(): Promise<void> {
    if (this.context) {
      await this.context.dispose();
      this.context = null;
      logger.info('API Client disposed');
    }
  }
}

export default ApiClient.getInstance();

generateReport.ts
-------------------

/**
 * Standalone script to generate a report
 * This can be run after testing to generate a report if it failed during execution
 */

import reportHelper from '../helpers/reportHelper';
import { logger } from '../helpers/loggerHelper';
import apiClient from '../api/apiClient';
import { configHelper } from '../../config/config';

// Main function to generate the report
async function generateReport() {
  try {
    logger.info('Generating test report manually...');
    
    // Print environment information for debugging
    logger.info(`Environment: ${configHelper.getEnvironment()}`);
    logger.info(`Base URL: ${configHelper.getBaseUrl()}`);
    logger.info(`Certificate Path: ${configHelper.getCertPath()}`);
    logger.info(`Debug Mode: ${configHelper.isDebugMode()}`);
    
    // Initialize API client
    try {
      await apiClient.initialize();
      logger.info('API client initialized successfully');
    } catch (apiInitError) {
      logger.error(`Failed to initialize API client: ${apiInitError}`);
      // Continue anyway to generate report
    }
    
    // Generate the report
    const reportPath = await reportHelper.generateReport('manual-report');
    logger.info(`Report successfully generated at: ${reportPath}`);
    
    // Clean up resources
    try {
      await apiClient.dispose();
      logger.info('API client disposed successfully');
    } catch (disposeError) {
      logger.error(`Error disposing API client: ${disposeError}`);
    }
    
    return reportPath;
  } catch (error) {
    logger.error(`Failed to generate report: ${error}`);
    if (error instanceof Error && error.stack) {
      logger.error(`Stack trace: ${error.stack}`);
    }
    process.exit(1);
  }
}

// Execute the function when script is run directly
if (require.main === module) {
  logger.info('Starting report generation script...');
  
  generateReport()
    .then(reportPath => {
      console.log(`Report generated at: ${reportPath}`);
      process.exit(0);
    })
    .catch(error => {
      console.error(`Error generating report: ${error}`);
      if (error instanceof Error && error.stack) {
        console.error(`Stack trace: ${error.stack}`);
      }
      process.exit(1);
    });
}

export default generateReport;
