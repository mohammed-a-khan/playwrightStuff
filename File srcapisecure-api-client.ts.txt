/**
 * Super simplified test script that uses minimal dependencies
 */

const fs = require('fs');
const path = require('path');
const https = require('https');
const { promisify } = require('util');

// Get configuration from environment file
function loadConfig() {
  const envPath = path.resolve('config/environments/.env.sit');
  if (!fs.existsSync(envPath)) {
    console.error(`Environment file not found: ${envPath}`);
    return { baseUrl: '', certPath: '', passphrase: '' };
  }
  
  const content = fs.readFileSync(envPath, 'utf8');
  const config = {};
  
  content.split('\n').forEach(line => {
    const match = line.match(/^([^=]+)=(.*)$/);
    if (match) {
      const key = match[1].trim();
      const value = match[2].trim();
      config[key] = value;
    }
  });
  
  return {
    baseUrl: config.API_BASE_URL || '',
    certPath: config.CERT_PATH || '',
    passphrase: config.CERT_PASSPHRASE || ''
  };
}

// Test certificate and make a request
async function testCertificateRequest() {
  try {
    console.log('Starting simple certificate test...');
    
    // Load configuration
    const config = loadConfig();
    console.log(`Base URL: ${config.baseUrl}`);
    console.log(`Certificate Path: ${config.certPath}`);
    console.log(`Has Passphrase: ${config.passphrase ? 'Yes' : 'No'}`);
    
    if (!config.baseUrl) {
      throw new Error('Base URL not configured');
    }
    
    // Parse URL
    const url = new URL(config.baseUrl);
    const host = url.hostname;
    const port = url.port ? parseInt(url.port) : 443;
    
    console.log(`Host: ${host}`);
    console.log(`Port: ${port}`);
    
    // Load certificate if available
    let cert = null;
    if (config.certPath) {
      const certFilePath = path.resolve(config.certPath);
      if (fs.existsSync(certFilePath)) {
        cert = fs.readFileSync(certFilePath);
        console.log(`Certificate loaded: ${cert.length} bytes`);
      } else {
        console.warn(`Certificate file not found: ${certFilePath}`);
      }
    }
    
    // Sample payload
    const payload = {
      messageId: 1234,
      dealId: 34384,
      reportDate: "2024-03-31"
    };
    
    console.log(`Using payload: ${JSON.stringify(payload)}`);
    const postData = JSON.stringify(payload);
    
    // Make HTTPS request
    return new Promise((resolve, reject) => {
      // Build request options
      const requestOptions = {
        hostname: host,
        port: port,
        path: '/v1/assets/assetlayout', // Endpoint path
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Content-Length': Buffer.byteLength(postData)
        },
        rejectUnauthorized: false // For self-signed certs
      };
      
      // Add certificate if available
      if (cert) {
        requestOptions.pfx = cert;
        requestOptions.passphrase = config.passphrase;
      }
      
      console.log('Sending request...');
      
      const req = https.request(requestOptions, (res) => {
        console.log(`Status Code: ${res.statusCode}`);
        console.log(`Headers: ${JSON.stringify(res.headers)}`);
        
        let responseData = '';
        
        res.on('data', (chunk) => {
          responseData += chunk;
        });
        
        res.on('end', () => {
          console.log('Response received');
          try {
            const jsonResponse = JSON.parse(responseData);
            console.log(`Response data: ${JSON.stringify(jsonResponse, null, 2)}`);
            resolve({
              statusCode: res.statusCode,
              headers: res.headers,
              data: jsonResponse
            });
          } catch (e) {
            console.log(`Raw response: ${responseData}`);
            resolve({
              statusCode: res.statusCode,
              headers: res.headers,
              data: responseData
            });
          }
        });
      });
      
      req.on('error', (e) => {
        console.error(`Request error: ${e.message}`);
        if (e.message.includes('ECONNRESET')) {
          console.error('ECONNRESET error detected. This usually means:');
          console.error('1. The server abruptly closed the connection');
          console.error('2. There might be a certificate/TLS issue');
          console.error('3. Network connectivity problems');
          console.error('4. Firewall or proxy interference');
        }
        reject(e);
      });
      
      req.write(postData);
      req.end();
      console.log('Request sent');
    });
  } catch (error) {
    console.error(`Error: ${error.message}`);
    throw error;
  }
}

// Run test
console.log('Starting simple certificate test...');
testCertificateRequest()
  .then(result => {
    console.log(`Test completed successfully with status: ${result.statusCode}`);
    process.exit(0);
  })
  .catch(error => {
    console.error(`Test failed: ${error.message}`);
    process.exit(1);
  });
