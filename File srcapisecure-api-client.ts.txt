package.json
------------
{
  "name": "api-test-framework",
  "version": "1.0.0",
  "description": "Simple plug-and-play API testing framework",
  "main": "dist/index.js",
  "scripts": {
    "test": "jest",
    "test:dev": "cross-env NODE_ENV=dev jest",
    "test:sit": "cross-env NODE_ENV=sit jest",
    "test:prod": "cross-env NODE_ENV=prod jest",
    "build": "tsc",
    "start": "ts-node src/index.ts",
    "debug": "node --inspect-brk -r ts-node/register src/index.ts"
  },
  "keywords": [
    "api",
    "testing",
    "framework"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "dotenv": "^16.3.1",
    "winston": "^3.11.0"
  },
  "devDependencies": {
    "@types/jest": "^29.5.5",
    "@types/node": "^20.9.1",
    "cross-env": "^7.0.3",
    "jest": "^29.7.0",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.1",
    "typescript": "^5.2.2"
  },
  "jest": {
    "preset": "ts-jest",
    "testEnvironment": "node",
    "testMatch": [
      "**/*.test.ts"
    ],
    "setupFiles": [
      "<rootDir>/src/framework/utils/setup-tests.ts"
    ]
  }
}

tsconfig.json
----------------
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "outDir": "dist",
    "sourceMap": true,
    "declaration": true,
    "moduleResolution": "node",
    "baseUrl": ".",
    "paths": {
      "*": ["node_modules/*"]
    },
    "types": ["node", "jest"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}

// .env - Default environment configuration
API_BASE_URL=https://katapi-dev.k8s.americas.ishare.net/v1
CERTIFICATE_PATH=./certs/kpfxPROD.pfx
CERTIFICATE_PASSPHRASE=khan#123!
REQUEST_TIMEOUT_MS=30000
RETRY_ATTEMPTS=3
RETRY_DELAY_MS=1000
LOG_LEVEL=info

.env.sit
-------------
API_BASE_URL=https://katapi-sit.k8s.americas.ishare.net/v1
CERTIFICATE_PATH=./certs/kpfxPROD.pfx
CERTIFICATE_PASSPHRASE=khan#123!
REQUEST_TIMEOUT_MS=30000
RETRY_ATTEMPTS=3
RETRY_DELAY_MS=1000
LOG_LEVEL=info

.env.prod
----------
API_BASE_URL=https://katapi.k8s.americas.ishare.net/v1
CERTIFICATE_PATH=./certs/kpfxPROD.pfx
CERTIFICATE_PASSPHRASE=khan#123!
REQUEST_TIMEOUT_MS=30000
RETRY_ATTEMPTS=3
RETRY_DELAY_MS=1000
LOG_LEVEL=info

src/framework/http/types.ts
--------------------------------
/**
 * HTTP method types
 */
export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';

/**
 * Request options interface
 */
export interface RequestOptions {
  method: HttpMethod;
  url: string;
  headers?: Record<string, string>;
  data?: any;
  params?: Record<string, string | number | boolean>;
  timeout?: number;
  useCertificate?: boolean;
  retryConfig?: RetryConfig;
}

/**
 * Retry configuration interface
 */
export interface RetryConfig {
  attempts: number;
  delayMs: number;
  statusCodes?: number[];
  useExponentialBackoff?: boolean;
  maxBackoffMs?: number;
}

/**
 * HTTP response interface
 */
export interface HttpResponse<T = any> {
  status: number;
  statusText: string;
  data: T;
  headers: Record<string, string>;
  requestTime: number;
  url: string;
  method: HttpMethod;
}

src/framework/utils/config.ts
----------------------------------
import * as dotenv from 'dotenv';
import * as path from 'path';
import * as fs from 'fs';

/**
 * Configuration manager class
 * Loads environment variables from .env files
 */
export class ConfigManager {
  private static instance: ConfigManager;
  private initialized = false;
  private env: Record<string, string> = {};

  private constructor() {}

  /**
   * Get singleton instance
   */
  public static getInstance(): ConfigManager {
    if (!ConfigManager.instance) {
      ConfigManager.instance = new ConfigManager();
    }
    return ConfigManager.instance;
  }

  /**
   * Initialize configuration
   */
  public initialize(): void {
    if (this.initialized) {
      return;
    }

    // Load default .env file
    this.loadEnvFile('.env');

    // Load environment-specific .env file
    const nodeEnv = process.env.NODE_ENV || 'dev';
    this.loadEnvFile(`.env.${nodeEnv}`);

    this.initialized = true;
    console.log(`Configuration initialized for environment: ${nodeEnv}`);
  }

  /**
   * Load environment variables from file
   */
  private loadEnvFile(filename: string): void {
    const envPath = path.resolve(process.cwd(), 'config', filename);

    try {
      if (fs.existsSync(envPath)) {
        const result = dotenv.config({ path: envPath });
        
        if (result.error) {
          console.error(`Error loading ${filename}: ${result.error.message}`);
        } else {
          Object.assign(this.env, result.parsed);
          console.log(`Loaded configuration from ${filename}`);
        }
      } else {
        console.warn(`Configuration file not found: ${envPath}`);
      }
    } catch (error) {
      console.error(`Error processing ${filename}: ${(error as Error).message}`);
    }
  }

  /**
   * Get environment variable
   */
  public get(key: string, defaultValue?: string): string {
    if (!this.initialized) {
      this.initialize();
    }

    const value = process.env[key] || this.env[key];
    if (value === undefined) {
      if (defaultValue !== undefined) {
        return defaultValue;
      }
      throw new Error(`Configuration key not found: ${key}`);
    }
    return value;
  }

  /**
   * Get environment variable as number
   */
  public getNumber(key: string, defaultValue?: number): number {
    const value = this.get(key, defaultValue?.toString());
    const num = Number(value);
    
    if (isNaN(num)) {
      throw new Error(`Invalid number format for key ${key}: ${value}`);
    }
    
    return num;
  }

  /**
   * Get environment variable as boolean
   */
  public getBoolean(key: string, defaultValue?: boolean): boolean {
    const value = this.get(key, defaultValue?.toString());
    return value.toLowerCase() === 'true';
  }
}

// Export singleton instance
export const config = ConfigManager.getInstance();

src/framework/utils/logger.ts
---------------------------------
import * as winston from 'winston';
import * as path from 'path';
import * as fs from 'fs';
import { config } from './config';

// Create logs directory if it doesn't exist
const logsDir = path.join(process.cwd(), 'logs');
if (!fs.existsSync(logsDir)) {
  fs.mkdirSync(logsDir, { recursive: true });
}

// Define log file paths
const logFilePath = path.join(logsDir, 'api-test.log');
const errorLogFilePath = path.join(logsDir, 'error.log');

// Custom format for logs
const customFormat = winston.format.combine(
  winston.format.timestamp({
    format: 'YYYY-MM-DD HH:mm:ss'
  }),
  winston.format.errors({ stack: true }),
  winston.format.printf(({ level, message, timestamp, ...meta }) => {
    let output = `${timestamp} [${level.toUpperCase()}]: ${message}`;
    
    if (Object.keys(meta).length > 0) {
      // Handle error objects specially
      if (meta.error) {
        if (meta.error instanceof Error) {
          output += ` - ${meta.error.message}`;
          if (meta.error.stack) {
            output += `\n${meta.error.stack}`;
          }
        } else {
          output += ` - ${JSON.stringify(meta.error)}`;
        }
        delete meta.error;
      }
      
      // Add remaining metadata
      if (Object.keys(meta).length > 0) {
        output += ` ${JSON.stringify(meta)}`;
      }
    }
    
    return output;
  })
);

/**
 * Logger class
 */
export class Logger {
  private static instance: Logger;
  private logger: winston.Logger;

  private constructor() {
    // Initialize the logger
    this.logger = winston.createLogger({
      level: config.get('LOG_LEVEL', 'info'),
      format: customFormat,
      transports: [
        // Write all errors to the error log
        new winston.transports.File({ 
          filename: errorLogFilePath, 
          level: 'error' 
        }),
        
        // Write all logs to the combined log file
        new winston.transports.File({ 
          filename: logFilePath 
        }),
        
        // Write to console
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            customFormat
          )
        })
      ]
    });
  }

  /**
   * Get singleton instance
   */
  public static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  /**
   * Log at debug level
   */
  public debug(message: string, meta?: Record<string, any>): void {
    this.logger.debug(message, meta);
  }

  /**
   * Log at info level
   */
  public info(message: string, meta?: Record<string, any>): void {
    this.logger.info(message, meta);
  }

  /**
   * Log at warning level
   */
  public warn(message: string, meta?: Record<string, any>): void {
    this.logger.warn(message, meta);
  }

  /**
   * Log at error level
   */
  public error(message: string, meta?: Record<string, any>): void {
    this.logger.error(message, meta);
  }

  /**
   * Log HTTP request
   */
  public logRequest(method: string, url: string, headers?: Record<string, string>, data?: any): void {
    this.debug(`HTTP Request: ${method} ${url}`, {
      headers,
      body: data
    });
  }

  /**
   * Log HTTP response
   */
  public logResponse(status: number, url: string, data?: any, time?: number): void {
    this.debug(`HTTP Response: ${status} from ${url} (${time}ms)`, {
      body: data
    });
  }
}

// Export singleton instance
export const logger = Logger.getInstance();

src/framework/utils/cert-manager.ts
-------------------------------------
import * as fs from 'fs';
import * as path from 'path';
import { config } from './config';
import { logger } from './logger';

/**
 * Certificate Manager class
 * Handles loading and providing PFX certificates
 */
export class CertificateManager {
  private static instance: CertificateManager;
  private certificateBuffer: Buffer | null = null;
  private passphrase: string = '';
  private initialized = false;

  private constructor() {}

  /**
   * Get singleton instance
   */
  public static getInstance(): CertificateManager {
    if (!CertificateManager.instance) {
      CertificateManager.instance = new CertificateManager();
    }
    return CertificateManager.instance;
  }

  /**
   * Initialize certificate manager
   */
  public initialize(): void {
    if (this.initialized) {
      return;
    }

    try {
      const certPath = path.resolve(process.cwd(), config.get('CERTIFICATE_PATH'));
      this.passphrase = config.get('CERTIFICATE_PASSPHRASE');

      if (!fs.existsSync(certPath)) {
        logger.warn(`Certificate file not found: ${certPath}`);
        this.initialized = true;
        return;
      }

      this.certificateBuffer = fs.readFileSync(certPath);
      logger.info(`Certificate loaded successfully from: ${certPath}`);
      this.initialized = true;
    } catch (error) {
      logger.error('Failed to initialize certificate manager', { error });
      throw new Error(`Certificate initialization failed: ${(error as Error).message}`);
    }
  }

  /**
   * Check if a certificate is available
   */
  public hasCertificate(): boolean {
    if (!this.initialized) {
      this.initialize();
    }
    return this.certificateBuffer !== null;
  }

  /**
   * Get certificate buffer
   */
  public getCertificateBuffer(): Buffer | null {
    if (!this.initialized) {
      this.initialize();
    }
    return this.certificateBuffer;
  }

  /**
   * Get certificate passphrase
   */
  public getPassphrase(): string {
    if (!this.initialized) {
      this.initialize();
    }
    return this.passphrase;
  }

  /**
   * Get certificate options for HTTPS requests
   */
  public getCertificateOptions(): { pfx: Buffer, passphrase: string } | null {
    if (!this.initialized) {
      this.initialize();
    }

    if (!this.certificateBuffer) {
      return null;
    }

    return {
      pfx: this.certificateBuffer,
      passphrase: this.passphrase
    };
  }
}

// Export singleton instance
export const certManager = CertificateManager.getInstance();

src/framework/utils/retry.ts
----------------------------
import { logger } from './logger';

/**
 * Retry Handler for API requests
 */
export class RetryHandler {
  /**
   * Execute a function with retry logic
   * @param fn - Function to execute
   * @param attempts - Maximum number of retry attempts
   * @param delayMs - Base delay between retries in milliseconds
   * @param statusCodes - HTTP status codes that should trigger a retry
   * @param useExponentialBackoff - Whether to use exponential backoff
   * @param maxBackoffMs - Maximum backoff time in milliseconds
   */
  public static async executeWithRetry<T>(
    fn: () => Promise<T>,
    attempts: number = 3,
    delayMs: number = 1000,
    statusCodes: number[] = [408, 429, 500, 502, 503, 504],
    useExponentialBackoff: boolean = true,
    maxBackoffMs: number = 30000
  ): Promise<T> {
    let lastError: Error | null = null;
    
    for (let attempt = 1; attempt <= attempts + 1; attempt++) {
      try {
        // Execute the function
        const result = await fn();
        
        // If this is a retry attempt, log success
        if (attempt > 1) {
          logger.info(`Request succeeded after ${attempt - 1} ${attempt === 2 ? 'retry' : 'retries'}`);
        }
        
        return result;
      } catch (error: any) {
        lastError = error instanceof Error ? error : new Error(String(error));
        
        // Check if we've reached the maximum number of retries
        if (attempt > attempts) {
          logger.error(`Request failed after ${attempts} retries`, { error: lastError });
          throw lastError;
        }
        
        // Extract status code if available
        let statusCode: number | undefined;
        if (error.status) {
          statusCode = error.status;
        } else if (error.statusCode) {
          statusCode = error.statusCode;
        } else if (error.response?.status) {
          statusCode = error.response.status;
        }
        
        // Check if the error is a network error
        const isNetworkError = 
          !statusCode && 
          (error.code === 'ECONNABORTED' || 
           error.code === 'ETIMEDOUT' || 
           error.code === 'ECONNREFUSED' ||
           error.code === 'ENOTFOUND' ||
           error.message?.includes('timeout'));
        
        // Determine if we should retry
        const shouldRetry = isNetworkError || (statusCode && statusCodes.includes(statusCode));
        
        if (!shouldRetry) {
          logger.error(`Request failed with status ${statusCode || 'unknown'}, not retrying`, { error: lastError });
          throw lastError;
        }
        
        // Calculate delay with exponential backoff if enabled
        let currentDelay = delayMs;
        if (useExponentialBackoff) {
          currentDelay = Math.min(
            delayMs * Math.pow(2, attempt - 1), 
            maxBackoffMs
          );
        }
        
        logger.warn(`Request attempt ${attempt} failed, retrying in ${currentDelay}ms`, {
          statusCode,
          error: lastError.message
        });
        
        // Wait before retrying
        await RetryHandler.delay(currentDelay);
      }
    }
    
    throw lastError || new Error('Unknown error during retry');
  }

  /**
   * Simple delay function
   */
  private static async delay(ms: number): Promise<void> {
    return new Promise(resolve => {
      const timeout = setTimeout(resolve, ms);
      // Ensure the timeout doesn't keep the Node.js process alive
      if (timeout.unref) {
        timeout.unref();
      }
    });
  }
}

src/framework/http/http-client.ts
--------------------------------------
import * as http from 'http';
import * as https from 'https';
import { URL } from 'url';
import { HttpMethod, RequestOptions, HttpResponse, RetryConfig } from './types';
import { certManager } from '../utils/cert-manager';
import { logger } from '../utils/logger';
import { config } from '../utils/config';
import { RetryHandler } from '../utils/retry';

/**
 * HTTP Client class
 * Provides methods for making HTTP requests
 */
export class HttpClient {
  private static instance: HttpClient;

  private constructor() {}

  /**
   * Get singleton instance
   */
  public static getInstance(): HttpClient {
    if (!HttpClient.instance) {
      HttpClient.instance = new HttpClient();
    }
    return HttpClient.instance;
  }

  /**
   * Make HTTP request
   */
  public async request<T = any>(options: RequestOptions): Promise<HttpResponse<T>> {
    const { method, url, headers = {}, data, params, timeout, useCertificate = true } = options;
    
    // Apply default timeout if not specified
    const requestTimeout = timeout || config.getNumber('REQUEST_TIMEOUT_MS', 30000);
    
    // Set retry configuration
    const retryConfig: RetryConfig = options.retryConfig || {
      attempts: config.getNumber('RETRY_ATTEMPTS', 3),
      delayMs: config.getNumber('RETRY_DELAY_MS', 1000),
      statusCodes: [408, 429, 500, 502, 503, 504],
      useExponentialBackoff: true,
      maxBackoffMs: 30000
    };

    // Execute request with retry
    return RetryHandler.executeWithRetry(
      () => this.executeRequest<T>(method, url, headers, data, params, requestTimeout, useCertificate),
      retryConfig.attempts,
      retryConfig.delayMs,
      retryConfig.statusCodes,
      retryConfig.useExponentialBackoff,
      retryConfig.maxBackoffMs
    );
  }

  /**
   * Execute a single HTTP request
   */
  private async executeRequest<T = any>(
    method: HttpMethod, 
    url: string, 
    headers: Record<string, string> = {}, 
    data?: any,
    params?: Record<string, string | number | boolean>,
    timeout: number = 30000,
    useCertificate: boolean = true
  ): Promise<HttpResponse<T>> {
    // Parse the URL
    const parsedUrl = new URL(url);
    
    // Add query parameters if provided
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        parsedUrl.searchParams.append(key, String(value));
      });
    }
    
    // Determine whether to use HTTP or HTTPS
    const isHttps = parsedUrl.protocol === 'https:';
    const httpModule = isHttps ? https : http;
    
    // Set standard headers
    const requestHeaders: Record<string, string> = {
      'Accept': 'application/json',
      ...headers
    };
    
    // Add Content-Type header for requests with body
    if (data && !requestHeaders['Content-Type']) {
      requestHeaders['Content-Type'] = 'application/json';
    }
    
    // Prepare request options
    const requestOptions: http.RequestOptions = {
      method,
      hostname: parsedUrl.hostname,
      port: parsedUrl.port || (isHttps ? '443' : '80'),
      path: `${parsedUrl.pathname}${parsedUrl.search}`,
      headers: requestHeaders,
      timeout
    };
    
    // Add certificate options if using HTTPS and certificates are enabled
    if (isHttps && useCertificate && certManager.hasCertificate()) {
      const certOptions = certManager.getCertificateOptions();
      if (certOptions) {
        requestOptions.pfx = certOptions.pfx;
        requestOptions.passphrase = certOptions.passphrase;
      }
    }
    
    // Log the request
    logger.logRequest(method, parsedUrl.toString(), requestHeaders, data);
    
    // Execute the request
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      
      // Create request
      const req = httpModule.request(requestOptions, (res) => {
        const responseChunks: Buffer[] = [];
        
        // Collect response data
        res.on('data', (chunk) => {
          responseChunks.push(Buffer.from(chunk));
        });
        
        // Process response when complete
        res.on('end', () => {
          const requestTime = Date.now() - startTime;
          const responseBody = Buffer.concat(responseChunks).toString('utf8');
          
          // Parse response data based on content type
          let parsedData: any;
          try {
            const contentType = res.headers['content-type'] || '';
            if (contentType.includes('application/json')) {
              parsedData = responseBody ? JSON.parse(responseBody) : null;
            } else {
              parsedData = responseBody;
            }
          } catch (error) {
            logger.warn('Failed to parse response as JSON', { error });
            parsedData = responseBody;
          }
          
          // Create response object
          const response: HttpResponse<T> = {
            status: res.statusCode || 0,
            statusText: res.statusMessage || '',
            data: parsedData,
            headers: res.headers as Record<string, string>,
            requestTime,
            url: parsedUrl.toString(),
            method
          };
          
          // Log the response
          logger.logResponse(response.status, parsedUrl.toString(), response.data, requestTime);
          
          // Resolve or reject based on status code
          if (response.status >= 200 && response.status < 300) {
            resolve(response);
          } else {
            const error = new Error(`Request failed with status ${response.status}: ${response.statusText}`);
            (error as any).response = response;
            (error as any).status = response.status;
            reject(error);
          }
        });
      });
      
      // Handle request errors
      req.on('error', (error) => {
        logger.error('Request error', { error, url: parsedUrl.toString() });
        reject(error);
      });
      
      // Handle timeout
      req.on('timeout', () => {
        logger.error('Request timeout', { url: parsedUrl.toString(), timeout });
        req.destroy(new Error(`Request timeout after ${timeout}ms`));
      });
      
      // Send request body for methods that support it
      if (data && ['POST', 'PUT', 'PATCH'].includes(method)) {
        const requestData = typeof data === 'string' ? data : JSON.stringify(data);
        req.write(requestData);
      }
      
      // End the request
      req.end();
    });
  }

  /**
   * GET request method
   */
  public async get<T = any>(url: string, params?: Record<string, string | number | boolean>, options: Omit<RequestOptions, 'method' | 'url' | 'params'> = {}): Promise<HttpResponse<T>> {
    return this.request<T>({ 
      method: 'GET', 
      url, 
      params, 
      ...options 
    });
  }

  /**
   * POST request method
   */
  public async post<T = any>(url: string, data?: any, options: Omit<RequestOptions, 'method' | 'url' | 'data'> = {}): Promise<HttpResponse<T>> {
    return this.request<T>({ 
      method: 'POST', 
      url, 
      data, 
      ...options 
    });
  }

  /**
   * PUT request method
   */
  public async put<T = any>(url: string, data?: any, options: Omit<RequestOptions, 'method' | 'url' | 'data'> = {}): Promise<HttpResponse<T>> {
    return this.request<T>({ 
      method: 'PUT', 
      url, 
      data, 
      ...options 
    });
  }

  /**
   * DELETE request method
   */
  public async delete<T = any>(url: string, options: Omit<RequestOptions, 'method' | 'url'> = {}): Promise<HttpResponse<T>> {
    return this.request<T>({ 
      method: 'DELETE', 
      url, 
      ...options 
    });
  }

  /**
   * PATCH request method
   */
  public async patch<T = any>(url: string, data?: any, options: Omit<RequestOptions, 'method' | 'url' | 'data'> = {}): Promise<HttpResponse<T>> {
    return this.request<T>({ 
      method: 'PATCH', 
      url, 
      data, 
      ...options 
    });
  }
}

// Export singleton instance
export const httpClient = HttpClient.getInstance();

src/clients/base-client.ts
------------------------------
import { httpClient } from '../framework/http/http-client';
import { HttpResponse, RequestOptions } from '../framework/http/types';
import { config } from '../framework/utils/config';
import { logger } from '../framework/utils/logger';

/**
 * Base API Client class
 * All specific API clients should extend this class
 */
export abstract class BaseApiClient {
  protected baseUrl: string;
  protected defaultHeaders: Record<string, string>;

  /**
   * Create a new API client
   * @param baseUrl - Base URL for API calls (optional, uses API_BASE_URL from config if not provided)
   */
  constructor(baseUrl?: string) {
    this.baseUrl = baseUrl || config.get('API_BASE_URL');
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    };
  }

  /**
   * Set base URL
   */
  public setBaseUrl(url: string): void {
    this.baseUrl = url;
  }

  /**
   * Get base URL
   */
  public getBaseUrl(): string {
    return this.baseUrl;
  }

  /**
   * Set default headers
   */
  public setDefaultHeaders(headers: Record<string, string>): void {
    this.defaultHeaders = {
      ...this.defaultHeaders,
      ...headers
    };
  }

  /**
   * Add a default header
   */
  public addDefaultHeader(name: string, value: string): void {
    this.defaultHeaders[name] = value;
  }

  /**
   * Get default headers
   */
  public getDefaultHeaders(): Record<string, string> {
    return this.defaultHeaders;
  }

  /**
   * Resolve URL by appending endpoint to base URL
   */
  protected resolveUrl(endpoint: string): string {
    // Ensure there's exactly one slash between baseUrl and endpoint
    const baseWithSlash = this.baseUrl.endsWith('/') ? this.baseUrl : `${this.baseUrl}/`;
    const endpointWithoutSlash = endpoint.startsWith('/') ? endpoint.substring(1) : endpoint;
    
    return `${baseWithSlash}${endpointWithoutSlash}`;
  }

  /**
   * Make a GET request
   */
  protected async get<T = any>(endpoint: string, params?: Record<string, string | number | boolean>, options: Partial<RequestOptions> = {}): Promise<HttpResponse<T>> {
    const url = this.resolveUrl(endpoint);
    return httpClient.get<T>(url, params, {
      headers: { ...this.defaultHeaders, ...options.headers },
      ...options
    });
  }

  /**
   * Make a POST request
   */
  protected async post<T = any>(endpoint: string, data?: any, options: Partial<RequestOptions> = {}): Promise<HttpResponse<T>> {
    const url = this.resolveUrl(endpoint);
    return httpClient.post<T>(url, data, {
      headers: { ...this.defaultHeaders, ...options.headers },
      ...options
    });
  }

  /**
   * Make a PUT request
   */
  protected async put<T = any>(endpoint: string, data?: any, options: Partial<RequestOptions> = {}): Promise<HttpResponse<T>> {
    const url = this.resolveUrl(endpoint);
    return httpClient.put<T>(url, data, {
      headers: { ...this.defaultHeaders, ...options.headers },
      ...options
    });
  }

  /**
   * Make a DELETE request
   */
  protected async delete<T = any>(endpoint: string, options: Partial<RequestOptions> = {}): Promise<HttpResponse<T>> {
    const url = this.resolveUrl(endpoint);
    return httpClient.delete<T>(url, {
      headers: { ...this.defaultHeaders, ...options.headers },
      ...options
    });
  }

  /**
   * Make a PATCH request
   */
  protected async patch<T = any>(endpoint: string, data?: any, options: Partial<RequestOptions> = {}): Promise<HttpResponse<T>> {
    const url = this.resolveUrl(endpoint);
    return httpClient.patch<T>(url, data, {
      headers: { ...this.defaultHeaders, ...options.headers },
      ...options
    });
  }

  /**
   * Wait for a condition to be met with polling
   */
  protected async pollUntil<T = any>(
    endpoint: string,
    condition: (response: HttpResponse<T>) => boolean,
    options: {
      interval?: number;
      timeout?: number;
      maxAttempts?: number;
      params?: Record<string, string | number | boolean>;
      requestOptions?: Partial<RequestOptions>;
    } = {}
  ): Promise<HttpResponse<T>> {
    const {
      interval = 2000,
      timeout = 60000,
      maxAttempts = 30,
      params = {},
      requestOptions = {}
    } = options;
    
    const startTime = Date.now();
    let attempts = 0;
    
    logger.info(`Starting polling for endpoint: ${endpoint}`);
    
    while (true) {
      attempts++;
      try {
        const response = await this.get<T>(endpoint, params, requestOptions);
        
        if (condition(response)) {
          logger.info(`Polling condition met after ${attempts} attempts (${Date.now() - startTime}ms)`);
          return response;
        }
        
        logger.debug(`Polling attempt ${attempts}: condition not met yet`);
      } catch (error) {
        logger.warn(`Polling attempt ${attempts} failed with error`, { error });
      }
      
      // Check if we've reached the maximum number of attempts
      if (maxAttempts && attempts >= maxAttempts) {
        throw new Error(`Polling reached maximum attempts (${maxAttempts})`);
      }
      
      // Check if we've reached the timeout
      if (Date.now() - startTime >= timeout) {
        throw new Error(`Polling timed out after ${timeout}ms`);
      }
      
      // Wait before the next attempt
      await new Promise(resolve => {
        const timeoutId = setTimeout(resolve, interval);
        if (timeoutId.unref) {
          timeoutId.unref();
        }
      });
    }
  }
}

asset-client.ts
---------------
import { BaseApiClient } from './base-client';
import { HttpResponse } from '../framework/http/types';
import { logger } from '../framework/utils/logger';

/**
 * Asset API response interface
 */
export interface AssetLayoutResponse {
  status: string;
  data: any;
  messageId: number;
}

/**
 * Asset API request interface
 */
export interface AssetLayoutRequest {
  messageId: number;
  dealId: number;
  reportDate: string;
}

/**
 * Asset API Client
 * Handles API calls to the Asset endpoints
 */
export class AssetApiClient extends BaseApiClient {
  /**
   * Create a new Asset API client
   * @param baseUrl - Base URL for API calls (optional)
   */
  constructor(baseUrl?: string) {
    super(baseUrl);
    logger.info('Asset API client initialized');
  }

  /**
   * Get asset layout
   * @param request - Asset layout request
   */
  public async getAssetLayout(request: AssetLayoutRequest): Promise<HttpResponse<AssetLayoutResponse>> {
    logger.info('Requesting asset layout', { request });
    
    return this.post<AssetLayoutResponse>('/assets/assetlayout', request);
  }

  /**
   * Get asset layout and wait for completion
   * Use this when the operation might take time to complete
   * @param request - Asset layout request
   */
  public async getAssetLayoutWithPolling(request: AssetLayoutRequest): Promise<HttpResponse<AssetLayoutResponse>> {
    logger.info('Requesting asset layout with polling', { request });
    
    // First, submit the request
    const initialResponse = await this.post<AssetLayoutResponse>('/assets/assetlayout', request);
    
    // If the result is already available, return it
    if (initialResponse.data.status === 'COMPLETED') {
      return initialResponse;
    }
    
    // Otherwise, poll until completion
    return this.pollUntil<AssetLayoutResponse>(
      `/assets/assetlayout/status/${request.messageId}`,
      (response) => response.data.status === 'COMPLETED',
      {
        interval: 5000,   // Check every 5 seconds
        timeout: 300000,  // Timeout after 5 minutes
        maxAttempts: 60
      }
    );
  }

  /**
   * Get asset by ID
   * @param assetId - Asset ID
   */
  public async getAssetById(assetId: string): Promise<HttpResponse<any>> {
    logger.info(`Requesting asset by ID: ${assetId}`);
    
    return this.get<any>(`/assets/${assetId}`);
  }

  /**
   * Search assets
   * @param params - Search parameters
   */
  public async searchAssets(params: Record<string, string | number | boolean>): Promise<HttpResponse<any>> {
    logger.info('Searching assets', { params });
    
    return this.get<any>('/assets/search', params);
  }
}

src/framework/utils/setup-tests.ts
-------------------------------------
/**
 * Test setup file
 * Initializes the required components before running tests
 */

import { config } from './config';
import { logger } from './logger';
import { certManager } from './cert-manager';

// Initialize configuration
config.initialize();

// Initialize certificate manager
certManager.initialize();

// Set up global error handlers
process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Promise Rejection', { reason });
});

process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception', { error });
});

// Log test environment info
logger.info('Test environment initialized', {
  environment: process.env.NODE_ENV || 'dev',
  baseUrl: config.get('API_BASE_URL'),
  hasCertificate: certManager.hasCertificate()
});

src/test/asset-layout.test.ts
---------------------------
import { AssetApiClient } from '../clients/asset-client';
import { logger } from '../framework/utils/logger';

describe('Asset Layout API', () => {
  const assetClient = new AssetApiClient();
  
  // Set test timeout to 2 minutes to accommodate for polling
  jest.setTimeout(120000);
  
  beforeAll(() => {
    logger.info('Starting Asset Layout API tests');
  });
  
  afterAll(() => {
    logger.info('Completed Asset Layout API tests');
  });
  
  it('should retrieve asset layout successfully', async () => {
    // Create test request
    const request = {
      messageId: Math.floor(Math.random() * 1000000),  // Random message ID
      dealId: 34384,
      reportDate: '2024-03-31'
    };
    
    try {
      // Call API
      const response = await assetClient.getAssetLayout(request);
      
      // Verify response
      expect(response.status).toBe(200);
      expect(response.data).toBeDefined();
      expect(response.data.messageId).toBe(request.messageId);
      
      // Log success
      logger.info('Asset layout retrieved successfully', { 
        messageId: response.data.messageId,
        status: response.data.status 
      });
    } catch (error) {
      // Log and rethrow to fail the test
      logger.error('Asset layout test failed', { error });
      throw error;
    }
  });
  
  it('should retrieve asset layout with polling', async () => {
    // Create test request
    const request = {
      messageId: Math.floor(Math.random() * 1000000),  // Random message ID
      dealId: 34384,
      reportDate: '2024-03-31'
    };
    
    try {
      // Call API with polling
      const response = await assetClient.getAssetLayoutWithPolling(request);
      
      // Verify response
      expect(response.status).toBe(200);
      expect(response.data).toBeDefined();
      expect(response.data.status).toBe('COMPLETED');
      
      // Log success
      logger.info('Asset layout with polling retrieved successfully', { 
        messageId: response.data.messageId,
        status: response.data.status 
      });
    } catch (error) {
      // Log and rethrow to fail the test
      logger.error('Asset layout polling test failed', { error });
      throw error;
    }
  });
});

src/framework/index.ts
-------------------------
/**
 * Framework index file
 * Exports all framework components
 */

// HTTP module exports
export { httpClient } from './http/http-client';
export { HttpMethod, RequestOptions, HttpResponse, RetryConfig } from './http/types';

// Utility exports
export { config } from './utils/config';
export { logger } from './utils/logger';
export { certManager } from './utils/cert-manager';
export { RetryHandler } from './utils/retry';

src/index.ts
-----------------

/**
 * Main index file
 * Exports all components for external use
 */

// Export framework components
export * from './framework';

// Export client classes
export { BaseApiClient } from './clients/base-client';
export { AssetApiClient } from './clients/asset-client';

// Initialize required components
import { config } from './framework/utils/config';
import { certManager } from './framework/utils/cert-manager';
import { logger } from './framework/utils/logger';

// Initialize configuration
config.initialize();

// Initialize certificate manager
certManager.initialize();

logger.info('API Testing Framework initialized');

README.md
-------------
# Simple API Testing Framework

A plug-and-play API testing framework that requires minimal configuration. This framework is designed for testing RESTful APIs that use client certificates for authentication.

## Features

- **Simple & Lightweight**: Built using only Node.js native HTTP modules
- **Certificate Authentication**: Supports PFX certificates with passphrase
- **Environment Configuration**: Easy switching between environments (dev, sit, prod)
- **Automatic Retries**: Built-in retry mechanism for transient failures
- **Polling Support**: Wait for long-running operations to complete
- **Detailed Logging**: Comprehensive logging for requests and responses
- **Type Safety**: Written in TypeScript for better developer experience

## Getting Started

### Prerequisites

- Node.js 14+
- npm or yarn

### Installation

1. Clone the repository:
   ```
   git clone https://github.com/yourusername/api-test-framework.git
   cd api-test-framework
   ```

2. Install dependencies:
   ```
   npm install
   ```

3. Add your client certificate:
   - Place your `.pfx` certificate in the `certs` directory
   - Update the config files with the certificate path and passphrase

4. Configure your API endpoints:
   - Update the `.env` files in the `config` directory with your API base URLs

### Running Tests

Run tests in the default environment:
```
npm test
```

Run tests in a specific environment:
```
npm run test:dev    # Development environment
npm run test:sit    # SIT environment
npm run test:prod   # Production environment
```

Run in debug mode:
```
npm run debug
```

## Framework Structure

```
/api-test-framework
  ├── config/               # Environment configuration
  ├── certs/                # Client certificates
  ├── src/                  # Source code
  │   ├── framework/        # Core framework
  │   ├── clients/          # API clients
  │   └── tests/            # Test files
  └── logs/                 # Log files (created at runtime)
```

## Creating a New API Client

To add a new API client, create a new class that extends `BaseApiClient`:

```typescript
// src/clients/my-client.ts
import { BaseApiClient } from './base-client';
import { HttpResponse } from '../framework/http/types';

export class MyApiClient extends BaseApiClient {
  constructor(baseUrl?: string) {
    super(baseUrl);
  }

  // Add your API methods
  public async getMyResource(id: string): Promise<HttpResponse<any>> {
    return this.get(`/my-resources/${id}`);
  }

  public async createMyResource(data: any): Promise<HttpResponse<any>> {
    return this.post('/my-resources', data);
  }
}
```

## Writing Tests

Create test files in the `src/tests` directory:

```typescript
// src/tests/my-resource.test.ts
import { MyApiClient } from '../clients/my-client';
import { logger } from '../framework/utils/logger';

describe('My Resource API', () => {
  const client = new MyApiClient();
  
  it('should get a resource', async () => {
    const response = await client.getMyResource('123');
    expect(response.status).toBe(200);
    expect(response.data).toBeDefined();
  });
  
  it('should create a resource', async () => {
    const data = { name: 'Test Resource' };
    const response = await client.createMyResource(data);
    expect(response.status).toBe(201);
  });
});
```

## Environment Configuration

Configure different environments by updating the `.env` files in the `config` directory:

```properties
# config/.env.sit
API_BASE_URL=https://api-sit.example.com/v1
CERTIFICATE_PATH=./certs/my-cert.pfx
CERTIFICATE_PASSPHRASE=mypassphrase
REQUEST_TIMEOUT_MS=30000
RETRY_ATTEMPTS=3
RETRY_DELAY_MS=1000
LOG_LEVEL=info
```

## Advanced Features

### Polling for Long-Running Operations

```typescript
// Wait for a resource to be in "COMPLETED" status
const response = await client.pollUntil(
  `/resources/${id}/status`,
  (response) => response.data.status === 'COMPLETED',
  {
    interval: 5000,    // Check every 5 seconds
    timeout: 300000,   // Timeout after 5 minutes
    maxAttempts: 60    // Maximum 60 attempts
  }
);
```

### Custom Retry Configuration

```typescript
// Custom retry configuration for a specific request
const response = await client.get('/flaky-endpoint', {}, {
  retryConfig: {
    attempts: 5,
    delayMs: 2000,
    statusCodes: [429, 500, 502, 503, 504],
    useExponentialBackoff: true,
    maxBackoffMs: 60000
  }
});
```

### Custom Headers

```typescript
// Add custom headers for a specific request
const response = await client.post('/secure-endpoint', data, {
  headers: {
    'X-Custom-Header': 'custom-value',
    'Authorization': 'Bearer token123'
  }
});
```

## Troubleshooting

### Certificate Issues
- Ensure your certificate file exists in the specified path
- Verify the passphrase is correct
- Check that the certificate is valid for the target environment

### Connection Issues
- Verify the API base URL is correct
- Check network connectivity to the API server
- Ensure no proxy or firewall is blocking the connection

### Debugging
- Set `LOG_LEVEL=debug` in the environment config for detailed logs
- Use `npm run debug` to run with Node.js inspector
- Check the `logs` directory for detailed log files

## License

This project is licensed under the ISC License.

http-client.ts
----------------------

import * as http from 'http';
import * as https from 'https';
import { URL } from 'url';
import { HttpMethod, RequestOptions, HttpResponse, RetryConfig } from './types';
import { certManager } from '../utils/cert-manager';
import { logger } from '../utils/logger';
import { config } from '../utils/config';
import { RetryHandler } from '../utils/retry';

/**
 * HTTP Client class
 * Provides methods for making HTTP requests
 */
export class HttpClient {
  private static instance: HttpClient;

  private constructor() {}

  /**
   * Get singleton instance
   */
  public static getInstance(): HttpClient {
    if (!HttpClient.instance) {
      HttpClient.instance = new HttpClient();
    }
    return HttpClient.instance;
  }

  /**
   * Make HTTP request
   */
  public async request<T = any>(options: RequestOptions): Promise<HttpResponse<T>> {
    const { method, url, headers = {}, data, params, timeout, useCertificate = true } = options;
    
    // Apply default timeout if not specified
    const requestTimeout = timeout || config.getNumber('REQUEST_TIMEOUT_MS', 30000);
    
    // Set retry configuration
    const retryConfig: RetryConfig = options.retryConfig || {
      attempts: config.getNumber('RETRY_ATTEMPTS', 3),
      delayMs: config.getNumber('RETRY_DELAY_MS', 1000),
      statusCodes: [408, 429, 500, 502, 503, 504],
      useExponentialBackoff: true,
      maxBackoffMs: 30000
    };

    // Execute request with retry
    return RetryHandler.executeWithRetry(
      () => this.executeRequest<T>(method, url, headers, data, params, requestTimeout, useCertificate),
      retryConfig.attempts,
      retryConfig.delayMs,
      retryConfig.statusCodes,
      retryConfig.useExponentialBackoff,
      retryConfig.maxBackoffMs
    );
  }

  /**
   * Execute a single HTTP request
   */
  private async executeRequest<T = any>(
    method: HttpMethod, 
    url: string, 
    headers: Record<string, string> = {}, 
    data?: any,
    params?: Record<string, string | number | boolean>,
    timeout: number = 30000,
    useCertificate: boolean = true
  ): Promise<HttpResponse<T>> {
    // Parse the URL
    const parsedUrl = new URL(url);
    
    // Add query parameters if provided
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        parsedUrl.searchParams.append(key, String(value));
      });
    }
    
    // Determine whether to use HTTP or HTTPS
    const isHttps = parsedUrl.protocol === 'https:';
    const httpModule = isHttps ? https : http;
    
    // Set standard headers
    const requestHeaders: Record<string, string> = {
      'Accept': 'application/json',
      ...headers
    };
    
    // Add Content-Type header for requests with body
    if (data && !requestHeaders['Content-Type']) {
      requestHeaders['Content-Type'] = 'application/json';
    }
    
    // Prepare request options
    const requestOptions: http.RequestOptions = {
      method,
      hostname: parsedUrl.hostname,
      port: parsedUrl.port || (isHttps ? '443' : '80'),
      path: `${parsedUrl.pathname}${parsedUrl.search}`,
      headers: requestHeaders,
      timeout
    };
    
    // Add certificate options if using HTTPS and certificates are enabled
    if (isHttps && useCertificate && certManager.hasCertificate()) {
      const certOptions = certManager.getCertificateOptions();
      if (certOptions) {
        requestOptions.pfx = certOptions.pfx;
        requestOptions.passphrase = certOptions.passphrase;
      }
    }
    
    // Log the request
    logger.logRequest(method, parsedUrl.toString(), requestHeaders, data);
    
    // Execute the request
    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      
      // Safety timeout to prevent hanging
      const safetyTimeoutId = global.setTimeout(() => {
        logger.error('Global safety timeout', { url: parsedUrl.toString(), timeout: timeout * 2 });
        req.destroy(new Error(`Global timeout after ${timeout * 2}ms`));
      }, timeout * 2);
      
      // Create request
      const req = httpModule.request(requestOptions, (res) => {
        const responseChunks: Buffer[] = [];
        
        // Set reasonable timeout for receiving data
        res.setTimeout(timeout, () => {
          logger.error('Response timeout', { url: parsedUrl.toString() });
          req.destroy(new Error(`Response timeout after ${timeout}ms`));
        });
        
        // Collect response data
        res.on('data', (chunk) => {
          responseChunks.push(Buffer.from(chunk));
        });
        
        // Process response when complete
        res.on('end', () => {
          // Clear safety timeout
          global.clearTimeout(safetyTimeoutId);
          
          const requestTime = Date.now() - startTime;
          const responseBody = Buffer.concat(responseChunks).toString('utf8');
          
          // Parse response data based on content type
          let parsedData: any;
          try {
            const contentType = res.headers['content-type'] || '';
            if (contentType.includes('application/json')) {
              parsedData = responseBody ? JSON.parse(responseBody) : null;
            } else {
              parsedData = responseBody;
            }
          } catch (error) {
            logger.warn('Failed to parse response as JSON', { error });
            parsedData = responseBody;
          }
          
          // Create response object
          const response: HttpResponse<T> = {
            status: res.statusCode || 0,
            statusText: res.statusMessage || '',
            data: parsedData,
            headers: res.headers as Record<string, string>,
            requestTime,
            url: parsedUrl.toString(),
            method
          };
          
          // Log the response
          logger.logResponse(response.status, parsedUrl.toString(), response.data, requestTime);
          
          // Resolve or reject based on status code
          if (response.status >= 200 && response.status < 300) {
            resolve(response);
          } else {
            const error = new Error(`Request failed with status ${response.status}: ${response.statusText}`);
            (error as any).response = response;
            (error as any).status = response.status;
            reject(error);
          }
        });
      });
      
      // Handle request errors
      req.on('error', (error) => {
        // Clear safety timeout
        global.clearTimeout(safetyTimeoutId);
        
        logger.error('Request error', { error, url: parsedUrl.toString() });
        reject(error);
      });
      
      // Handle timeout
      req.on('timeout', () => {
        // Clear safety timeout
        global.clearTimeout(safetyTimeoutId);
        
        logger.error('Request timeout', { url: parsedUrl.toString(), timeout });
        req.destroy(new Error(`Request timeout after ${timeout}ms`));
      });
      
      // Send request body for methods that support it
      if (data && ['POST', 'PUT', 'PATCH'].includes(method)) {
        const requestData = typeof data === 'string' ? data : JSON.stringify(data);
        req.write(requestData);
      }
      
      // End the request
      req.end();
    });
  }

  /**
   * GET request method
   */
  public async get<T = any>(url: string, params?: Record<string, string | number | boolean>, options: Omit<RequestOptions, 'method' | 'url' | 'params'> = {}): Promise<HttpResponse<T>> {
    return this.request<T>({ 
      method: 'GET', 
      url, 
      params, 
      ...options 
    });
  }

  /**
   * POST request method
   */
  public async post<T = any>(url: string, data?: any, options: Omit<RequestOptions, 'method' | 'url' | 'data'> = {}): Promise<HttpResponse<T>> {
    return this.request<T>({ 
      method: 'POST', 
      url, 
      data, 
      ...options 
    });
  }

  /**
   * PUT request method
   */
  public async put<T = any>(url: string, data?: any, options: Omit<RequestOptions, 'method' | 'url' | 'data'> = {}): Promise<HttpResponse<T>> {
    return this.request<T>({ 
      method: 'PUT', 
      url, 
      data, 
      ...options 
    });
  }

  /**
   * DELETE request method
   */
  public async delete<T = any>(url: string, options: Omit<RequestOptions, 'method' | 'url'> = {}): Promise<HttpResponse<T>> {
    return this.request<T>({ 
      method: 'DELETE', 
      url, 
      ...options 
    });
  }

  /**
   * PATCH request method
   */
  public async patch<T = any>(url: string, data?: any, options: Omit<RequestOptions, 'method' | 'url' | 'data'> = {}): Promise<HttpResponse<T>> {
    return this.request<T>({ 
      method: 'PATCH', 
      url, 
      data, 
      ...options 
    });
  }
}

// Export singleton instance
export const httpClient = HttpClient.getInstance();

retry.ts
------------
import { logger } from './logger';

/**
 * Retry Handler for API requests
 */
export class RetryHandler {
  /**
   * Execute a function with retry logic
   * @param fn - Function to execute
   * @param attempts - Maximum number of retry attempts
   * @param delayMs - Base delay between retries in milliseconds
   * @param statusCodes - HTTP status codes that should trigger a retry
   * @param useExponentialBackoff - Whether to use exponential backoff
   * @param maxBackoffMs - Maximum backoff time in milliseconds
   */
  public static async executeWithRetry<T>(
    fn: () => Promise<T>,
    attempts: number = 3,
    delayMs: number = 1000,
    statusCodes: number[] = [408, 429, 500, 502, 503, 504],
    useExponentialBackoff: boolean = true,
    maxBackoffMs: number = 30000
  ): Promise<T> {
    let lastError: Error | null = null;
    
    for (let attempt = 1; attempt <= attempts + 1; attempt++) {
      try {
        // Execute the function
        const result = await fn();
        
        // If this is a retry attempt, log success
        if (attempt > 1) {
          logger.info(`Request succeeded after ${attempt - 1} ${attempt === 2 ? 'retry' : 'retries'}`);
        }
        
        return result;
      } catch (error: any) {
        lastError = error instanceof Error ? error : new Error(String(error));
        
        // Check if we've reached the maximum number of retries
        if (attempt > attempts) {
          logger.error(`Request failed after ${attempts} retries`, { error: lastError });
          throw lastError;
        }
        
        // Extract status code if available
        let statusCode: number | undefined;
        if (error.status) {
          statusCode = error.status;
        } else if (error.statusCode) {
          statusCode = error.statusCode;
        } else if (error.response?.status) {
          statusCode = error.response.status;
        }
        
        // Check if the error is a network error
        const isNetworkError = 
          !statusCode && 
          (error.code === 'ECONNABORTED' || 
           error.code === 'ETIMEDOUT' || 
           error.code === 'ECONNREFUSED' ||
           error.code === 'ENOTFOUND' ||
           error.message?.includes('timeout'));
        
        // Determine if we should retry
        const shouldRetry = isNetworkError || (statusCode && statusCodes.includes(statusCode));
        
        if (!shouldRetry) {
          logger.error(`Request failed with status ${statusCode || 'unknown'}, not retrying`, { error: lastError });
          throw lastError;
        }
        
        // Calculate delay with exponential backoff if enabled
        let currentDelay = delayMs;
        if (useExponentialBackoff) {
          currentDelay = Math.min(
            delayMs * Math.pow(2, attempt - 1), 
            maxBackoffMs
          );
        }
        
        logger.warn(`Request attempt ${attempt} failed, retrying in ${currentDelay}ms`, {
          statusCode,
          error: lastError.message
        });
        
        // Wait before retrying
        await RetryHandler.delay(currentDelay);
      }
    }
    
    throw lastError || new Error('Unknown error during retry');
  }

  /**
   * Simple delay function
   */
  private static async delay(ms: number): Promise<void> {
    return new Promise(resolve => {
      const timeout = global.setTimeout(resolve, ms);
      // Ensure the timeout doesn't keep the Node.js process alive
      if (timeout.unref) {
        timeout.unref();
      }
    });
  }
}

base-client.ts
------------------
import { httpClient } from '../framework/http/http-client';
import { HttpResponse, RequestOptions } from '../framework/http/types';
import { config } from '../framework/utils/config';
import { logger } from '../framework/utils/logger';

/**
 * Base API Client class
 * All specific API clients should extend this class
 */
export abstract class BaseApiClient {
  protected baseUrl: string;
  protected defaultHeaders: Record<string, string>;

  /**
   * Create a new API client
   * @param baseUrl - Base URL for API calls (optional, uses API_BASE_URL from config if not provided)
   */
  constructor(baseUrl?: string) {
    this.baseUrl = baseUrl || config.get('API_BASE_URL');
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    };
  }

  /**
   * Set base URL
   */
  public setBaseUrl(url: string): void {
    this.baseUrl = url;
  }

  /**
   * Get base URL
   */
  public getBaseUrl(): string {
    return this.baseUrl;
  }

  /**
   * Set default headers
   */
  public setDefaultHeaders(headers: Record<string, string>): void {
    this.defaultHeaders = {
      ...this.defaultHeaders,
      ...headers
    };
  }

  /**
   * Add a default header
   */
  public addDefaultHeader(name: string, value: string): void {
    this.defaultHeaders[name] = value;
  }

  /**
   * Get default headers
   */
  public getDefaultHeaders(): Record<string, string> {
    return this.defaultHeaders;
  }

  /**
   * Resolve URL by appending endpoint to base URL
   */
  protected resolveUrl(endpoint: string): string {
    // Ensure there's exactly one slash between baseUrl and endpoint
    const baseWithSlash = this.baseUrl.endsWith('/') ? this.baseUrl : `${this.baseUrl}/`;
    const endpointWithoutSlash = endpoint.startsWith('/') ? endpoint.substring(1) : endpoint;
    
    return `${baseWithSlash}${endpointWithoutSlash}`;
  }

  /**
   * Make a GET request
   */
  protected async get<T = any>(endpoint: string, params?: Record<string, string | number | boolean>, options: Partial<RequestOptions> = {}): Promise<HttpResponse<T>> {
    const url = this.resolveUrl(endpoint);
    return httpClient.get<T>(url, params, {
      headers: { ...this.defaultHeaders, ...options.headers },
      ...options
    });
  }

  /**
   * Make a POST request
   */
  protected async post<T = any>(endpoint: string, data?: any, options: Partial<RequestOptions> = {}): Promise<HttpResponse<T>> {
    const url = this.resolveUrl(endpoint);
    return httpClient.post<T>(url, data, {
      headers: { ...this.defaultHeaders, ...options.headers },
      ...options
    });
  }

  /**
   * Make a PUT request
   */
  protected async put<T = any>(endpoint: string, data?: any, options: Partial<RequestOptions> = {}): Promise<HttpResponse<T>> {
    const url = this.resolveUrl(endpoint);
    return httpClient.put<T>(url, data, {
      headers: { ...this.defaultHeaders, ...options.headers },
      ...options
    });
  }

  /**
   * Make a DELETE request
   */
  protected async delete<T = any>(endpoint: string, options: Partial<RequestOptions> = {}): Promise<HttpResponse<T>> {
    const url = this.resolveUrl(endpoint);
    return httpClient.delete<T>(url, {
      headers: { ...this.defaultHeaders, ...options.headers },
      ...options
    });
  }

  /**
   * Make a PATCH request
   */
  protected async patch<T = any>(endpoint: string, data?: any, options: Partial<RequestOptions> = {}): Promise<HttpResponse<T>> {
    const url = this.resolveUrl(endpoint);
    return httpClient.patch<T>(url, data, {
      headers: { ...this.defaultHeaders, ...options.headers },
      ...options
    });
  }

  /**
   * Wait for a condition to be met with polling
   */
  protected async pollUntil<T = any>(
    endpoint: string,
    condition: (response: HttpResponse<T>) => boolean,
    options: {
      interval?: number;
      timeout?: number;
      maxAttempts?: number;
      params?: Record<string, string | number | boolean>;
      requestOptions?: Partial<RequestOptions>;
    } = {}
  ): Promise<HttpResponse<T>> {
    const {
      interval = 2000,
      timeout = 60000,
      maxAttempts = 30,
      params = {},
      requestOptions = {}
    } = options;
    
    const startTime = Date.now();
    let attempts = 0;
    
    logger.info(`Starting polling for endpoint: ${endpoint}`);
    
    while (true) {
      attempts++;
      try {
        const response = await this.get<T>(endpoint, params, requestOptions);
        
        if (condition(response)) {
          logger.info(`Polling condition met after ${attempts} attempts (${Date.now() - startTime}ms)`);
          return response;
        }
        
        logger.debug(`Polling attempt ${attempts}: condition not met yet`);
      } catch (error) {
        logger.warn(`Polling attempt ${attempts} failed with error`, { error });
      }
      
      // Check if we've reached the maximum number of attempts
      if (maxAttempts && attempts >= maxAttempts) {
        throw new Error(`Polling reached maximum attempts (${maxAttempts})`);
      }
      
      // Check if we've reached the timeout
      if (Date.now() - startTime >= timeout) {
        throw new Error(`Polling timed out after ${timeout}ms`);
      }
      
      // Wait before the next attempt
      await new Promise(resolve => {
        const timeoutId = global.setTimeout(resolve, interval);
        if (timeoutId.unref) {
          timeoutId.unref();
        }
      });
    }
  }
}
