Project Structure:
-----------------
Project Structure:
├── config/
│   └── testng_sit.xml
├── resources/
│   ├── application.properties
│   ├── payloads/
│   │   └── assetlayout-payload.json
│   └── env/
│       ├── dev/
│       │   ├── env.properties
│       │   └── testdata/
│       │       └── Regression_testdata.xlsx
│       ├── sit/
│       │   ├── env.properties
│       │   └── testdata/
│       │       └── Regression_testdata.xlsx
│       └── uat/
│           ├── env.properties
│           └── testdata/
│               └── Regression_testdata.xlsx
├── scenarios/
│   └── api/
│       └── AssetLayoutAPI.feature
└── src/
    └── com/
        └── yourcompany/
            ├── api/
            │   ├── core/
            │   │   ├── GenericRestClient.java
            │   │   └── BaseAPIEndpoint.java
            │   ├── endpoints/
            │   │   └── AssetLayoutEndpoint.java
            │   └── utils/
            │       └── CertificateManager.java
            ├── steps/
            │   └── api/
            │       ├── BaseAPISteps.java
            │       └── AssetLayoutSteps.java
            └── tests/
                └── api/
                    └── AssetLayoutAPITest.java

config/testng_sit.xml
------------------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="Asset Layout API Test Suite - SIT">
    <test name="API Tests">
        <parameter name="env.resources" value="resources/env/sit" />
        <parameter name="scenario.file.loc" value="scenarios/api" />
        <parameter name="ws.service.name" value="spc" />
        <classes>
            <class name="com.yourcompany.tests.api.AssetLayoutAPITest" />
        </classes>
    </test>
</suite>

resources/application.properties
------------------------------------
# QAF Framework Main Configuration
env.resources.dir=resources
scenario.file.dir=scenarios
scenario.file.ext=.feature

# Web service settings
ws.endpoint.assetlayout=${base.url}/api/v1/spc/assetlayout

# Test data settings
test.data.sheet.name=testData
test.data.start.key=TestCase
test.data.end.key=TestCase

# QAF Web Service Configuration
ws.service.name=spc

resources/env/sit/env.properties
----------------------------------
# SIT Environment Specific Configuration
env.name=SIT
base.url=https://ktgapi-sit.ksmls.americas.ishare.net

# Certificate settings
certificate.file=resources/env/sit/certificates/KHANonProd.pfx
certificate.password=kha#123!

# API Timeouts
ws.request.timeout=30000
ws.connection.timeout=10000

# Logging settings
logger.detailed.reporting=true

src/com/yourcompany/api/core/GenericRestClient.java
----------------------------------------------------
package com.yourcompany.api.core;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.json.JSONObject;

import com.qmetry.qaf.automation.core.ConfigurationManager;
import com.qmetry.qaf.automation.util.PropertyUtil;
import com.qmetry.qaf.automation.ws.WsRequestBean;
import com.yourcompany.api.utils.CertificateManager;

/**
 * Generic REST client for handling API requests.
 * This class provides common functionality for all API requests.
 */
public class GenericRestClient {
    
    private static final Log logger = LogFactory.getLog(GenericRestClient.class);
    private static final PropertyUtil props = ConfigurationManager.getBundle();
    
    // HTTP Methods
    public static final String METHOD_GET = "GET";
    public static final String METHOD_POST = "POST";
    public static final String METHOD_PUT = "PUT";
    public static final String METHOD_DELETE = "DELETE";
    public static final String METHOD_PATCH = "PATCH";
    
    // Common Content Types
    public static final String CONTENT_TYPE_JSON = "application/json";
    public static final String CONTENT_TYPE_XML = "application/xml";
    public static final String CONTENT_TYPE_FORM = "application/x-www-form-urlencoded";
    public static final String CONTENT_TYPE_MULTIPART = "multipart/form-data";
    
    /**
     * Represents an API response with status code and body content.
     */
    public static class ApiResponse {
        private int statusCode;
        private String responseBody;
        private Map<String, String> responseHeaders;
        
        public ApiResponse(int statusCode, String responseBody, Map<String, String> responseHeaders) {
            this.statusCode = statusCode;
            this.responseBody = responseBody;
            this.responseHeaders = responseHeaders;
        }
        
        public int getStatusCode() {
            return statusCode;
        }
        
        public String getResponseBody() {
            return responseBody;
        }
        
        public Map<String, String> getResponseHeaders() {
            return responseHeaders;
        }
        
        public boolean isSuccessful() {
            return statusCode >= 200 && statusCode < 300;
        }
        
        public JSONObject getJsonResponse() {
            if (responseBody != null && !responseBody.isEmpty()) {
                try {
                    return new JSONObject(responseBody);
                } catch (Exception e) {
                    logger.error("Error parsing response as JSON: " + e.getMessage(), e);
                }
            }
            return null;
        }
    }
    
    /**
     * Sends a request to the specified endpoint using the specified method.
     * 
     * @param endpointKey property key for the endpoint URL
     * @param method HTTP method (GET, POST, PUT, DELETE, PATCH)
     * @param headers request headers
     * @param payload request payload (for POST, PUT, PATCH)
     * @param useSSL whether to use SSL certificate for authentication
     * @return ApiResponse containing status code and response body
     */
    public static ApiResponse sendRequest(String endpointKey, String method, 
                                          Map<String, String> headers, String payload, 
                                          boolean useSSL) {
        String endpoint = props.getString(endpointKey);
        
        try {
            URL url = new URL(endpoint);
            HttpURLConnection connection;
            
            if (url.getProtocol().equals("https")) {
                connection = (HttpsURLConnection) url.openConnection();
                if (useSSL) {
                    ((HttpsURLConnection) connection).setSSLSocketFactory(
                            CertificateManager.getSSLContext().getSocketFactory());
                }
            } else {
                connection = (HttpURLConnection) url.openConnection();
            }
            
            connection.setRequestMethod(method);
            
            // Set request headers
            if (headers == null || headers.isEmpty()) {
                headers = getDefaultHeaders();
            }
            
            for (Map.Entry<String, String> header : headers.entrySet()) {
                connection.setRequestProperty(header.getKey(), header.getValue());
            }
            
            // Set connection timeouts
            if (props.containsKey("ws.request.timeout")) {
                connection.setReadTimeout(props.getInt("ws.request.timeout"));
            }
            
            if (props.containsKey("ws.connection.timeout")) {
                connection.setConnectTimeout(props.getInt("ws.connection.timeout"));
            }
            
            // Set payload for methods that support it
            if (payload != null && 
               (METHOD_POST.equals(method) || METHOD_PUT.equals(method) || METHOD_PATCH.equals(method))) {
                connection.setDoOutput(true);
                try (OutputStream os = connection.getOutputStream()) {
                    byte[] input = payload.getBytes(StandardCharsets.UTF_8);
                    os.write(input, 0, input.length);
                }
            }
            
            // Get response
            int statusCode = connection.getResponseCode();
            
            // Read response
            BufferedReader reader;
            if (statusCode >= 200 && statusCode < 300) {
                reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));
            } else {
                reader = new BufferedReader(new InputStreamReader(connection.getErrorStream(), StandardCharsets.UTF_8));
            }
            
            String responseBody = reader.lines().collect(Collectors.joining("\n"));
            reader.close();
            
            // Get response headers
            Map<String, String> responseHeaders = new HashMap<>();
            connection.getHeaderFields().forEach((key, values) -> {
                if (key != null && !values.isEmpty()) {
                    responseHeaders.put(key, values.get(0));
                }
            });
            
            // Log response info
            logger.info("Received response with status: " + statusCode);
            logger.debug("Response body: " + responseBody);
            
            return new ApiResponse(statusCode, responseBody, responseHeaders);
            
        } catch (Exception e) {
            logger.error("Error executing API request: " + e.getMessage(), e);
            throw new RuntimeException("Failed to execute API request: " + e.getMessage(), e);
        }
    }
    
    /**
     * Sends a GET request to the specified endpoint.
     * 
     * @param endpointKey property key for the endpoint URL
     * @param headers request headers
     * @param useSSL whether to use SSL certificate for authentication
     * @return ApiResponse containing status code and response body
     */
    public static ApiResponse sendGetRequest(String endpointKey, Map<String, String> headers, boolean useSSL) {
        return sendRequest(endpointKey, METHOD_GET, headers, null, useSSL);
    }
    
    /**
     * Sends a POST request to the specified endpoint.
     * 
     * @param endpointKey property key for the endpoint URL
     * @param headers request headers
     * @param payload request payload
     * @param useSSL whether to use SSL certificate for authentication
     * @return ApiResponse containing status code and response body
     */
    public static ApiResponse sendPostRequest(String endpointKey, Map<String, String> headers, 
                                             String payload, boolean useSSL) {
        return sendRequest(endpointKey, METHOD_POST, headers, payload, useSSL);
    }
    
    /**
     * Sends a PUT request to the specified endpoint.
     * 
     * @param endpointKey property key for the endpoint URL
     * @param headers request headers
     * @param payload request payload
     * @param useSSL whether to use SSL certificate for authentication
     * @return ApiResponse containing status code and response body
     */
    public static ApiResponse sendPutRequest(String endpointKey, Map<String, String> headers, 
                                           String payload, boolean useSSL) {
        return sendRequest(endpointKey, METHOD_PUT, headers, payload, useSSL);
    }
    
    /**
     * Sends a DELETE request to the specified endpoint.
     * 
     * @param endpointKey property key for the endpoint URL
     * @param headers request headers
     * @param useSSL whether to use SSL certificate for authentication
     * @return ApiResponse containing status code and response body
     */
    public static ApiResponse sendDeleteRequest(String endpointKey, Map<String, String> headers, boolean useSSL) {
        return sendRequest(endpointKey, METHOD_DELETE, headers, null, useSSL);
    }
    
    /**
     * Sends a PATCH request to the specified endpoint.
     * 
     * @param endpointKey property key for the endpoint URL
     * @param headers request headers
     * @param payload request payload
     * @param useSSL whether to use SSL certificate for authentication
     * @return ApiResponse containing status code and response body
     */
    public static ApiResponse sendPatchRequest(String endpointKey, Map<String, String> headers, 
                                             String payload, boolean useSSL) {
        return sendRequest(endpointKey, METHOD_PATCH, headers, payload, useSSL);
    }
    
    /**
     * Gets default headers for API requests.
     * 
     * @return map of default headers
     */
    public static Map<String, String> getDefaultHeaders() {
        Map<String, String> headers = new HashMap<>();
        headers.put("Content-Type", CONTENT_TYPE_JSON);
        headers.put("Accept", CONTENT_TYPE_JSON);
        return headers;
    }
    
    /**
     * Loads a payload from a file and substitutes placeholders with values.
     * 
     * @param payloadFileName name of the payload file
     * @param dataMap map of values to substitute
     * @return processed payload as a string
     */
    public static String loadPayload(String payloadFileName, Map<String, Object> dataMap) {
        String payloadPath = "resources/payloads/" + payloadFileName;
        
        try {
            String content = new String(Files.readAllBytes(Paths.get(payloadPath)));
            
            // Replace placeholders with actual values
            if (dataMap != null) {
                for (Map.Entry<String, Object> entry : dataMap.entrySet()) {
                    String placeholder = "${" + entry.getKey() + "}";
                    String value = entry.getValue() != null ? entry.getValue().toString() : "";
                    content = content.replace(placeholder, value);
                }
            }
            
            logger.info("Prepared payload: " + content);
            return content;
        } catch (IOException e) {
            logger.error("Failed to load payload file: " + e.getMessage(), e);
            throw new RuntimeException("Failed to load payload file: " + e.getMessage(), e);
        }
    }
    
    /**
     * Creates a payload from a JSON object.
     * 
     * @param jsonObject JSON object to convert to string
     * @return JSON string
     */
    public static String createPayload(JSONObject jsonObject) {
        return jsonObject != null ? jsonObject.toString() : null;
    }
    
    /**
     * Extracts a value from the JSON response by key.
     * 
     * @param response API response
     * @param key the JSON key
     * @return the value as a string, or null if not found
     */
    public static String getResponseValue(ApiResponse response, String key) {
        if (response == null || response.getResponseBody() == null) {
            return null;
        }
        
        try {
            JSONObject json = new JSONObject(response.getResponseBody());
            return json.has(key) ? json.get(key).toString() : null;
        } catch (Exception e) {
            logger.error("Error parsing response JSON: " + e.getMessage(), e);
            return null;
        }
    }
    
    /**
     * Checks if a field exists in the JSON response.
     * 
     * @param response API response
     * @param field the field name
     * @return true if the field exists, false otherwise
     */
    public static boolean hasResponseField(ApiResponse response, String field) {
        if (response == null || response.getResponseBody() == null) {
            return false;
        }
        
        try {
            JSONObject json = new JSONObject(response.getResponseBody());
            return json.has(field);
        } catch (Exception e) {
            logger.error("Error checking field in response JSON: " + e.getMessage(), e);
            return false;
        }
    }
    
    /**
     * Builds a query string from parameters.
     * 
     * @param params map of query parameters
     * @return formatted query string (without leading '?')
     */
    public static String buildQueryString(Map<String, String> params) {
        if (params == null || params.isEmpty()) {
            return "";
        }
        
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        
        for (Map.Entry<String, String> entry : params.entrySet()) {
            if (first) {
                first = false;
            } else {
                sb.append("&");
            }
            
            sb.append(entry.getKey()).append("=").append(entry.getValue());
        }
        
        return sb.toString();
    }
    
    /**
     * Adds query parameters to an endpoint URL.
     * 
     * @param endpoint base endpoint URL
     * @param params map of query parameters
     * @return endpoint URL with query parameters
     */
    public static String addQueryParams(String endpoint, Map<String, String> params) {
        if (params == null || params.isEmpty()) {
            return endpoint;
        }
        
        String queryString = buildQueryString(params);
        
        if (endpoint.contains("?")) {
            return endpoint + "&" + queryString;
        } else {
            return endpoint + "?" + queryString;
        }
    }
}

src/com/yourcompany/api/core/BaseAPIEndpoint.java
----------------------------------------------------
package com.yourcompany.api.core;

import java.util.HashMap;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.json.JSONObject;

import com.qmetry.qaf.automation.core.ConfigurationManager;
import com.qmetry.qaf.automation.util.PropertyUtil;
import com.yourcompany.api.core.GenericRestClient.ApiResponse;

/**
 * Base class for all API endpoint classes.
 * Provides common functionality and access to the GenericRestClient.
 */
public abstract class BaseAPIEndpoint {
    
    protected static final Log logger = LogFactory.getLog(BaseAPIEndpoint.class);
    protected static final PropertyUtil props = ConfigurationManager.getBundle();
    
    protected ApiResponse response;
    protected String endpointKey;
    protected boolean useSSL;
    protected Map<String, String> defaultHeaders;
    
    /**
     * Constructor for BaseAPIEndpoint.
     * 
     * @param endpointKey the property key for the endpoint URL
     * @param useSSL whether to use SSL certificate for authentication
     */
    public BaseAPIEndpoint(String endpointKey, boolean useSSL) {
        this.endpointKey = endpointKey;
        this.useSSL = useSSL;
        this.defaultHeaders = new HashMap<>();
        initializeDefaultHeaders();
    }
    
    /**
     * Initializes default headers for this endpoint.
     * Override this method to set endpoint-specific headers.
     */
    protected void initializeDefaultHeaders() {
        defaultHeaders.put("Content-Type", GenericRestClient.CONTENT_TYPE_JSON);
        defaultHeaders.put("Accept", GenericRestClient.CONTENT_TYPE_JSON);
    }
    
    /**
     * Sends a GET request to this endpoint.
     * 
     * @return this endpoint for chaining
     */
    public BaseAPIEndpoint get() {
        response = GenericRestClient.sendGetRequest(endpointKey, defaultHeaders, useSSL);
        return this;
    }
    
    /**
     * Sends a GET request with query parameters to this endpoint.
     * 
     * @param queryParams map of query parameters
     * @return this endpoint for chaining
     */
    public BaseAPIEndpoint get(Map<String, String> queryParams) {
        String endpoint = props.getString(endpointKey);
        String endpointWithParams = GenericRestClient.addQueryParams(endpoint, queryParams);
        
        // Create a temporary endpoint key
        String tempKey = endpointKey + ".temp";
        props.setProperty(tempKey, endpointWithParams);
        
        response = GenericRestClient.sendGetRequest(tempKey, defaultHeaders, useSSL);
        
        // Clean up
        props.remove(tempKey);
        
        return this;
    }
    
    /**
     * Sends a POST request to this endpoint.
     * 
     * @param payload request payload
     * @return this endpoint for chaining
     */
    public BaseAPIEndpoint post(String payload) {
        response = GenericRestClient.sendPostRequest(endpointKey, defaultHeaders, payload, useSSL);
        return this;
    }
    
    /**
     * Sends a POST request to this endpoint with a JSON object as payload.
     * 
     * @param jsonObject JSON object to send as payload
     * @return this endpoint for chaining
     */
    public BaseAPIEndpoint post(JSONObject jsonObject) {
        String payload = GenericRestClient.createPayload(jsonObject);
        return post(payload);
    }
    
    /**
     * Sends a POST request to this endpoint with payload from a file.
     * 
     * @param payloadFileName name of the payload file
     * @param dataMap map of values to substitute in the payload
     * @return this endpoint for chaining
     */
    public BaseAPIEndpoint post(String payloadFileName, Map<String, Object> dataMap) {
        String payload = GenericRestClient.loadPayload(payloadFileName, dataMap);
        return post(payload);
    }
    
    /**
     * Sends a PUT request to this endpoint.
     * 
     * @param payload request payload
     * @return this endpoint for chaining
     */
    public BaseAPIEndpoint put(String payload) {
        response = GenericRestClient.sendPutRequest(endpointKey, defaultHeaders, payload, useSSL);
        return this;
    }
    
    /**
     * Sends a PUT request to this endpoint with a JSON object as payload.
     * 
     * @param jsonObject JSON object to send as payload
     * @return this endpoint for chaining
     */
    public BaseAPIEndpoint put(JSONObject jsonObject) {
        String payload = GenericRestClient.createPayload(jsonObject);
        return put(payload);
    }
    
    /**
     * Sends a PUT request to this endpoint with payload from a file.
     * 
     * @param payloadFileName name of the payload file
     * @param dataMap map of values to substitute in the payload
     * @return this endpoint for chaining
     */
    public BaseAPIEndpoint put(String payloadFileName, Map<String, Object> dataMap) {
        String payload = GenericRestClient.loadPayload(payloadFileName, dataMap);
        return put(payload);
    }
    
    /**
     * Sends a DELETE request to this endpoint.
     * 
     * @return this endpoint for chaining
     */
    public BaseAPIEndpoint delete() {
        response = GenericRestClient.sendDeleteRequest(endpointKey, defaultHeaders, useSSL);
        return this;
    }
    
    /**
     * Sends a PATCH request to this endpoint.
     * 
     * @param payload request payload
     * @return this endpoint for chaining
     */
    public BaseAPIEndpoint patch(String payload) {
        response = GenericRestClient.sendPatchRequest(endpointKey, defaultHeaders, payload, useSSL);
        return this;
    }
    
    /**
     * Sends a PATCH request to this endpoint with a JSON object as payload.
     * 
     * @param jsonObject JSON object to send as payload
     * @return this endpoint for chaining
     */
    public BaseAPIEndpoint patch(JSONObject jsonObject) {
        String payload = GenericRestClient.createPayload(jsonObject);
        return patch(payload);
    }
    
    /**
     * Sends a PATCH request to this endpoint with payload from a file.
     * 
     * @param payloadFileName name of the payload file
     * @param dataMap map of values to substitute in the payload
     * @return this endpoint for chaining
     */
    public BaseAPIEndpoint patch(String payloadFileName, Map<String, Object> dataMap) {
        String payload = GenericRestClient.loadPayload(payloadFileName, dataMap);
        return patch(payload);
    }
    
    /**
     * Adds a custom header to this endpoint.
     * 
     * @param name header name
     * @param value header value
     * @return this endpoint for chaining
     */
    public BaseAPIEndpoint addHeader(String name, String value) {
        defaultHeaders.put(name, value);
        return this;
    }
    
    /**
     * Adds multiple custom headers to this endpoint.
     * 
     * @param headers map of headers
     * @return this endpoint for chaining
     */
    public BaseAPIEndpoint addHeaders(Map<String, String> headers) {
        if (headers != null) {
            defaultHeaders.putAll(headers);
        }
        return this;
    }
    
    /**
     * Gets the response status code.
     * 
     * @return the HTTP status code
     */
    public int getStatusCode() {
        return response != null ? response.getStatusCode() : -1;
    }
    
    /**
     * Gets the response body as a String.
     * 
     * @return the response body
     */
    public String getResponseBody() {
        return response != null ? response.getResponseBody() : null;
    }
    
    /**
     * Gets the raw ApiResponse.
     * 
     * @return the raw response
     */
    public ApiResponse getResponse() {
        return response;
    }
    
    /**
     * Gets a value from the JSON response by key.
     * 
     * @param key the JSON key
     * @return the value as a String, or null if not found
     */
    public String getResponseValue(String key) {
        return GenericRestClient.getResponseValue(response, key);
    }
    
    /**
     * Checks if a field exists in the response JSON.
     * 
     * @param field the field name
     * @return true if the field exists, false otherwise
     */
    public boolean hasField(String field) {
        return GenericRestClient.hasResponseField(response, field);
    }
    
    /**
     * Checks if the response was successful (status code 2xx).
     * 
     * @return true if successful, false otherwise
     */
    public boolean isSuccessful() {
        return response != null && response.isSuccessful();
    }
    
    /**
     * Gets the response as a JSONObject.
     * 
     * @return JSONObject representing the response
     */
    public JSONObject getResponseJson() {
        return response != null ? response.getJsonResponse() : null;
    }
}

src/com/yourcompany/api/utils/CertificateManager.java
------------------------------------------------------
package com.yourcompany.api.utils;

import java.io.FileInputStream;
import java.io.IOException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;

import javax.net.ssl.KeyManager;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.qmetry.qaf.automation.core.ConfigurationManager;
import com.qmetry.qaf.automation.util.PropertyUtil;

/**
 * Utility class for managing SSL certificates for API requests.
 */
public class CertificateManager {
    
    private static final Log logger = LogFactory.getLog(CertificateManager.class);
    private static final PropertyUtil props = ConfigurationManager.getBundle();
    private static SSLContext sslContext;
    
    /**
     * Configures and returns the SSL context with the specified certificate.
     * 
     * @return configured SSLContext
     */
    public static SSLContext getSSLContext() {
        if (sslContext == null) {
            try {
                String certificateFile = props.getString("certificate.file");
                String certificatePassword = props.getString("certificate.password");
                
                logger.info("Loading certificate from: " + certificateFile);
                
                KeyStore keyStore = KeyStore.getInstance("PKCS12");
                try (FileInputStream fis = new FileInputStream(certificateFile)) {
                    keyStore.load(fis, certificatePassword.toCharArray());
                }
                
                KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
                keyManagerFactory.init(keyStore, certificatePassword.toCharArray());
                KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();
                
                sslContext = SSLContext.getInstance("TLS");
                sslContext.init(keyManagers, null, null);
                
                logger.info("SSL context initialized successfully");
                
            } catch (KeyStoreException | NoSuchAlgorithmException | CertificateException | IOException 
                    | UnrecoverableKeyException | java.security.KeyManagementException e) {
                logger.error("Failed to configure SSL context: " + e.getMessage(), e);
                throw new RuntimeException("Failed to configure SSL context: " + e.getMessage(), e);
            }
        }
        return sslContext;
    }
}

src/com/yourcompany/api/endpoints/AssetLayoutEndpoint.java
----------------------------------------------------------

package com.yourcompany.api.endpoints;

import java.util.Map;

import com.yourcompany.api.core.BaseAPIEndpoint;
import com.yourcompany.api.core.GenericRestClient.ApiResponse;

/**
 * Endpoint class for the Asset Layout API.
 * Uses the generic BaseAPIEndpoint to handle API requests.
 */
public class AssetLayoutEndpoint extends BaseAPIEndpoint {
    
    private static final String PAYLOAD_FILE = "assetlayout-payload.json";
    
    /**
     * Constructor for AssetLayoutEndpoint.
     * Configures the endpoint for certificate-based authentication.
     */
    public AssetLayoutEndpoint() {
        super("ws.endpoint.assetlayout", true);
    }
    
    /**
     * Executes a request to the Asset Layout API using the test data provided.
     * 
     * @param testData map containing test data values
     * @return the response from the API
     */
    public ApiResponse executeRequest(Map<String, Object> testData) {
        logger.info("Executing Asset Layout API request with test data: " + testData);
        
        // Execute POST request with payload from file
        post(PAYLOAD_FILE, testData);
        
        logger.info("Received response with status: " + getStatusCode());
        logger.debug("Response body: " + getResponseBody());
        
        return getResponse();
    }
}

src/com/yourcompany/steps/api/BaseAPISteps.java
-----------------------------------------------
package com.yourcompany.steps.api;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.MatcherAssert.assertThat;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.qmetry.qaf.automation.step.QAFTestStep;
import com.qmetry.qaf.automation.util.Reporter;
import com.qmetry.qaf.automation.util.Validator;
import com.yourcompany.api.core.BaseAPIEndpoint;

/**
 * Base class for all API step definition classes.
 * Provides common step definitions that can be used across all API tests.
 */
public abstract class BaseAPISteps {
    
    protected static final Log logger = LogFactory.getLog(BaseAPISteps.class);
    
    /**
     * Gets the endpoint for this steps class.
     * 
     * @return the API endpoint
     */
    protected abstract BaseAPIEndpoint getEndpoint();
    
    /**
     * Verifies that the response status code matches the expected value.
     * This method will take the expectedStatus from the test data if not provided.
     * 
     * @param expectedStatus the expected HTTP status code
     */
    @QAFTestStep(description = "the response status code should be {expectedStatus}")
    public void theResponseStatusCodeShouldBe(int expectedStatus) {
        int actualStatus = getEndpoint().getStatusCode();
        
        Reporter.log("Verifying response status code: expected=" + expectedStatus + ", actual=" + actualStatus);
        assertThat("Response status code", actualStatus, is(equalTo(expectedStatus)));
    }
    
    /**
     * Verifies that the response is successful (status code 2xx).
     */
    @QAFTestStep(description = "the response should be successful")
    public void theResponseShouldBeSuccessful() {
        boolean successful = getEndpoint().isSuccessful();
        
        Reporter.log("Verifying response is successful: " + successful);
        assertThat("Response is successful", successful, is(true));
    }
    
    /**
     * Verifies that the response contains the specified field.
     * 
     * @param field the field to check for
     */
    @QAFTestStep(description = "the response should contain the field {field}")
    public void theResponseShouldContainField(String field) {
        boolean hasField = getEndpoint().hasField(field);
        
        Reporter.log("Verifying response contains field '" + field + "': " + hasField);
        assertThat("Response contains field '" + field + "'", hasField, is(true));
    }
    
    /**
     * Verifies that the response field has the expected value.
     * 
     * @param field the field to check
     * @param expectedValue the expected value
     */
    @QAFTestStep(description = "the response field {field} should be {expectedValue}")
    public void theResponseFieldShouldBe(String field, String expectedValue) {
        String actualValue = getEndpoint().getResponseValue(field);
        
        Reporter.log("Verifying response field '" + field + "': expected=" + expectedValue + ", actual=" + actualValue);
        
        assertThat("Response field '" + field + "' exists", actualValue, is(notNullValue()));
        assertThat("Response field '" + field + "' value", actualValue, is(equalTo(expectedValue)));
    }
    
    /**
     * Verifies that the response field contains the expected text.
     * 
     * @param field the field to check
     * @param expectedText the text that should be contained
     */
    @QAFTestStep(description = "the response field {field} should contain {expectedText}")
    public void theResponseFieldShouldContain(String field, String expectedText) {
        String actualValue = getEndpoint().getResponseValue(field);
        
        Reporter.log("Verifying response field '" + field + "' contains: " + expectedText);
        
        assertThat("Response field '" + field + "' exists", actualValue, is(notNullValue()));
        Validator.verifyThat("Response field '" + field + "' contains expected text", 
                actualValue.contains(expectedText), is(true));
    }
    
    /**
     * Verifies that the response field does not contain the expected text.
     * 
     * @param field the field to check
     * @param unexpectedText the text that should not be contained
     */
    @QAFTestStep(description = "the response field {field} should not contain {unexpectedText}")
    public void theResponseFieldShouldNotContain(String field, String unexpectedText) {
        String actualValue = getEndpoint().getResponseValue(field);
        
        Reporter.log("Verifying response field '" + field + "' does not contain: " + unexpectedText);
        
        assertThat("Response field '" + field + "' exists", actualValue, is(notNullValue()));
        Validator.verifyThat("Response field '" + field + "' does not contain unexpected text", 
                !actualValue.contains(unexpectedText), is(true));
    }
    
    /**
     * Verifies that the response contains a non-empty array field.
     * 
     * @param arrayField the array field to check
     */
    @QAFTestStep(description = "the response should contain a non-empty {arrayField} array")
    public void theResponseShouldContainNonEmptyArray(String arrayField) {
        if (!getEndpoint().hasField(arrayField)) {
            assertThat("Response contains array field '" + arrayField + "'", false, is(true));
            return;
        }
        
        String arrayValue = getEndpoint().getResponseValue(arrayField);
        boolean isNonEmptyArray = arrayValue != null && arrayValue.startsWith("[") && 
                                 !arrayValue.equals("[]") && arrayValue.endsWith("]");
        
        Reporter.log("Verifying response contains non-empty array '" + arrayField + "': " + isNonEmptyArray);
        assertThat("Response contains non-empty array '" + arrayField + "'", isNonEmptyArray, is(true));
    }
}

src/com/yourcompany/steps/api/AssetLayoutSteps.java
-------------------------------------------------------
package com.yourcompany.steps.api;

import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.qmetry.qaf.automation.step.QAFTestStep;
import com.qmetry.qaf.automation.util.Reporter;
import com.yourcompany.api.core.BaseAPIEndpoint;
import com.yourcompany.api.core.GenericRestClient.ApiResponse;
import com.yourcompany.api.endpoints.AssetLayoutEndpoint;

/**
 * BDD step definitions for the Asset Layout API tests.
 * Extends BaseAPISteps to inherit common step definitions.
 */
public class AssetLayoutSteps extends BaseAPISteps {
    
    private static final Log logger = LogFactory.getLog(AssetLayoutSteps.class);
    private AssetLayoutEndpoint endpoint = new AssetLayoutEndpoint();
    
    @Override
    protected BaseAPIEndpoint getEndpoint() {
        return endpoint;
    }
    
    /**
     * Executes a request to the Asset Layout API using the provided test data.
     * 
     * @param data Map containing the test data from the Excel file
     */
    @QAFTestStep(description = "I send a request to the asset layout API with data {data}")
    public void iSendRequestToAssetLayoutAPIWithData(Map<String, Object> data) {
        try {
            logger.info("Sending asset layout API request with data: " + data);
            ApiResponse response = endpoint.executeRequest(data);
            
            Reporter.log("Request sent successfully.");
            Reporter.log("Response status: " + endpoint.getStatusCode());
            Reporter.log("Response body: " + endpoint.getResponseBody());
            
        } catch (Exception e) {
            Reporter.log("Error sending request: " + e.getMessage());
            throw e;
        }
    }
}

src/com/yourcompany/tests/api/AssetLayoutAPITest.java
--------------------------------------------------------
package com.yourcompany.tests.api;

import org.testng.annotations.Test;

import com.qmetry.qaf.automation.core.ConfigurationManager;
import com.qmetry.qaf.automation.step.WsStep;
import com.qmetry.qaf.automation.ui.WebDriverTestCase;
import com.qmetry.qaf.automation.util.Reporter;

/**
 * Test class for Asset Layout API tests.
 */
public class AssetLayoutAPITest extends WebDriverTestCase {
    
    /**
     * Executes all Asset Layout API test scenarios.
     */
    @Test(description = "Asset Layout API Tests")
    public void testAssetLayoutAPI() {
        // Setting the environment - this can also be done via maven profiles or system properties
        ConfigurationManager.getBundle().setProperty("env.name", "sit");
        
        Reporter.log("Starting Asset Layout API Tests", Reporter.PASS);
        
        // The BDD scenarios will be automatically executed based on the 
        // @key annotation in the feature file matching the test data
        WsStep.executeScenarios("AssetLayoutAPI.feature");
        
        Reporter.log("Asset Layout API Tests completed", Reporter.PASS);
    }
}

