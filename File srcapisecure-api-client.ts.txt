// File: src/api/trade-api-client.ts
import { SecureApiClient } from './secure-api-client';
import { ApiRequestOptions } from '../framework/base-api-client';
import * as fs from 'fs';
import * as https from 'https';
import * as path from 'path';

// Define interfaces for request and response
interface TradeSearchRequest {
  accountNumFilter?: string[];
  tradeStatusFilter?: string[];
  tradeTypeFilter?: string[];
  priorityOrder?: boolean;
}

interface Trade {
  id: string;
  accountNum: string;
  tradeStatus: string;
  tradeType: string;
  // Add other trade properties as needed
}

interface TradeSearchResponse {
  trades: Trade[];
  totalCount: number;
}

/**
 * Trade API Client for interactions with the trade service
 */
export class TradeApiClient extends SecureApiClient {
  /**
   * Constructor for the TradeApiClient
   */
  constructor() {
    // Get base URL from environment variables
    const apiBaseUrl = process.env.TRADE_API_BASE_URL || 'https://jonat-sit.k8joha.americas.kshare.net';
    super(apiBaseUrl);
  }

  /**
   * Override createHttpsAgent to support PFX certificate with passphrase
   * and include proxy settings
   */
  protected createHttpsAgent(): https.Agent {
    // Get certificate info from environment variables
    const certPath = process.env.CERT_PATH || path.resolve(process.cwd(), 'certs', 'johana.pfx');
    const certPassphrase = process.env.CERT_PASSPHRASE || 'Test12345';
    
    // Check if certificate file exists
    if (!fs.existsSync(certPath)) {
      this.logger.error(`Certificate file not found: ${certPath}`);
      throw new Error(`Certificate file not found: ${certPath}`);
    }
    
    // Create HTTPS agent with certificate
    const httpsOptions: https.AgentOptions = {
      pfx: fs.readFileSync(certPath),
      passphrase: certPassphrase,
      rejectUnauthorized: process.env.VERIFY_SSL !== 'false'
    };
    
    this.logger.info(`Using certificate from ${certPath} for API requests`);
    
    return new https.Agent(httpsOptions);
  }

  /**
   * Override to add proxy configuration
   */
  protected async createRequestConfig(options?: ApiRequestOptions): Promise<ApiRequestOptions> {
    // Get base config from parent
    const config = await super.createRequestConfig(options);
    
    // Get proxy settings from environment variables
    const httpsProxy = process.env.HTTPS_PROXY_URL;
    const httpProxy = process.env.HTTP_PROXY_URL;
    
    if (httpsProxy || httpProxy) {
      (config as any).proxy = {};
      
      if (httpsProxy) {
        (config as any).proxy.https = httpsProxy;
        this.logger.info(`Using HTTPS proxy: ${httpsProxy}`);
      }
      
      if (httpProxy) {
        (config as any).proxy.http = httpProxy;
        this.logger.info(`Using HTTP proxy: ${httpProxy}`);
      }
    }
    
    return config;
  }

  /**
   * Search for trades based on filters loaded from a JSON file or provided directly
   * @param requestBodyOrFilePath - Either a request body object or path to a JSON file
   * @returns Promise with trade search results
   */
  async searchTrades(requestBodyOrFilePath: TradeSearchRequest | string): Promise<TradeSearchResponse> {
    let requestBody: TradeSearchRequest;
    
    // If requestBodyOrFilePath is a string, assume it's a file path
    if (typeof requestBodyOrFilePath === 'string') {
      try {
        const jsonContent = fs.readFileSync(requestBodyOrFilePath, 'utf8');
        requestBody = JSON.parse(jsonContent);
        this.logger.info(`Loaded request body from ${requestBodyOrFilePath}`);
      } catch (error) {
        this.logger.error(`Failed to load request body from file: ${error.message}`);
        throw new Error(`Failed to load request body from file: ${error.message}`);
      }
    } else {
      requestBody = requestBodyOrFilePath;
    }
    
    // Get headers from environment variables
    const headers: Record<string, string> = {
      'X-CLIENT-SUBJECT': process.env.X_CLIENT_SUBJECT || 'AU=JOHA',
      'AUTHORIZED_UPN': process.env.AUTHORIZED_UPN || 'joa@americas.kshare.net',
      'Content-Type': 'application/json'
    };
    
    // Create request config with headers
    const config = await this.createRequestConfig({ headers });
    
    // Make the POST request
    this.logger.info(`Searching trades with filters: ${JSON.stringify(requestBody)}`);
    
    try {
      const endpoint = process.env.TRADE_SEARCH_ENDPOINT || '/api/trades/search';
      const response = await this.post<TradeSearchResponse>(endpoint, requestBody, config);
      
      // Verify response status
      if (response.status !== 200) {
        this.logger.error(`Unexpected response status: ${response.status}`);
        throw new Error(`API returned unexpected status: ${response.status}`);
      }
      
      this.logger.info(`Response status: ${response.status} OK`);
      this.logger.info(`Found ${response.data?.totalCount || 0} trades matching filters`);
      return response.data;
    } catch (error) {
      this.logger.error(`Trade search failed: ${error.message}`);
      if (error.response) {
        this.logger.error(`Response status: ${error.response.status}`);
        this.logger.error(`Response data: ${JSON.stringify(error.response.data)}`);
      }
      throw error;
    }
  }
}
