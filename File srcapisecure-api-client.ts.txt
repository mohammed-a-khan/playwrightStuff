package com.yourcompany.api.core;

import io.restassured.RestAssured;
import io.restassured.config.SSLConfig;
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.qmetry.qaf.automation.core.ConfigurationManager;
import com.qmetry.qaf.automation.util.PropertyUtil;

/**
 * Base class for all REST API operations using REST Assured.
 */
public class RestAPIBase {
    
    private static final Log logger = LogFactory.getLog(RestAPIBase.class);
    protected static final PropertyUtil props = ConfigurationManager.getBundle();
    
    /**
     * Configure REST Assured with SSL settings.
     * This needs to be called before each request to ensure the configuration is active.
     */
    public static void configureRestAssured() {
        try {
            String certificateFile = props.getString("certificate.file");
            String certificatePassword = props.getString("certificate.password");
            
            logger.info("Configuring REST Assured with certificate: " + certificateFile);
            
            // Verify certificate file exists
            File certFile = new File(certificateFile);
            logger.info("Certificate file exists: " + certFile.exists());
            
            // Configure REST Assured exactly as in the working script
            RestAssured.config = RestAssured.config()
                    .sslConfig(new SSLConfig()
                            .keyStore(certFile, certificatePassword)
                            .trustStore(certFile, certificatePassword)
                            .relaxedHTTPSValidation());
            
            // Configure proxy if needed
            if (props.containsKey("http.proxyHost") && props.containsKey("http.proxyPort")) {
                String proxyHost = props.getString("http.proxyHost");
                int proxyPort = props.getInt("http.proxyPort");
                logger.info("Configuring proxy: " + proxyHost + ":" + proxyPort);
                
                RestAssured.proxy(proxyHost, proxyPort);
            }
            
            logger.info("REST Assured configured successfully");
            
        } catch (Exception e) {
            logger.error("Error configuring REST Assured: " + e.getMessage(), e);
            throw new RuntimeException("Failed to configure REST Assured: " + e.getMessage(), e);
        }
    }
    
    /**
     * Loads a payload from a file and substitutes placeholders with values.
     * 
     * @param payloadFileName name of the payload file
     * @param dataMap map of values to substitute
     * @return processed payload as a string
     */
    public static String loadPayload(String payloadFileName, Map<String, Object> dataMap) {
        String payloadPath = "resources/payloads/" + payloadFileName;
        
        try {
            String content = new String(Files.readAllBytes(Paths.get(payloadPath)));
            
            // Replace placeholders with actual values
            if (dataMap != null) {
                for (Map.Entry<String, Object> entry : dataMap.entrySet()) {
                    String placeholder = "${" + entry.getKey() + "}";
                    String value = entry.getValue() != null ? entry.getValue().toString() : "";
                    content = content.replace(placeholder, value);
                }
            }
            
            logger.info("Prepared payload: " + content);
            return content;
        } catch (IOException e) {
            logger.error("Failed to load payload file: " + e.getMessage(), e);
            throw new RuntimeException("Failed to load payload file: " + e.getMessage(), e);
        }
    }
    
    /**
     * Creates a request specification with default headers.
     * 
     * @return RequestSpecification
     */
    public static RequestSpecification createRequest() {
        // Make sure REST Assured is configured with every request
        configureRestAssured();
        
        RequestSpecification request = RestAssured.given()
                .header("Content-Type", "application/json")
                .header("Accept", "application/json");
        
        // Add any additional default headers from properties
        if (props.containsKey("api.default.headers")) {
            String[] headers = props.getStringArray("api.default.headers");
            for (String header : headers) {
                String[] parts = header.split(":");
                if (parts.length == 2) {
                    request.header(parts[0].trim(), parts[1].trim());
                }
            }
        }
        
        return request;
    }
    
    /**
     * Gets the base URL for API endpoints.
     * 
     * @return base URL
     */
    public static String getBaseUrl() {
        return props.getString("base.url");
    }
    
    /**
     * Gets the endpoint URL for the specified endpoint key.
     * 
     * @param endpointKey the property key for the endpoint
     * @return full endpoint URL
     */
    public static String getEndpointUrl(String endpointKey) {
        String endpoint = props.getString(endpointKey);
        if (endpoint.startsWith("/")) {
            return getBaseUrl() + endpoint;
        }
        return endpoint;
    }
    
    /**
     * Adds query parameters to a request.
     * 
     * @param request the request specification
     * @param queryParams map of query parameters
     * @return updated request specification
     */
    public static RequestSpecification addQueryParams(RequestSpecification request, Map<String, String> queryParams) {
        if (queryParams != null && !queryParams.isEmpty()) {
            for (Map.Entry<String, String> entry : queryParams.entrySet()) {
                request.queryParam(entry.getKey(), entry.getValue());
            }
        }
        return request;
    }
    
    /**
     * Logs response details.
     * 
     * @param response the response to log
     */
    public static void logResponse(Response response) {
        logger.info("Response Status: " + response.getStatusCode());
        logger.info("Response Time: " + response.getTime() + "ms");
        logger.debug("Response Body: " + response.getBody().asString());
    }
}


package com.yourcompany.api.core;

import io.restassured.http.ContentType;
import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;

import java.util.HashMap;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.json.JSONObject;

/**
 * Builder class for creating and executing REST API requests.
 */
public class RequestBuilder {
    
    private static final Log logger = LogFactory.getLog(RequestBuilder.class);
    
    private String endpointKey;
    private Map<String, String> headers;
    private Map<String, String> queryParams;
    private String payload;
    
    /**
     * Creates a new RequestBuilder for the specified endpoint.
     * 
     * @param endpointKey the property key for the endpoint
     * @return new RequestBuilder
     */
    public static RequestBuilder withEndpoint(String endpointKey) {
        return new RequestBuilder(endpointKey);
    }
    
    /**
     * Constructor for RequestBuilder.
     * 
     * @param endpointKey the property key for the endpoint
     */
    private RequestBuilder(String endpointKey) {
        this.endpointKey = endpointKey;
        this.headers = new HashMap<>();
        this.queryParams = new HashMap<>();
    }
    
    /**
     * Adds a header to the request.
     * 
     * @param name header name
     * @param value header value
     * @return this builder for chaining
     */
    public RequestBuilder withHeader(String name, String value) {
        headers.put(name, value);
        return this;
    }
    
    /**
     * Adds multiple headers to the request.
     * 
     * @param headers map of headers
     * @return this builder for chaining
     */
    public RequestBuilder withHeaders(Map<String, String> headers) {
        if (headers != null) {
            this.headers.putAll(headers);
        }
        return this;
    }
    
    /**
     * Adds a query parameter to the request.
     * 
     * @param name parameter name
     * @param value parameter value
     * @return this builder for chaining
     */
    public RequestBuilder withQueryParam(String name, String value) {
        queryParams.put(name, value);
        return this;
    }
    
    /**
     * Adds multiple query parameters to the request.
     * 
     * @param params map of query parameters
     * @return this builder for chaining
     */
    public RequestBuilder withQueryParams(Map<String, String> params) {
        if (params != null) {
            this.queryParams.putAll(params);
        }
        return this;
    }
    
    /**
     * Sets the payload for the request.
     * 
     * @param payload request payload
     * @return this builder for chaining
     */
    public RequestBuilder withPayload(String payload) {
        this.payload = payload;
        return this;
    }
    
    /**
     * Sets the payload from a JSON object.
     * 
     * @param jsonObject JSON object for the payload
     * @return this builder for chaining
     */
    public RequestBuilder withPayload(JSONObject jsonObject) {
        this.payload = jsonObject != null ? jsonObject.toString() : null;
        return this;
    }
    
    /**
     * Sets the payload from a file with variable substitution.
     * 
     * @param payloadFileName name of the payload file
     * @param dataMap map of values to substitute
     * @return this builder for chaining
     */
    public RequestBuilder withPayloadFromFile(String payloadFileName, Map<String, Object> dataMap) {
        this.payload = RestAPIBase.loadPayload(payloadFileName, dataMap);
        return this;
    }
    
    /**
     * Sends a GET request.
     * 
     * @return the response
     */
    public Response get() {
        // Configure REST Assured for this request
        RestAPIBase.configureRestAssured();
        
        String url = RestAPIBase.getEndpointUrl(endpointKey);
        logger.info("Sending GET request to: " + url);
        
        // Create request using the same approach as the working script
        RequestSpecification request = RestAPIBase.createRequest();
        
        // Add headers
        for (Map.Entry<String, String> header : headers.entrySet()) {
            request.header(header.getKey(), header.getValue());
        }
        
        // Add query parameters
        RestAPIBase.addQueryParams(request, queryParams);
        
        // Execute request
        Response response = request.get(url);
        
        // Log response
        RestAPIBase.logResponse(response);
        
        return response;
    }
    
    /**
     * Sends a POST request.
     * 
     * @return the response
     */
    public Response post() {
        // Configure REST Assured for this request
        RestAPIBase.configureRestAssured();
        
        String url = RestAPIBase.getEndpointUrl(endpointKey);
        logger.info("Sending POST request to: " + url);
        logger.info("Request payload: " + payload);
        
        // Create request exactly like the working script
        RequestSpecification request = RestAPIBase.createRequest()
                .contentType(ContentType.JSON);
        
        // Add headers
        for (Map.Entry<String, String> header : headers.entrySet()) {
            request.header(header.getKey(), header.getValue());
        }
        
        // Add query parameters
        RestAPIBase.addQueryParams(request, queryParams);
        
        // Add payload
        if (payload != null) {
            request.body(payload);
        }
        
        // Execute request
        Response response = request.post(url);
        
        // Log response
        RestAPIBase.logResponse(response);
        
        return response;
    }
    
    /**
     * Sends a PUT request.
     * 
     * @return the response
     */
    public Response put() {
        // Configure REST Assured for this request
        RestAPIBase.configureRestAssured();
        
        String url = RestAPIBase.getEndpointUrl(endpointKey);
        logger.info("Sending PUT request to: " + url);
        
        // Create request using the same approach as the working script
        RequestSpecification request = RestAPIBase.createRequest()
                .contentType(ContentType.JSON);
        
        // Add headers
        for (Map.Entry<String, String> header : headers.entrySet()) {
            request.header(header.getKey(), header.getValue());
        }
        
        // Add query parameters
        RestAPIBase.addQueryParams(request, queryParams);
        
        // Add payload
        if (payload != null) {
            request.body(payload);
        }
        
        // Execute request
        Response response = request.put(url);
        
        // Log response
        RestAPIBase.logResponse(response);
        
        return response;
    }
    
    /**
     * Sends a DELETE request.
     * 
     * @return the response
     */
    public Response delete() {
        // Configure REST Assured for this request
        RestAPIBase.configureRestAssured();
        
        String url = RestAPIBase.getEndpointUrl(endpointKey);
        logger.info("Sending DELETE request to: " + url);
        
        // Create request using the same approach as the working script
        RequestSpecification request = RestAPIBase.createRequest();
        
        // Add headers
        for (Map.Entry<String, String> header : headers.entrySet()) {
            request.header(header.getKey(), header.getValue());
        }
        
        // Add query parameters
        RestAPIBase.addQueryParams(request, queryParams);
        
        // Execute request
        Response response = request.delete(url);
        
        // Log response
        RestAPIBase.logResponse(response);
        
        return response;
    }
    
    /**
     * Sends a PATCH request.
     * 
     * @return the response
     */
    public Response patch() {
        // Configure REST Assured for this request
        RestAPIBase.configureRestAssured();
        
        String url = RestAPIBase.getEndpointUrl(endpointKey);
        logger.info("Sending PATCH request to: " + url);
        
        // Create request using the same approach as the working script
        RequestSpecification request = RestAPIBase.createRequest()
                .contentType(ContentType.JSON);
        
        // Add headers
        for (Map.Entry<String, String> header : headers.entrySet()) {
            request.header(header.getKey(), header.getValue());
        }
        
        // Add query parameters
        RestAPIBase.addQueryParams(request, queryParams);
        
        // Add payload
        if (payload != null) {
            request.body(payload);
        }
        
        // Execute request
        Response response = request.patch(url);
        
        // Log response
        RestAPIBase.logResponse(response);
        
        return response;
    }
}

