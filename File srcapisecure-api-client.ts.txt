// src/framework/base-api-client.ts
import { AxiosResponse } from 'axios';
import { Logger } from './utils/logger';
import { ConfigManager } from './utils/config-manager';
import { CertificateManager } from './utils/certificate-manager';
import { ProxyManager } from './utils/proxy-manager';
import {
  ApiRequestOptions,
  DefaultRetryOptions,
  DefaultPollingOptions,
  ApiClientConfig
} from './api/types';
import { createRequestConfig, normalizeUrl } from './api/request-config';
import { executeRequest } from './api/request-executor';
import { retryRequest } from './api/retry-handler';
import { handleLongRunningRequest } from './api/polling-handler';
import {
  assertStatusCode,
  assertResponseData,
  assertHasData,
  assertHeader,
  assertResponseTime
} from './api/assertions';

/**
 * Base API client for all API interactions
 * Enhanced with asynchronous initialization, certificate handling, and retry logic
 */
export class BaseApiClient {
  readonly logger: Logger;
  readonly config: ConfigManager;
  readonly certManager: CertificateManager;
  readonly proxyManager: ProxyManager;
  
  // Configuration properties
  private apiBaseUrl: string = '';
  private defaultTimeout: number = 30000;
  private defaultHeaders: Record<string, string> = {};
  private serviceName: string = 'default';
  private defaultRetryOptions: DefaultRetryOptions = { maxAttempts: 3, retryDelay: 1000 };
  private defaultPollingOptions: DefaultPollingOptions = {
    enabled: false,
    maxAttempts: 10,
    interval: 2000,
    timeoutPerAttempt: 10000
  };
  
  // Initialization state
  private initialized: boolean = false;
  private initPromise: Promise<void> | null = null;

  /**
   * Constructor for the BaseApiClient
   * @param apiBaseUrl - Base URL for API requests
   * @param defaultHeaders - Default headers to include in all requests
   */
  constructor(
    apiBaseUrl?: string,
    defaultHeaders: Record<string, string> = {}
  ) {
    this.logger = new Logger(this.constructor.name);
    this.config = ConfigManager.getInstance();
    this.certManager = CertificateManager.getInstance();
    this.proxyManager = ProxyManager.getInstance();
    
    // Store initial values (will be overridden during initialization)
    if (apiBaseUrl) {
      this.apiBaseUrl = apiBaseUrl;
    }
    
    this.defaultHeaders = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      ...defaultHeaders
    };
  }

  /**
   * Initialize the client asynchronously
   * Loads configurations, certificates, and proxy settings
   */
  public async init(): Promise<void> {
    if (this.initialized) {
      return;
    }

    if (this.initPromise) {
      return this.initPromise;
    }

    this.initPromise = this.initializeClient();
    await this.initPromise;
    this.initialized = true;
  }

  /**
   * Initialize client with configuration, certificates, and proxy settings
   * @private
   */
  private async initializeClient(): Promise<void> {
    try {
      // Initialize config manager
      await this.config.init();
      
      // Get API configuration from config manager
      this.apiBaseUrl = await this.config.getString('API_BASE_URL', this.apiBaseUrl);
      this.defaultTimeout = await this.config.getNumber('DEFAULT_TIMEOUT', this.defaultTimeout);
      this.serviceName = await this.config.getString('SERVICE_NAME', this.serviceName);
      
      // Initialize retry options
      this.defaultRetryOptions = {
        maxAttempts: await this.config.getNumber('API_RETRY_ATTEMPTS', this.defaultRetryOptions.maxAttempts),
        retryDelay: await this.config.getNumber('API_RETRY_DELAY', this.defaultRetryOptions.retryDelay)
      };
      
      // Initialize polling options
      this.defaultPollingOptions = {
        enabled: await this.config.getBoolean('API_ENABLE_POLLING', this.defaultPollingOptions.enabled),
        maxAttempts: await this.config.getNumber('API_POLLING_MAX_ATTEMPTS', this.defaultPollingOptions.maxAttempts),
        interval: await this.config.getNumber('API_POLLING_INTERVAL', this.defaultPollingOptions.interval),
        timeoutPerAttempt: await this.config.getNumber('API_POLLING_TIMEOUT_PER_ATTEMPT', this.defaultPollingOptions.timeoutPerAttempt)
      };
      
      // Initialize certificate manager
      await this.certManager.init();
      
      // Initialize proxy manager
      await this.proxyManager.init();
      
      this.logger.info(`API client initialized for service: ${this.serviceName}`);
      this.logger.debug(`Base URL: ${this.apiBaseUrl}`);
    } catch (error: any) {
      this.logger.error(`Error initializing API client: ${error.message}`);
      throw error;
    }
  }

  /**
   * Ensure client is initialized before making requests
   * @private
   */
  private async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      await this.init();
    }
  }

  /**
   * Make a GET request
   * @param endpoint - API endpoint
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  async get<T = any>(endpoint: string, options?: ApiRequestOptions): Promise<AxiosResponse<T>> {
    await this.ensureInitialized();
    
    const url = normalizeUrl(endpoint, this.apiBaseUrl);
    this.logger.info(`Making GET request to: ${url}`);
    
    const requestConfig = await createRequestConfig(
      options,
      this.defaultHeaders,
      this.defaultTimeout,
      this.serviceName,
      this.logger
    );
    
    // Check if this is a long-running request that needs polling
    if (options?.pollingOptions?.enabled || this.defaultPollingOptions.enabled) {
      return handleLongRunningRequest<T>(
        () => executeRequest('get', url, undefined, requestConfig, this.logger),
        this.defaultPollingOptions,
        options?.pollingOptions,
        this.logger,
        this.config
      );
    }
    
    return retryRequest<T>(
      () => executeRequest('get', url, undefined, requestConfig, this.logger),
      this.defaultRetryOptions,
      options?.retryOptions,
      this.logger
    );
  }

  /**
   * Make a POST request
   * @param endpoint - API endpoint
   * @param data - Request body
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  async post<T = any>(endpoint: string, data?: any, options?: ApiRequestOptions): Promise<AxiosResponse<T>> {
    await this.ensureInitialized();
    
    const url = normalizeUrl(endpoint, this.apiBaseUrl);
    this.logger.info(`Making POST request to: ${url}`);
    
    const requestConfig = await createRequestConfig(
      options,
      this.defaultHeaders,
      this.defaultTimeout,
      this.serviceName,
      this.logger
    );
    
    // Check if this is a long-running request that needs polling
    if (options?.pollingOptions?.enabled || this.defaultPollingOptions.enabled) {
      return handleLongRunningRequest<T>(
        () => executeRequest('post', url, data, requestConfig, this.logger),
        this.defaultPollingOptions,
        options?.pollingOptions,
        this.logger,
        this.config
      );
    }
    
    return retryRequest<T>(
      () => executeRequest('post', url, data, requestConfig, this.logger),
      this.defaultRetryOptions,
      options?.retryOptions,
      this.logger
    );
  }

  /**
   * Make a PUT request
   * @param endpoint - API endpoint
   * @param data - Request body
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  async put<T = any>(endpoint: string, data?: any, options?: ApiRequestOptions): Promise<AxiosResponse<T>> {
    await this.ensureInitialized();
    
    const url = normalizeUrl(endpoint, this.apiBaseUrl);
    this.logger.info(`Making PUT request to: ${url}`);
    
    const requestConfig = await createRequestConfig(
      options,
      this.defaultHeaders,
      this.defaultTimeout,
      this.serviceName,
      this.logger
    );
    
    // Check if this is a long-running request that needs polling
    if (options?.pollingOptions?.enabled || this.defaultPollingOptions.enabled) {
      return handleLongRunningRequest<T>(
        () => executeRequest('put', url, data, requestConfig, this.logger),
        this.defaultPollingOptions,
        options?.pollingOptions,
        this.logger,
        this.config
      );
    }
    
    return retryRequest<T>(
      () => executeRequest('put', url, data, requestConfig, this.logger),
      this.defaultRetryOptions,
      options?.retryOptions,
      this.logger
    );
  }

  /**
   * Make a PATCH request
   * @param endpoint - API endpoint
   * @param data - Request body
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  async patch<T = any>(endpoint: string, data?: any, options?: ApiRequestOptions): Promise<AxiosResponse<T>> {
    await this.ensureInitialized();
    
    const url = normalizeUrl(endpoint, this.apiBaseUrl);
    this.logger.info(`Making PATCH request to: ${url}`);
    
    const requestConfig = await createRequestConfig(
      options,
      this.defaultHeaders,
      this.defaultTimeout,
      this.serviceName,
      this.logger
    );
    
    // Check if this is a long-running request that needs polling
    if (options?.pollingOptions?.enabled || this.defaultPollingOptions.enabled) {
      return handleLongRunningRequest<T>(
        () => executeRequest('patch', url, data, requestConfig, this.logger),
        this.defaultPollingOptions,
        options?.pollingOptions,
        this.logger,
        this.config
      );
    }
    
    return retryRequest<T>(
      () => executeRequest('patch', url, data, requestConfig, this.logger),
      this.defaultRetryOptions,
      options?.retryOptions,
      this.logger
    );
  }

  /**
   * Make a DELETE request
   * @param endpoint - API endpoint
   * @param options - Request options
   * @returns Promise<AxiosResponse> - API response
   */
  async delete<T = any>(endpoint: string, options?: ApiRequestOptions): Promise<AxiosResponse<T>> {
    await this.ensureInitialized();
    
    const url = normalizeUrl(endpoint, this.apiBaseUrl);
    this.logger.info(`Making DELETE request to: ${url}`);
    
    const requestConfig = await createRequestConfig(
      options,
      this.defaultHeaders,
      this.defaultTimeout,
      this.serviceName,
      this.logger
    );
    
    // Check if this is a long-running request that needs polling
    if (options?.pollingOptions?.enabled || this.defaultPollingOptions.enabled) {
      return handleLongRunningRequest<T>(
        () => executeRequest('delete', url, options?.data, requestConfig, this.logger),
        this.defaultPollingOptions,
        options?.pollingOptions,
        this.logger,
        this.config
      );
    }
    
    return retryRequest<T>(
      () => executeRequest('delete', url, options?.data, requestConfig, this.logger),
      this.defaultRetryOptions,
      options?.retryOptions,
      this.logger
    );
  }

  /**
   * Assert API response status code
   * @param response - Axios response
   * @param expectedStatus - Expected status code
   */
  assertStatusCode(response: AxiosResponse, expectedStatus: number): void {
    assertStatusCode(response, expectedStatus, this.logger);
  }

  /**
   * Assert API response contains specific data
   * @param response - Axios response
   * @param expectedData - Data to check for
   */
  assertResponseData(response: AxiosResponse, expectedData: any): void {
    assertResponseData(response, expectedData, this.logger);
  }

  /**
   * Assert response has data
   * @param response - Axios response
   */
  assertHasData(response: AxiosResponse): void {
    assertHasData(response, this.logger);
  }

  /**
   * Assert response header has a specific value
   * @param response - Axios response
   * @param headerName - Header name
   * @param expectedValue - Expected header value
   */
  assertHeader(response: AxiosResponse, headerName: string, expectedValue: string): void {
    assertHeader(response, headerName, expectedValue, this.logger);
  }

  /**
   * Assert response time is within acceptable limits
   * @param response - Axios response
   * @param maxTime - Maximum acceptable response time in ms
   */
  assertResponseTime(response: AxiosResponse, maxTime: number): void {
    assertResponseTime(response, maxTime, this.logger);
  }

  /**
   * Get authentication token (to be implemented by derived classes)
   * @returns Promise<string> - Authentication token
   */
  async getAuthToken(): Promise<string> {
    throw new Error('getAuthToken() method must be implemented by derived API client classes');
  }

  /**
   * Create auth header with token
   * @param token - Authentication token
   * @returns Record<string, string> - Headers with authentication
   */
  createAuthHeader(token: string): Record<string, string> {
    return { 'Authorization': `Bearer ${token}` };
  }

  /**
   * Attempt to resolve a hostname
   * @param hostname - Hostname to resolve
   * @returns Promise<string> - Resolved IP address
   */
  async resolveHostname(hostname: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const dns = require('dns');
      dns.lookup(hostname, (err: Error | null, address: string) => {
        if (err) {
          this.logger.error(`Failed to resolve hostname ${hostname}: ${err.message}`);
          reject(err);
        } else {
          this.logger.info(`Resolved ${hostname} to ${address}`);
          resolve(address);
        }
      });
    });
  }

  /**
   * Update default headers
   * @param headers - Headers to update
   */
  updateDefaultHeaders(headers: Record<string, string>): void {
    this.defaultHeaders = {
      ...this.defaultHeaders,
      ...headers
    };
    this.logger.debug(`Updated default headers: ${JSON.stringify(this.defaultHeaders)}`);
  }

  /**
   * Set a specific default header
   * @param name - Header name
   * @param value - Header value
   */
  setDefaultHeader(name: string, value: string): void {
    this.defaultHeaders[name] = value;
    this.logger.debug(`Set default header ${name}: ${value}`);
  }

  /**
   * Get client configuration
   * @returns ApiClientConfig - Current client configuration
   */
  getConfig(): ApiClientConfig {
    return {
      baseUrl: this.apiBaseUrl,
      timeout: this.defaultTimeout,
      headers: { ...this.defaultHeaders },
      serviceName: this.serviceName,
      retryOptions: { ...this.defaultRetryOptions },
      pollingOptions: { ...this.defaultPollingOptions }
    };
  }
}

// Re-export all types and utilities for easier importing
export * from './api/types';
export * from './api/request-config';
export * from './api/assertions';
