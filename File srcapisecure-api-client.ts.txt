src/utils/test-request.ts
-------------------
/**
 * Simple script to test API request directly
 * This bypasses the Playwright request API to use Node's https module
 */

import * as fs from 'fs-extra';
import * as path from 'path';
import * as https from 'https';
import { configHelper } from '../../config/config';

// Function to make a direct HTTPS request with certificate
async function makeDirectRequest() {
  try {
    console.log('Starting direct HTTPS request test...');
    
    // Get config values
    const baseUrl = configHelper.getBaseUrl();
    const certPath = configHelper.getCertPath();
    const passphrase = configHelper.getCertPassphrase();
    
    console.log(`Base URL: ${baseUrl}`);
    console.log(`Certificate Path: ${certPath}`);
    console.log(`Has Passphrase: ${passphrase ? 'Yes' : 'No'}`);
    
    // Extract host and path from baseUrl
    const url = new URL(baseUrl);
    const host = url.hostname;
    const port = url.port ? parseInt(url.port) : 443;
    
    console.log(`Host: ${host}`);
    console.log(`Port: ${port}`);
    
    // Load certificate
    let cert = null;
    if (certPath && fs.existsSync(path.resolve(certPath))) {
      cert = fs.readFileSync(path.resolve(certPath));
      console.log(`Certificate loaded: ${cert.length} bytes`);
    } else {
      console.log('No certificate found or path is invalid');
    }
    
    // Load test payload from test data
    const payloadPath = path.resolve('tests/testData/payloads/assetLayoutPayload.json');
    let payload = {};
    
    if (fs.existsSync(payloadPath)) {
      const payloadContent = fs.readFileSync(payloadPath, 'utf8');
      payload = JSON.parse(payloadContent);
      console.log(`Payload loaded: ${JSON.stringify(payload)}`);
    } else {
      console.log('Payload file not found, using sample payload');
      payload = {
        messageId: 1234,
        dealId: 34384,
        reportDate: "2024-03-31"
      };
    }
    
    // Convert payload to string
    const postData = JSON.stringify(payload);
    
    // Create request options
    const options = {
      hostname: host,
      port: port,
      path: '/v1/assets/assetlayout', // Endpoint from your code
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Content-Length': postData.length
      },
      rejectUnauthorized: false // Important for self-signed certs
    };
    
    // Add certificate if available
    if (cert) {
      options['pfx'] = cert;
      if (passphrase) {
        options['passphrase'] = passphrase;
      }
    }
    
    console.log('Request options prepared (without sensitive data)');
    
    // Make the request
    return new Promise((resolve, reject) => {
      const req = https.request(options, (res) => {
        console.log(`STATUS: ${res.statusCode}`);
        console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
        
        let data = '';
        
        res.on('data', (chunk) => {
          data += chunk;
        });
        
        res.on('end', () => {
          console.log('Response received');
          try {
            const jsonData = JSON.parse(data);
            console.log(`Response data: ${JSON.stringify(jsonData, null, 2)}`);
            resolve({ status: res.statusCode, data: jsonData });
          } catch (e) {
            console.log(`Raw response: ${data}`);
            resolve({ status: res.statusCode, data: data });
          }
        });
      });
      
      req.on('error', (e) => {
        console.error(`Request error: ${e.message}`);
        if (e.message.includes('ECONNRESET')) {
          console.error('ECONNRESET error detected - this might be due to a certificate issue or network problem');
        }
        reject(e);
      });
      
      // Write data to request body
      console.log('Sending request...');
      req.write(postData);
      req.end();
      console.log('Request sent');
    });
  } catch (error) {
    console.error(`Error in makeDirectRequest: ${error}`);
    throw error;
  }
}

// Execute the function when script is run directly
if (require.main === module) {
  console.log('Starting direct request test script...');
  
  makeDirectRequest()
    .then(result => {
      console.log(`Test completed successfully with status: ${result.status}`);
      process.exit(0);
    })
    .catch(error => {
      console.error(`Test failed: ${error}`);
      process.exit(1);
    });
}

export default makeDirectRequest;

src/utils/axios-client.ts
----------------------------

/**
 * Alternative API client using axios instead of Playwright
 * This may handle certificates differently
 */

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import * as fs from 'fs-extra';
import * as path from 'path';
import * as https from 'https';
import { configHelper } from '../../config/config';
import { logger } from '../helpers/loggerHelper';
import { RetryHelper } from '../helpers/retryHelper';
import { ApiResponse } from '../models/apiModels';

export class AxiosApiClient {
  private static instance: AxiosApiClient;
  private axiosInstance: AxiosInstance | null = null;

  private constructor() {}

  public static getInstance(): AxiosApiClient {
    if (!AxiosApiClient.instance) {
      AxiosApiClient.instance = new AxiosApiClient();
    }
    return AxiosApiClient.instance;
  }

  /**
   * Initialize the Axios API client
   */
  public async initialize(): Promise<void> {
    try {
      const baseURL = configHelper.getBaseUrl();
      logger.info(`Initializing Axios API client with base URL: ${baseURL}`);
      
      // Handle certificates
      const certPath = configHelper.getCertPath();
      const passphrase = configHelper.getCertPassphrase();
      
      // Create HTTPS agent with certificate if available
      let httpsAgent;
      if (certPath && fs.existsSync(path.resolve(certPath))) {
        const cert = fs.readFileSync(path.resolve(certPath));
        logger.info(`Certificate loaded: ${cert.length} bytes`);
        
        httpsAgent = new https.Agent({
          pfx: cert,
          passphrase: passphrase,
          rejectUnauthorized: false // Important for self-signed certs
        });
      } else {
        logger.warn('No certificate found or path is invalid');
        httpsAgent = new https.Agent({
          rejectUnauthorized: false
        });
      }
      
      // Create axios instance
      const config: AxiosRequestConfig = {
        baseURL,
        timeout: configHelper.getTimeout(),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        httpsAgent,
        validateStatus: () => true // Don't throw on any status code
      };
      
      this.axiosInstance = axios.create(config);
      logger.info('Axios API client initialized successfully');
    } catch (error) {
      logger.error(`Failed to initialize Axios API client: ${error}`);
      this.axiosInstance = null;
      throw error;
    }
  }

  /**
   * Get Axios instance, initializing if needed
   */
  private async getAxiosInstance(): Promise<AxiosInstance> {
    if (!this.axiosInstance) {
      await this.initialize();
    }
    return this.axiosInstance!;
  }

  /**
   * Make a POST request
   * @param url Endpoint URL
   * @param data Request data
   * @returns API response
   */
  public async post<T>(url: string, data: any): Promise<ApiResponse<T>> {
    try {
      logger.info(`Making POST request to ${url}`);
      
      const axios = await this.getAxiosInstance();
      
      // Use retry for robustness
      const retries = parseInt(configHelper.get('REQUEST_RETRY_COUNT'), 10) || 3;
      const retryDelay = parseInt(configHelper.get('REQUEST_RETRY_DELAY'), 10) || 1000;
      
      const response = await RetryHelper.withRetry<AxiosResponse>(
        async () => {
          try {
            return await axios.post(url, data);
          } catch (error) {
            logger.error(`Request error: ${error}`);
            if (error.message?.includes('ECONNRESET')) {
              logger.error('ECONNRESET error detected - retrying...');
            }
            throw error;
          }
        },
        retries,
        retryDelay
      );
      
      logger.info(`Received response with status: ${response.status}`);
      
      // Convert to API response format
      const apiResponse: ApiResponse<T> = {
        statusCode: response.status,
        headers: response.headers as Record<string, string>,
        data: response.data as T,
        ok: response.status >= 200 && response.status < 300
      };
      
      return apiResponse;
    } catch (error) {
      logger.error(`POST request failed: ${error}`);
      throw error;
    }
  }
}

// Create a test function to make a request
async function testAxiosRequest() {
  try {
    console.log('Starting Axios API request test...');
    
    const client = AxiosApiClient.getInstance();
    await client.initialize();
    
    // Load test payload from test data
    const payloadPath = path.resolve('tests/testData/payloads/assetLayoutPayload.json');
    let payload = {};
    
    if (fs.existsSync(payloadPath)) {
      const payloadContent = fs.readFileSync(payloadPath, 'utf8');
      payload = JSON.parse(payloadContent);
      console.log(`Payload loaded: ${JSON.stringify(payload)}`);
    } else {
      console.log('Payload file not found, using sample payload');
      payload = {
        messageId: 1234,
        dealId: 34384,
        reportDate: "2024-03-31"
      };
    }
    
    // Make the request
    console.log('Sending request...');
    const response = await client.post('/v1/assets/assetlayout', payload);
    
    console.log(`Response status: ${response.statusCode}`);
    console.log(`Response data: ${JSON.stringify(response.data, null, 2)}`);
    
    return response;
  } catch (error) {
    console.error(`Error in Axios request test: ${error}`);
    throw error;
  }
}

// Execute the function when script is run directly
if (require.main === module) {
  console.log('Starting Axios API client test script...');
  
  testAxiosRequest()
    .then(response => {
      console.log(`Test completed successfully with status: ${response.statusCode}`);
      process.exit(0);
    })
    .catch(error => {
      console.error(`Test failed: ${error}`);
      process.exit(1);
    });
}

export default {
  client: AxiosApiClient.getInstance(),
  test: testAxiosRequest
};

src/utils/cert-checker.ts
------------------------
/**
 * Script to check certificate details and validate them
 * This helps diagnose certificate-related issues
 */

import * as fs from 'fs-extra';
import * as path from 'path';
import * as crypto from 'crypto';
import { configHelper } from '../../config/config';

// Function to analyze and validate the certificate
async function analyzeCertificate() {
  try {
    console.log('Starting certificate analysis...');
    
    // Get certificate path and passphrase from config
    const certPath = configHelper.getCertPath();
    const passphrase = configHelper.getCertPassphrase();
    
    console.log(`Certificate Path: ${certPath}`);
    console.log(`Has Passphrase: ${passphrase ? 'Yes' : 'No'}`);
    
    if (!certPath) {
      console.error('No certificate path configured in config');
      return false;
    }
    
    const resolvedPath = path.resolve(certPath);
    console.log(`Resolved Certificate Path: ${resolvedPath}`);
    
    // Check if file exists
    if (!fs.existsSync(resolvedPath)) {
      console.error(`Certificate file does not exist at path: ${resolvedPath}`);
      return false;
    }
    
    // Read certificate
    const certBuffer = fs.readFileSync(resolvedPath);
    console.log(`Certificate file size: ${certBuffer.length} bytes`);
    console.log(`Certificate file MD5 hash: ${crypto.createHash('md5').update(certBuffer).digest('hex')}`);
    
    // Check if it's a PFX file (PKCS#12)
    const isPfxFile = resolvedPath.toLowerCase().endsWith('.pfx') || resolvedPath.toLowerCase().endsWith('.p12');
    console.log(`Is PFX file (by extension): ${isPfxFile}`);
    
    // Try to verify PFX file if it has that extension
    if (isPfxFile) {
      try {
        // Try to load the PFX and extract info
        const pfx = crypto.createPrivateKey({
          key: certBuffer,
          format: 'der',
          type: 'pkcs12',
          passphrase: passphrase
        });
        
        console.log('Successfully loaded PFX certificate!');
        console.log(`PFX type: ${pfx.asymmetricKeyType}`);
        console.log(`PFX algorithm: ${pfx.asymmetricKeyDetails?.namedCurve || pfx.asymmetricKeyDetails?.modulusLength || 'unknown'}`);
        
        return true;
      } catch (pfxError) {
        console.error(`Failed to parse PFX certificate: ${pfxError}`);
        console.log('This usually indicates an incorrect passphrase or corrupted certificate file');
        
        // If the error mentions "mac verify failure", it's likely a passphrase issue
        if (pfxError.message && pfxError.message.includes('mac verify failure')) {
          console.error('MAC verify failure detected - this usually means the passphrase is incorrect');
        }
        
        return false;
      }
    } else {
      console.log('Certificate does not appear to be a PFX file based on extension');
      console.log('Make sure you are using the correct certificate format (PFX/PKCS#12)');
      return false;
    }
  } catch (error) {
    console.error(`Error analyzing certificate: ${error}`);
    return false;
  }
}

// Execute the function when script is run directly
if (require.main === module) {
  console.log('Starting certificate analysis script...');
  
  analyzeCertificate()
    .then(isValid => {
      console.log(`Certificate analysis completed. Certificate is ${isValid ? 'valid' : 'invalid'}.`);
      process.exit(isValid ? 0 : 1);
    })
    .catch(error => {
      console.error(`Certificate analysis failed with error: ${error}`);
      process.exit(1);
    });
}

export default analyzeCertificate;

src/utils/connection-tester.ts
-----------------------------
/**
 * Script to test connectivity to the API endpoint
 * This helps diagnose network and connection issues
 */

import * as https from 'https';
import * as net from 'net';
import * as dns from 'dns';
import { configHelper } from '../../config/config';

// Function to test basic connectivity
async function testConnectivity() {
  try {
    console.log('Starting connectivity tests...');
    
    // Get base URL from config
    const baseUrl = configHelper.getBaseUrl();
    console.log(`Base URL: ${baseUrl}`);
    
    if (!baseUrl) {
      console.error('No base URL configured in config');
      return false;
    }
    
    // Parse the URL
    const url = new URL(baseUrl);
    const host = url.hostname;
    const port = url.port ? parseInt(url.port) : 443;
    
    console.log(`Host: ${host}`);
    console.log(`Port: ${port}`);
    
    // Test DNS resolution
    console.log(`Testing DNS resolution for ${host}...`);
    try {
      const addresses = await new Promise<string[]>((resolve, reject) => {
        dns.resolve4(host, (err, addresses) => {
          if (err) reject(err);
          else resolve(addresses);
        });
      });
      
      console.log(`DNS resolution successful. IP addresses: ${addresses.join(', ')}`);
    } catch (dnsError) {
      console.error(`DNS resolution failed: ${dnsError}`);
      return false;
    }
    
    // Test TCP connection
    console.log(`Testing TCP connection to ${host}:${port}...`);
    try {
      await new Promise<void>((resolve, reject) => {
        const socket = net.createConnection({ host, port }, () => {
          console.log('TCP connection successful');
          socket.end();
          resolve();
        });
        
        socket.on('error', (err) => {
          reject(err);
        });
        
        socket.setTimeout(5000, () => {
          socket.destroy();
          reject(new Error('Connection timeout'));
        });
      });
    } catch (tcpError) {
      console.error(`TCP connection failed: ${tcpError}`);
      return false;
    }
    
    // Test HTTPS connection (without certificate)
    console.log(`Testing HTTPS connection to ${host}:${port}...`);
    try {
      await new Promise<void>((resolve, reject) => {
        const req = https.request({
          hostname: host,
          port: port,
          path: '/',
          method: 'HEAD',
          rejectUnauthorized: false,
          timeout: 5000
        }, (res) => {
          console.log(`HTTPS connection successful. Status code: ${res.statusCode}`);
          resolve();
        });
        
        req.on('error', (err) => {
          reject(err);
        });
        
        req.on('timeout', () => {
          req.destroy();
          reject(new Error('HTTPS request timeout'));
        });
        
        req.end();
      });
    } catch (httpsError) {
      console.error(`HTTPS connection failed: ${httpsError}`);
      return false;
    }
    
    console.log('All connectivity tests passed successfully');
    return true;
  } catch (error) {
    console.error(`Error in connectivity tests: ${error}`);
    return false;
  }
}

// Execute the function when script is run directly
if (require.main === module) {
  console.log('Starting connectivity test script...');
  
  testConnectivity()
    .then(isConnected => {
      console.log(`Connectivity test completed. Connection is ${isConnected ? 'successful' : 'failed'}.`);
      process.exit(isConnected ? 0 : 1);
    })
    .catch(error => {
      console.error(`Connectivity test failed with error: ${error}`);
      process.exit(1);
    });
}

export default testConnectivity;
