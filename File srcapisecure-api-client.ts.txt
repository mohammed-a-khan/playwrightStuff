apiclient.ts
--------------

import * as https from 'https';
import * as fs from 'fs-extra';
import * as path from 'path';
import { URL } from 'url';
import { configHelper } from '../../config/config';
import { logger, logHttpDetails } from '../helpers/loggerHelper';
import { RetryHelper } from '../helpers/retryHelper';
import { TimeoutUtils } from '../utils/timeoutUtils';

export interface RequestOptions {
  headers?: Record<string, string>;
  timeout?: number;
  retries?: number;
  retryDelay?: number;
  retryCondition?: (response: ApiResponse<any>) => boolean;
}

export interface ApiResponse<T> {
  statusCode: number;
  headers: Record<string, string>;
  data: T;
  ok: boolean;
}

export class ApiClient {
  private static instance: ApiClient;
  private baseUrl: string;
  private certificatePath: string | null = null;
  private certificatePassphrase: string | null = null;
  private certificate: Buffer | null = null;

  private constructor() {
    this.baseUrl = configHelper.getBaseUrl();
    this.initializeCertificate();
  }

  public static getInstance(): ApiClient {
    if (!ApiClient.instance) {
      ApiClient.instance = new ApiClient();
    }
    return ApiClient.instance;
  }

  /**
   * Initialize certificate
   */
  private initializeCertificate(): void {
    try {
      const certPath = configHelper.getCertPath();
      if (certPath) {
        const resolvedPath = path.resolve(certPath);
        if (fs.existsSync(resolvedPath)) {
          this.certificatePath = resolvedPath;
          this.certificatePassphrase = configHelper.getCertPassphrase();
          this.certificate = fs.readFileSync(resolvedPath);
          logger.info(`Certificate loaded: ${this.certificate.length} bytes from ${resolvedPath}`);
        } else {
          logger.warn(`Certificate file not found at path: ${resolvedPath}`);
        }
      } else {
        logger.info('No certificate path configured');
      }
    } catch (error) {
      logger.error(`Failed to initialize certificate: ${error}`);
    }
  }

  /**
   * Initialize the API client
   * @returns Promise resolving when initialization is complete
   */
  public async initialize(): Promise<void> {
    logger.info(`API Client initialized with base URL: ${this.baseUrl}`);
    if (this.certificate) {
      logger.info('Certificate is loaded and ready');
    } else {
      logger.info('Running without certificate');
    }
    return Promise.resolve();
  }

  /**
   * Perform a GET request
   * @param url The URL to request
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async get<T>(url: string, options: RequestOptions = {}): Promise<ApiResponse<T>> {
    return this.executeRequest<T>('GET', url, undefined, options);
  }

  /**
   * Perform a POST request
   * @param url The URL to request
   * @param data The data to send
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async post<T>(url: string, data: any, options: RequestOptions = {}): Promise<ApiResponse<T>> {
    return this.executeRequest<T>('POST', url, data, options);
  }

  /**
   * Perform a PUT request
   * @param url The URL to request
   * @param data The data to send
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async put<T>(url: string, data: any, options: RequestOptions = {}): Promise<ApiResponse<T>> {
    return this.executeRequest<T>('PUT', url, data, options);
  }

  /**
   * Perform a DELETE request
   * @param url The URL to request
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async delete<T>(url: string, options: RequestOptions = {}): Promise<ApiResponse<T>> {
    return this.executeRequest<T>('DELETE', url, undefined, options);
  }

  /**
   * Perform a PATCH request
   * @param url The URL to request
   * @param data The data to send
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async patch<T>(url: string, data: any, options: RequestOptions = {}): Promise<ApiResponse<T>> {
    return this.executeRequest<T>('PATCH', url, data, options);
  }

  /**
   * Execute a request with retries and timeouts
   * @param method The HTTP method
   * @param endpoint The endpoint URL
   * @param data The data to send (for POST, PUT, PATCH)
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  private async executeRequest<T>(
    method: string,
    endpoint: string,
    data?: any,
    options: RequestOptions = {}
  ): Promise<ApiResponse<T>> {
    const headers = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      ...(options.headers || {})
    };
    
    const timeout = options.timeout || configHelper.getRequestTimeout();
    const retries = options.retries || parseInt(configHelper.get('REQUEST_RETRY_COUNT'), 10) || 3;
    const retryDelay = options.retryDelay || parseInt(configHelper.get('REQUEST_RETRY_DELAY'), 10) || 1000;
    
    // Normalize the endpoint URL
    if (endpoint.startsWith('/')) {
      endpoint = endpoint.substring(1);
    }
    
    const fullUrl = `${this.baseUrl}/${endpoint}`;
    
    // Only log if detailed logging is enabled
    if (configHelper.isDetailedLogging()) {
      logHttpDetails(method, fullUrl, headers, data);
    }
    
    return RetryHelper.withRetry<ApiResponse<T>>(
      async () => {
        return TimeoutUtils.withTimeout<ApiResponse<T>>(
          async () => {
            return this.makeHttpRequest<T>(method, fullUrl, data, headers);
          },
          timeout,
          `Request ${method} ${fullUrl} timed out after ${timeout}ms`
        );
      },
      retries,
      retryDelay
    );
  }

  /**
   * Make an HTTP request using Node.js https module
   * @param method HTTP method
   * @param url Full URL
   * @param data Request data
   * @param headers Request headers
   * @returns Promise resolving to API response
   */
  private async makeHttpRequest<T>(
    method: string,
    url: string,
    data?: any,
    headers: Record<string, string> = {}
  ): Promise<ApiResponse<T>> {
    return new Promise<ApiResponse<T>>((resolve, reject) => {
      try {
        // Parse URL
        const parsedUrl = new URL(url);
        
        // Prepare request data if needed
        const postData = data ? JSON.stringify(data) : '';
        
        // Set Content-Length for requests with body
        if (postData && !headers['Content-Length']) {
          headers['Content-Length'] = Buffer.byteLength(postData).toString();
        }
        
        // Prepare request options
        const options: https.RequestOptions = {
          hostname: parsedUrl.hostname,
          port: parsedUrl.port || 443,
          path: parsedUrl.pathname + parsedUrl.search,
          method: method,
          headers: headers,
          rejectUnauthorized: false // For self-signed certificates
        };
        
        // Add certificate if available
        if (this.certificate) {
          options.pfx = this.certificate;
          if (this.certificatePassphrase) {
            options.passphrase = this.certificatePassphrase;
          }
        }
        
        logger.debug(`Making ${method} request to ${url}`);
        
        // Create request
        const req = https.request(options, (res) => {
          let responseData = '';
          
          // Collect response data
          res.on('data', (chunk) => {
            responseData += chunk;
          });
          
          // Process response when complete
          res.on('end', () => {
            try {
              // Parse JSON if possible
              let parsedData: any;
              try {
                parsedData = JSON.parse(responseData);
              } catch (e) {
                parsedData = responseData;
              }
              
              // Create API response
              const apiResponse: ApiResponse<T> = {
                statusCode: res.statusCode || 0,
                headers: res.headers as Record<string, string>,
                data: parsedData,
                ok: (res.statusCode || 0) >= 200 && (res.statusCode || 0) < 300
              };
              
              // Log response details if needed
              if (configHelper.isDetailedLogging()) {
                logHttpDetails(
                  method,
                  url,
                  headers,
                  data,
                  apiResponse.statusCode,
                  apiResponse.headers,
                  apiResponse.data
                );
              }
              
              // Determine if we should retry based on status code
              const status = apiResponse.statusCode;
              const shouldRetry = status >= 500;
              
              if (shouldRetry) {
                reject(new Error(`Request failed with status: ${status}`));
              } else {
                resolve(apiResponse);
              }
            } catch (error) {
              logger.error(`Error processing response: ${error}`);
              reject(error);
            }
          });
        });
        
        // Handle request errors
        req.on('error', (error) => {
          logger.error(`Request error: ${error.message}`);
          
          // Handle specific errors
          if (error.message.includes('ECONNRESET')) {
            logger.error('ECONNRESET error detected - connection was reset by server');
          }
          
          reject(error);
        });
        
        // Handle timeout
        req.on('timeout', () => {
          req.destroy();
          reject(new Error('Request timed out'));
        });
        
        // Send data for request methods that have a body
        if (['POST', 'PUT', 'PATCH'].includes(method.toUpperCase()) && postData) {
          req.write(postData);
        }
        
        // End the request
        req.end();
      } catch (error) {
        logger.error(`Error creating request: ${error}`);
        reject(error);
      }
    });
  }

  /**
   * Dispose the API client
   */
  public async dispose(): Promise<void> {
    logger.info('API Client disposed');
  }
}

export default ApiClient.getInstance();

reporthelper.ts
------------------
import * as fs from 'fs-extra';
import * as path from 'path';
import * as dayjs from 'dayjs';
import { logger } from './loggerHelper';
import { configHelper } from '../../config/config';
import { TestResult, TestSummary, TestReport } from '../models/reportModels';
import * as handlebars from 'handlebars';
import { v4 as uuidv4 } from 'uuid';

// Register handlebars helpers
handlebars.registerHelper('formatDate', (date: string, format?: string) => {
  if (!date) return '';
  try {
    return format ? 
      dayjs(date).format(format) : 
      dayjs(date).format('YYYY-MM-DD HH:mm:ss');
  } catch (e) {
    return date;
  }
});

handlebars.registerHelper('formatDuration', (ms: number) => {
  if (ms === undefined || ms === null) return '0ms';
  try {
    if (ms < 1000) return `${ms}ms`;
    const seconds = Math.floor(ms / 1000);
    const remainingMs = ms % 1000;
    return seconds > 0 ? 
      `${seconds}.${remainingMs.toString().padStart(3, '0')}s` : 
      `${ms}ms`;
  } catch (e) {
    return `${ms}ms`;
  }
});

handlebars.registerHelper('passPercentage', (passed: number, total: number) => {
  try {
    if (total === 0) return 0;
    return Math.round((passed / total) * 100);
  } catch (e) {
    return 0;
  }
});

export class ReportHelper {
  private static instance: ReportHelper;
  private testResults: TestResult[] = [];
  private startTime: Date | null = null;
  private endTime: Date | null = null;
  private reportDir: string;
  private screenshotDir: string;

  private constructor() {
    this.reportDir = path.join(process.cwd(), 'reports', 'html');
    this.screenshotDir = path.join(process.cwd(), 'reports', 'screenshots');
    fs.ensureDirSync(this.reportDir);
    fs.ensureDirSync(this.screenshotDir);
  }

  public static getInstance(): ReportHelper {
    if (!ReportHelper.instance) {
      ReportHelper.instance = new ReportHelper();
    }
    return ReportHelper.instance;
  }

  /**
   * Start a test run
   */
  public startTestRun(): void {
    this.startTime = new Date();
    this.testResults = [];
    logger.info(`Test run started at ${this.startTime.toISOString()}`);
  }

  /**
   * Add test result to the report
   * @param feature Feature name
   * @param scenario Scenario name
   * @param status Test status
   * @param duration Test duration
   * @param error Error message
   * @param metadata Additional metadata
   * @param screenshots Array of screenshot paths
   */
  public addTestResult(
    feature: string,
    scenario: string,
    status: string,
    duration: number,
    error?: string,
    metadata?: Record<string, any>,
    screenshots?: string[]
  ): void {
    // Ensure parameters are valid to prevent errors
    const safeFeature = feature || 'Unknown';
    const safeScenario = scenario || 'Unknown';
    const safeStatus = status || 'unknown';
    const safeDuration = duration || 0;
    
    const testResult: TestResult = {
      id: uuidv4(),
      feature: safeFeature,
      scenario: safeScenario,
      status: safeStatus,
      duration: safeDuration,
      error,
      timestamp: new Date().toISOString(),
      metadata,
      screenshots
    };
    
    this.testResults.push(testResult);
    
    logger.info(`Test result added: ${safeScenario} - ${safeStatus} (${safeDuration}ms)`);
  }

  /**
   * End a test run
   */
  public endTestRun(): void {
    this.endTime = new Date();
    logger.info(`Test run ended at ${this.endTime ? this.endTime.toISOString() : 'unknown time'}`);
  }

  /**
   * Take a screenshot
   * @param name Screenshot name
   * @param content Screenshot content (base64 encoded)
   * @returns Path to saved screenshot
   */
  public async takeScreenshot(name: string, content: string): Promise<string> {
    try {
      const timestamp = dayjs().format('YYYYMMDD_HHmmss');
      const sanitizedName = name ? name.replace(/[^a-zA-Z0-9]/g, '_') : 'screenshot';
      const filename = `${sanitizedName}_${timestamp}.png`;
      const filePath = path.join(this.screenshotDir, filename);
      
      // Convert base64 to buffer
      const data = Buffer.from(content, 'base64');
      
      // Save screenshot
      await fs.writeFile(filePath, data);
      
      logger.debug(`Screenshot saved: ${filePath}`);
      return filePath;
    } catch (error) {
      logger.error(`Error saving screenshot: ${error}`);
      return '';
    }
  }

  /**
   * Generate test report
   * @param customReportName Optional custom report name
   * @returns Path to generated report
   */
  public async generateReport(customReportName?: string): Promise<string> {
    try {
      // If start/end time not set, set them now to prevent errors
      if (!this.startTime) {
        this.startTime = new Date();
        logger.warn('Start time was not set, using current time');
      }
      
      if (!this.endTime) {
        this.endTime = new Date();
        logger.warn('End time was not set, using current time');
      }
      
      // Safely generate report name
      let reportName = 'report';
      
      if (customReportName) {
        // Ensure custom report name is safe for file system
        reportName = customReportName.replace(/[^a-zA-Z0-9-_]/g, '-');
      } else {
        // Generate timestamped report name
        const timestamp = dayjs().format('YYYYMMDD_HHmmss');
        reportName = `report_${timestamp}`;
      }
      
      const reportPath = path.join(this.reportDir, `${reportName}.html`);
      const jsonReportPath = path.join(this.reportDir, `${reportName}.json`);
      
      // Make sure the directories exist
      await fs.ensureDir(this.reportDir);

      // Calculate summary
      const totalDuration = this.endTime.getTime() - this.startTime.getTime();
      const totalTests = this.testResults.length;
      const passedTests = this.testResults.filter(test => test.status === 'passed').length;
      const failedTests = this.testResults.filter(test => test.status === 'failed').length;
      const skippedTests = this.testResults.filter(test => test.status === 'skipped').length;
      const pendingTests = this.testResults.filter(test => test.status === 'pending').length;

      const environment = configHelper.getEnvironment() || 'unknown';
      const baseUrl = configHelper.getBaseUrl() || 'unknown';

      // Create summary
      const summary: TestSummary = {
        environment,
        baseUrl,
        startTime: this.startTime.toISOString(),
        endTime: this.endTime.toISOString(),
        totalDuration,
        totalTests,
        passedTests,
        failedTests,
        skippedTests,
        pendingTests
      };

      // Create report data
      const reportData: TestReport = {
        summary,
        results: this.testResults
      };

      // Generate HTML report from embedded template
      const template = this.getEmbeddedTemplate();

      // Compile and apply template
      const compiledTemplate = handlebars.compile(template);
      const html = compiledTemplate(reportData);

      // Write HTML report
      await fs.writeFile(reportPath, html, 'utf8');
      logger.info(`HTML report generated: ${reportPath}`);

      // Write JSON report
      await fs.writeFile(jsonReportPath, JSON.stringify(reportData, null, 2), 'utf8');
      logger.info(`JSON report generated: ${jsonReportPath}`);

      return reportPath;
    } catch (error) {
      logger.error(`Error generating report: ${error}`);
      throw error;
    }
  }

  /**
   * Get embedded HTML template
   * @returns HTML template string
   */
  private getEmbeddedTemplate(): string {
    return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>API Test Report</title>
      <style>
        body {
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          margin: 0;
          padding: 0;
          background-color: #f5f7fa;
          color: #333;
          line-height: 1.6;
        }
        .container {
          max-width: 1200px;
          margin: 0 auto;
          padding: 20px;
        }
        .report-header {
          background-color: #fff;
          padding: 30px;
          border-radius: 8px;
          margin-bottom: 30px;
          box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        .report-title {
          margin: 0;
          color: #2c3e50;
          font-size: 28px;
          border-bottom: 2px solid #eaeaea;
          padding-bottom: 15px;
          margin-bottom: 20px;
        }
        .report-info {
          display: flex;
          flex-wrap: wrap;
          gap: 20px;
        }
        .info-item {
          flex: 1 1 200px;
        }
        .info-label {
          font-weight: 600;
          color: #7f8c8d;
          font-size: 14px;
          margin-bottom: 5px;
        }
        .info-value {
          font-size: 16px;
        }
        .report-summary {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
          gap: 20px;
          margin-bottom: 30px;
        }
        .summary-item {
          background-color: #fff;
          padding: 20px;
          border-radius: 8px;
          box-shadow: 0 4px 6px rgba(0,0,0,0.05);
          text-align: center;
        }
        .summary-item.total { border-top: 4px solid #3498db; }
        .summary-item.passed { border-top: 4px solid #2ecc71; }
        .summary-item.failed { border-top: 4px solid #e74c3c; }
        .summary-item.skipped { border-top: 4px solid #f39c12; }
        .summary-item.pending { border-top: 4px solid #9b59b6; }
        .summary-title {
          font-size: 14px;
          font-weight: 600;
          color: #7f8c8d;
          margin: 0 0 10px 0;
        }
        .summary-value {
          font-size: 36px;
          font-weight: 700;
          margin: 0;
        }
        .summary-value.passed { color: #2ecc71; }
        .summary-value.failed { color: #e74c3c; }
        .summary-value.skipped { color: #f39c12; }
        .summary-value.pending { color: #9b59b6; }
        .progress-container {
          height: 10px;
          background-color: #ecf0f1;
          border-radius: 5px;
          overflow: hidden;
          margin: 20px 0;
        }
        .progress-bar {
          height: 100%;
          background-color: #2ecc71;
          border-radius: 5px;
        }
        .test-results {
          background-color: #fff;
          border-radius: 8px;
          box-shadow: 0 4px 6px rgba(0,0,0,0.05);
          overflow: hidden;
        }
        .section-title {
          padding: 20px;
          margin: 0;
          background-color: #f8f9fa;
          border-bottom: 1px solid #eaeaea;
          font-size: 20px;
          color: #2c3e50;
        }
        .results-table {
          width: 100%;
          border-collapse: collapse;
        }
        .results-table th,
        .results-table td {
          padding: 15px;
          text-align: left;
          border-bottom: 1px solid #eaeaea;
        }
        .results-table th {
          background-color: #f8f9fa;
          font-weight: 600;
          color: #7f8c8d;
        }
        .results-table tr:hover {
          background-color: #f9f9f9;
        }
        .results-table tr:last-child td {
          border-bottom: none;
        }
        .status-pill {
          display: inline-block;
          padding: 5px 12px;
          border-radius: 20px;
          font-weight: 600;
          font-size: 12px;
          text-transform: uppercase;
        }
        .status-pill.passed { background-color: #e8f8f0; color: #2ecc71; }
        .status-pill.failed { background-color: #fdedeb; color: #e74c3c; }
        .status-pill.skipped { background-color: #fef5e8; color: #f39c12; }
        .status-pill.pending { background-color: #f4ecf7; color: #9b59b6; }
        .error-details {
          padding: 15px;
          background-color: #fdedeb;
          color: #c0392b;
          border-radius: 5px;
          margin-top: 10px;
          font-family: monospace;
          white-space: pre-wrap;
          display: none;
        }
        .toggle-error {
          cursor: pointer;
          color: #3498db;
          text-decoration: underline;
          display: inline-block;
          margin-top: 10px;
          font-size: 14px;
        }
        .duration {
          font-family: monospace;
          color: #7f8c8d;
        }
        .screenshot-link {
          display: inline-block;
          padding: 5px 10px;
          background-color: #3498db;
          color: white;
          border-radius: 4px;
          text-decoration: none;
          margin-top: 10px;
          font-size: 12px;
        }
        .screenshot-link:hover {
          background-color: #2980b9;
        }
        .footer {
          text-align: center;
          margin-top: 40px;
          padding: 20px;
          color: #7f8c8d;
          font-size: 14px;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="report-header">
          <h1 class="report-title">API Test Automation Report</h1>
          <div class="report-info">
            <div class="info-item">
              <div class="info-label">Environment</div>
              <div class="info-value">{{summary.environment}}</div>
            </div>
            <div class="info-item">
              <div class="info-label">Base URL</div>
              <div class="info-value">{{summary.baseUrl}}</div>
            </div>
            <div class="info-item">
              <div class="info-label">Start Time</div>
              <div class="info-value">{{formatDate summary.startTime}}</div>
            </div>
            <div class="info-item">
              <div class="info-label">End Time</div>
              <div class="info-value">{{formatDate summary.endTime}}</div>
            </div>
            <div class="info-item">
              <div class="info-label">Duration</div>
              <div class="info-value">{{formatDuration summary.totalDuration}}</div>
            </div>
          </div>
        </div>
        
        <div class="report-summary">
          <div class="summary-item total">
            <div class="summary-title">TOTAL TESTS</div>
            <div class="summary-value">{{summary.totalTests}}</div>
          </div>
          <div class="summary-item passed">
            <div class="summary-title">PASSED</div>
            <div class="summary-value passed">{{summary.passedTests}}</div>
          </div>
          <div class="summary-item failed">
            <div class="summary-title">FAILED</div>
            <div class="summary-value failed">{{summary.failedTests}}</div>
          </div>
          <div class="summary-item skipped">
            <div class="summary-title">SKIPPED</div>
            <div class="summary-value skipped">{{summary.skippedTests}}</div>
          </div>
          {{#if summary.pendingTests}}
          <div class="summary-item pending">
            <div class="summary-title">PENDING</div>
            <div class="summary-value pending">{{summary.pendingTests}}</div>
          </div>
          {{/if}}
        </div>
        
        <div class="progress-container">
          <div class="progress-bar" style="width: {{passPercentage summary.passedTests summary.totalTests}}%"></div>
        </div>
        
        <div class="test-results">
          <h2 class="section-title">Test Results</h2>
          <table class="results-table">
            <thead>
              <tr>
                <th>Feature</th>
                <th>Scenario</th>
                <th>Status</th>
                <th>Duration</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {{#each results}}
              <tr>
                <td>{{this.feature}}</td>
                <td>{{this.scenario}}</td>
                <td><span class="status-pill {{this.status}}">{{this.status}}</span></td>
                <td><span class="duration">{{formatDuration this.duration}}</span></td>
                <td>
                  {{#if this.error}}
                  <span class="toggle-error" onclick="toggleError('{{this.id}}')">Show/Hide Error</span>
                  <div id="error-{{this.id}}" class="error-details">{{this.error}}</div>
                  {{/if}}
                  
                  {{#if this.screenshots}}
                  <div>
                    {{#each this.screenshots}}
                    <a href="{{this}}" target="_blank" class="screenshot-link">Screenshot {{@index}}</a>
                    {{/each}}
                  </div>
                  {{/if}}
                </td>
              </tr>
              {{/each}}
            </tbody>
          </table>
        </div>
        
        <div class="footer">
          <p>Generated on {{formatDate summary.endTime 'YYYY-MM-DD HH:mm:ss'}} by Enhanced Playwright API Automation Framework</p>
        </div>
      </div>
      
      <script>
        function toggleError(id) {
          const element = document.getElementById('error-' + id);
          if (element.style.display === 'block') {
            element.style.display = 'none';
          } else {
            element.style.display = 'block';
          }
        }
      </script>
    </body>
    </html>
    `;
  }
}

export default ReportHelper.getInstance();

test-runner.ts
------------------
/**
 * Simple script to run a single test to verify the implementation
 */

import apiClient from '../src/api/apiClient';
import { Endpoints } from '../src/api/endpoints';
import { logger } from '../src/helpers/loggerHelper';
import { AssetLayoutRequest } from '../src/models/apiModels';

async function runSimpleTest() {
  try {
    logger.info('Starting simple API test...');
    
    // Initialize API client
    await apiClient.initialize();
    
    // Create test payload
    const payload: AssetLayoutRequest = {
      messageId: 1234,
      dealId: 34384,
      reportDate: "2024-03-31"
    };
    
    logger.info(`Sending asset layout request with dealId: ${payload.dealId}`);
    
    // Send request
    const response = await apiClient.post(Endpoints.ASSET_LAYOUT, payload);
    
    // Log results
    logger.info(`Received response with status code: ${response.statusCode}`);
    logger.info(`Response data: ${JSON.stringify(response.data, null, 2)}`);
    
    return response;
  } catch (error) {
    logger.error(`Test failed: ${error}`);
    throw error;
  } finally {
    // Clean up
    await apiClient.dispose();
  }
}

// Run test if called directly
if (require.main === module) {
  runSimpleTest()
    .then(() => {
      logger.info('Test completed successfully');
      process.exit(0);
    })
    .catch((error) => {
      logger.error(`Test failed: ${error}`);
      process.exit(1);
    });
}

export default runSimpleTest;
