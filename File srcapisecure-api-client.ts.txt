// src/framework/utils/config-manager.ts
import dotenv from 'dotenv';
import path from 'path';
import fs from 'fs';

/**
 * Enhanced Configuration Manager for handling environment-specific configurations
 * Implements singleton pattern to ensure configuration is loaded only once
 * 
 * Features:
 * - Multiple configuration sources (JSON files, .env files, environment variables)
 * - Type conversion for configuration values
 * - Nested configuration keys with dot notation
 * - Default values
 * - Caching for better performance
 * - Environment-specific configuration overrides
 */
export class ConfigManager {
  private static instance: ConfigManager;
  private config: Record<string, any> = {};
  private initialized: boolean = false;
  private configSources: string[] = [];

  /**
   * Private constructor for singleton pattern
   */
  private constructor() {
    this.loadConfiguration();
  }

  /**
   * Get singleton instance
   * @returns ConfigManager instance
   */
  public static getInstance(): ConfigManager {
    if (!ConfigManager.instance) {
      ConfigManager.instance = new ConfigManager();
    }
    return ConfigManager.instance;
  }

  /**
   * Load configuration from all sources
   * - .env files
   * - JSON configuration files
   * - Environment variables
   * @private
   */
  private loadConfiguration(): void {
    if (this.initialized) {
      return;
    }

    try {
      // Start with an empty configuration
      this.config = {};
      
      // 1. Load base .env file first (if exists)
      this.loadEnvFile('.env');

      // 2. Load environment-specific .env file if specified
      const env = process.env.NODE_ENV || 'development';
      this.loadEnvFile(`.env.${env}`);

      // 3. Load JSON configuration files if they exist
      this.loadJsonConfig('default.json');
      this.loadJsonConfig(`${env}.json`);
      
      // 4. Override with any CI-specific configuration
      if (process.env.CI === 'true') {
        this.loadJsonConfig('ci.json');
        this.loadEnvFile('.env.ci');
      }

      // 5. Override with environment variables (highest priority)
      this.mergeEnvironmentVariables();

      this.initialized = true;
      console.log(`Configuration loaded from: ${this.configSources.join(', ')}`);
    } catch (error) {
      console.error(`Error loading configuration: ${error}`);
    }
  }

  /**
   * Load configuration from a .env file
   * @param filename - Name of the .env file
   * @private
   */
  private loadEnvFile(filename: string): void {
    const envPath = path.resolve(process.cwd(), filename);
    
    if (fs.existsSync(envPath)) {
      dotenv.config({ path: envPath, override: true });
      this.configSources.push(filename);
    }
  }

  /**
   * Load configuration from a JSON file
   * @param filename - Name of the JSON file
   * @private
   */
  private loadJsonConfig(filename: string): void {
    const configPath = path.join(process.cwd(), 'config', filename);
    
    if (fs.existsSync(configPath)) {
      try {
        const fileConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));
        this.mergeConfig(fileConfig);
        this.configSources.push(`config/${filename}`);
      } catch (error) {
        console.error(`Error loading JSON config ${filename}: ${error}`);
      }
    }
  }

  /**
   * Merge configuration objects
   * @param config - Configuration object to merge
   * @private
   */
  private mergeConfig(config: Record<string, any>): void {
    this.config = this.deepMerge(this.config, config);
  }

  /**
   * Deep merge two objects
   * @param target - Target object
   * @param source - Source object
   * @returns Merged object
   * @private
   */
  private deepMerge(target: Record<string, any>, source: Record<string, any>): Record<string, any> {
    const result = { ...target };
    
    for (const key in source) {
      if (source[key] instanceof Object && key in target && target[key] instanceof Object) {
        result[key] = this.deepMerge(target[key], source[key]);
      } else {
        result[key] = source[key];
      }
    }
    
    return result;
  }

  /**
   * Override configuration with environment variables
   * @private
   */
  private mergeEnvironmentVariables(): void {
    // First add all environment variables to config
    for (const [key, value] of Object.entries(process.env)) {
      if (value !== undefined) {
        this.config[key] = value;
      }
    }

    // Then handle special prefixed environment variables for nested configuration
    for (const [key, value] of Object.entries(process.env)) {
      if (key.startsWith('CONFIG_') && value !== undefined) {
        // Convert CONFIG_DB_HOST to db.host
        const configKey = key
          .replace('CONFIG_', '')
          .toLowerCase()
          .replace(/_([a-z])/g, (_, c) => `.${c.toLowerCase()}`);
        
        this.set(configKey, value);
      }
    }
  }

  /**
   * Get configuration value with type conversion
   * @param key - Configuration key (supports dot notation)
   * @param defaultValue - Default value if configuration not found
   * @returns Configuration value with appropriate type
   */
  public get<T>(key: string, defaultValue?: T): T {
    if (!this.initialized) {
      this.loadConfiguration();
    }
    
    // Parse dot notation
    const keys = key.split('.');
    let value: any = this.config;
    
    // Check environment variables first (highest priority)
    const envKey = keys.join('_').toUpperCase();
    if (process.env[envKey] !== undefined) {
      return this.convertValue(process.env[envKey], defaultValue);
    }
    
    // Then check nested config
    for (const k of keys) {
      value = value && value[k] !== undefined ? value[k] : undefined;
    }
    
    if (value === undefined) {
      return defaultValue as T;
    }
    
    return this.convertValue(value, defaultValue);
  }

  /**
   * Convert value to appropriate type based on defaultValue
   * @param value - Value to convert
   * @param defaultValue - Default value with type
   * @returns Converted value
   * @private
   */
  private convertValue<T>(value: any, defaultValue?: T): T {
    // If value is already the right type, return it
    if (typeof value === typeof defaultValue) {
      return value as T;
    }
    
    // If no default value is provided, return as is
    if (defaultValue === undefined) {
      return value as unknown as T;
    }
    
    // Convert based on the type of defaultValue
    const defaultType = typeof defaultValue;
    
    if (defaultType === 'number') {
      const numberValue = Number(value);
      return (isNaN(numberValue) ? defaultValue : numberValue) as unknown as T;
    } 
    else if (defaultType === 'boolean') {
      if (typeof value === 'string') {
        const lowerValue = value.toLowerCase();
        if (lowerValue === 'true' || lowerValue === '1' || lowerValue === 'yes') return true as unknown as T;
        if (lowerValue === 'false' || lowerValue === '0' || lowerValue === 'no') return false as unknown as T;
      }
      return defaultValue;
    } 
    else if (defaultType === 'object') {
      if (Array.isArray(defaultValue)) {
        if (typeof value === 'string') {
          if (value.startsWith('[') && value.endsWith(']')) {
            try {
              return JSON.parse(value) as T;
            } catch {
              // Fall back to comma-separated interpretation
              return value.split(',').map(item => item.trim()) as unknown as T;
            }
          }
          // If it doesn't look like JSON, split by comma
          return value.split(',').map(item => item.trim()) as unknown as T;
        }
      } else {
        // Object - try to parse JSON
        if (typeof value === 'string') {
          try {
            return JSON.parse(value) as T;
          } catch {
            return defaultValue;
          }
        }
      }
    }
    
    // If no conversion applied, return as is
    return value as unknown as T;
  }

  /**
   * Set configuration value
   * @param key - Configuration key (supports dot notation)
   * @param value - Configuration value
   */
  public set<T>(key: string, value: T): void {
    if (!this.initialized) {
      this.loadConfiguration();
    }
    
    const keys = key.split('.');
    let current = this.config;
    
    // Navigate to the right level in the config object
    for (let i = 0; i < keys.length - 1; i++) {
      const k = keys[i];
      current[k] = current[k] || {};
      current = current[k];
    }
    
    // Set the value
    current[keys[keys.length - 1]] = value;
  }

  /**
   * Check if a configuration exists
   * @param key - Configuration key
   * @returns Whether the configuration exists
   */
  public has(key: string): boolean {
    if (!this.initialized) {
      this.loadConfiguration();
    }
    
    const keys = key.split('.');
    let value: any = this.config;
    
    for (const k of keys) {
      value = value && value[k] !== undefined ? value[k] : undefined;
    }
    
    return value !== undefined;
  }

  /**
   * Get entire configuration object
   * @returns Configuration object
   */
  public getAll(): Record<string, any> {
    if (!this.initialized) {
      this.loadConfiguration();
    }
    
    return { ...this.config };
  }

  /**
   * Get boolean value (convenience method)
   * @param key - Configuration key
   * @param defaultValue - Default value if not found
   */
  public getBoolean(key: string, defaultValue: boolean = false): boolean {
    return this.get<boolean>(key, defaultValue);
  }

  /**
   * Get number value (convenience method)
   * @param key - Configuration key
   * @param defaultValue - Default value if not found
   */
  public getNumber(key: string, defaultValue: number = 0): number {
    return this.get<number>(key, defaultValue);
  }

  /**
   * Get string value (convenience method)
   * @param key - Configuration key
   * @param defaultValue - Default value if not found
   */
  public getString(key: string, defaultValue: string = ''): string {
    return this.get<string>(key, defaultValue);
  }

  /**
   * Get array value (convenience method)
   * @param key - Configuration key
   * @param defaultValue - Default value if not found
   */
  public getArray<T>(key: string, defaultValue: T[] = []): T[] {
    return this.get<T[]>(key, defaultValue);
  }

  /**
   * Get object value (convenience method)
   * @param key - Configuration key
   * @param defaultValue - Default value if not found
   */
  public getObject<T extends Record<string, any>>(key: string, defaultValue: T = {} as T): T {
    return this.get<T>(key, defaultValue);
  }

  /**
   * Reset configuration (mainly for testing)
   */
  public reset(): void {
    this.config = {};
    this.initialized = false;
    this.configSources = [];
  }
}
