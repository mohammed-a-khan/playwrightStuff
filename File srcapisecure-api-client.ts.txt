// Replace your existing handleLongRunningRequest method with this improved version

private async handleLongRunningRequest<T = any>(
  requestFn: () => Promise<AxiosResponse<T>>,
  options?: {
    enabled?: boolean;
    maxAttempts?: number;
    interval?: number;
    timeoutPerAttempt?: number;
    successCondition?: (response: AxiosResponse<T>) => boolean;
  }
): Promise<AxiosResponse<T>> {
  // Merge options with defaults
  const pollOptions = {
    maxAttempts: options?.maxAttempts || this.defaultPollingOptions.maxAttempts,
    interval: options?.interval || this.defaultPollingOptions.interval,
    timeoutPerAttempt: options?.timeoutPerAttempt || this.defaultPollingOptions.timeoutPerAttempt,
    successCondition: options?.successCondition || ((response: AxiosResponse<T>) => {
      // Default condition implementation...
      return this.defaultPollingSuccessCheck(response);
    })
  };
  
  // Make the initial request
  let response: AxiosResponse<T>;
  let originalUrl: string = '';
  let originalMethod: string = 'get';
  let originalData: any = null;
  
  try {
    this.logger.info(`Making initial request for long-running operation`);
    response = await requestFn();
    
    // Store the original request details immediately to avoid losing them
    originalUrl = response.config.url || '';
    originalMethod = (response.config.method || 'get').toLowerCase();
    originalData = response.config.data;
    
    if (!originalUrl) {
      throw new Error('Missing URL in response config');
    }
    
    this.logger.info(`Initial request complete. URL: ${originalUrl}, Method: ${originalMethod}`);
    
    // Log response for debugging
    this.logger.debug(`Initial response status: ${response.status}`);
    
    // Check if we already have a complete response
    if (pollOptions.successCondition(response)) {
      this.logger.info(`Initial response is complete, no polling needed`);
      return response;
    }
    
    this.logger.info(`Initial response incomplete, starting polling...`);
  } catch (error: any) {
    this.logger.error(`Initial request failed: ${error.message}`);
    throw error;
  }
  
  // Create a clean config for polling
  const pollConfig: AxiosRequestConfig = {
    headers: { ...this.defaultHeaders },
    method: originalMethod as Method,
    url: originalUrl,
    timeout: pollOptions.timeoutPerAttempt
  };
  
  // Add certificate if needed
  if (this.pfxCertPath && fs.existsSync(this.pfxCertPath)) {
    try {
      const pfx = fs.readFileSync(this.pfxCertPath);
      pollConfig.httpsAgent = new https.Agent({
        pfx,
        passphrase: this.pfxCertPassphrase,
        rejectUnauthorized: this.config.getBoolean('REJECT_UNAUTHORIZED', true)
      });
      this.logger.info(`Using certificate for polling requests`);
    } catch (error: any) {
      this.logger.error(`Failed to load certificate for polling: ${error.message}`);
    }
  }
  
  // Add proxy if needed
  const proxyUrl = this.proxyUrl;
  if (proxyUrl) {
    try {
      const formattedProxyUrl = proxyUrl.startsWith('http') ? proxyUrl : `http://${proxyUrl}`;
      const parsedUrl = new URL(formattedProxyUrl);
      
      pollConfig.proxy = {
        host: parsedUrl.hostname,
        port: parseInt(parsedUrl.port || '80'),
        protocol: parsedUrl.protocol.replace(':', '') as 'http' | 'https'
      };
      
      this.logger.info(`Using proxy for polling: ${formattedProxyUrl}`);
    } catch (error: any) {
      this.logger.error(`Invalid proxy URL for polling: ${error.message}`);
    }
  }
  
  // Start polling with the fixed configuration
  for (let attempt = 1; attempt <= pollOptions.maxAttempts; attempt++) {
    // Wait for the polling interval
    await new Promise(resolve => setTimeout(resolve, pollOptions.interval));
    
    try {
      this.logger.info(`Polling attempt ${attempt}/${pollOptions.maxAttempts}`);
      
      // Create a new request based on the stored details
      let pollResponse: AxiosResponse<T>;
      
      if (originalMethod === 'post' || originalMethod === 'put' || originalMethod === 'patch') {
        pollResponse = await axios.request<T>({
          ...pollConfig,
          data: originalData
        });
      } else {
        pollResponse = await axios.request<T>(pollConfig);
      }
      
      // Update our response reference
      response = pollResponse;
      
      // Check if the response is now complete
      if (pollOptions.successCondition(response)) {
        this.logger.info(`Polling successful after ${attempt} attempts`);
        return response;
      }
      
      this.logger.info(`Polling attempt ${attempt} - data still incomplete`);
    } catch (error: any) {
      this.logger.warn(`Polling attempt ${attempt} failed: ${error.message}`);
      
      // Don't fail the entire operation if a single poll fails
      // Continue with the next attempt
    }
  }
  
  // If we get here, we've exceeded the maximum polling attempts
  // Return the last response we got, even if incomplete
  this.logger.warn(`Polling maximum attempts (${pollOptions.maxAttempts}) reached without complete data`);
  return response;
}

// Add this helper method
private defaultPollingSuccessCheck<T>(response: AxiosResponse<T>): boolean {
  // Check if the response has data
  if (!response.data) {
    return false;
  }
  
  // For array responses, check if there are elements
  if (Array.isArray(response.data)) {
    return response.data.length > 0;
  }
  
  // For object responses with specific fields, check if required fields have data
  if (typeof response.data === 'object') {
    const dataObj = response.data as any;
    
    // Check for common patterns in response objects
    if (dataObj.assetLayouts && Array.isArray(dataObj.assetLayouts)) {
      return dataObj.assetLayouts.length > 0;
    }
    
    if (dataObj.items && Array.isArray(dataObj.items)) {
      return dataObj.items.length > 0;
    }
    
    if (dataObj.data && Array.isArray(dataObj.data)) {
      return dataObj.data.length > 0;
    }
    
    // Check if the object has any properties (not empty)
    return Object.keys(dataObj).length > 0;
  }
  
  // For primitive types, check if it's not null, undefined, or empty string
  return response.data !== null && response.data !== undefined && response.data !== '';
}
