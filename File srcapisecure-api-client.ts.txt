hooks.ts
-------------

import { BeforeAll, AfterAll, Before, After, Status } from '@cucumber/cucumber';
import apiClient from '../api/apiClient';
import { logger } from '../helpers/loggerHelper';
import reportHelper from '../helpers/reportHelper';
import * as fs from 'fs-extra';
import * as path from 'path';
import { configHelper } from '../../config/config';
import { TimeoutUtils } from '../utils/timeoutUtils';
import { World, ScenarioContext } from '../models/worldModels';

// Ensure reports directories exist
const reportsDir = path.join(process.cwd(), 'reports');
const jsonReportsDir = path.join(reportsDir, 'json');
const htmlReportsDir = path.join(reportsDir, 'html');
const screenshotsDir = path.join(reportsDir, 'screenshots');
const logsDir = path.join(reportsDir, 'logs');

fs.ensureDirSync(jsonReportsDir);
fs.ensureDirSync(htmlReportsDir);
fs.ensureDirSync(screenshotsDir);
fs.ensureDirSync(logsDir);

// Store test context in module-level variable to avoid global variable issues
const testContextMap: Record<string, ScenarioContext> = {};

BeforeAll(async function() {
  logger.info('üöÄ Test execution started');
  reportHelper.startTestRun();
  
  // Initialize API client and wait for completion
  await apiClient.initialize();
  
  // Log environment information
  logger.info(`Environment: ${configHelper.getEnvironment()}`);
  logger.info(`Base URL: ${configHelper.getBaseUrl()}`);
  logger.info(`Debug Mode: ${configHelper.isDebugMode()}`);
  logger.info(`Timeout: ${configHelper.getTimeout()}ms`);
  logger.info(`Retry Attempts: ${configHelper.getRetryAttempts()}`);
});

AfterAll(async function() {
  logger.info('üèÅ Test execution completed');
  
  // Wait for any pending operations to complete
  await TimeoutUtils.sleep(1000);
  
  // Cleanup
  await apiClient.dispose();
  
  // Generate report
  reportHelper.endTestRun();
  await reportHelper.generateReport();
  
  // Clear test context
  Object.keys(testContextMap).forEach(key => delete testContextMap[key]);
});

Before(async function(this: World, scenario) {
  const featureName = scenario.pickle.uri?.split('/').pop()?.replace('.feature', '') || 'Unknown';
  const scenarioName = scenario.pickle.name;
  
  logger.info(`‚ñ∂Ô∏è Starting scenario: ${scenarioName} [${featureName}]`);
  
  // Initialize scenario context
  this.context = {
    scenarioName,
    scenarioId: scenario.pickle.id,
    featureName,
    startTime: new Date(),
    responses: {},
    data: {},
    screenshots: []
  };
  
  // Add to test context map
  testContextMap[scenarioName] = this.context;
});

After(async function(this: World, scenario) {
  const duration = new Date().getTime() - this.context.startTime.getTime();
  const status = scenario.result?.status || 'unknown';
  
  logger.info(`‚èπÔ∏è Completed scenario: ${this.context.scenarioName} with status: ${status.toUpperCase()} (${duration}ms)`);
  
  let error = undefined;
  const screenshots: string[] = this.context.screenshots || [];
  
  if (scenario.result?.status === Status.FAILED) {
    error = scenario.result.message;
    logger.error(`Scenario failed: ${error}`);
    
    // Take screenshot on failure if configured
    if (configHelper.shouldTakeScreenshotOnFailure()) {
      try {
        const screenshotName = `${this.context.featureName}_${this.context.scenarioName}_failure`;
        const screenshotPath = path.join(screenshotsDir, `${screenshotName}.png`);
        
        // For API testing, save error details as a text file instead of screenshot
        await fs.writeFile(
          screenshotPath,
          `Error: ${error}\n\nContext: ${JSON.stringify(this.context, null, 2)}`,
          'utf8'
        );
        
        screenshots.push(screenshotPath);
        logger.info(`Error details saved to: ${screenshotPath}`);
      } catch (screenshotError) {
        logger.error(`Failed to save error details: ${screenshotError}`);
      }
    }
  }
  
  // Add test result to the report
  reportHelper.addTestResult(
    this.context.featureName,
    this.context.scenarioName,
    status,
    duration,
    error,
    { 
      scenarioId: this.context.scenarioId,
      responses: Object.keys(this.context.responses)
    },
    screenshots
  );
  
  // Remove from test context map
  delete testContextMap[this.context.scenarioName];
});

worldmodel.ts
--------------
import { World as CucumberWorld } from '@cucumber/cucumber';
import { ApiResponse, AssetLayoutResponse } from './apiModels';

export interface ScenarioContext {
  scenarioName: string;
  scenarioId: string;
  featureName: string;
  startTime: Date;
  requestStartTime?: number;
  responseTime?: number;
  responses: Record<string, any>;
  data: Record<string, any>;
  screenshots: string[];
  assetLayoutResponse?: ApiResponse<AssetLayoutResponse>;
  [key: string]: any; // Allow any other properties
}

// Extend the Cucumber World type to include our custom context
export interface World extends CucumberWorld {
  context: ScenarioContext;
}

assetlayoutsteps.ts
-------------------
import { Given, When, Then } from '@cucumber/cucumber';
import assertionUtils from '../../src/utils/assertionUtils';
import AssetLayoutService from '../../src/api/services/assetLayoutService';
import { AssetLayoutRequest } from '../../src/models/apiModels';
import { logger } from '../../src/helpers/loggerHelper';
import { World } from '../../src/models/worldModels';
import { expect } from 'chai';

Given('the API is available', async function(this: World) {
  logger.info('Verifying API availability');
  // In a real implementation, we might do a health check here
  // For now, we'll assume the API is available
});

When('I send a request to get asset layout with the following data:', async function(this: World, dataTable) {
  try {
    // Convert the data table to our request object
    const rows = dataTable.hashes();
    if (rows.length === 0) {
      throw new Error('No data provided in the data table');
    }

    const row = rows[0];
    const request: AssetLayoutRequest = {
      messageId: parseInt(row.messageId),
      dealId: parseInt(row.dealId),
      reportDate: row.reportDate
    };

    logger.info(`Sending asset layout request with dealId: ${request.dealId}`);
    
    // Record the start time for performance measurements
    this.context.requestStartTime = Date.now();
    
    // Send the request and store the response in the world context
    this.context.assetLayoutResponse = await AssetLayoutService.getAssetLayout(request);
    
    // Calculate and store the response time
    this.context.responseTime = Date.now() - this.context.requestStartTime;
    
    logger.info(`Received response with status: ${this.context.assetLayoutResponse.statusCode} in ${this.context.responseTime}ms`);
  } catch (error) {
    logger.error(`Error during asset layout request: ${error}`);
    throw error;
  }
});

Then('the response status code should be {int}', function(this: World, expectedStatusCode) {
  assertionUtils.assertStatusCode(this.context.assetLayoutResponse, expectedStatusCode);
});

Then('the response should contain valid asset layout data', function(this: World) {
  // Verify response structure
  assertionUtils.assertFieldExists(this.context.assetLayoutResponse, 'data');
  assertionUtils.assertFieldExists(this.context.assetLayoutResponse.data, 'assetLayouts');
  assertionUtils.assertArrayHasItems(this.context.assetLayoutResponse.data, 'assetLayouts');
  
  // Verify first asset layout
  const firstAssetLayout = this.context.assetLayoutResponse.data.assetLayouts[0];
  expect(firstAssetLayout).to.have.property('dealId');
  expect(firstAssetLayout).to.have.property('entityId');
  expect(firstAssetLayout.dealId).to.be.a('number');
  expect(firstAssetLayout.entityId).to.be.a('number');
});

Then('the response should not contain any errors', function(this: World) {
  assertionUtils.assertNoError(this.context.assetLayoutResponse);
});

Then('the response should contain an error message', function(this: World) {
  assertionUtils.assertHasError(this.context.assetLayoutResponse, 'errorMessage');
});

Then('the response should contain a validation error', function(this: World) {
  assertionUtils.assertHasError(this.context.assetLayoutResponse, 'validationErrorMessage');
});

Then('the response time should be less than {int} seconds', function(this: World, expectedSeconds) {
  const expectedMs = expectedSeconds * 1000;
  assertionUtils.assertResponseTime(this.context.responseTime, expectedMs);
});
