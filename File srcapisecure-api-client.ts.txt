reportHelper.ts
------------------

import * as fs from 'fs-extra';
import * as path from 'path';
import * as dayjs from 'dayjs';
import { logger } from './loggerHelper';
import { configHelper } from '../../config/config';
import { TestResult, TestSummary, TestReport, TestStep } from '../models/reportModels';
import * as handlebars from 'handlebars';
import { v4 as uuidv4 } from 'uuid';

// Register handlebars helpers
handlebars.registerHelper('formatDate', (date: string, format?: string) => {
  if (!date) return '';
  try {
    return format ? 
      dayjs(date).format(format) : 
      dayjs(date).format('YYYY-MM-DD HH:mm:ss');
  } catch (e) {
    return date;
  }
});

handlebars.registerHelper('formatDuration', (ms: number) => {
  if (ms === undefined || ms === null) return '0ms';
  try {
    if (ms < 1000) return `${ms}ms`;
    const seconds = Math.floor(ms / 1000);
    const remainingMs = ms % 1000;
    return seconds > 0 ? 
      `${seconds}.${remainingMs.toString().padStart(3, '0')}s` : 
      `${ms}ms`;
  } catch (e) {
    return `${ms}ms`;
  }
});

handlebars.registerHelper('passPercentage', (passed: number, total: number) => {
  try {
    if (total === 0) return 0;
    return Math.round((passed / total) * 100);
  } catch (e) {
    return 0;
  }
});

handlebars.registerHelper('ifEqual', function(arg1, arg2, options) {
  return (arg1 == arg2) ? options.fn(this) : options.inverse(this);
});

handlebars.registerHelper('ifNotEqual', function(arg1, arg2, options) {
  return (arg1 != arg2) ? options.fn(this) : options.inverse(this);
});

export class ReportHelper {
  private static instance: ReportHelper;
  private testResults: TestResult[] = [];
  private startTime: Date | null = null;
  private endTime: Date | null = null;
  private reportDir: string;
  private screenshotDir: string;
  private historicalReportsDir: string;
  private currentScenario: string = '';
  private currentFeature: string = '';
  private steps: Map<string, TestStep[]> = new Map();

  private constructor() {
    this.reportDir = path.join(process.cwd(), 'reports', 'html');
    this.screenshotDir = path.join(process.cwd(), 'reports', 'screenshots');
    this.historicalReportsDir = path.join(process.cwd(), 'reports', 'history');
    
    fs.ensureDirSync(this.reportDir);
    fs.ensureDirSync(this.screenshotDir);
    fs.ensureDirSync(this.historicalReportsDir);
  }

  public static getInstance(): ReportHelper {
    if (!ReportHelper.instance) {
      ReportHelper.instance = new ReportHelper();
    }
    return ReportHelper.instance;
  }

  /**
   * Start a test run
   */
  public startTestRun(): void {
    this.startTime = new Date();
    this.testResults = [];
    this.steps = new Map();
    logger.info(`Test run started at ${this.startTime.toISOString()}`);
  }

  /**
   * Set current scenario context
   * @param feature Feature name
   * @param scenario Scenario name
   */
  public setCurrentScenario(feature: string, scenario: string): void {
    this.currentFeature = feature || 'Unknown';
    this.currentScenario = scenario || 'Unknown';
    
    // Initialize steps array for this scenario if it doesn't exist
    const scenarioKey = `${this.currentFeature}|${this.currentScenario}`;
    if (!this.steps.has(scenarioKey)) {
      this.steps.set(scenarioKey, []);
    }
    
    logger.debug(`Current scenario set to: ${this.currentFeature} - ${this.currentScenario}`);
  }

  /**
   * Add a test step to the current scenario
   * @param keyword Step keyword (Given, When, Then)
   * @param name Step name
   * @param status Step status
   * @param duration Step duration
   * @param error Error message if failed
   */
  public addStep(
    keyword: string,
    name: string,
    status: string,
    duration: number,
    error?: string
  ): void {
    if (!this.currentScenario) {
      logger.warn('No current scenario set, cannot add step');
      return;
    }
    
    const scenarioKey = `${this.currentFeature}|${this.currentScenario}`;
    const step: TestStep = {
      id: uuidv4(),
      keyword: keyword || '',
      name: name || '',
      status: status || 'unknown',
      duration: duration || 0,
      error,
      timestamp: new Date().toISOString()
    };
    
    const steps = this.steps.get(scenarioKey) || [];
    steps.push(step);
    this.steps.set(scenarioKey, steps);
    
    logger.debug(`Step added: ${keyword} ${name} - ${status} (${duration}ms)`);
  }

  /**
   * Add test result to the report
   * @param feature Feature name
   * @param scenario Scenario name
   * @param status Test status
   * @param duration Test duration
   * @param error Error message
   * @param metadata Additional metadata
   * @param screenshots Array of screenshot paths
   */
  public addTestResult(
    feature: string,
    scenario: string,
    status: string,
    duration: number,
    error?: string,
    metadata?: Record<string, any>,
    screenshots?: string[]
  ): void {
    // Ensure parameters are valid to prevent errors
    const safeFeature = feature || 'Unknown';
    const safeScenario = scenario || 'Unknown';
    const safeStatus = status || 'unknown';
    const safeDuration = duration || 0;
    
    // Get steps for this scenario
    const scenarioKey = `${safeFeature}|${safeScenario}`;
    const steps = this.steps.get(scenarioKey) || [];
    
    const testResult: TestResult = {
      id: uuidv4(),
      feature: safeFeature,
      scenario: safeScenario,
      status: safeStatus,
      duration: safeDuration,
      error,
      timestamp: new Date().toISOString(),
      metadata,
      screenshots,
      steps
    };
    
    this.testResults.push(testResult);
    
    logger.info(`Test result added: ${safeScenario} - ${safeStatus} (${safeDuration}ms)`);
  }

  /**
   * End a test run
   */
  public endTestRun(): void {
    this.endTime = new Date();
    logger.info(`Test run ended at ${this.endTime ? this.endTime.toISOString() : 'unknown time'}`);
  }

  /**
   * Take a screenshot
   * @param name Screenshot name
   * @param content Screenshot content (base64 encoded)
   * @returns Path to saved screenshot
   */
  public async takeScreenshot(name: string, content: string): Promise<string> {
    try {
      const timestamp = dayjs().format('YYYYMMDD_HHmmss');
      const sanitizedName = name ? name.replace(/[^a-zA-Z0-9]/g, '_') : 'screenshot';
      const filename = `${sanitizedName}_${timestamp}.png`;
      const filePath = path.join(this.screenshotDir, filename);
      
      // Convert base64 to buffer
      const data = Buffer.from(content, 'base64');
      
      // Save screenshot
      await fs.writeFile(filePath, data);
      
      logger.debug(`Screenshot saved: ${filePath}`);
      return filePath;
    } catch (error) {
      logger.error(`Error saving screenshot: ${error}`);
      return '';
    }
  }

  /**
   * Generate test report
   * @param customReportName Optional custom report name
   * @returns Path to generated report
   */
  public async generateReport(customReportName?: string): Promise<string> {
    try {
      // If start/end time not set, set them now to prevent errors
      if (!this.startTime) {
        this.startTime = new Date();
        logger.warn('Start time was not set, using current time');
      }
      
      if (!this.endTime) {
        this.endTime = new Date();
        logger.warn('End time was not set, using current time');
      }
      
      // Safely generate report name
      let reportName = 'report';
      const timestamp = dayjs().format('YYYYMMDD_HHmmss');
      
      if (customReportName) {
        // Ensure custom report name is safe for file system
        reportName = customReportName.replace(/[^a-zA-Z0-9-_]/g, '-');
      } else {
        // Generate timestamped report name
        reportName = `report_${timestamp}`;
      }
      
      const reportPath = path.join(this.reportDir, `${reportName}.html`);
      const jsonReportPath = path.join(this.reportDir, `${reportName}.json`);
      
      // Save a copy to history folder with timestamp
      const historyReportPath = path.join(this.historicalReportsDir, `report_${timestamp}.html`);
      const historyJsonPath = path.join(this.historicalReportsDir, `report_${timestamp}.json`);
      
      // Make sure the directories exist
      await fs.ensureDir(this.reportDir);
      await fs.ensureDir(this.historicalReportsDir);

      // Calculate summary
      const totalDuration = this.endTime.getTime() - this.startTime.getTime();
      const totalTests = this.testResults.length;
      const passedTests = this.testResults.filter(test => test.status === 'passed').length;
      const failedTests = this.testResults.filter(test => test.status === 'failed').length;
      const skippedTests = this.testResults.filter(test => test.status === 'skipped').length;
      const pendingTests = this.testResults.filter(test => test.status === 'pending').length;

      const environment = configHelper.getEnvironment() || 'unknown';
      const baseUrl = configHelper.getBaseUrl() || 'unknown';

      // Get historical test data
      const historyData = await this.getHistoricalData();

      // Create summary
      const summary: TestSummary = {
        environment,
        baseUrl,
        startTime: this.startTime.toISOString(),
        endTime: this.endTime.toISOString(),
        totalDuration,
        totalTests,
        passedTests,
        failedTests,
        skippedTests,
        pendingTests
      };

      // Create report data
      const reportData: TestReport = {
        summary,
        results: this.testResults,
        history: historyData
      };

      // Generate HTML report from embedded template
      const template = this.getEmbeddedTemplate();

      // Compile and apply template
      const compiledTemplate = handlebars.compile(template);
      const html = compiledTemplate(reportData);

      // Write HTML report
      await fs.writeFile(reportPath, html, 'utf8');
      logger.info(`HTML report generated: ${reportPath}`);

      // Write JSON report
      await fs.writeFile(jsonReportPath, JSON.stringify(reportData, null, 2), 'utf8');
      logger.info(`JSON report generated: ${jsonReportPath}`);

      // Save copies to history folder
      await fs.writeFile(historyReportPath, html, 'utf8');
      await fs.writeFile(historyJsonPath, JSON.stringify(reportData, null, 2), 'utf8');
      logger.info(`Historical reports saved: ${historyReportPath}`);

      return reportPath;
    } catch (error) {
      logger.error(`Error generating report: ${error}`);
      throw error;
    }
  }

  /**
   * Get historical test data
   * @returns Array of historical test data
   */
  private async getHistoricalData(): Promise<Array<{date: string, pass: number, fail: number, skip: number}>> {
    try {
      const historyData: Array<{date: string, pass: number, fail: number, skip: number}> = [];
      
      // Get list of JSON files in history directory
      const files = await fs.readdir(this.historicalReportsDir);
      const jsonFiles = files.filter(file => file.endsWith('.json')).sort();
      
      // Limit to last 10 reports
      const recentFiles = jsonFiles.slice(-10);
      
      for (const file of recentFiles) {
        try {
          const filePath = path.join(this.historicalReportsDir, file);
          const content = await fs.readFile(filePath, 'utf8');
          const data = JSON.parse(content) as TestReport;
          
          const date = dayjs(data.summary.startTime).format('MM/DD');
          historyData.push({
            date,
            pass: data.summary.passedTests,
            fail: data.summary.failedTests,
            skip: data.summary.skippedTests
          });
        } catch (e) {
          logger.warn(`Could not read historical data from ${file}: ${e}`);
        }
      }
      
      return historyData;
    } catch (error) {
      logger.error(`Error getting historical data: ${error}`);
      return [];
    }
  }

  /**
   * Get embedded HTML template
   * @returns HTML template string
   */
  private getEmbeddedTemplate(): string {
    return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>API Test Report</title>
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
      <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
      <style>
        :root {
          --primary-color: #3f51b5;
          --secondary-color: #009688;
          --success-color: #4caf50;
          --warning-color: #ff9800;
          --danger-color: #f44336;
          --info-color: #2196f3;
          --light-color: #f5f5f5;
          --dark-color: #333;
          --primary-bg: #f9fafc;
          --card-bg: #fff;
          --card-shadow: 0 2px 10px rgba(0,0,0,0.05);
          --border-radius: 8px;
        }
        body {
          font-family: 'Roboto', sans-serif;
          margin: 0;
          padding: 0;
          background-color: var(--primary-bg);
          color: #333;
          line-height: 1.6;
        }
        .container {
          max-width: 1280px;
          margin: 0 auto;
          padding: 20px;
        }
        .report-header {
          background-color: var(--card-bg);
          padding: 30px;
          border-radius: var(--border-radius);
          margin-bottom: 30px;
          box-shadow: var(--card-shadow);
          border-top: 4px solid var(--primary-color);
        }
        .report-title {
          margin: 0;
          color: var(--primary-color);
          font-size: 28px;
          font-weight: 700;
          border-bottom: 2px solid #eaeaea;
          padding-bottom: 15px;
          margin-bottom: 20px;
        }
        .report-info {
          display: flex;
          flex-wrap: wrap;
          gap: 20px;
        }
        .info-item {
          flex: 1 1 200px;
        }
        .info-label {
          font-weight: 500;
          color: #757575;
          font-size: 14px;
          margin-bottom: 5px;
        }
        .info-value {
          font-size: 16px;
          font-weight: 500;
        }
        .report-summary {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
          gap: 20px;
          margin-bottom: 30px;
        }
        .summary-item {
          background-color: var(--card-bg);
          padding: 20px;
          border-radius: var(--border-radius);
          box-shadow: var(--card-shadow);
          text-align: center;
          transition: transform 0.2s;
        }
        .summary-item:hover {
          transform: translateY(-5px);
        }
        .summary-item.total { border-top: 4px solid var(--info-color); }
        .summary-item.passed { border-top: 4px solid var(--success-color); }
        .summary-item.failed { border-top: 4px solid var(--danger-color); }
        .summary-item.skipped { border-top: 4px solid var(--warning-color); }
        .summary-item.pending { border-top: 4px solid #9e9e9e; }
        .summary-title {
          font-size: 14px;
          font-weight: 500;
          color: #757575;
          margin: 0 0 10px 0;
          text-transform: uppercase;
          letter-spacing: 1px;
        }
        .summary-value {
          font-size: 42px;
          font-weight: 700;
          margin: 0;
        }
        .summary-value.passed { color: var(--success-color); }
        .summary-value.failed { color: var(--danger-color); }
        .summary-value.skipped { color: var(--warning-color); }
        .summary-value.pending { color: #9e9e9e; }
        
        .charts-container {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
          gap: 20px;
          margin-bottom: 30px;
        }
        .chart-card {
          background-color: var(--card-bg);
          padding: 20px;
          border-radius: var(--border-radius);
          box-shadow: var(--card-shadow);
        }
        .chart-title {
          margin-top: 0;
          margin-bottom: 20px;
          font-size: 18px;
          color: var(--dark-color);
          border-bottom: 1px solid #eaeaea;
          padding-bottom: 10px;
        }
        .chart-container {
          position: relative;
          height: 250px;
        }
        
        .progress-container {
          height: 10px;
          background-color: #e0e0e0;
          border-radius: 5px;
          overflow: hidden;
          margin: 20px 0;
        }
        .progress-bar {
          height: 100%;
          background-color: var(--success-color);
          border-radius: 5px;
        }
        .test-results {
          background-color: var(--card-bg);
          border-radius: var(--border-radius);
          box-shadow: var(--card-shadow);
          overflow: hidden;
          margin-bottom: 30px;
        }
        .section-title {
          padding: 20px;
          margin: 0;
          background-color: #f8f9fa;
          border-bottom: 1px solid #eaeaea;
          font-size: 20px;
          color: var(--primary-color);
          font-weight: 500;
        }
        .results-table {
          width: 100%;
          border-collapse: collapse;
        }
        .results-table th,
        .results-table td {
          padding: 15px;
          text-align: left;
          border-bottom: 1px solid #eaeaea;
        }
        .results-table th {
          background-color: #f8f9fa;
          font-weight: 500;
          color: #757575;
          position: sticky;
          top: 0;
          z-index: 10;
        }
        .results-table tr {
          transition: background-color 0.2s;
        }
        .results-table tr:hover {
          background-color: #f5f5f5;
        }
        .results-table tr:last-child td {
          border-bottom: none;
        }
        .status-pill {
          display: inline-block;
          padding: 5px 12px;
          border-radius: 20px;
          font-weight: 500;
          font-size: 12px;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }
        .status-pill.passed { background-color: #e8f5e9; color: var(--success-color); }
        .status-pill.failed { background-color: #ffebee; color: var(--danger-color); }
        .status-pill.skipped { background-color: #fff8e1; color: var(--warning-color); }
        .status-pill.pending { background-color: #f5f5f5; color: #757575; }
        .error-details {
          padding: 15px;
          background-color: #ffebee;
          color: #b71c1c;
          border-radius: 5px;
          margin-top: 10px;
          font-family: 'Courier New', monospace;
          white-space: pre-wrap;
          font-size: 13px;
          display: none;
        }
        .toggle-error {
          cursor: pointer;
          color: var(--info-color);
          text-decoration: underline;
          display: inline-block;
          margin-top: 10px;
          font-size: 14px;
        }
        .toggle-btn {
          background-color: var(--info-color);
          color: white;
          border: none;
          border-radius: 4px;
          padding: 6px 12px;
          cursor: pointer;
          font-size: 12px;
          margin-right: 5px;
          transition: background-color 0.2s;
        }
        .toggle-btn:hover {
          background-color: #1976d2;
        }
        .toggle-btn:focus {
          outline: none;
          box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.4);
        }
        .duration {
          font-family: 'Courier New', monospace;
          color: #757575;
          font-weight: 500;
        }
        .screenshot-link {
          display: inline-block;
          padding: 5px 10px;
          background-color: var(--info-color);
          color: white;
          border-radius: 4px;
          text-decoration: none;
          margin-top: 10px;
          font-size: 12px;
          transition: background-color 0.2s;
        }
        .screenshot-link:hover {
          background-color: #1976d2;
        }
        
        .steps-container {
          margin: 10px 0;
          display: none;
          border-left: 3px solid #e0e0e0;
          margin-left: 10px;
          padding-left: 20px;
        }
        .step-item {
          margin-bottom: 10px;
          padding: 8px 12px;
          border-radius: 4px;
          background-color: #f9f9f9;
          position: relative;
        }
        .step-item:before {
          content: '';
          position: absolute;
          left: -23px;
          top: 50%;
          width: 10px;
          height: 3px;
          background-color: #e0e0e0;
        }
        .step-keyword {
          font-weight: 700;
          margin-right: 5px;
          color: var(--primary-color);
        }
        .step-name {
          font-weight: 400;
        }
        .step-status {
          float: right;
          font-size: 12px;
        }
        .step-status.passed { color: var(--success-color); }
        .step-status.failed { color: var(--danger-color); }
        .step-status.skipped { color: var(--warning-color); }
        .step-status.pending { color: #757575; }
        
        .badge {
          display: inline-block;
          padding: 2px 8px;
          border-radius: 12px;
          font-size: 12px;
          font-weight: 500;
          margin-left: 8px;
        }
        .badge-primary { background-color: #e3f2fd; color: var(--info-color); }
        .badge-success { background-color: #e8f5e9; color: var(--success-color); }
        .badge-danger { background-color: #ffebee; color: var(--danger-color); }
        .badge-warning { background-color: #fff8e1; color: var(--warning-color); }
        
        .footer {
          text-align: center;
          margin-top: 40px;
          padding: 20px;
          color: #757575;
          font-size: 14px;
          background-color: var(--card-bg);
          border-radius: var(--border-radius);
          box-shadow: var(--card-shadow);
        }
        
        /* Animation */
        @keyframes fadeIn {
          from { opacity: 0; transform: translateY(10px); }
          to { opacity: 1; transform: translateY(0); }
        }
        .summary-item, .test-results, .chart-card {
          animation: fadeIn 0.5s ease-out forwards;
        }
        .summary-item:nth-child(1) { animation-delay: 0.1s; }
        .summary-item:nth-child(2) { animation-delay: 0.2s; }
        .summary-item:nth-child(3) { animation-delay: 0.3s; }
        .summary-item:nth-child(4) { animation-delay: 0.4s; }
        
        /* Responsive design */
        @media (max-width: 768px) {
          .report-info, .report-summary {
            grid-template-columns: 1fr;
          }
          .charts-container {
            grid-template-columns: 1fr;
          }
          .results-table thead {
            display: none;
          }
          .results-table tbody tr {
            display: block;
            margin-bottom: 15px;
            border: 1px solid #eaeaea;
            border-radius: 5px;
          }
          .results-table tbody td {
            display: block;
            text-align: right;
            padding: 10px;
            position: relative;
            border-bottom: 1px solid #eaeaea;
          }
          .results-table tbody td:before {
            content: attr(data-label);
            float: left;
            font-weight: 700;
            text-transform: uppercase;
            font-size: 12px;
            color: #757575;
          }
          .results-table tbody td:last-child {
            border-bottom: 0;
          }
        }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="report-header">
          <h1 class="report-title">API Test Automation Report</h1>
          <div class="report-info">
            <div class="info-item">
              <div class="info-label">Environment</div>
              <div class="info-value">{{summary.environment}}</div>
            </div>
            <div class="info-item">
              <div class="info-label">Base URL</div>
              <div class="info-value">{{summary.baseUrl}}</div>
            </div>
            <div class="info-item">
              <div class="info-label">Start Time</div>
              <div class="info-value">{{formatDate summary.startTime}}</div>
            </div>
            <div class="info-item">
              <div class="info-label">End Time</div>
              <div class="info-value">{{formatDate summary.endTime}}</div>
            </div>
            <div class="info-item">
              <div class="info-label">Duration</div>
              <div class="info-value">{{formatDuration summary.totalDuration}}</div>
            </div>
          </div>
        </div>
        
        <div class="report-summary">
          <div class="summary-item total">
            <div class="summary-title">TOTAL TESTS</div>
            <div class="summary-value">{{summary.totalTests}}</div>
          </div>
          <div class="summary-item passed">
            <div class="summary-title">PASSED</div>
            <div class="summary-value passed">{{summary.passedTests}}</div>
          </div>
          <div class="summary-item failed">
            <div class="summary-title">FAILED</div>
            <div class="summary-value failed">{{summary.failedTests}}</div>
          </div>
          <div class="summary-item skipped">
            <div class="summary-title">SKIPPED</div>
            <div class="summary-value skipped">{{summary.skippedTests}}</div>
          </div>
          {{#if summary.pendingTests}}
          <div class="summary-item pending">
            <div class="summary-title">PENDING</div>
            <div class="summary-value pending">{{summary.pendingTests}}</div>
          </div>
          {{/if}}
        </div>
        
        <div class="charts-container">
          <div class="chart-card">
            <h3 class="chart-title">Test Results Distribution</h3>
            <div class="chart-container">
              <canvas id="resultsPieChart"></canvas>
            </div>
          </div>
          
          <div class="chart-card">
            <h3 class="chart-title">Historical Test Results</h3>
            <div class="chart-container">
              <canvas id="historyChart"></canvas>
            </div>
          </div>
        </div>
        
        <div class="progress-container">
          <div class="progress-bar" style="width: {{passPercentage summary.passedTests summary.totalTests}}%"></div>
        </div>
        
        <div class="test-results">
          <h2 class="section-title">Test Results</h2>
          <table class="results-table">
            <thead>
              <tr>
                <th>Feature</th>
                <th>Scenario</th>
                <th>Status</th>
                <th>Duration</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {{#each results}}
              <tr>
                <td data-label="Feature">{{this.feature}}</td>
                <td data-label="Scenario">{{this.scenario}}</td>
                <td data-label="Status"><span class="status-pill {{this.status}}">{{this.status}}</span></td>
                <td data-label="Duration"><span class="duration">{{formatDuration this.duration}}</span></td>
                <td data-label="Actions">
                  {{#if this.steps.length}}
                  <button class="toggle-btn" onclick="toggleSteps('{{this.id}}')">Steps</button>
                  {{/if}}
                  
                  {{#if this.error}}
                  <button class="toggle-btn" style="background-color: #f44336;" onclick="toggleError('{{this.id}}')">Error</button>
                  <div id="error-{{this.id}}" class="error-details">{{this.error}}</div>
                  {{/if}}
                  
                  {{#if this.screenshots}}
                  <div>
                    {{#each this.screenshots}}
                    <a href="{{this}}" target="_blank" class="screenshot-link">Screenshot {{@index}}</a>
                    {{/each}}
                  </div>
                  {{/if}}
                </td>
              </tr>
              {{#if this.steps.length}}
              <tr class="steps-row">
                <td colspan="5" class="steps-cell">
                  <div id="steps-{{this.id}}" class="steps-container">
                    {{#each this.steps}}
                    <div class="step-item">
                      <span class="step-keyword">{{this.keyword}}</span>
                      <span class="step-name">{{this.name}}</span>
                      <span class="step-status {{this.status}}">{{this.status}}</span>
                      {{#if this.error}}
                      <div class="error-details" style="display: block; margin-top: 8px;">{{this.error}}</div>
                      {{/if}}
                    </div>
                    {{/each}}
                  </div>
                </td>
              </tr>
              {{/if}}
              {{/each}}
            </tbody>
          </table>
        </div>
        
        <div class="footer">
          <p>Generated on {{formatDate summary.endTime 'YYYY-MM-DD HH:mm:ss'}} by Enhanced Playwright API Automation Framework</p>
        </div>
      </div>
      
      <script>
        // Toggle error details
        function toggleError(id) {
          const element = document.getElementById('error-' + id);
          if (element.style.display === 'block') {
            element.style.display = 'none';
          } else {
            element.style.display = 'block';
          }
        }
        
        // Toggle steps
        function toggleSteps(id) {
          const element = document.getElementById('steps-' + id);
          if (element.style.display === 'block') {
            element.style.display = 'none';
          } else {
            element.style.display = 'block';
          }
        }
        
        // Create pie chart for test results
        document.addEventListener('DOMContentLoaded', function() {
          // Results Pie Chart
          const passedTests = {{summary.passedTests}};
          const failedTests = {{summary.failedTests}};
          const skippedTests = {{summary.skippedTests}};
          
          if (document.getElementById('resultsPieChart')) {
            const ctx = document.getElementById('resultsPieChart').getContext('2d');
            new Chart(ctx, {
              type: 'doughnut',
              data: {
                labels: ['Passed', 'Failed', 'Skipped'],
                datasets: [{
                  data: [passedTests, failedTests, skippedTests],
                  backgroundColor: [
                    '#4caf50',  // Green for passed
                    '#f44336',  // Red for failed
                    '#ff9800'   // Orange for skipped
                  ],
                  borderWidth: 0
                }]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                  legend: {
                    position: 'right',
                  }
                },
                cutout: '65%'
              }
            });
          }
          
          // History Chart
          if (document.getElementById('historyChart')) {
            const historyData = [
              {{#each history}}
              {
                date: "{{this.date}}",
                pass: {{this.pass}},
                fail: {{this.fail}},
                skip: {{this.skip}}
              },
              {{/each}}
            ];
            
            if (historyData.length > 0) {
              const labels = historyData.map(item => item.date);
              const passData = historyData.map(item => item.pass);
              const failData = historyData.map(item => item.fail);
              const skipData = historyData.map(item => item.skip);
              
              const ctx = document.getElementById('historyChart').getContext('2d');
              new Chart(ctx, {
                type: 'bar',
                data: {
                  labels: labels,
                  datasets: [
                    {
                      label: 'Passed',
                      data: passData,
                      backgroundColor: '#4caf50',
                      borderWidth: 0
                    },
                    {
                      label: 'Failed',
                      data: failData,
                      backgroundColor: '#f44336',
                      borderWidth: 0
                    },
                    {
                      label: 'Skipped',
                      data: skipData,
                      backgroundColor: '#ff9800',
                      borderWidth: 0
                    }
                  ]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  scales: {
                    x: {
                      stacked: true,
                      grid: {
                        display: false
                      }
                    },
                    y: {
                      stacked: true,
                      beginAtZero: true,
                      ticks: {
                        precision: 0
                      }
                    }
                  },
                  plugins: {
                    legend: {
                      position: 'top',
                    }
                  }
                }
              });
            }
          }
        });

reportModel.ts
--------------------

// Reporting Models

export interface TestStep {
  id: string;
  keyword: string;
  name: string;
  status: string;
  duration: number;
  error?: string;
  timestamp: string;
}

export interface TestResult {
  id: string;
  feature: string;
  scenario: string;
  status: string;
  duration: number;
  error?: string;
  timestamp: string;
  metadata?: Record<string, any>;
  screenshots?: string[];
  steps?: TestStep[];
}

export interface TestSummary {
  environment: string;
  baseUrl: string;
  startTime: string;
  endTime: string;
  totalDuration: number;
  totalTests: number;
  passedTests: number;
  failedTests: number;
  skippedTests: number;
  pendingTests: number;
}

export interface HistoricalData {
  date: string;
  pass: number;
  fail: number;
  skip: number;
}

export interface TestReport {
  summary: TestSummary;
  results: TestResult[];
  history?: HistoricalData[];
}

hooks.ts
-------------

import { BeforeAll, AfterAll, Before, After, BeforeStep, AfterStep, Status, setDefaultTimeout } from '@cucumber/cucumber';
import apiClient from '../api/apiClient';
import { logger } from '../helpers/loggerHelper';
import reportHelper from '../helpers/reportHelper';
import * as fs from 'fs-extra';
import * as path from 'path';
import { configHelper } from '../../config/config';
import { TimeoutUtils } from '../utils/timeoutUtils';
import { World, ScenarioContext } from '../models/worldModels';

// Set a higher default timeout for all steps (in milliseconds)
// This is crucial for API testing where responses may take longer than the default 5 seconds
setDefaultTimeout(120 * 1000); // 120 seconds (2 minutes)

// Ensure reports directories exist
const reportsDir = path.join(process.cwd(), 'reports');
const jsonReportsDir = path.join(reportsDir, 'json');
const htmlReportsDir = path.join(reportsDir, 'html');
const screenshotsDir = path.join(reportsDir, 'screenshots');
const logsDir = path.join(reportsDir, 'logs');
const historyDir = path.join(reportsDir, 'history');

fs.ensureDirSync(jsonReportsDir);
fs.ensureDirSync(htmlReportsDir);
fs.ensureDirSync(screenshotsDir);
fs.ensureDirSync(logsDir);
fs.ensureDirSync(historyDir);

// Store test context in module-level variable to avoid global variable issues
const testContextMap: Record<string, ScenarioContext> = {};

BeforeAll(async function() {
  logger.info('üöÄ Test execution started');
  // Note: The report is also initialized by the cucumber formatter
  // but we call it here as well to ensure it runs even without the formatter
  reportHelper.startTestRun();
  
  // Initialize API client and wait for completion
  await apiClient.initialize();
  
  // Log environment information
  logger.info(`Environment: ${configHelper.getEnvironment()}`);
  logger.info(`Base URL: ${configHelper.getBaseUrl()}`);
  logger.info(`Debug Mode: ${configHelper.isDebugMode()}`);
  logger.info(`Timeout: ${configHelper.getTimeout()}ms`);
  logger.info(`Retry Attempts: ${configHelper.getRetryAttempts()}`);
});

AfterAll(async function() {
  try {
    logger.info('üèÅ Test execution completed');
    
    // Wait for any pending operations to complete
    await TimeoutUtils.sleep(1000);
    
    // Cleanup
    await apiClient.dispose();
    
    // Generate report
    // Note: The report is also generated by the cucumber formatter
    // but we call it here as well to ensure it runs even without the formatter
    reportHelper.endTestRun();
    
    // Use a hardcoded name to avoid issues with string manipulation
    try {
      await reportHelper.generateReport('api-test-report');
      logger.info('Report generation completed successfully');
    } catch (reportError) {
      logger.error(`Error generating report: ${reportError}`);
    }
    
    // Clear test context
    for (const key of Object.keys(testContextMap)) {
      delete testContextMap[key];
    }
    
    logger.info('AfterAll hook completed successfully');
  } catch (error) {
    logger.error(`Error in AfterAll hook: ${error}`);
  }
});

Before(async function(this: World, scenario) {
  try {
    // Safely get the feature name from the URI if it exists
    let featureName = 'Unknown';
    if (scenario.pickle.uri && typeof scenario.pickle.uri === 'string') {
      const uriParts = scenario.pickle.uri.split('/');
      const featureFile = uriParts[uriParts.length - 1];
      featureName = featureFile.replace('.feature', '');
    }
    
    const scenarioName = scenario.pickle.name || 'Unnamed Scenario';
    
    logger.info(`‚ñ∂Ô∏è Starting scenario: ${scenarioName} [${featureName}]`);
    
    // Set current scenario in report helper for step tracking
    reportHelper.setCurrentScenario(featureName, scenarioName);
    
    // Initialize scenario context
    this.context = {
      scenarioName,
      scenarioId: scenario.pickle.id || '',
      featureName,
      startTime: new Date(),
      responses: {},
      data: {},
      screenshots: []
    };
    
    // Add to test context map
    testContextMap[scenarioName] = this.context;
  } catch (error) {
    logger.error(`Error in Before hook: ${error}`);
    throw error;
  }
});

// Track each step
BeforeStep(async function(this: World, step) {
  logger.debug(`Starting step: ${step.pickleStep.text}`);
  
  // Store step start time in world context for duration calculation
  this.context.stepStartTime = new Date();
});

AfterStep(async function(this: World, step, result) {
  try {
    if (!this.context || !this.context.stepStartTime) {
      logger.error('Context or stepStartTime is missing in AfterStep hook');
      return;
    }
    
    const duration = new Date().getTime() - this.context.stepStartTime.getTime();
    const status = result.status || 'unknown';
    const stepText = step.pickleStep.text || '';
    const stepKeyword = step.pickleStepType || '';
    
    logger.debug(`Completed step: ${stepText} with status: ${status.toUpperCase()} (${duration}ms)`);
    
    // Add step to the report
    reportHelper.addStep(
      stepKeyword,
      stepText,
      status,
      duration,
      result.status === Status.FAILED ? result.message : undefined
    );
    
    // Take screenshot on step failure if configured
    if (result.status === Status.FAILED && configHelper.shouldTakeScreenshotOnFailure()) {
      try {
        const screenshotName = `${this.context.featureName}_${this.context.scenarioName}_step_failure`;
        const screenshotPath = path.join(screenshotsDir, `${screenshotName}.txt`);
        
        // For API testing, save error details as a text file instead of screenshot
        await fs.writeFile(
          screenshotPath,
          `Error: ${result.message}\n\nStep: ${stepKeyword} ${stepText}\n\nContext: ${JSON.stringify(this.context, null, 2)}`,
          'utf8'
        );
        
        this.context.screenshots.push(screenshotPath);
        logger.info(`Error details saved to: ${screenshotPath}`);
      } catch (screenshotError) {
        logger.error(`Failed to save error details: ${screenshotError}`);
      }
    }
  } catch (error) {
    logger.error(`Error in AfterStep hook: ${error}`);
  }
});

After(async function(this: World, scenario) {
  try {
    if (!this.context || !this.context.startTime) {
      logger.error('Context or startTime is missing in After hook');
      return;
    }
    
    const duration = new Date().getTime() - this.context.startTime.getTime();
    const status = scenario.result?.status || 'unknown';
    
    logger.info(`‚èπÔ∏è Completed scenario: ${this.context.scenarioName} with status: ${status.toUpperCase()} (${duration}ms)`);
    
    let error = undefined;
    const screenshots: string[] = this.context.screenshots || [];
    
    if (scenario.result?.status === Status.FAILED) {
      error = scenario.result.message;
      logger.error(`Scenario failed: ${error}`);
      
      // Take screenshot on failure if configured
      if (configHelper.shouldTakeScreenshotOnFailure()) {
        try {
          const screenshotName = `${this.context.featureName}_${this.context.scenarioName}_failure`;
          const screenshotPath = path.join(screenshotsDir, `${screenshotName}.txt`);
          
          // For API testing, save error details as a text file instead of screenshot
          await fs.writeFile(
            screenshotPath,
            `Error: ${error}\n\nContext: ${JSON.stringify(this.context, null, 2)}`,
            'utf8'
          );
          
          screenshots.push(screenshotPath);
          logger.info(`Error details saved to: ${screenshotPath}`);
        } catch (screenshotError) {
          logger.error(`Failed to save error details: ${screenshotError}`);
        }
      }
    }
    
    // Add test result to the report
    reportHelper.addTestResult(
      this.context.featureName,
      this.context.scenarioName,
      status,
      duration,
      error,
      { 
        scenarioId: this.context.scenarioId,
        responses: Object.keys(this.context.responses)
      },
      screenshots
    );
    
    // Remove from test context map
    if (this.context.scenarioName && testContextMap[this.context.scenarioName]) {
      delete testContextMap[this.context.scenarioName];
    }
  } catch (error) {
    logger.error(`Error in After hook: ${error}`);
  }
});
worldModel.ts
---------------

import { World as CucumberWorld } from '@cucumber/cucumber';
import { ApiResponse, AssetLayoutResponse } from './apiModels';
import { TestStep } from './reportModels';

export interface ScenarioContext {
  scenarioName: string;
  scenarioId: string;
  featureName: string;
  startTime: Date;
  stepStartTime?: Date;
  requestStartTime?: number;
  responseTime?: number;
  responses: Record<string, any>;
  data: Record<string, any>;
  screenshots: string[];
  assetLayoutResponse?: ApiResponse<AssetLayoutResponse>;
  [key: string]: any; // Allow any other properties
}

// Extend the Cucumber World type to include our custom context
export interface World extends CucumberWorld {
  context: ScenarioContext;
}
