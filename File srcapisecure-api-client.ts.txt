import { request, APIRequestContext, APIResponse } from '@playwright/test';
import { configHelper } from '../../config/config';
import { logger, logHttpDetails } from '../helpers/loggerHelper';
import { certificateHelper } from '../helpers/certificateHelper';
import { RetryHelper } from '../helpers/retryHelper';
import { TimeoutUtils } from '../utils/timeoutUtils';
import { ProxyAgent } from 'https-proxy-agent';

export interface RequestOptions {
  headers?: Record<string, string>;
  timeout?: number;
  retries?: number;
  retryDelay?: number;
  retryCondition?: (response: APIResponse) => boolean;
}

export class ApiClient {
  private static instance: ApiClient;
  private context: APIRequestContext | null = null;
  private isInitializing: boolean = false;
  private initializePromise: Promise<void> | null = null;

  private constructor() {}

  public static getInstance(): ApiClient {
    if (!ApiClient.instance) {
      ApiClient.instance = new ApiClient();
    }
    return ApiClient.instance;
  }

  /**
   * Initialize the API client
   * @returns Promise resolving when initialization is complete
   */
  public async initialize(): Promise<void> {
    // If already initializing, return the existing promise
    if (this.isInitializing && this.initializePromise) {
      return this.initializePromise;
    }

    // If already initialized, return immediately
    if (this.context) {
      return Promise.resolve();
    }

    this.isInitializing = true;
    this.initializePromise = this.doInitialize();
    
    try {
      await this.initializePromise;
    } finally {
      this.isInitializing = false;
      this.initializePromise = null;
    }
  }

  private async doInitialize(): Promise<void> {
    try {
      const baseURL = configHelper.getBaseUrl();
      const certOptions = await certificateHelper.getCertificateOptions();
      const proxyUrl = configHelper.getProxyUrl();
      
      const requestOptions: any = {
        baseURL,
        extraHTTPHeaders: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Connection': 'keep-alive' // Add keep-alive to prevent ECONNRESET
        },
        ignoreHTTPSErrors: true,
        timeout: configHelper.getTimeout(),
        ...certOptions
      };
      
      // Add proxy if configured
      if (proxyUrl) {
        requestOptions.proxy = {
          server: proxyUrl
        };
      }
      
      this.context = await request.newContext(requestOptions);
      
      logger.info(`API Client initialized with base URL: ${baseURL}`);
    } catch (error) {
      logger.error(`Failed to initialize API client: ${error}`);
      this.context = null;
      throw error;
    }
  }

  private async ensureContext(): Promise<APIRequestContext> {
    if (!this.context) {
      await this.initialize();
    }
    return this.context!;
  }

  /**
   * Perform a GET request
   * @param url The URL to request
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async get(url: string, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('GET', url, undefined, options);
  }

  /**
   * Perform a POST request
   * @param url The URL to request
   * @param data The data to send
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async post(url: string, data: any, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('POST', url, data, options);
  }

  /**
   * Perform a PUT request
   * @param url The URL to request
   * @param data The data to send
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async put(url: string, data: any, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('PUT', url, data, options);
  }

  /**
   * Perform a DELETE request
   * @param url The URL to request
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async delete(url: string, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('DELETE', url, undefined, options);
  }

  /**
   * Perform a PATCH request
   * @param url The URL to request
   * @param data The data to send
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  public async patch(url: string, data: any, options: RequestOptions = {}): Promise<APIResponse> {
    return this.executeRequest('PATCH', url, data, options);
  }

  /**
   * Execute a request with retries and timeouts
   * @param method The HTTP method
   * @param url The URL to request
   * @param data The data to send (for POST, PUT, PATCH)
   * @param options Request options
   * @returns Promise resolving to the API response
   */
  private async executeRequest(
    method: string,
    url: string,
    data?: any,
    options: RequestOptions = {}
  ): Promise<APIResponse> {
    const headers = {
      'Connection': 'keep-alive', // Add keep-alive to prevent ECONNRESET
      ...(options.headers || {})
    };
    
    const timeout = options.timeout || configHelper.getRequestTimeout();
    const retries = options.retries || parseInt(configHelper.get('REQUEST_RETRY_COUNT'), 10) || 3;
    const retryDelay = options.retryDelay || parseInt(configHelper.get('REQUEST_RETRY_DELAY'), 10) || 1000;
    
    // Only log if detailed logging is enabled
    if (configHelper.isDetailedLogging()) {
      logHttpDetails(method, url, headers, data);
    }
    
    return RetryHelper.withRetry(
      async () => {
        try {
          const context = await this.ensureContext();
          
          // Execute request with timeout
          const response = await TimeoutUtils.withTimeout(
            async () => {
              let requestConfig: any = { headers };
              
              switch (method.toUpperCase()) {
                case 'GET':
                  return await context.get(url, requestConfig);
                case 'POST':
                  return await context.post(url, { ...requestConfig, data });
                case 'PUT':
                  return await context.put(url, { ...requestConfig, data });
                case 'DELETE':
                  return await context.delete(url, requestConfig);
                case 'PATCH':
                  return await context.patch(url, { ...requestConfig, data });
                default:
                  throw new Error(`Unsupported HTTP method: ${method}`);
              }
            },
            timeout,
            `Request ${method} ${url} timed out after ${timeout}ms`
          );
          
          // Only log if detailed logging is enabled
          if (configHelper.isDetailedLogging()) {
            let responseData = null;
            try {
              responseData = await response.json();
            } catch (e) {
              // Ignore JSON parsing errors for logging
            }
            
            logHttpDetails(
              method,
              url,
              headers,
              data,
              response.status(),
              response.headers(),
              responseData
            );
          }
          
          // Check if retry is needed based on status code
          const shouldRetryStatus = options.retryCondition ? 
            options.retryCondition(response) : 
            response.status() >= 500;
          
          if (shouldRetryStatus) {
            throw new Error(`Request failed with status: ${response.status()}`);
          }
          
          return response;
        } catch (error) {
          // Log the error and always retry network related errors
          logger.error(`Request error (will retry): ${error}`);
          throw error; // Re-throw to trigger retry
        }
      },
      retries,
      retryDelay
    );
  }

  /**
   * Dispose the API client
   */
  public async dispose(): Promise<void> {
    if (this.context) {
      await this.context.dispose();
      this.context = null;
      logger.info('API Client disposed');
    }
  }
}

export default ApiClient.getInstance();
