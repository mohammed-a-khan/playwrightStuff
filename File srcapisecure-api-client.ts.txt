private async handleLongRunningRequest<T = any>(
  requestFn: () => Promise<AxiosResponse<T>>,
  options?: {
    enabled?: boolean;
    maxAttempts?: number;
    interval?: number;
    timeoutPerAttempt?: number;
    successCondition?: (response: AxiosResponse<T>) => boolean;
  }
): Promise<AxiosResponse<T>> {
  // Merge options with defaults and create pollOptions
  const pollOptions = {
    // Your existing options merging code...
  };
  
  // Make the initial request
  let response: AxiosResponse<T>;
  try {
    this.logger.info(`Making initial request for long-running operation`);
    response = await requestFn();
    
    // Store the original request URL for later use in polling
    const originalUrl = response.config.url;
    this.logger.debug(`Original request URL: ${originalUrl}`);
    
    // Store original method for retry
    const originalMethod = response.config.method?.toLowerCase() || 'get';
    
    // Store original data if any
    const originalData = response.config.data;
    
    // Check if we need to poll for completion
    if (pollOptions.successCondition(response)) {
      this.logger.info(`Initial response is complete, no polling needed`);
      return response;
    }
    
    // Start polling for completion
    this.logger.info(`Initial response incomplete, starting polling...`);
    
    for (let attempt = 1; attempt <= pollOptions.maxAttempts; attempt++) {
      // Wait for the polling interval
      this.logger.debug(`Waiting ${pollOptions.interval}ms before polling attempt ${attempt}/${pollOptions.maxAttempts}`);
      await new Promise(resolve => setTimeout(resolve, pollOptions.interval));
      
      try {
        // Instead of reusing the entire config, create a fresh request with the essential parts
        const requestConfig = this.createRequestConfig({
          timeout: pollOptions.timeoutPerAttempt,
          headers: response.config.headers,
          // Reuse any auth/certificate settings
          pfxPath: this.pfxCertPath,
          pfxPassphrase: this.pfxCertPassphrase,
          useProxy: true
        });
        
        // Add debug logging to see what's being requested
        this.logger.debug(`Polling attempt ${attempt}/${pollOptions.maxAttempts} to URL: ${originalUrl}`);
        
        // Use our executeRequest method to ensure consistency
        if (originalMethod === 'post' || originalMethod === 'put' || originalMethod === 'patch') {
          response = await this.executeRequest(originalMethod as any, originalUrl, originalData, requestConfig);
        } else {
          response = await this.executeRequest(originalMethod as any, originalUrl, undefined, requestConfig);
        }
        
        // Check if the response is now complete
        if (pollOptions.successCondition(response)) {
          this.logger.info(`Polling successful after ${attempt} attempts`);
          return response;
        }
        
        this.logger.debug(`Polling attempt ${attempt}/${pollOptions.maxAttempts} - data still incomplete`);
      } catch (error) {
        // Enhanced error logging
        this.logger.warn(`Polling attempt ${attempt} failed: ${error.message}`);
        
        if (error.response) {
          this.logger.debug(`Error status: ${error.response.status}`);
          if (error.response.status === 502) {
            this.logger.debug(`DNS Error detected - attempting to resolve hostname...`);
            try {
              const parsedUrl = new URL(originalUrl);
              const dns = require('dns');
              const result = await new Promise((resolve, reject) => {
                dns.lookup(parsedUrl.hostname, (err, address) => {
                  if (err) reject(err);
                  else resolve(address);
                });
              });
              this.logger.debug(`Hostname resolved to: ${result}`);
            } catch (dnsError) {
              this.logger.debug(`DNS resolution failed: ${dnsError.message}`);
            }
          }
        }
        
        // Continue to next attempt despite error
      }
    }
    
    // If we get here, we've exceeded the maximum polling attempts
    throw new Error(`Long-running request did not complete after ${pollOptions.maxAttempts} polling attempts`);
  } catch (error) {
    this.logger.error(`Initial request failed: ${error.message}`);
    throw error;
  }
}
