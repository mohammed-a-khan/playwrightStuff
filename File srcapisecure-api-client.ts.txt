hooks.ts
----------

import { BeforeAll, AfterAll, Before, After, BeforeStep, AfterStep, Status, setDefaultTimeout } from '@cucumber/cucumber';
import { ITestCaseHookParameter, ITestStepHookParameter } from '@cucumber/cucumber';
import apiClient from '../api/apiClient';
import { logger } from '../helpers/loggerHelper';
import reportHelper from '../helpers/reportHelper';
import * as fs from 'fs-extra';
import * as path from 'path';
import { configHelper } from '../../config/config';
import { TimeoutUtils } from '../utils/timeoutUtils';
import { World, ScenarioContext } from '../models/worldModels';

// Set a higher default timeout for all steps (in milliseconds)
// This is crucial for API testing where responses may take longer than the default 5 seconds
setDefaultTimeout(120 * 1000); // 120 seconds (2 minutes)

// Ensure reports directories exist
const reportsDir = path.join(process.cwd(), 'reports');
const jsonReportsDir = path.join(reportsDir, 'json');
const htmlReportsDir = path.join(reportsDir, 'html');
const screenshotsDir = path.join(reportsDir, 'screenshots');
const logsDir = path.join(reportsDir, 'logs');
const historyDir = path.join(reportsDir, 'history');

fs.ensureDirSync(jsonReportsDir);
fs.ensureDirSync(htmlReportsDir);
fs.ensureDirSync(screenshotsDir);
fs.ensureDirSync(logsDir);
fs.ensureDirSync(historyDir);

// Store test context in module-level variable to avoid global variable issues
const testContextMap: Record<string, ScenarioContext> = {};

BeforeAll(async function() {
  logger.info('üöÄ Test execution started');
  // Note: The report is also initialized by the cucumber formatter
  // but we call it here as well to ensure it runs even without the formatter
  reportHelper.startTestRun();
  
  // Initialize API client and wait for completion
  await apiClient.initialize();
  
  // Log environment information
  logger.info(`Environment: ${configHelper.getEnvironment()}`);
  logger.info(`Base URL: ${configHelper.getBaseUrl()}`);
  logger.info(`Debug Mode: ${configHelper.isDebugMode()}`);
  logger.info(`Timeout: ${configHelper.getTimeout()}ms`);
  logger.info(`Retry Attempts: ${configHelper.getRetryAttempts()}`);
});

AfterAll(async function() {
  try {
    logger.info('üèÅ Test execution completed');
    
    // Wait for any pending operations to complete
    await TimeoutUtils.sleep(1000);
    
    // Cleanup
    await apiClient.dispose();
    
    // Generate report
    // Note: The report is also generated by the cucumber formatter
    // but we call it here as well to ensure it runs even without the formatter
    reportHelper.endTestRun();
    
    // Use a hardcoded name to avoid issues with string manipulation
    try {
      await reportHelper.generateReport('api-test-report');
      logger.info('Report generation completed successfully');
    } catch (reportError) {
      logger.error(`Error generating report: ${reportError}`);
    }
    
    // Clear test context
    Object.keys(testContextMap).forEach((key) => {
      delete testContextMap[key];
    });
    
    logger.info('AfterAll hook completed successfully');
  } catch (error) {
    logger.error(`Error in AfterAll hook: ${error}`);
  }
});

Before(async function(this: World, scenario: ITestCaseHookParameter) {
  try {
    // Safely get the feature name from the URI if it exists
    let featureName = 'Unknown';
    if (scenario.pickle.uri && typeof scenario.pickle.uri === 'string') {
      const uriParts = scenario.pickle.uri.split('/');
      const featureFile = uriParts[uriParts.length - 1];
      featureName = featureFile.replace('.feature', '');
    }
    
    const scenarioName = scenario.pickle.name || 'Unnamed Scenario';
    
    logger.info(`‚ñ∂Ô∏è Starting scenario: ${scenarioName} [${featureName}]`);
    
    // Set current scenario in report helper for step tracking
    reportHelper.setCurrentScenario(featureName, scenarioName);
    
    // Initialize scenario context
    this.context = {
      scenarioName,
      scenarioId: scenario.pickle.id || '',
      featureName,
      startTime: new Date(),
      responses: {},
      data: {},
      screenshots: []
    };
    
    // Add to test context map
    testContextMap[scenarioName] = this.context;
  } catch (error) {
    logger.error(`Error in Before hook: ${error}`);
    throw error;
  }
});

// Track each step with proper type annotations
BeforeStep(async function(this: World, step: ITestStepHookParameter) {
  try {
    const stepText = step.pickleStep.text || '';
    logger.debug(`Starting step: ${stepText}`);
    
    // Store step start time in world context for duration calculation
    this.context.stepStartTime = new Date();
  } catch (error) {
    logger.error(`Error in BeforeStep hook: ${error}`);
  }
});

// Fixed AfterStep hook with proper type annotation
AfterStep(async function(this: World, step: ITestStepHookParameter) {
  try {
    if (!this.context || !this.context.stepStartTime) {
      logger.error('Context or stepStartTime is missing in AfterStep hook');
      return;
    }
    
    const duration = new Date().getTime() - this.context.stepStartTime.getTime();
    const status = step.result?.status || 'unknown';
    const stepText = step.pickleStep.text || '';
    
    // Get keyword from the step type
    let stepKeyword = '';
    switch (step.pickleStepType) {
      case 'Given':
        stepKeyword = 'Given';
        break;
      case 'When':
        stepKeyword = 'When';
        break;
      case 'Then':
        stepKeyword = 'Then';
        break;
      case 'And':
        stepKeyword = 'And';
        break;
      case 'But':
        stepKeyword = 'But';
        break;
      default:
        stepKeyword = step.pickleStepType || '';
    }
    
    logger.debug(`Completed step: ${stepText} with status: ${status.toUpperCase()} (${duration}ms)`);
    
    // Add step to the report
    reportHelper.addStep(
      stepKeyword,
      stepText,
      status,
      duration,
      step.result?.status === Status.FAILED ? step.result.message : undefined
    );
    
    // Take screenshot on step failure if configured
    if (step.result?.status === Status.FAILED && configHelper.shouldTakeScreenshotOnFailure()) {
      try {
        const screenshotName = `${this.context.featureName}_${this.context.scenarioName}_step_failure`;
        const screenshotPath = path.join(screenshotsDir, `${screenshotName}.txt`);
        
        // For API testing, save error details as a text file instead of screenshot
        await fs.writeFile(
          screenshotPath,
          `Error: ${step.result.message || 'Unknown error'}\n\nStep: ${stepKeyword} ${stepText}\n\nContext: ${JSON.stringify(this.context, null, 2)}`,
          'utf8'
        );
        
        this.context.screenshots = this.context.screenshots || [];
        this.context.screenshots.push(screenshotPath);
        logger.info(`Error details saved to: ${screenshotPath}`);
      } catch (screenshotError) {
        logger.error(`Failed to save error details: ${screenshotError}`);
      }
    }
  } catch (error) {
    logger.error(`Error in AfterStep hook: ${error}`);
  }
});

After(async function(this: World, scenario: ITestCaseHookParameter) {
  try {
    if (!this.context || !this.context.startTime) {
      logger.error('Context or startTime is missing in After hook');
      return;
    }
    
    const duration = new Date().getTime() - this.context.startTime.getTime();
    const status = scenario.result?.status || 'unknown';
    
    logger.info(`‚èπÔ∏è Completed scenario: ${this.context.scenarioName} with status: ${status.toUpperCase()} (${duration}ms)`);
    
    let error = undefined;
    const screenshots: string[] = this.context.screenshots || [];
    
    if (scenario.result?.status === Status.FAILED) {
      error = scenario.result.message;
      logger.error(`Scenario failed: ${error}`);
      
      // Take screenshot on failure if configured
      if (configHelper.shouldTakeScreenshotOnFailure()) {
        try {
          const screenshotName = `${this.context.featureName}_${this.context.scenarioName}_failure`;
          const screenshotPath = path.join(screenshotsDir, `${screenshotName}.txt`);
          
          // For API testing, save error details as a text file instead of screenshot
          await fs.writeFile(
            screenshotPath,
            `Error: ${error}\n\nContext: ${JSON.stringify(this.context, null, 2)}`,
            'utf8'
          );
          
          screenshots.push(screenshotPath);
          logger.info(`Error details saved to: ${screenshotPath}`);
        } catch (screenshotError) {
          logger.error(`Failed to save error details: ${screenshotError}`);
        }
      }
    }
    
    // Add test result to the report
    reportHelper.addTestResult(
      this.context.featureName,
      this.context.scenarioName,
      status,
      duration,
      error,
      { 
        scenarioId: this.context.scenarioId,
        responses: Object.keys(this.context.responses)
      },
      screenshots
    );
    
    // Remove from test context map
    if (this.context.scenarioName && testContextMap[this.context.scenarioName]) {
      delete testContextMap[this.context.scenarioName];
    }
  } catch (error) {
    logger.error(`Error in After hook: ${error}`);
  }
});

