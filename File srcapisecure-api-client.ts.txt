import winston from 'winston';
import 'winston-daily-rotate-file';
import * as path from 'path';
import * as fs from 'fs-extra';
import chalk from 'chalk';

// Create logs directory
const logsDir = path.join(process.cwd(), 'reports', 'logs');
fs.ensureDirSync(logsDir);

// Custom log format with colors and detailed information
const customFormat = winston.format.printf(({ level, message, timestamp, ...metadata }) => {
  const metaStr = Object.keys(metadata).length ? 
    `\n${JSON.stringify(metadata, null, 2)}` : '';
  
  let colorizedLevel;
  switch (level) {
    case 'error':
      colorizedLevel = chalk.red.bold(level.toUpperCase());
      break;
    case 'warn':
      colorizedLevel = chalk.yellow.bold(level.toUpperCase());
      break;
    case 'info':
      colorizedLevel = chalk.green.bold(level.toUpperCase());
      break;
    case 'debug':
      colorizedLevel = chalk.blue.bold(level.toUpperCase());
      break;
    default:
      colorizedLevel = chalk.white.bold(level.toUpperCase());
  }
  
  return `${timestamp} [${colorizedLevel}]: ${message}${metaStr}`;
});

// Create daily rotating file transports
const fileRotateTransport = new winston.transports.DailyRotateFile({
  filename: path.join(logsDir, 'application-%DATE%.log'),
  datePattern: 'YYYY-MM-DD',
  maxSize: '20m',
  maxFiles: '14d',
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
    winston.format.json()
  )
});

const errorFileRotateTransport = new winston.transports.DailyRotateFile({
  filename: path.join(logsDir, 'error-%DATE%.log'),
  datePattern: 'YYYY-MM-DD',
  maxSize: '20m',
  maxFiles: '14d',
  level: 'error',
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
    winston.format.json()
  )
});

// Determine log level from environment variable directly
const determineLogLevel = (): string => {
  return process.env.DEBUG === 'true' ? 'debug' : 'info';
};

// Create the logger instance
export const logger = winston.createLogger({
  level: determineLogLevel(),
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
    winston.format.metadata({ fillExcept: ['message', 'level', 'timestamp'] }),
    winston.format.json()
  ),
  defaultMeta: { service: 'api-automation' },
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss.SSS' }),
        winston.format.metadata({ fillExcept: ['message', 'level', 'timestamp'] }),
        customFormat
      )
    }),
    fileRotateTransport,
    errorFileRotateTransport
  ]
});

// Function to update logger level
export const updateLogLevel = (debugMode: boolean): void => {
  logger.level = debugMode ? 'debug' : 'info';
};

// Function to log HTTP requests and responses in detailed mode
export const logHttpDetails = (
  method: string,
  url: string,
  requestHeaders?: Record<string, string>,
  requestData?: any,
  responseStatus?: number,
  responseHeaders?: Record<string, string>,
  responseData?: any,
  error?: any
) => {
  // Get DETAILED_LOGGING setting, default to true if undefined
  const isDetailedLogging = process.env.DETAILED_LOGGING !== 'false';
  
  if (!isDetailedLogging) {
    return;
  }

  const logObj: any = {
    request: {
      method,
      url
    }
  };

  if (requestHeaders) {
    logObj.request.headers = { ...requestHeaders };
    // Mask sensitive headers
    if (logObj.request.headers.Authorization) {
      logObj.request.headers.Authorization = '[REDACTED]';
    }
  }

  if (requestData) {
    logObj.request.data = requestData;
  }

  if (responseStatus !== undefined) {
    logObj.response = {
      status: responseStatus
    };

    if (responseHeaders) {
      logObj.response.headers = responseHeaders;
    }

    if (responseData) {
      logObj.response.data = responseData;
    }
  }

  if (error) {
    logObj.error = error.message || error;
    logger.error(`HTTP Request Failed: ${method} ${url}`, logObj);
  } else {
    logger.debug(`HTTP Transaction: ${method} ${url}`, logObj);
  }
};

config.ts
-------------

import * as dotenv from 'dotenv';
import * as path from 'path';
import * as fs from 'fs-extra';
import { logger, updateLogLevel } from '../src/helpers/loggerHelper';

export class ConfigHelper {
  private static instance: ConfigHelper;
  private config: Record<string, string> = {};
  
  private constructor() {
    this.initializeConfig();
  }

  private initializeConfig(): void {
    try {
      // Load environment variables based on NODE_ENV
      const env = process.env.NODE_ENV || 'sit';
      const envPath = path.join(__dirname, `environments/.env.${env}`);
      
      if (fs.existsSync(envPath)) {
        const result = dotenv.config({ path: envPath });
        if (result.error) {
          throw new Error(`Error loading environment variables: ${result.error.message}`);
        }
        this.config = { ...process.env } as Record<string, string>;
        logger.info(`Environment loaded: ${env} from ${envPath}`);

        // Update logger level after config is loaded
        updateLogLevel(this.isDebugMode());
      } else {
        throw new Error(`Environment file not found: ${envPath}`);
      }
    } catch (error) {
      logger.error(`Config initialization error: ${error}`);
      throw error;
    }
  }

  public static getInstance(): ConfigHelper {
    if (!ConfigHelper.instance) {
      ConfigHelper.instance = new ConfigHelper();
    }
    return ConfigHelper.instance;
  }

  public get(key: string): string {
    const value = this.config[key];
    if (value === undefined) {
      logger.warn(`Configuration key not found: ${key}`);
      return '';
    }
    return value;
  }

  public getBaseUrl(): string {
    return this.get('API_BASE_URL');
  }

  public getCertPath(): string {
    return this.get('CERT_PATH');
  }

  public getCertPassphrase(): string {
    return this.get('CERT_PASSPHRASE');
  }

  public getEnvironment(): string {
    return this.get('NODE_ENV') || 'sit';
  }
  
  public isDebugMode(): boolean {
    return this.get('DEBUG') === 'true';
  }

  public getTimeout(): number {
    const timeout = parseInt(this.get('TIMEOUT'), 10);
    return isNaN(timeout) ? 30000 : timeout;
  }

  public getRetryAttempts(): number {
    const retries = parseInt(this.get('RETRY_ATTEMPTS'), 10);
    return isNaN(retries) ? 2 : retries;
  }

  public getRequestTimeout(): number {
    const timeout = parseInt(this.get('REQUEST_TIMEOUT'), 10);
    return isNaN(timeout) ? 30000 : timeout;
  }

  public getMaxConcurrentRequests(): number {
    const maxRequests = parseInt(this.get('MAX_CONCURRENT_REQUESTS'), 10);
    return isNaN(maxRequests) ? 1 : maxRequests; // Default to 1 for sequential execution
  }

  public shouldTakeScreenshotOnFailure(): boolean {
    return this.get('SCREENSHOT_ON_FAILURE') !== 'false';
  }

  public getProxyUrl(): string | undefined {
    const proxyUrl = this.get('PROXY_URL');
    return proxyUrl === '' ? undefined : proxyUrl;
  }
}

export const configHelper = ConfigHelper.getInstance();
