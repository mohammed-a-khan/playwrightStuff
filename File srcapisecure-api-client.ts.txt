# Complete Framework Structure

Here's a complete overview of all the key files that should be in your project:

## Core Configuration Files

### 1. package.json
```json
{
  "name": "playwright-api-framework",
  "version": "1.0.0",
  "description": "Enterprise-level API test automation framework using Playwright, TypeScript, and Cucumber BDD",
  "main": "index.js",
  "scripts": {
    "build": "tsc",
    "test": "cucumber-js",
    "test:sit": "cross-env NODE_ENV=sit cucumber-js",
    "test:uat": "cross-env NODE_ENV=uat cucumber-js",
    "test:prod": "cross-env NODE_ENV=prod cucumber-js",
    "test:debug": "cross-env DEBUG=true cucumber-js",
    "report": "node ./src/helpers/reportHelper.js",
    "clean": "rimraf reports/json/* reports/html/* dist/*"
  },
  "keywords": [
    "playwright",
    "typescript",
    "cucumber",
    "api",
    "testing"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@cucumber/cucumber": "^9.1.2",
    "@playwright/test": "^1.35.1",
    "chai": "^4.3.7",
    "cross-env": "^7.0.3",
    "dotenv": "^16.3.1",
    "fs-extra": "^11.1.1",
    "moment": "^2.29.4",
    "pem": "^1.14.8",
    "ts-node": "^10.9.1",
    "typescript": "^5.1.6",
    "winston": "^3.9.0"
  },
  "devDependencies": {
    "@types/chai": "^4.3.5",
    "@types/fs-extra": "^11.0.1",
    "@types/node": "^20.4.1",
    "prettier": "^3.0.0",
    "rimraf": "^5.0.1"
  }
}
```

### 2. tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2018",
    "module": "commonjs",
    "lib": ["es2018", "dom"],
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": ".",
    "paths": {
      "@config/*": ["./config/*"],
      "@src/*": ["./src/*"],
      "@tests/*": ["./tests/*"]
    },
    "allowJs": true,
    "strict": false,
    "noImplicitAny": false,
    "experimentalDecorators": true,
    "types": ["node", "@cucumber/cucumber"]
  },
  "include": ["**/*.ts", "**/*.d.ts"],
  "exclude": ["node_modules", "dist"]
}
```

### 3. cucumber.js
```javascript
const common = {
  require: [
    'ts-node/register',
    './tests/support/World.ts',
    './src/hooks/hooks.ts',
    './tests/step-definitions/*.ts'
  ],
  paths: ['./tests/features/'],
  format: [
    'progress-bar',
    'json:reports/json/cucumber-report.json'
  ],
  formatOptions: { snippetInterface: 'async-await' },
  publishQuiet: true
};

module.exports = {
  default: common
};
```

### 4. playwright.config.ts
```typescript
import { PlaywrightTestConfig } from '@playwright/test';
import * as dotenv from 'dotenv';
import path from 'path';

// Load environment variables based on NODE_ENV
const env = process.env.NODE_ENV || 'sit';
dotenv.config({ path: path.join(__dirname, `config/environments/.env.${env}`) });

const config: PlaywrightTestConfig = {
  timeout: 30000,
  retries: 0,
  use: {
    extraHTTPHeaders: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
    ignoreHTTPSErrors: true,
    trace: 'on-first-retry'
  },
  reporter: [['html', { outputFolder: 'reports/playwright' }]],
  workers: process.env.CI ? 1 : undefined,
};

export default config;
```

## Environment Configuration

### 5. config/config.ts
```typescript
import * as dotenv from 'dotenv';
import path from 'path';
import fs from 'fs-extra';

class Config {
  private static instance: Config;
  private config: Record<string, string> = {};
  
  private constructor() {
    // Load environment variables based on NODE_ENV
    const env = process.env.NODE_ENV || 'sit';
    const envPath = path.join(__dirname, `environments/.env.${env}`);
    
    if (fs.existsSync(envPath)) {
      const result = dotenv.config({ path: envPath });
      if (result.error) {
        throw new Error(`Error loading environment variables: ${result.error.message}`);
      }
      this.config = { ...process.env } as Record<string, string>;
    } else {
      throw new Error(`Environment file not found: ${envPath}`);
    }
  }

  public static getInstance(): Config {
    if (!Config.instance) {
      Config.instance = new Config();
    }
    return Config.instance;
  }

  public get(key: string): string {
    return this.config[key] || '';
  }

  public getBaseUrl(): string {
    return this.get('API_BASE_URL');
  }

  public getCertPath(): string {
    return this.get('CERT_PATH');
  }

  public getCertPassphrase(): string {
    return this.get('CERT_PASSPHRASE');
  }

  public getEnvironment(): string {
    return this.get('NODE_ENV') || 'sit';
  }
  
  public isDebugMode(): boolean {
    return this.get('DEBUG') === 'true';
  }
}

export default Config.getInstance();
```

### 6. config/environments/.env.sit
```
API_BASE_URL=https://katapi-sit.k8s.americas.ishare.net
CERT_PATH=./certs/kpfxPROD.pfx
CERT_PASSPHRASE=khan#123!
DEBUG=false
TIMEOUT=30000
RETRY_ATTEMPTS=2
```

## API Client and Endpoints

### 7. src/api/apiClient.ts
```typescript
import { request, APIRequestContext, APIResponse } from '@playwright/test';
import config from '../../config/config';
import logger from '../helpers/loggerHelper';
import { certificateHelper } from '../helpers/certificateHelper';

export class ApiClient {
  private static instance: ApiClient;
  private context: APIRequestContext | null = null;

  private constructor() {}

  public static getInstance(): ApiClient {
    if (!ApiClient.instance) {
      ApiClient.instance = new ApiClient();
    }
    return ApiClient.instance;
  }

  public async initialize(): Promise<void> {
    if (!this.context) {
      try {
        const baseURL = config.getBaseUrl();
        const certOptions = await certificateHelper.getCertificateOptions();
        
        this.context = await request.newContext({
          baseURL,
          extraHTTPHeaders: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          ignoreHTTPSErrors: true,
          ...certOptions
        });
        
        logger.info(`API Client initialized with base URL: ${baseURL}`);
      } catch (error) {
        logger.error(`Failed to initialize API client: ${error}`);
        throw error;
      }
    }
  }

  private async ensureContext(): Promise<APIRequestContext> {
    if (!this.context) {
      await this.initialize();
    }
    return this.context!;
  }

  public async get(url: string, headers?: Record<string, string>): Promise<APIResponse> {
    const context = await this.ensureContext();
    logger.debug(`GET Request - URL: ${url}`);
    const response = await context.get(url, { headers });
    logger.debug(`GET Response - Status: ${response.status()}`);
    return response;
  }

  public async post(url: string, data: any, headers?: Record<string, string>): Promise<APIResponse> {
    const context = await this.ensureContext();
    logger.debug(`POST Request - URL: ${url}, Payload: ${JSON.stringify(data)}`);
    const response = await context.post(url, {
      data,
      headers
    });
    logger.debug(`POST Response - Status: ${response.status()}`);
    return response;
  }

  public async put(url: string, data: any, headers?: Record<string, string>): Promise<APIResponse> {
    const context = await this.ensureContext();
    logger.debug(`PUT Request - URL: ${url}, Payload: ${JSON.stringify(data)}`);
    const response = await context.put(url, {
      data,
      headers
    });
    logger.debug(`PUT Response - Status: ${response.status()}`);
    return response;
  }

  public async delete(url: string, headers?: Record<string, string>): Promise<APIResponse> {
    const context = await this.ensureContext();
    logger.debug(`DELETE Request - URL: ${url}`);
    const response = await context.delete(url, { headers });
    logger.debug(`DELETE Response - Status: ${response.status()}`);
    return response;
  }

  public async patch(url: string, data: any, headers?: Record<string, string>): Promise<APIResponse> {
    const context = await this.ensureContext();
    logger.debug(`PATCH Request - URL: ${url}, Payload: ${JSON.stringify(data)}`);
    const response = await context.patch(url, {
      data,
      headers
    });
    logger.debug(`PATCH Response - Status: ${response.status()}`);
    return response;
  }

  public async dispose(): Promise<void> {
    if (this.context) {
      await this.context.dispose();
      this.context = null;
      logger.info('API Client disposed');
    }
  }
}

export default ApiClient.getInstance();
```

### 8. src/api/endpoints.ts
```typescript
export const Endpoints = {
  ASSET_LAYOUT: '/v1/assets/assetlayout',
  // Add more endpoints as needed
};
```

### 9. src/api/services/assetLayoutService.ts
```typescript
import apiClient from '../apiClient';
import { Endpoints } from '../endpoints';
import { AssetLayoutRequest, AssetLayoutResponse } from '../../models/assetLayout.model';
import logger from '../../helpers/loggerHelper';
import { ApiResponse } from '../../models/response.model';

export class AssetLayoutService {
  private static instance: AssetLayoutService;

  private constructor() {}

  public static getInstance(): AssetLayoutService {
    if (!AssetLayoutService.instance) {
      AssetLayoutService.instance = new AssetLayoutService();
    }
    return AssetLayoutService.instance;
  }

  public async getAssetLayout(request: AssetLayoutRequest): Promise<ApiResponse<AssetLayoutResponse>> {
    try {
      logger.info(`Fetching asset layout for dealId: ${request.dealId}`);
      const response = await apiClient.post(Endpoints.ASSET_LAYOUT, request);
      
      const apiResponse: ApiResponse<AssetLayoutResponse> = {
        statusCode: response.status(),
        headers: response.headers(),
        data: await response.json() as AssetLayoutResponse,
        ok: response.ok()
      };
      
      logger.info(`Asset layout response received with status: ${apiResponse.statusCode}`);
      return apiResponse;
    } catch (error) {
      logger.error(`Error fetching asset layout: ${error}`);
      throw error;
    }
  }
}

export default AssetLayoutService.getInstance();
```

## Models

### 10. src/models/assetLayout.model.ts
```typescript
export interface AssetLayoutRequest {
  messageId: number;
  dealId: number;
  reportDate: string;
}

export interface AssetLayout {
  dealId: number;
  entityId: number;
  // Add other fields as needed
  [key: string]: any; // This allows for additional fields
}

export interface AssetLayoutResponse {
  assetLayouts: AssetLayout[];
  systemError: string | null;
  responseMessageId: string;
  validationErrorMessage: string | null;
  errorMessage: string | null;
}
```

### 11. src/models/response.model.ts
```typescript
export interface ApiResponse<T> {
  statusCode: number;
  headers: Record<string, string>;
  data: T;
  ok: boolean;
}
```

## Helpers

### 12. src/helpers/certificateHelper.ts
```typescript
import * as fs from 'fs-extra';
import * as path from 'path';
import config from '../../config/config';
import logger from './loggerHelper';

export class CertificateHelper {
  private static instance: CertificateHelper;

  private constructor() {}

  public static getInstance(): CertificateHelper {
    if (!CertificateHelper.instance) {
      CertificateHelper.instance = new CertificateHelper();
    }
    return CertificateHelper.instance;
  }

  public async getCertificateOptions(): Promise<any> {
    try {
      const certPath = path.resolve(config.getCertPath());
      const passphrase = config.getCertPassphrase();
      
      if (!fs.existsSync(certPath)) {
        logger.warn(`Certificate file not found at: ${certPath}`);
        return {};
      }

      logger.debug(`Using certificate at: ${certPath}`);
      
      // Read the certificate file
      const pfxBuffer = await fs.readFile(certPath);
      
      return {
        httpsOptions: {
          pfx: pfxBuffer,
          passphrase
        }
      };
    } catch (error) {
      logger.error(`Error loading certificate: ${error}`);
      throw error;
    }
  }
}

export const certificateHelper = CertificateHelper.getInstance();
```

### 13. src/helpers/loggerHelper.ts
```typescript
import winston from 'winston';
import path from 'path';
import fs from 'fs-extra';
import config from '../../config/config';

// Create logs directory if it doesn't exist
const logsDir = path.join(process.cwd(), 'reports', 'logs');
fs.ensureDirSync(logsDir);

const logFormat = winston.format.printf(({ level, message, timestamp }) => {
  return `${timestamp} [${level.toUpperCase()}]: ${message}`;
});

const logger = winston.createLogger({
  level: config.isDebugMode() ? 'debug' : 'info',
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    logFormat
  ),
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        logFormat
      )
    }),
    new winston.transports.File({ 
      filename: path.join(logsDir, 'error.log'), 
      level: 'error' 
    }),
    new winston.transports.File({ 
      filename: path.join(logsDir, 'combined.log') 
    })
  ]
});

export default logger;
```

## Cucumber Setup

### 14. tests/support/World.ts
```typescript
import { setWorldConstructor, World as CucumberWorld } from '@cucumber/cucumber';

export class CustomWorld extends CucumberWorld {
  context: {
    scenarioName: string;
    scenarioId: string;
    startTime: Date;
    responses: Record<string, any>;
    assetLayoutResponse?: any;
  };

  constructor(options) {
    super(options);
    this.context = {
      scenarioName: '',
      scenarioId: '',
      startTime: new Date(),
      responses: {}
    };
  }
}

setWorldConstructor(CustomWorld);
```

### 15. tests/support/world.d.ts
```typescript
import { World as CucumberWorld } from '@cucumber/cucumber';
import { ApiResponse } from '../../src/models/response.model';
import { AssetLayoutResponse } from '../../src/models/assetLayout.model';

declare module '@cucumber/cucumber' {
  interface World {
    context: {
      scenarioName: string;
      scenarioId: string;
      startTime: Date;
      responses: Record<string, any>;
      assetLayoutResponse?: ApiResponse<AssetLayoutResponse>;
    };
  }
}
```

### 16. src/hooks/hooks.ts
```typescript
import { BeforeAll, AfterAll, Before, After, Status } from '@cucumber/cucumber';
import apiClient from '../api/apiClient';
import logger from '../helpers/loggerHelper';
import reportHelper from '../helpers/reportHelper';
import * as fs from 'fs-extra';
import * as path from 'path';

// Ensure reports directory exists
const reportsDir = path.join(process.cwd(), 'reports');
const jsonReportsDir = path.join(reportsDir, 'json');
const htmlReportsDir = path.join(reportsDir, 'html');
fs.ensureDirSync(jsonReportsDir);
fs.ensureDirSync(htmlReportsDir);

BeforeAll(async function() {
  logger.info('Test execution started');
  reportHelper.startTestRun();
  await apiClient.initialize();
});

AfterAll(async function() {
  logger.info('Test execution completed');
  await apiClient.dispose();
  reportHelper.endTestRun();
  await reportHelper.generateReport();
});

Before(async function(scenario) {
  logger.info(`Starting scenario: ${scenario.pickle.name}`);
  this.context = {
    scenarioName: scenario.pickle.name,
    scenarioId: scenario.pickle.id,
    startTime: new Date(),
    responses: {}
  };
});

After(async function(scenario) {
  const duration = new Date().getTime() - this.context.startTime.getTime();
  
  logger.info(`Completed scenario: ${scenario.pickle.name} with status: ${scenario.result?.status}`);
  
  let error = undefined;
  if (scenario.result?.status === Status.FAILED && scenario.result.message) {
    error = scenario.result.message;
    logger.error(`Scenario failed: ${error}`);
  }
  
  reportHelper.addTestResult(
    scenario.pickle.uri || 'Unknown',
    scenario.pickle.name,
    scenario.result?.status || 'unknown',
    duration,
    error
  );
});
```

## Tests

### 17. tests/features/assetLayout.feature
```gherkin
Feature: Asset Layout API Tests
  As a user
  I want to test the Asset Layout API
  So that I can ensure it works correctly

  Background:
    Given the API is available

  Scenario: Get asset layout with valid data
    When I send a request to get asset layout with the following data:
      | messageId | dealId | reportDate  |
      | 1234      | 34384  | 2024-03-31  |
    Then the response status code should be 200
    And the response should contain valid asset layout data

  Scenario: Get asset layout with invalid deal ID
    When I send a request to get asset layout with the following data:
      | messageId | dealId | reportDate  |
      | 1234      | 99999  | 2024-03-31  |
    Then the response status code should be 404
    And the response should contain an error message

  Scenario: Get asset layout with invalid report date
    When I send a request to get asset layout with the following data:
      | messageId | dealId | reportDate  |
      | 1234      | 34384  | invalid-date|
    Then the response status code should be 400
    And the response should contain a validation error
```

### 18. tests/step-definitions/assetLayoutSteps.ts
```typescript
import { Given, When, Then } from '@cucumber/cucumber';
import { expect } from 'chai';
import AssetLayoutService from '../../src/api/services/assetLayoutService';
import { AssetLayoutRequest } from '../../src/models/assetLayout.model';
import logger from '../../src/helpers/loggerHelper';

Given('the API is available', async function() {
  // This step is a placeholder to verify the API is accessible
  // The actual API connectivity check is done in the hooks
  logger.info('Verifying API availability');
});

When('I send a request to get asset layout with the following data:', async function(dataTable) {
  try {
    // Convert the data table to our request object
    const rows = dataTable.hashes();
    if (rows.length === 0) {
      throw new Error('No data provided in the data table');
    }

    const row = rows[0];
    const request: AssetLayoutRequest = {
      messageId: parseInt(row.messageId),
      dealId: parseInt(row.dealId),
      reportDate: row.reportDate
    };

    logger.info(`Sending asset layout request with dealId: ${request.dealId}`);
    
    // Send the request and store the response in the world context
    this.context.assetLayoutResponse = await AssetLayoutService.getAssetLayout(request);
    logger.info(`Received response with status: ${this.context.assetLayoutResponse.statusCode}`);
  } catch (error) {
    logger.error(`Error during asset layout request: ${error}`);
    throw error;
  }
});

Then('the response status code should be {int}', function(expectedStatusCode) {
  expect(this.context.assetLayoutResponse).to.not.be.undefined;
  expect(this.context.assetLayoutResponse?.statusCode).to.equal(expectedStatusCode);
});

Then('the response should contain valid asset layout data', function() {
  expect(this.context.assetLayoutResponse).to.not.be.undefined;
  expect(this.context.assetLayoutResponse?.data).to.not.be.undefined;
  
  const response = this.context.assetLayoutResponse?.data;
  expect(response.assetLayouts).to.be.an('array');
  expect(response.assetLayouts.length).to.be.greaterThan(0);
  expect(response.systemError).to.be.null;
  expect(response.errorMessage).to.be.null;
  expect(response.validationErrorMessage).to.be.null;
  expect(response.responseMessageId).to.be.a('string');
  
  // Validate the first asset layout in the array
  const firstAssetLayout = response.assetLayouts[0];
  expect(firstAssetLayout).to.have.property('dealId');
  expect(firstAssetLayout).to.have.property('entityId');
  expect(firstAssetLayout.dealId).to.be.a('number');
  expect(firstAssetLayout.entityId).to.be.a('number');
});

Then('the response should contain an error message', function() {
  expect(this.context.assetLayoutResponse).to.not.be.undefined;
  expect(this.context.assetLayoutResponse?.data).to.not.be.undefined;
  
  const response = this.context.assetLayoutResponse?.data;
  expect(response.errorMessage).to.not.be.null;
  expect(response.errorMessage).to.be.a('string');
  expect(response.assetLayouts).to.be.an('array');
  expect(response.assetLayouts.length).to.equal(0);
});

Then('the response should contain a validation error', function() {
  expect(this.context.assetLayoutResponse).to.not.be.undefined;
  expect(this.context.assetLayoutResponse?.data).to.not.be.undefined;
  
  const response = this.context.assetLayoutResponse?.data;
  expect(response.validationErrorMessage).to.not.be.null;
  expect(response.validationErrorMessage).to.be.a('string');
  expect(response.assetLayouts).to.be.an('array');
  expect(response.assetLayouts.length).to.equal(0);
});
```

### 19. tests/testData/payloads/assetLayoutPayload.json
```json
{
  "messageId": 1234,
  "dealId": 34384,
  "reportDate": "2024-03-31"
}
```
