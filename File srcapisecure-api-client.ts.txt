// File: src/support/hooks.ts
import { Before, After, BeforeStep, AfterStep, BeforeAll, AfterAll, setDefaultTimeout, ITestCaseHookParameter } from '@cucumber/cucumber';
import { Page } from '@playwright/test';
import { TestContext } from './test-context';
import { Logger } from '../framework/utils/logger';
import { BrowserManager } from '../framework/browser-manager';
import { ConfigManager } from '../framework/utils/config-manager';
import path from 'path';
import fs from 'fs';

// Load configuration once at the start
const config = ConfigManager.getInstance();

// Set default timeout asynchronously
(async () => {
  try {
    const defaultTimeout = await config.getNumber('DEFAULT_TIMEOUT', 30000);
    setDefaultTimeout(defaultTimeout);
  } catch (error) {
    console.error('Error setting default timeout:', error);
    setDefaultTimeout(30000); // Fallback to 30 seconds
  }
})();

// Create a BrowserManager instance
const browserManager = BrowserManager.getInstance();

// Before all scenarios
BeforeAll(async function() {
  const globalLogger = new Logger('GlobalSetup');
  globalLogger.info('Starting test execution');
  
  // Ensure report directories exist
  const dirs = ['reports/screenshots', 'reports/videos', 'reports/logs', 'reports/html', 'reports/json'];
  dirs.forEach(dir => {
    const dirPath = path.join(process.cwd(), dir);
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
      globalLogger.info(`Created directory: ${dirPath}`);
    }
  });
  
  // For web tests, initialize the browser once
  try {
    const preLaunchBrowser = process.env.PRELAUNCH_BROWSER === 'true';
    if (preLaunchBrowser) {
      globalLogger.info('Pre-launching browser');
      await browserManager.initialize();
      globalLogger.info('Browser pre-launched successfully');
    }
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    globalLogger.error(`Failed to pre-launch browser: ${errorMessage}`);
  }
});

// After all scenarios
AfterAll(async function() {
  const globalLogger = new Logger('GlobalTeardown');
  globalLogger.info('Finishing test execution');
  
  // Close the browser if it's open
  try {
    await browserManager.closeBrowser();
    globalLogger.info('All resources cleaned up');
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    globalLogger.error(`Error during cleanup: ${errorMessage}`);
  }
});

// Before each scenario
Before(async function(this: TestContext, scenario: ITestCaseHookParameter) {
  this.startTime = Date.now();
  this.scenarioName = scenario.pickle.name;
  this.scenarioTags = scenario.pickle.tags.map(tag => tag.name);
  
  // Create a unique test ID based on scenario name and timestamp
  const testId = `${scenario.pickle.name.replace(/[^a-zA-Z0-9]/g, '-')}-${Date.now()}`;
  
  // Initialize logger with test ID
  this.logger = new Logger(testId);
  this.logger.info(`Starting scenario: ${scenario.pickle.name}`);
  
  // Log tags
  if (this.scenarioTags.length > 0) {
    this.logger.info(`Tags: ${this.scenarioTags.join(', ')}`);
  }
  
  // Create test data object for sharing data between steps
  this.testData = {};
  
  // For UI tests, initialize browser context and page
  if (this.scenarioTags.some(tag => tag === '@web' || tag === '@ui')) {
    this.logger.info('Initializing web test');
    
    try {
      // Create a new context
      const recordVideo = await config.getBoolean('VIDEO_RECORD', false);
      
      const contextOptions: Record<string, any> = {};
      if (recordVideo) {
        contextOptions.recordVideo = {
          dir: 'videos/',
          size: { 
            width: await config.getNumber('VIDEO_WIDTH', 1280), 
            height: await config.getNumber('VIDEO_HEIGHT', 720) 
          }
        };
      }
      
      this.context = await browserManager.createContext(contextOptions);
      
      // Add ability to set breakpoints if needed
      if (process.env.DEBUG === 'true') {
        this.context.setDefaultTimeout(0); // No timeout during debugging
      }
      
      // Create a new page
      this.page = await this.context.newPage();
      this.logger.info('Browser context and page initialized');
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(`Failed to initialize browser: ${errorMessage}`);
      throw error;
    }
  } 
  // For API tests, we don't need browser initialization
  else if (this.scenarioTags.some(tag => tag === '@api')) {
    this.logger.info('Initializing API test');
    // API clients will be initialized in step definitions when needed
  }
});

// Before each step
BeforeStep(async function(this: TestContext) {
  if (this.logger) {
    try {
      // Get current step from Cucumber context if available
      const stepText = this.currentStep?.text || 'unknown step';
      this.logger.info(`Executing step: ${stepText}`);
    } catch (error: unknown) {
      console.error('Error logging step execution:', error);
    }
  }
});

// After each step - fix for the signature issue
AfterStep(function(this: TestContext) {
  // The hook will receive the world instance (this) as the first parameter
  return async (result: any) => {
    if (this.logger) {
      try {
        const stepText = result?.pickleStep?.text || 'unknown step';
        
        if (result?.status === 'PASSED') {
          this.logger.info(`Step passed: ${stepText}`);
        } else if (result?.status === 'FAILED') {
          this.logger.error(`Step failed: ${stepText}`);
          if (result.error) {
            this.logger.error(`Error: ${result.error.message}`);
          }
          
          // For UI tests, take a screenshot on failure
          if (this.page) {
            try {
              const screenshotName = `failed-${this.scenarioName?.replace(/[^a-zA-Z0-9]/g, '-')}-${Date.now()}`;
              const screenshotPath = `./reports/screenshots/${screenshotName}.png`;
              const screenshot = await this.page.screenshot({ 
                path: screenshotPath,
                fullPage: true 
              });
              this.logger.info(`Screenshot captured: ${screenshotPath}`);
              if (this.attach) {
                this.attach(screenshot, 'image/png');
              }
            } catch (error: unknown) {
              const errorMessage = error instanceof Error ? error.message : 'Unknown error';
              this.logger.error(`Failed to take screenshot: ${errorMessage}`);
            }
          }
        }
      } catch (error: unknown) {
        console.error('Error processing step result:', error);
      }
    }
  };
});

// After each scenario
After(async function(this: TestContext, scenario: ITestCaseHookParameter) {
  this.endTime = Date.now();
  const executionTime = this.endTime - (this.startTime || this.endTime);
  
  // Store result status for use in clean-up
  this.result = { status: scenario.result?.status || 'UNKNOWN' };
  
  // Log scenario result
  if (this.logger) {
    this.logger.info(`Scenario ${this.result.status}: ${scenario.pickle.name} (${executionTime}ms)`);
  }
  
  // Generic cleanup for browser resources
  if (this.page && this.context) {
    try {
      // Close context (and associated page)
      this.logger.info('Closing browser context');
      await browserManager.closeContext(this.context);
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      if (this.logger) {
        this.logger.error(`Error closing browser context: ${errorMessage}`);
      }
    }
  }
  
  // Add logs to Cucumber report
  if (this.logger && this.attach) {
    const logs = this.logger.getLogs();
    if (logs.length > 0) {
      try {
        this.attach(logs.join('\n'), 'text/plain');
      } catch (error: unknown) {
        console.error('Error attaching logs:', error);
      }
    }
  }
  
  // Explicitly clean up references to help garbage collection
  delete this.page;
  delete this.context;
});
