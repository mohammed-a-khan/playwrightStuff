/**
 * Types for method parameter
 */
interface MethodParam {
  type: string;
  name: string;
}

/**
 * Types for tokenized constructor args
 */
interface Token {
  type: 'string' | 'parameter' | 'unknown';
  value?: string;
  name?: string;
}

/**
 * Types for parameter context
 */
interface ParameterContext {
  type: 'position' | 'text' | 'contains' | 'other';
  replacement: string;
}

/**
 * Result of XPath reconstruction
 */
interface XPathReconstructResult {
  xpath: string;
  paramPositions: Record<string, number>;
}

/**
 * Extract dynamic locator from constructor args
 */
function extractDynamicLocator(constructorArgs: string, methodBody: string, paramsList: MethodParam[]): string {
  if (DEBUG) {
    console.log("Processing: ", constructorArgs);
  }
  
  // Step 1: Analyze and tokenize the constructor args to identify XPath parts and parameters
  const tokens = tokenizeConstructorArgs(constructorArgs);
  
  if (DEBUG) {
    console.log("Tokenized constructor args:", tokens);
  }
  
  // Step 2: Extract the XPath from the tokens
  const { xpath, paramPositions } = reconstructXPathFromTokens(tokens, paramsList);
  
  if (DEBUG) {
    console.log("Reconstructed XPath:", xpath);
    console.log("Parameter positions:", paramPositions);
  }
  
  // Step 3: Analyze the context of each parameter to determine substitution pattern
  const parameterContexts = analyzeParameterContexts(constructorArgs, paramsList);
  
  if (DEBUG) {
    console.log("Parameter contexts:", parameterContexts);
  }
  
  // Step 4: Substitute parameters in the XPath
  let finalXPath = substituteParametersInXPath(xpath, paramPositions, parameterContexts, paramsList);
  
  if (DEBUG) {
    console.log("Final XPath:", finalXPath);
  }
  
  // If we didn't extract anything useful, return a placeholder
  if (!finalXPath || finalXPath.trim() === '') {
    return `//TODO-${paramsList.map(p => p.name).join('-')}`;
  }
  
  return finalXPath;
}

/**
 * Tokenize constructor args to separate string literals and parameters
 */
function tokenizeConstructorArgs(constructorArgs: string): Token[] {
  const tokens: Token[] = [];
  
  // Clean up the constructor args first
  const cleanArgs = constructorArgs
    .replace(/\\"/g, '"')  // Replace escaped quotes
    .replace(/\s+/g, ' '); // Normalize whitespace
  
  // Split by string concatenation operator
  const parts = cleanArgs.split('+').map(p => p.trim());
  
  for (let part of parts) {
    // Remove surrounding quotes from string literals
    if ((part.startsWith('"') && part.endsWith('"')) || 
        (part.startsWith("'") && part.endsWith("'"))) {
      tokens.push({
        type: 'string',
        value: part.substring(1, part.length - 1)
      });
    } 
    // Parameters (not surrounded by quotes)
    else if (part && !part.includes('"') && !part.includes("'")) {
      tokens.push({
        type: 'parameter',
        name: part
      });
    }
    // Complex parts might have partial quotes or other structures
    else if (part) {
      // Try to extract any useful content
      const quoteMatch = part.match(/["']([^"']+)["']/);
      if (quoteMatch) {
        tokens.push({
          type: 'string',
          value: quoteMatch[1]
        });
      } else {
        tokens.push({
          type: 'unknown',
          value: part
        });
      }
    }
  }
  
  return tokens;
}

/**
 * Reconstruct the XPath from tokenized constructor args
 */
function reconstructXPathFromTokens(tokens: Token[], paramsList: MethodParam[]): XPathReconstructResult {
  let xpath = "";
  const paramPositions: Record<string, number> = {};
  let inXPath = false;
  
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    
    // Start of XPath marker
    if (token.type === 'string' && token.value && token.value.includes('xpath=') && !inXPath) {
      inXPath = true;
      const xpathStart = token.value.substring(token.value.indexOf('xpath=') + 6);
      xpath += xpathStart;
      continue;
    }
    
    // End of XPath marker
    if (inXPath && token.type === 'string' && token.value && 
        (token.value.includes('","desc"') || token.value.includes('"}'))) {
      // Extract up to the marker
      const endMarkers = ['","desc"', '"}'];
      for (const marker of endMarkers) {
        if (token.value.includes(marker)) {
          xpath += token.value.substring(0, token.value.indexOf(marker));
          inXPath = false;
          break;
        }
      }
      continue;
    }
    
    // Parameter token in XPath
    if (inXPath && token.type === 'parameter' && token.name) {
      // Verify this is a valid parameter
      const param = paramsList.find(p => p.name === token.name);
      if (param) {
        // Store parameter position
        paramPositions[param.name] = xpath.length;
        
        // Next and previous tokens might give context
        const prevToken = i > 0 ? tokens[i-1] : null;
        const nextToken = i < tokens.length - 1 ? tokens[i+1] : null;
        
        // Add placeholder based on context
        if (prevToken && prevToken.type === 'string' && prevToken.value && 
            prevToken.value.includes('position()=')) {
          xpath += "POSITION_PARAM";
        } 
        else if (prevToken && prevToken.type === 'string' && prevToken.value && 
                prevToken.value.includes('text()=\'')) {
          xpath += "TEXT_PARAM";
        }
        else if (prevToken && prevToken.type === 'string' && prevToken.value && 
                prevToken.value.includes('contains(')) {
          xpath += "CONTAINS_PARAM";
        }
        else {
          // Generic placeholder based on type
          xpath += param.type === 'int' || param.type === 'Integer' ? "NUMERIC_PARAM" : "STRING_PARAM";
        }
      }
      continue;
    }
    
    // Regular string token in XPath
    if (inXPath && token.type === 'string' && token.value) {
      xpath += token.value;
    }
  }
  
  return { xpath, paramPositions };
}

/**
 * Analyze parameters to determine their context in the XPath
 */
function analyzeParameterContexts(constructorArgs: string, paramsList: MethodParam[]): Record<string, ParameterContext> {
  const contexts: Record<string, ParameterContext> = {};
  
  for (const param of paramsList) {
    // Different context detection strategies based on parameter type
    if (param.type === 'int' || param.type === 'Integer' || param.type === 'number') {
      // Check for position() usage
      if (constructorArgs.includes(`position()="+${param.name}+"`)) {
        contexts[param.name] = {
          type: 'position',
          replacement: `\${${param.name}}`
        };
      }
    }
    
    if (param.type === 'String' || param.type === 'string') {
      // Check for text() usage
      if (constructorArgs.includes(`text()='"+${param.name}+"'`)) {
        contexts[param.name] = {
          type: 'text',
          replacement: `\${${param.name}}`
        };
      }
      // Check for contains() usage
      else if (constructorArgs.includes(`contains(`) && 
               constructorArgs.includes(`${param.name}`)) {
        contexts[param.name] = {
          type: 'contains',
          replacement: `\${${param.name}}`
        };
      }
      else {
        contexts[param.name] = {
          type: 'other',
          replacement: `\${${param.name}}`
        };
      }
    }
  }
  
  return contexts;
}

/**
 * Substitute parameters in the XPath using intelligent pattern matching
 */
function substituteParametersInXPath(
  xpath: string, 
  paramPositions: Record<string, number>,
  contexts: Record<string, ParameterContext>, 
  paramsList: MethodParam[]
): string {
  let result = xpath;
  
  // Track parameters we've already processed
  const processedParams = new Set<string>();
  
  // First pass: Use specific context replacements
  for (const param of paramsList) {
    if (param.name in contexts) {
      const context = contexts[param.name];
      
      switch (context.type) {
        case 'position':
          // Replace position()=X with position()=${param}
          result = result.replace(/position\(\)\s*=\s*(POSITION_PARAM|NUMERIC_PARAM|\d+)/g, 
                                 `position()=\${${param.name}}`);
          processedParams.add(param.name);
          break;
          
        case 'text':
          // Replace text()='X' with text()='${param}'
          result = result.replace(/text\(\)\s*=\s*['"]?(TEXT_PARAM|STRING_PARAM|[^'"]+)['"]?/g, 
                                 `text()='\${${param.name}}'`);
          processedParams.add(param.name);
          break;
          
        case 'contains':
          // Replace contains(..., 'X') with contains(..., '${param}')
          const containsPattern = /contains\([^,]+,\s*['"]?(CONTAINS_PARAM|STRING_PARAM|[^'"]+)['"]?\)/g;
          if (containsPattern.test(result)) {
            result = result.replace(containsPattern, (match) => {
              return match.replace(/['"]?(CONTAINS_PARAM|STRING_PARAM|[^'"]+)['"]?/, `'\${${param.name}}'`);
            });
            processedParams.add(param.name);
          }
          break;
      }
    }
  }
  
  // Second pass: Generic replacements for remaining parameters
  for (const param of paramsList) {
    if (processedParams.has(param.name)) continue;
    
    if (param.type === 'int' || param.type === 'Integer' || param.type === 'number') {
      // Try to replace any position-like pattern
      if (result.includes("POSITION_PARAM")) {
        result = result.replace("POSITION_PARAM", `\${${param.name}}`);
        processedParams.add(param.name);
        continue;
      }
      if (result.includes("NUMERIC_PARAM")) {
        result = result.replace("NUMERIC_PARAM", `\${${param.name}}`);
        processedParams.add(param.name);
        continue;
      }
    }
    
    if (param.type === 'String' || param.type === 'string') {
      // Try to replace any text-like pattern
      if (result.includes("TEXT_PARAM")) {
        result = result.replace("TEXT_PARAM", `\${${param.name}}`);
        processedParams.add(param.name);
        continue;
      }
      if (result.includes("STRING_PARAM")) {
        result = result.replace("STRING_PARAM", `\${${param.name}}`);
        processedParams.add(param.name);
        continue;
      }
      if (result.includes("CONTAINS_PARAM")) {
        result = result.replace("CONTAINS_PARAM", `\${${param.name}}`);
        processedParams.add(param.name);
        continue;
      }
    }
  }
  
  // Final cleanup of any remaining placeholders
  result = result
    .replace(/POSITION_PARAM/g, "1")
    .replace(/NUMERIC_PARAM/g, "1")
    .replace(/TEXT_PARAM/g, "value")
    .replace(/STRING_PARAM/g, "value")
    .replace(/CONTAINS_PARAM/g, "value");
  
  return result;
}
