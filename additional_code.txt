import * as fs from 'fs';
import * as path from 'path';
import { Command } from 'commander';

/**
 * Comprehensive QAF to Playwright Parser
 * This parser handles conversion from QAF Selenium Java to Playwright TypeScript
 */
class QafToPlaywrightParser {
  private filesProcessed = 0;
  private elementsConverted = 0;
  private methodsConverted = 0;
  private stepsConverted = 0;

  /**
   * Convert a single Java file to TypeScript
   */
  public convertFile(inputPath: string, outputPath: string): void {
    try {
      console.log(`Processing: ${inputPath}`);
      
      // Read the file content
      const content = fs.readFileSync(inputPath, 'utf8');
      let result = '';
      
      // Process the content
      result = this.processContent(content);
      
      // Ensure output directory exists
      const outputDir = path.dirname(outputPath);
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }
      
      // Write the output file
      fs.writeFileSync(outputPath, result);
      this.filesProcessed++;
      
      console.log(`Converted: ${outputPath}`);
    } catch (error) {
      console.error(`Error processing file ${inputPath}:`, error);
    }
  }

  /**
   * Process the content of a Java file
   */
  private processContent(content: string): string {
    // Add TypeScript imports
    let result = "import { Page, Locator, expect } from '@playwright/test';\n\n";
    
    // Remove comments
    content = this.removeComments(content);
    
    // Remove package and import statements
    content = this.removePackageAndImports(content);
    
    // Process class definition
    const { className, processedContent } = this.processClassDefinition(content);
    content = processedContent;
    
    if (className) {
      result += `export class ${className} {\n`;
      result += `  constructor(private page: Page) {}\n\n`;
    } else {
      result += `export class PageObject {\n`;
      result += `  constructor(private page: Page) {}\n\n`;
    }
    
    // Process @FindBy declarations with clean content
    content = this.processFindByDeclarations(content);
    
    // Process method-style element declarations
    content = this.processMethodStyleDeclarations(content);
    
    // Process step definitions
    content = this.processStepDefinitions(content);
    
    // Additional clean-up for any remaining Java elements
    content = this.cleanupRemainingJavaElements(content);
    
    // Add processed content to result
    result += content;
    
    // Close the class
    result += '}\n';
    
    return result;
  }

  /**
   * Remove comments from the code
   */
  private removeComments(content: string): string {
    // Remove single line comments
    let result = content.replace(/\/\/.*$/gm, '');
    
    // Remove multi-line comments
    result = result.replace(/\/\*[\s\S]*?\*\//g, '');
    
    return result;
  }

  /**
   * Remove package and import statements
   */
  private removePackageAndImports(content: string): string {
    // Remove package declarations
    let result = content.replace(/package\s+[\w.]+;/g, '');
    
    // Remove import statements
    result = result.replace(/import\s+[\w.]+(?:\.\*)?;/g, '');
    
    return result;
  }

  /**
   * Process class definition
   */
  private processClassDefinition(content: string): { className: string | null, processedContent: string } {
    const classMatch = content.match(/public\s+class\s+(\w+)(?:\s+extends\s+(\w+))?\s*\{/);
    
    if (classMatch) {
      const className = classMatch[1];
      const baseClassName = classMatch[2] || null;
      
      let processedContent = content.replace(
        /public\s+class\s+(\w+)(?:\s+extends\s+(\w+))?\s*\{/,
        ''
      );
      
      // Remove the closing brace of the class
      const lastBraceIndex = processedContent.lastIndexOf('}');
      if (lastBraceIndex !== -1) {
        processedContent = processedContent.substring(0, lastBraceIndex);
      }
      
      return { className, processedContent };
    }
    
    return { className: null, processedContent: content };
  }

  /**
   * Process @FindBy declarations - completely revamped to handle complex cases
   */
  private processFindByDeclarations(content: string): string {
    // Process line by line to handle complex multi-line declarations
    const lines = content.split('\n');
    const processedLines: string[] = [];
    
    let i = 0;
    while (i < lines.length) {
      const line = lines[i].trim();
      
      // Check if line contains @FindBy
      if (line.includes('@FindBy')) {
        // Start collecting the full declaration that may span multiple lines
        let fullDeclaration = line;
        let j = i + 1;
        
        // Keep collecting lines until we find one with a semicolon
        while (j < lines.length && !lines[j].includes(';')) {
          fullDeclaration += ' ' + lines[j].trim();
          j++;
        }
        
        // Include the line with semicolon
        if (j < lines.length) {
          fullDeclaration += ' ' + lines[j].trim();
        }
        
        // Now we have the full multi-line declaration
        const convertedLine = this.convertFindByToLocator(fullDeclaration);
        if (convertedLine) {
          processedLines.push(convertedLine);
          this.elementsConverted++;
        } else {
          // If conversion failed, keep original lines
          processedLines.push(line);
          for (let k = i + 1; k <= j; k++) {
            if (k < lines.length) {
              processedLines.push(lines[k]);
            }
          }
        }
        
        // Skip ahead to after the semicolon
        i = j + 1;
      } else {
        processedLines.push(lines[i]);
        i++;
      }
    }
    
    return processedLines.join('\n');
  }

  /**
   * Convert @FindBy annotation to Playwright locator - completely new approach
   */
  private convertFindByToLocator(declaration: string): string | null {
    // First, extract the element name from CSWebElement declaration
    const elementMatch = declaration.match(/\b(?:private|public|protected)?\s*CSWebElement\s+(\w+)\s*;/);
    if (!elementMatch) {
      return null;
    }
    
    const elementName = elementMatch[1];
    
    // Handle complex quote escaping in locator strings
    let locatorValue: string | null = null;
    let locatorType: string | null = null;
    
    // Try to match different locator formats
    
    // Format 1: @FindBy(locator="xpath=//div[@id='something']")
    const simpleLocatorMatch = declaration.match(/@FindBy\s*\(\s*locator\s*=\s*"([^"]*?)"\s*\)/);
    if (simpleLocatorMatch) {
      locatorValue = simpleLocatorMatch[1];
    }
    
    // Format 2: @FindBy(locator="{\"locator\":\"xpath=//div[@id='something']\"}")
    const jsonLocatorMatch = declaration.match(/@FindBy\s*\(\s*locator\s*=\s*"(\{.*?\"locator\"(?:\\"|:|\")\s*\"(.*?)\".*?\})"\s*\)/);
    if (jsonLocatorMatch) {
      locatorValue = jsonLocatorMatch[2];
    }
    
    // Format 3: @FindBy(locator="\"locator\":\"xpath=//div[@id='something']\"")
    const nestedQuotesMatch = declaration.match(/@FindBy\s*\(\s*locator\s*=\s*"\\+"locator\\+"(?:\\"|:)\\+"(.*?)\\+"\s*\)/);
    if (nestedQuotesMatch) {
      locatorValue = nestedQuotesMatch[1];
    }
    
    // If we couldn't extract a locator value, try a more general approach
    if (!locatorValue) {
      // Look for any pattern that might contain xpath=, css=, or id=
      const generalMatch = declaration.match(/(?:xpath|css|id)=([^"']+?)(?:\\"|\\',|\s|"|')/);
      if (generalMatch) {
        locatorValue = generalMatch[0];
      }
    }
    
    // If we still couldn't extract, return null
    if (!locatorValue) {
      return null;
    }
    
    // Determine locator type
    if (locatorValue.includes('xpath=')) {
      locatorType = 'xpath';
      locatorValue = locatorValue.replace('xpath=', '');
    } else if (locatorValue.includes('css=')) {
      locatorType = 'css';
      locatorValue = locatorValue.replace('css=', '');
    } else if (locatorValue.includes('id=')) {
      locatorType = 'id';
      locatorValue = locatorValue.replace('id=', '');
    } else {
      // Default to CSS if no prefix is found
      locatorType = 'css';
    }
    
    // Clean up the locator value - remove any escaped quotes
    locatorValue = locatorValue.replace(/\\"/g, '"').replace(/\\'/g, "'");
    
    // Create the Playwright locator
    if (locatorType === 'xpath') {
      return `  private readonly ${elementName} = this.page.locator('xpath=${locatorValue}');`;
    } else if (locatorType === 'id') {
      return `  private readonly ${elementName} = this.page.locator('#${locatorValue}');`;
    } else {
      return `  private readonly ${elementName} = this.page.locator('${locatorValue}');`;
    }
  }

  /**
   * Process method-style element declarations with improved regex
   */
  private processMethodStyleDeclarations(content: string): string {
    const lines = content.split('\n');
    let processedLines: string[] = [];
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      // Check for method-style declarations with CSWebElement return type
      if ((line.includes('public CSWebElement') || line.includes('private CSWebElement') || 
           line.includes('protected CSWebElement')) && line.includes('(')) {
        
        // Collect the entire method
        let methodDeclaration = line;
        let braceCount = line.split('{').length - line.split('}').length;
        let j = i + 1;
        
        while (j < lines.length && braceCount > 0) {
          methodDeclaration += '\n' + lines[j];
          braceCount += lines[j].split('{').length - lines[j].split('}').length;
          j++;
        }
        
        // Process the method declaration
        const processedMethod = this.processMethodDeclaration(methodDeclaration);
        processedLines.push(processedMethod);
        
        // Skip the lines we've already processed
        i = j - 1;
      } else {
        processedLines.push(line);
      }
    }
    
    return processedLines.join('\n');
  }

  /**
   * Process a single method-style declaration with improved pattern matching
   */
  private processMethodDeclaration(declaration: string): string {
    // Extract method name and parameter name with improved pattern
    const methodInfoMatch = declaration.match(/(?:public|private|protected)\s+CSWebElement\s+(\w+)\s*\(\s*String\s+(\w+)(?:\s*,\s*[^)]*?)?\s*\)/);
    if (!methodInfoMatch) {
      return declaration; // Keep as is if no match
    }
    
    const methodName = methodInfoMatch[1];
    const paramName = methodInfoMatch[2];
    
    // Look for the return statement with locator with more flexible pattern
    const returnMatches = declaration.match(/return\s+(?:.*?)(?:new\s+CSWebElement\s*\(\s*"(.*?)"\s*\)|new\s+CSWebElement\s*\(\s*(.*?)\s*\))/s);
    if (!returnMatches) {
      return declaration; // Keep as is if no return line found
    }
    
    // Try to extract the locator expression
    const locatorExpression = returnMatches[1] || returnMatches[2];
    
    // Try to determine if it's an xpath, css, or id locator
    let locatorType = 'xpath'; // Default to xpath
    let locatorTemplate = '';
    
    if (locatorExpression.includes('xpath=')) {
      locatorType = 'xpath';
      
      // Try to extract the pattern with parameter
      const xpathMatch = locatorExpression.match(/xpath=([^']+?)'(?:\s*\+\s*(\w+)\s*\+\s*'([^']*?))?/);
      if (xpathMatch) {
        if (xpathMatch[2] === paramName) {
          // We have a parameterized xpath
          const prefix = xpathMatch[1] || '';
          const suffix = xpathMatch[3] || '';
          locatorTemplate = `xpath=${prefix}\${${paramName}}${suffix}`;
        } else {
          // Non-parameterized xpath
          locatorTemplate = `xpath=${locatorExpression.replace('xpath=', '')}`;
        }
      } else {
        // Fallback for xpath
        locatorTemplate = `xpath=${locatorExpression.replace('xpath=', '')}`;
      }
    } else if (locatorExpression.includes('css=')) {
      locatorType = 'css';
      // Similar pattern for CSS
      locatorTemplate = locatorExpression.replace('css=', '');
    } else if (locatorExpression.includes('id=')) {
      locatorType = 'id';
      // Format for ID selector
      locatorTemplate = `#${locatorExpression.replace('id=', '')}`;
    } else {
      // Try to guess from the context if no explicit prefix
      if (locatorExpression.includes("//")) {
        locatorType = 'xpath';
        locatorTemplate = `xpath=${locatorExpression}`;
      } else {
        locatorType = 'css';
        locatorTemplate = locatorExpression;
      }
    }
    
    // Check if the locator uses parameter interpolation
    const hasInterpolation = locatorExpression.includes(paramName);
    
    // Create the Playwright locator method
    this.methodsConverted++;
    
    if (hasInterpolation) {
      return `  private ${methodName} = (${paramName}: string): Locator => this.page.locator(\`${locatorTemplate}\`);`;
    } else {
      return `  private ${methodName} = (${paramName}: string): Locator => this.page.locator('${locatorTemplate}');`;
    }
  }

  /**
   * Process step definitions
   */
  private processStepDefinitions(content: string): string {
    const lines = content.split('\n');
    let processedLines: string[] = [];
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      // Check if line might be the start of a step definition
      if (line.includes('@QAFTestStep')) {
        // Collect the entire step definition
        let stepDeclaration = line;
        let j = i + 1;
        
        // Look for the method declaration line
        while (j < lines.length && !lines[j].includes('public void')) {
          stepDeclaration += '\n' + lines[j];
          j++;
        }
        
        // Add the method declaration line
        if (j < lines.length) {
          stepDeclaration += '\n' + lines[j];
        }
        
        // Now collect the method body
        let braceCount = stepDeclaration.split('{').length - stepDeclaration.split('}').length;
        j++;
        
        while (j < lines.length && braceCount > 0) {
          stepDeclaration += '\n' + lines[j];
          braceCount += lines[j].split('{').length - lines[j].split('}').length;
          j++;
        }
        
        // Process the step definition
        const processedStep = this.processStepDefinition(stepDeclaration);
        processedLines.push(processedStep);
        
        // Skip the lines we've already processed
        i = j - 1;
      } else {
        processedLines.push(line);
      }
    }
    
    return processedLines.join('\n');
  }

  /**
   * Process a single step definition with improved parameter handling
   */
  private processStepDefinition(declaration: string): string {
    // Extract step description with improved pattern
    const descriptionMatch = declaration.match(/@QAFTestStep\s*\(\s*(?:description\s*=\s*|injectableProcessor\s*=\s*(?:.*?),\s*description\s*=\s*)"([^"]*)"/);
    if (!descriptionMatch) {
      return declaration; // Keep as is if no match
    }
    
    const description = descriptionMatch[1];
    
    // Extract method name and parameters
    const methodMatch = declaration.match(/public\s+void\s+(\w+)\s*\(([^)]*)\)/);
    if (!methodMatch) {
      return declaration; // Keep as is if no match
    }
    
    const methodName = methodMatch[1];
    const paramsList = methodMatch[2];
    
    // Process parameters with improved type conversion
    let processedParams = '';
    let paramTypes: string[] = [];
    
    if (paramsList && paramsList.trim()) {
      const params = paramsList.split(',');
      processedParams = params
        .map(param => {
          const parts = param.trim().split(/\s+/);
          const paramType = parts[0];
          const paramName = parts[parts.length - 1];
          
          // Store the parameter type for later use
          paramTypes.push(paramType);
          
          // Convert Java types to TypeScript types
          let tsType = '';
          switch (paramType) {
            case 'String':
              tsType = 'string';
              break;
            case 'int':
            case 'Integer':
            case 'double':
            case 'float':
            case 'Double':
            case 'Float':
              tsType = 'number';
              break;
            case 'boolean':
            case 'Boolean':
              tsType = 'boolean';
              break;
            default:
              tsType = 'any';
          }
          
          return `${paramName}: ${tsType}`;
        })
        .join(', ');
    }
    
    // Determine step type based on description
    let stepType = 'Given';
    if (description.toLowerCase().startsWith('when')) {
      stepType = 'When';
    } else if (description.toLowerCase().startsWith('then')) {
      stepType = 'Then';
    }
    
    // Extract method body
    const bodyMatch = declaration.match(/\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)?\}/s);
    if (!bodyMatch) {
      return declaration; // Keep as is if no match
    }
    
    let body = bodyMatch[1] || '';
    
    // Convert common method calls
    body = body
      .replace(/\.sendKeys\(/g, '.fill(')
      .replace(/\.click\(\)/g, '.click()')
      .replace(/\.isDisplayed\(\)/g, '.isVisible()')
      .replace(/Assert\.assertTrue\(([^)]+)\.isDisplayed\(\)\)/g, 'await expect($1).toBeVisible()')
      .replace(/Assert\.assertTrue\(([^)]+)\)/g, 'expect($1).toBeTruthy()')
      .replace(/Assert\.assertEquals\(([^,]+),\s*([^)]+)\)/g, 'expect($1).toEqual($2)');
    
    // Add await to common method calls if not already there
    body = body.replace(/(?<!await\s+)(\w+)\.(click|type|fill|check|uncheck|selectOption|press)\(/g, 'await $1.$2(');
    
    // Replace any remaining CSWebElement references
    body = body.replace(/CSWebElement/g, 'Locator');
    
    // Prepare the result
    let result = `  /**\n   * ${description}\n   */\n  async ${methodName}(${processedParams}) {\n`;
    
    // Clean up body lines and add them
    body.split('\n').forEach(line => {
      if (line.trim()) {
        result += `    ${line.trim()}\n`;
      }
    });
    
    result += '  }';
    this.stepsConverted++;
    
    return result;
  }

  /**
   * Clean up any remaining Java elements that might have been missed
   */
  private cleanupRemainingJavaElements(content: string): string {
    let result = content;
    
    // Replace any remaining annotations
    result = result.replace(/@FindBy\s*\([^)]*\)/g, '');
    result = result.replace(/@QAFTestStep\s*\([^)]*\)/g, '');
    
    // Replace any remaining CSWebElement declarations
    result = result.replace(/(?:public|private|protected)?\s*CSWebElement\s+(\w+)\s*;/g, 
                          '  private readonly $1 = this.page.locator(\'xpath=//MISSING_LOCATOR\'); // TODO: Add correct locator');
    
    // Replace Java-style modifiers
    result = result.replace(/\b(?:public|private|protected)\s+/g, '  ');
    
    // Replace void return type
    result = result.replace(/\bvoid\s+/g, '');
    
    // Clean up blank lines and fix indentation
    const lines = result.split('\n');
    const cleanedLines = lines
      .filter(line => line.trim() !== '')
      .map(line => {
        if (line.trim() === '') return '';
        // Fix indentation by ensuring each non-empty line has at least 2 spaces
        if (!line.startsWith('  ') && !line.startsWith('\t')) {
          return '  ' + line.trim();
        }
        return line;
      });
    
    return cleanedLines.join('\n');
  }

  /**
   * Process a directory of Java files
   */
  public processDirectory(inputDir: string, outputDir: string): void {
    try {
      // Get all Java files
      const files = this.getJavaFiles(inputDir);
      console.log(`Found ${files.length} Java files to process`);
      
      // Create output directory if it doesn't exist
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }
      
      // Process each file
      for (const file of files) {
        const relativePath = path.relative(inputDir, file);
        const outputPath = path.join(outputDir, relativePath.replace('.java', '.ts'));
        this.convertFile(file, outputPath);
      }
      
      console.log('\nConversion completed successfully!');
      console.log(`Files processed: ${this.filesProcessed}`);
      console.log(`Elements converted: ${this.elementsConverted}`);
      console.log(`Methods converted: ${this.methodsConverted}`);
      console.log(`Steps converted: ${this.stepsConverted}`);
    } catch (error) {
      console.error('Error processing directory:', error);
    }
  }

  /**
   * Get all Java files in a directory and its subdirectories
   */
  private getJavaFiles(dir: string): string[] {
    const files: string[] = [];
    
    try {
      const items = fs.readdirSync(dir);
      
      for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory()) {
          files.push(...this.getJavaFiles(fullPath));
        } else if (item.endsWith('.java')) {
          files.push(fullPath);
        }
      }
    } catch (error) {
      console.error(`Error reading directory ${dir}:`, error);
    }
    
    return files;
  }
}

// Set up command-line interface
const program = new Command();

program
  .name('qaf-to-playwright')
  .description('Comprehensive converter for QAF Java code to Playwright TypeScript')
  .version('1.0.0')
  .requiredOption('-i, --input <directory>', 'Input directory containing QAF Java files')
  .requiredOption('-o, --output <directory>', 'Output directory for Playwright TypeScript files')
  .action(async (options) => {
    try {
      console.log('\n🔄 QAF to Playwright Converter');
      console.log('============================');
      
      console.log(`Input directory: ${options.input}`);
      console.log(`Output directory: ${options.output}`);
      console.log('----------------------------');
      
      const parser = new QafToPlaywrightParser();
      parser.processDirectory(options.input, options.output);
      
    } catch (error) {
      console.error('❌ Conversion failed:', error);
      process.exit(1);
    }
  });

program.parse();
