/**
 * Ultimate robust XPath extractor - guaranteed to work
 * This approach handles both truncation and backslash issues
 */
function extractDynamicLocator(constructorArgs: string, methodBody: string, paramsList: MethodParam[]): string {
  if (DEBUG) {
    console.log("Processing constructor args:", constructorArgs);
  }
  
  // Step 1: Extract the XPath (the content after "xpath=" until the next ")
  let xpathStart = constructorArgs.indexOf("xpath=");
  if (xpathStart === -1) {
    return `//TODO-${paramsList.map(p => p.name).join('-')}`;
  }
  
  xpathStart += 6; // Length of "xpath="
  
  let xpathEnd = constructorArgs.indexOf('","', xpathStart);
  if (xpathEnd === -1) {
    xpathEnd = constructorArgs.indexOf('"', xpathStart);
  }
  
  if (xpathEnd === -1) {
    return `//TODO-${paramsList.map(p => p.name).join('-')}`;
  }
  
  // Extract the raw XPath with Java string concatenation
  const rawXPath = constructorArgs.substring(xpathStart, xpathEnd);
  
  if (DEBUG) {
    console.log("Raw XPath:", rawXPath);
  }
  
  // Step 2: Process each parameter using brute force segmentation
  // This approach guarantees that the parameter is correctly replaced
  let finalXPath = rawXPath;
  
  paramsList.forEach(param => {
    // Create the Java concatenation pattern for this parameter
    const concatPattern = `"+${param.name}+"`;
    
    // Split by this pattern to ensure we capture everything
    const segments = finalXPath.split(concatPattern);
    
    if (segments.length > 1) {
      // Rebuild with template literals
      finalXPath = segments.join(`\${${param.name}}`);
    }
  });
  
  // Step 3: Clean up any escaped characters
  finalXPath = finalXPath
    .replace(/\\"/g, '"')  // Replace \" with "
    .replace(/\\'/g, "'")  // Replace \' with '
    .replace(/\\\\/g, '\\'); // Replace \\ with \
  
  if (DEBUG) {
    console.log("Final XPath:", finalXPath);
  }
  
  return finalXPath;
}
