#!/usr/bin/env node

import * as fs from 'fs';
import * as path from 'path';
import { Command } from 'commander';

/**
 * Simplified QAF to Playwright Converter
 * Focuses on handling the specific patterns mentioned in requirements
 */
class SimplifiedQafConverter {
  /**
   * Convert a QAF Java file to Playwright TypeScript
   */
  convertFile(inputPath: string, outputPath: string): void {
    try {
      // Read the input file
      let content = fs.readFileSync(inputPath, 'utf8');
      
      // Apply conversions
      content = this.convertFindByLocators(content);
      content = this.convertMethodLocators(content);
      content = this.convertStepDefinitions(content);
      content = this.performCleanup(content);
      
      // Create output directory if it doesn't exist
      const outputDir = path.dirname(outputPath);
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }
      
      // Write the output file
      fs.writeFileSync(outputPath, content);
      console.log(`Converted ${inputPath} to ${outputPath}`);
    } catch (error) {
      console.error(`Error converting file ${inputPath}:`, error);
    }
  }
  
  /**
   * Convert @FindBy locators to Playwright locators
   */
  convertFindByLocators(content: string): string {
    // First, handle the JSON format locators
    content = content.replace(
      /@FindBy\s*\(\s*locator\s*=\s*"\{\s*\"locator\"\s*:\s*\"([^"]+)\"\s*,\s*\"desc\"\s*:\s*\"[^"]*\"\s*\}"\s*\)\s*(?:public\s+)?(?:CSWebElement|WebElement)\s+(\w+)/g,
      (match, locator, elementName) => {
        return `private readonly ${elementName} = ${this.formatLocator(locator)}`;
      }
    );
    
    // Then, handle the simple format locators
    content = content.replace(
      /@FindBy\s*\(\s*locator\s*=\s*"([^"]+)"\s*\)\s*(?:public\s+)?(?:CSWebElement|WebElement)\s+(\w+)/g,
      (match, locator, elementName) => {
        return `private readonly ${elementName} = ${this.formatLocator(locator)}`;
      }
    );
    
    return content;
  }
  
  /**
   * Convert method-style locator declarations
   */
  convertMethodLocators(content: string): string {
    // Handle method locators with JSON format
    content = content.replace(
      /public\s+(?:CSWebElement|WebElement)\s+(\w+)\s*\(\s*String\s+(\w+)\s*\)\s*\{\s*return\s+new\s+(?:CSWebElement|WebElement)\s*\(\s*"\{\s*\"locator\"\s*:\s*\"([^"]+)'\s*\+\s*(\w+)\s*\+\s*'([^"]+)\"\s*,\s*\"desc\"\s*:\s*\"[^"]*\"\s*\}"\s*\)\s*;\s*\}/g,
      (match, methodName, paramName, locatorPrefix, paramRef, locatorSuffix) => {
        return `private ${methodName} = (${paramName}: string) => \`${locatorPrefix}\${${paramName}}${locatorSuffix}\``;
      }
    );
    
    // Handle simple method locators
    content = content.replace(
      /public\s+(?:CSWebElement|WebElement)\s+(\w+)\s*\(\s*String\s+(\w+)\s*\)\s*\{\s*return\s+new\s+(?:CSWebElement|WebElement)\s*\(\s*"([^"]+)'\s*\+\s*(\w+)\s*\+\s*'([^"]*)"\s*\)\s*;\s*\}/g,
      (match, methodName, paramName, locatorPrefix, paramRef, locatorSuffix) => {
        return `private ${methodName} = (${paramName}: string) => \`${locatorPrefix}\${${paramName}}${locatorSuffix}\``;
      }
    );
    
    return content;
  }
  
  /**
   * Convert step definitions
   */
  convertStepDefinitions(content: string): string {
    // Handle page object instantiations
    content = content.replace(
      /(\w+)\s+(\w+)\s*=\s*new\s+\1\(\);/g,
      "private $2 = new $1();"
    );
    
    // Handle step definitions
    content = content.replace(
      /@QAFTestStep\s*\(\s*description\s*=\s*"([^"]*)"\s*\)\s*public\s+void\s+(\w+)\s*\(([^)]*)\)\s*\{/g,
      (match, description, methodName, params) => {
        // Determine the step type (Given/When/Then)
        let stepType = "Given";
        if (description.toLowerCase().startsWith("when")) {
          stepType = "When";
        } else if (description.toLowerCase().startsWith("then")) {
          stepType = "Then";
        }
        
        // Convert parameters
        const convertedParams = this.convertParameters(params);
        
        return `${stepType}('${description}', async function(${convertedParams}) {`;
      }
    );
    
    return content;
  }
  
  /**
   * Convert method parameters
   */
  convertParameters(params: string): string {
    if (!params.trim()) return '';
    
    return params
      .split(',')
      .map(param => {
        const parts = param.trim().split(/\s+/);
        const paramName = parts[parts.length - 1];
        return paramName;
      })
      .join(', ');
  }
  
  /**
   * Format locator string to Playwright format
   */
  formatLocator(locator: string): string {
    // Handle different locator types
    if (locator.startsWith('xpath=')) {
      return `\`${locator.substring(6)}\``;
    } else if (locator.startsWith('css=')) {
      return `page.locator('${locator.substring(4)}')`;
    } else if (locator.startsWith('id=')) {
      return `page.locator('#${locator.substring(3)}')`;
    } else if (locator.startsWith('name=')) {
      return `page.locator('[name="${locator.substring(5)}"]')`;
    } else if (locator.startsWith('link=')) {
      return `page.getByRole('link', { name: '${locator.substring(5)}' })`;
    } else if (locator.startsWith('text=')) {
      return `page.getByText('${locator.substring(5)}')`;
    } else {
      // Default to using the locator as is
      return `\`${locator}\``;
    }
  }
  
  /**
   * Perform final cleanup and add required imports
   */
  performCleanup(content: string): string {
    // Add imports
    let result = "import { Given, When, Then } from '@cucumber/cucumber';\n";
    result += "import { Page, expect } from '@playwright/test';\n\n";
    
    // Add the modified content
    result += content;
    
    // Add await to common method calls
    result = result.replace(/(\w+)\.click\(\)/g, 'await $1.click()');
    result = result.replace(/(\w+)\.sendKeys\(([^)]+)\)/g, 'await $1.fill($2)');
    
    return result;
  }
  
  /**
   * Process a directory of files
   */
  processDirectory(inputDir: string, outputDir: string, extensions: string[]): void {
    const files = this.getFiles(inputDir, extensions);
    console.log(`Found ${files.length} files with extensions ${extensions.join(', ')} to process.`);
    
    for (const file of files) {
      const relativePath = path.relative(inputDir, file);
      const outputPath = path.join(outputDir, relativePath.replace(/\.[^/.]+$/, '.ts'));
      this.convertFile(file, outputPath);
    }
    
    console.log('Conversion completed.');
  }
  
  /**
   * Get all files with specified extensions from a directory recursively
   */
  getFiles(dir: string, extensions: string[]): string[] {
    const files: string[] = [];
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory()) {
        files.push(...this.getFiles(fullPath, extensions));
      } else if (extensions.some(ext => fullPath.endsWith(ext))) {
        files.push(fullPath);
      }
    }
    
    return files;
  }
}

// Set up the command-line interface
const program = new Command();

program
  .name('qaf-to-playwright')
  .description('Convert QAF Java code to Playwright TypeScript')
  .version('1.0.0')
  .requiredOption('-i, --input <directory>', 'Input directory containing QAF Java files')
  .requiredOption('-o, --output <directory>', 'Output directory for Playwright TypeScript files')
  .option('-e, --extensions <extensions>', 'File extensions to process (comma-separated)', '.java')
  .action((options) => {
    try {
      const extensions = options.extensions.split(',').map((ext: string) => ext.trim());
      
      console.log('Starting conversion...');
      console.log(`Input directory: ${options.input}`);
      console.log(`Output directory: ${options.output}`);
      console.log(`File extensions: ${extensions.join(', ')}`);
      
      const converter = new SimplifiedQafConverter();
      converter.processDirectory(options.input, options.output, extensions);
      
    } catch (error) {
      console.error('Conversion failed:', error);
      process.exit(1);
    }
  });

program.parse();
