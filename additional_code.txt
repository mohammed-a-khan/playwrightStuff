import * as fs from 'fs';
import * as path from 'path';
import { Command } from 'commander';
import QafToPlaywrightConverter from './qaf-to-playwright-converter';
import QafToCucumberAdapter from './qaf-to-cucumber-adapter';

// Set up command-line interface
const program = new Command();

program
  .name('qaf-to-playwright')
  .description('Comprehensive converter for QAF Java code to Playwright TypeScript')
  .version('1.0.0')
  .requiredOption('-i, --input <directory>', 'Input directory containing QAF Java files')
  .requiredOption('-o, --output <directory>', 'Output directory for Playwright TypeScript files')
  .option('--cucumber', 'Also generate Cucumber feature files and step definitions')
  .option('--fix-syntax', 'Try to fix syntax errors in Java source files')
  .action(async (options) => {
    try {
      console.log('\n🔄 QAF to Playwright Converter');
      console.log('============================');
      
      console.log(`Input directory: ${options.input}`);
      console.log(`Output directory: ${options.output}`);
      console.log(`Generate Cucumber files: ${options.cucumber ? 'Yes' : 'No'}`);
      console.log(`Fix syntax errors: ${options.fixSyntax ? 'Yes' : 'No'}`);
      console.log('----------------------------');
      
      // Create output directory if it doesn't exist
      if (!fs.existsSync(options.output)) {
        fs.mkdirSync(options.output, { recursive: true });
      }
      
      // Convert Java files to Playwright TypeScript
      const converter = new QafToPlaywrightConverter();
      
      // Fix syntax errors if option is enabled
      if (options.fixSyntax) {
        console.log('Pre-processing Java files to fix syntax errors...');
        fixSyntaxErrors(options.input);
      }
      
      // Convert to Playwright
      converter.processDirectory(options.input, options.output);
      
      // Generate Cucumber files if option is enabled
      if (options.cucumber) {
        console.log('\nGenerating Cucumber feature files and step definitions...');
        const cucumberAdapter = new QafToCucumberAdapter();
        cucumberAdapter.processDirectory(options.input, options.output);
      }
      
      console.log('\n✅ Conversion completed successfully!');
      
    } catch (error) {
      console.error('❌ Conversion failed:', error);
      process.exit(1);
    }
  });

/**
 * Pre-process Java files to fix common syntax errors
 */
function fixSyntaxErrors(inputDir: string): void {
  const javaFiles = getAllJavaFiles(inputDir);
  
  for (const file of javaFiles) {
    try {
      let content = fs.readFileSync(file, 'utf8');
      let modified = false;
      
      // Fix 1: Fix "Sring" typo to "String"
      if (content.includes('Sring')) {
        content = content.replace(/\bSring\b/g, 'String');
        modified = true;
      }
      
      // Fix 2: Fix parameters in quotes (like "buttonName")
      content = content.replace(/\((?:\w+\s+)?["'](\w+)["']\s*\)/g, '($1)');
      
      // Fix 3: Fix unclosed quotes in locator strings
      content = fixUnclosedQuotes(content);
      
      // Fix 4: Fix typos in method names (like sendkeys to sendKeys)
      content = content.replace(/\.sendkeys\(/g, '.sendKeys(');
      
      // Fix 5: Fix missing semicolons 
      content = fixMissingSemicolons(content);
      
      // Write back only if content was modified
      if (modified) {
        fs.writeFileSync(file, content);
        console.log(`Fixed syntax errors in: ${file}`);
      }
    } catch (error) {
      console.error(`Error fixing syntax in ${file}:`, error);
    }
  }
}

/**
 * Fix unclosed quotes in locator strings
 */
function fixUnclosedQuotes(content: string): string {
  // Regex to find JSON-like locator strings with unclosed quotes
  const regex = /\{\s*"locator"\s*:\s*"([^"]*?)\+\s*([^)]+)\s*\+\s*"([^"]*?)"\s*,\s*"desc"\s*:\s*"([^"]*?)"\s*\}/g;
  
  return content.replace(regex, (match, prefix, variable, suffix, desc) => {
    return `{"locator":"${prefix}"+${variable}+"${suffix}","desc":"${desc}"}`;
  });
}

/**
 * Fix missing semicolons in statements
 */
function fixMissingSemicolons(content: string): string {
  const lines = content.split('\n');
  const result: string[] = [];
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Check if the line might be missing a semicolon
    if (line && !line.endsWith(';') && !line.endsWith('{') && !line.endsWith('}') && !line.startsWith('//') 
        && !line.startsWith('/*') && !line.startsWith('*') && !line.startsWith('@') 
        && !line.startsWith('import ') && !line.startsWith('package ')) {
      
      // Check if it's an assignment, method call, or variable declaration
      if (line.includes('=') || line.includes('.') || line.match(/\b\w+\s+\w+\b/)) {
        result.push(lines[i] + ';');
        continue;
      }
    }
    
    result.push(lines[i]);
  }
  
  return result.join('\n');
}

/**
 * Get all Java files in a directory and its subdirectories
 */
function getAllJavaFiles(dir: string): string[] {
  const files: string[] = [];
  
  try {
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory()) {
        files.push(...getAllJavaFiles(fullPath));
      } else if (item.endsWith('.java')) {
        files.push(fullPath);
      }
    }
  } catch (error) {
    console.error(`Error reading directory ${dir}:`, error);
  }
  
  return files;
}

// Run the program
program.parse();
