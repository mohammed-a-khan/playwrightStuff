/**
 * Robust XPath extractor that handles complex XPaths with multiple parameters
 * This is the final solution based on test results
 */
function extractDynamicLocator(constructorArgs: string, methodBody: string, paramsList: MethodParam[]): string {
  if (DEBUG) {
    console.log("Processing constructor args:", constructorArgs);
  }
  
  // Extract the XPath string from the constructor args
  const xpathStartIndex = constructorArgs.indexOf('xpath=');
  if (xpathStartIndex === -1) {
    return `//TODO-${paramsList.map(p => p.name).join('-')}`;
  }
  
  // Find the end of the XPath (usually at a quote before the desc field)
  let endIndex = constructorArgs.indexOf('","', xpathStartIndex);
  if (endIndex === -1) {
    endIndex = constructorArgs.indexOf('"', xpathStartIndex + 7); // Skip the opening quote after xpath=
  }
  
  if (endIndex === -1) {
    return `//TODO-${paramsList.map(p => p.name).join('-')}`;
  }
  
  // Extract the XPath string with Java concatenation
  const xpathString = constructorArgs.substring(xpathStartIndex + 6, endIndex);
  
  if (DEBUG) {
    console.log("XPath string with concatenation:", xpathString);
  }
  
  // Split the XPath string on Java concatenation markers
  // This pattern matches both "+paramName+" and variations with whitespace
  const segments = xpathString.split(/"\s*\+\s*|\s*\+\s*"/);
  
  if (DEBUG) {
    console.log("Split segments:", segments);
  }
  
  // Rebuild the XPath with template literals
  let finalXPath = '';
  
  segments.forEach(segment => {
    // Skip empty segments
    if (!segment.trim()) return;
    
    // Check if this segment is a parameter name
    const param = paramsList.find(p => p.name === segment.trim());
    
    if (param) {
      // Add as template literal
      finalXPath += `\${${param.name}}`;
    } else {
      // Add as regular string
      finalXPath += segment;
    }
  });
  
  if (DEBUG) {
    console.log("Final XPath:", finalXPath);
  }
  
  return finalXPath;
}
