import * as fs from 'fs';
import * as path from 'path';
import * as readline from 'readline';

/**
 * QAF to Playwright Converter that targets exact patterns specified
 */
async function convertFile(inputFile: string, outputFile: string): Promise<void> {
  console.log(`Converting ${inputFile} to ${outputFile}`);
  
  try {
    // Create output directory if it doesn't exist
    const outputDir = path.dirname(outputFile);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Create input stream for reading the file line by line
    const fileStream = fs.createReadStream(inputFile);
    const rl = readline.createInterface({
      input: fileStream,
      crlfDelay: Infinity
    });
    
    // Prepare output content
    let outputContent = "import { Page } from '@playwright/test';\n\n";
    
    // Variables to track multi-line patterns
    let inClass = false;
    let className = "PageObject";
    let inFindBy = false;
    let findByBuffer = "";
    let inMethod = false;
    let methodBuffer = "";
    let braceCount = 0;
    
    // Process line by line
    for await (const line of rl) {
      // Detect class definition
      if (!inClass && line.includes("public class")) {
        const match = line.match(/public\s+class\s+(\w+)/);
        if (match) {
          className = match[1];
          inClass = true;
          outputContent += `export class ${className} {\n  constructor(private page: Page) {}\n\n`;
        }
        continue;
      }
      
      // Start of @FindBy
      if (line.includes("@FindBy") && !inFindBy && !inMethod) {
        inFindBy = true;
        findByBuffer = line;
        continue;
      }
      
      // Continuation of @FindBy
      if (inFindBy) {
        findByBuffer += line;
        
        // If this line completes the @FindBy declaration
        if (line.includes(";")) {
          inFindBy = false;
          
          // Process the complete @FindBy declaration
          let processed = processFindBy(findByBuffer);
          if (processed) {
            outputContent += `  ${processed}\n`;
          }
          
          findByBuffer = "";
        }
        continue;
      }
      
      // Start of method-style declaration
      if (line.includes("public CSWebElement") || line.includes("public WebElement")) {
        inMethod = true;
        methodBuffer = line;
        braceCount = (line.match(/{/g) || []).length - (line.match(/}/g) || []).length;
        
        // If the method is complete on a single line (unlikely but possible)
        if (braceCount === 0 && line.includes("}")) {
          inMethod = false;
          let processed = processMethodDeclaration(methodBuffer);
          if (processed) {
            outputContent += `  ${processed}\n`;
          }
          methodBuffer = "";
        }
        
        continue;
      }
      
      // Continuation of method
      if (inMethod) {
        methodBuffer += line;
        braceCount += (line.match(/{/g) || []).length - (line.match(/}/g) || []).length;
        
        // If method is complete
        if (braceCount === 0 && line.includes("}")) {
          inMethod = false;
          let processed = processMethodDeclaration(methodBuffer);
          if (processed) {
            outputContent += `  ${processed}\n`;
          }
          methodBuffer = "";
        }
        
        continue;
      }
    }
    
    // Add closing brace for class if needed
    if (inClass) {
      outputContent += "}\n";
    }
    
    // Write the output file
    fs.writeFileSync(outputFile, outputContent);
    console.log(`Successfully converted: ${outputFile}`);
    
  } catch (error) {
    console.error(`Error converting file ${inputFile}:`, error);
  }
}

/**
 * Process @FindBy declarations
 */
function processFindBy(findByText: string): string | null {
  // Normalize the text (remove extra whitespace)
  findByText = findByText.replace(/\s+/g, ' ').trim();
  
  // Pattern 1: JSON format with locator and desc
  // @FindBy(locator = "{\"locator\":\"xpath=//button[@sometype='somename']\",\"desc\":\"some description\"}") public CSWebElement someElementName;
  let match = findByText.match(/@FindBy\s*\(\s*locator\s*=\s*"(\{[^}]*locator[^}]*\})"\s*\)\s*public\s+(?:CSWebElement|WebElement)\s+(\w+)\s*;/);
  
  if (match) {
    const jsonStr = match[1];
    const elementName = match[2];
    
    // Extract xpath from JSON
    const xpathMatch = jsonStr.match(/locator[^:]*:[^"]*"xpath=([^"]+)"/);
    if (xpathMatch) {
      const xpathValue = xpathMatch[1];
      return `private readonly ${elementName} = this.page.locator(\`${xpathValue}\`);`;
    }
  }
  
  // Pattern 2: Direct xpath
  // @FindBy(locator="xpath=//somexpath") public CSWebElement someElementName;
  match = findByText.match(/@FindBy\s*\(\s*locator\s*=\s*"xpath=([^"]+)"\s*\)\s*public\s+(?:CSWebElement|WebElement)\s+(\w+)\s*;/);
  
  if (match) {
    const xpathValue = match[1];
    const elementName = match[2];
    return `private readonly ${elementName} = this.page.locator(\`${xpathValue}\`);`;
  }
  
  return null;
}

/**
 * Process method-style element declarations
 */
function processMethodDeclaration(methodText: string): string | null {
  // Normalize the text (remove extra whitespace and newlines)
  methodText = methodText.replace(/\s+/g, ' ').trim();
  
  // Pattern: Method with JSON locator containing xpath and buttonName parameter
  // public CSWebElement getMyButtonElement(String buttonName) { return new CSWebElement( "{\"locator\":\"xpath=//button[@sometype='"+buttonName+"']\",\"desc\":\"some description\"}"); }
  const match = methodText.match(/public\s+(?:CSWebElement|WebElement)\s+(\w+)\s*\(\s*String\s+(\w+)\s*\)\s*\{[^}]*new\s+(?:CSWebElement|WebElement)\s*\(\s*"[^"]*xpath=([^']+)'"\s*\+\s*(\w+)\s*\+\s*"'([^"]*)"/);
  
  if (match) {
    const methodName = match[1];
    const paramName = match[2];
    const prefix = match[3];
    const suffix = match[5];
    
    return `private ${methodName} = (${paramName}: string) => this.page.locator(\`${prefix}\${${paramName}}${suffix}\`);`;
  }
  
  return null;
}

/**
 * Process a directory of files
 */
async function processDirectory(inputDir: string, outputDir: string): Promise<void> {
  try {
    // Get all Java files
    const files = getJavaFiles(inputDir);
    console.log(`Found ${files.length} Java files to process`);
    
    // Create output directory if it doesn't exist
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Process each file
    for (const file of files) {
      const relativePath = path.relative(inputDir, file);
      const outputFile = path.join(outputDir, relativePath.replace('.java', '.ts'));
      await convertFile(file, outputFile);
    }
    
    console.log('Conversion completed successfully!');
  } catch (error) {
    console.error('Error processing directory:', error);
  }
}

/**
 * Get all Java files in a directory and its subdirectories
 */
function getJavaFiles(dir: string): string[] {
  const files: string[] = [];
  
  try {
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory()) {
        files.push(...getJavaFiles(fullPath));
      } else if (item.endsWith('.java')) {
        files.push(fullPath);
      }
    }
  } catch (error) {
    console.error(`Error reading directory ${dir}:`, error);
  }
  
  return files;
}

/**
 * Main function
 */
async function main(): Promise<void> {
  try {
    // Get command line arguments
    const args = process.argv.slice(2);
    const inputDir = args[0];
    const outputDir = args[1];
    
    if (!inputDir || !outputDir) {
      console.error('Usage: npx ts-node qaf-converter.ts <input-directory> <output-directory>');
      process.exit(1);
    }
    
    console.log(`Converting QAF files from ${inputDir} to ${outputDir}`);
    await processDirectory(inputDir, outputDir);
    
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}

// Run the program
main().catch(console.error);
