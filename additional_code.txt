/**
 * Extract dynamic locator from constructor args with a pure algorithmic approach
 * No hardcoding of specific patterns - handles any XPath format
 */
function extractDynamicLocator(constructorArgs, methodBody, paramsList) {
  if (DEBUG) {
    console.log("Processing constructor args:", constructorArgs);
    console.log("Parameters:", paramsList.map(p => `${p.type} ${p.name}`).join(", "));
  }
  
  // First, find all parts of the constructor args
  // Split by the + operator to identify string literals and parameters
  const parts = constructorArgs.split(/\+/).map(part => part.trim());
  
  // Reconstruct the XPath by analyzing each part
  let rawXpath = "";
  let inXpath = false;
  let parameterMap = {}; // Maps parameter names to their positions in the XPath
  
  // First pass: identify where the XPath starts and extract both 
  // the static parts and track where parameters would go
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    
    // Start of XPath detection (looking for the locator pattern)
    if (part.includes("xpath=") && !inXpath) {
      inXpath = true;
      
      // Extract the start of the XPath after "xpath="
      const xpathStartIndex = part.indexOf("xpath=") + 6;
      rawXpath += part.substring(xpathStartIndex);
      continue;
    }
    
    // End of XPath detection (looking for common ending patterns)
    if (inXpath && (part.includes('","desc"') || part.includes('"}') || part.endsWith('"'))) {
      // Extract up to the end pattern
      const endPatterns = ['","desc"', '"}', '"'];
      for (const endPattern of endPatterns) {
        if (part.includes(endPattern)) {
          const endIndex = part.indexOf(endPattern);
          if (endIndex > -1) {
            rawXpath += part.substring(0, endIndex);
            inXpath = false;
            break;
          }
        }
      }
      
      if (inXpath) {
        // If no end pattern matched, just add the whole part
        rawXpath += part;
      }
      continue;
    }
    
    // Parameter detection
    if (inXpath) {
      // Check if this part is a parameter reference
      const paramName = part.replace(/^"/, '').replace(/"$/, '');
      const param = paramsList.find(p => p.name === paramName);
      
      if (param) {
        // Record the parameter's position in the reconstructed XPath
        parameterMap[param.name] = rawXpath.length;
        
        // For numeric parameters (e.g., position indexes), add a placeholder
        if (param.type === 'int' || param.type === 'Integer' || param.type === 'number') {
          rawXpath += "NUMERIC_PARAM";
        } else {
          // For string parameters, add a different placeholder
          rawXpath += "STRING_PARAM";
        }
      } else {
        // If not a parameter, it's part of the XPath
        rawXpath += part;
      }
    }
  }
  
  if (DEBUG) {
    console.log("Extracted raw XPath:", rawXpath);
    console.log("Parameter positions:", parameterMap);
  }
  
  // Now analyze the constructor args to understand the context of each parameter
  // This helps us determine what parts of the XPath to replace with parameter references
  
  // Second pass: Identify parameter context patterns
  const paramContexts = {};
  
  for (const param of paramsList) {
    // Try to find contextual patterns around the parameter
    // Common patterns include: position()=, text()=, contains(), @attribute=, etc.
    
    // Look for position() pattern for numeric parameters
    if (param.type === 'int' || param.type === 'Integer' || param.type === 'number') {
      if (constructorArgs.includes(`position()="+${param.name}+"`)) {
        paramContexts[param.name] = {
          type: 'position',
          pattern: /position\(\)\s*=\s*NUMERIC_PARAM/g
        };
      }
    }
    
    // Look for text() pattern for string parameters
    if (param.type === 'String' || param.type === 'string') {
      if (constructorArgs.includes(`text()='"+${param.name}+"'`)) {
        paramContexts[param.name] = {
          type: 'text',
          pattern: /text\(\)\s*=\s*['"]STRING_PARAM['"]/g
        };
      }
      
      // Look for contains() pattern
      else if (constructorArgs.includes(`contains(`) && constructorArgs.includes(`+${param.name}+`)) {
        paramContexts[param.name] = {
          type: 'contains',
          pattern: /contains\([^,]+,\s*['"]STRING_PARAM['"]\)/g
        };
      }
    }
  }
  
  if (DEBUG) {
    console.log("Parameter contexts:", paramContexts);
  }
  
  // Third pass: Replace placeholders with template literals for parameters
  let finalXpath = rawXpath;
  
  for (const param of paramsList) {
    const context = paramContexts[param.name];
    
    if (context) {
      switch (context.type) {
        case 'position':
          finalXpath = finalXpath.replace(context.pattern, `position()=\${${param.name}}`);
          break;
          
        case 'text':
          finalXpath = finalXpath.replace(context.pattern, `text()='\${${param.name}}'`);
          break;
          
        case 'contains':
          // For contains, we need to be more careful about replacement
          finalXpath = finalXpath.replace(context.pattern, (match) => {
            // Replace just the string part within contains()
            return match.replace(/['"]STRING_PARAM['"]/, `'\${${param.name}}'`);
          });
          break;
      }
    } else {
      // No specific context found - try a more generic approach
      // For numeric parameters, look for numeric literals in the XPath
      if (param.type === 'int' || param.type === 'Integer' || param.type === 'number') {
        if (finalXpath.includes("NUMERIC_PARAM")) {
          finalXpath = finalXpath.replace("NUMERIC_PARAM", `\${${param.name}}`);
        }
      }
      
      // For string parameters, look for string literals
      if (param.type === 'String' || param.type === 'string') {
        if (finalXpath.includes("STRING_PARAM")) {
          finalXpath = finalXpath.replace("STRING_PARAM", `\${${param.name}}`);
        }
      }
    }
  }
  
  // If we still have placeholders, try a last-resort approach
  finalXpath = finalXpath
    .replace(/NUMERIC_PARAM/g, "1") // Replace remaining numeric placeholders with default values
    .replace(/STRING_PARAM/g, "value"); // Replace remaining string placeholders with default values
  
  if (DEBUG) {
    console.log("Final XPath with parameters:", finalXpath);
  }
  
  return finalXpath;
}

/**
 * Improved version that uses string tokenization to reconstruct the full XPath
 */
function extractDynamicLocatorV2(constructorArgs, methodBody, paramsList) {
  if (DEBUG) {
    console.log("Processing: ", constructorArgs);
  }
  
  // Step 1: Analyze and tokenize the constructor args to identify XPath parts and parameters
  const tokens = tokenizeConstructorArgs(constructorArgs);
  
  if (DEBUG) {
    console.log("Tokenized constructor args:", tokens);
  }
  
  // Step 2: Extract the XPath from the tokens
  const { xpath, paramPositions } = reconstructXPathFromTokens(tokens, paramsList);
  
  if (DEBUG) {
    console.log("Reconstructed XPath:", xpath);
    console.log("Parameter positions:", paramPositions);
  }
  
  // Step 3: Analyze the context of each parameter to determine substitution pattern
  const parameterContexts = analyzeParameterContexts(constructorArgs, paramsList);
  
  if (DEBUG) {
    console.log("Parameter contexts:", parameterContexts);
  }
  
  // Step 4: Substitute parameters in the XPath
  let finalXPath = substituteParametersInXPath(xpath, paramPositions, parameterContexts, paramsList);
  
  if (DEBUG) {
    console.log("Final XPath:", finalXPath);
  }
  
  return finalXPath;
}

/**
 * Tokenize constructor args to separate string literals and parameters
 */
function tokenizeConstructorArgs(constructorArgs) {
  const tokens = [];
  
  // Clean up the constructor args first
  const cleanArgs = constructorArgs
    .replace(/\\"/g, '"')  // Replace escaped quotes
    .replace(/\s+/g, ' '); // Normalize whitespace
  
  // Split by string concatenation operator
  const parts = cleanArgs.split('+').map(p => p.trim());
  
  for (let part of parts) {
    // Remove surrounding quotes from string literals
    if ((part.startsWith('"') && part.endsWith('"')) || 
        (part.startsWith("'") && part.endsWith("'"))) {
      tokens.push({
        type: 'string',
        value: part.substring(1, part.length - 1)
      });
    } 
    // Parameters (not surrounded by quotes)
    else if (part && !part.includes('"') && !part.includes("'")) {
      tokens.push({
        type: 'parameter',
        name: part
      });
    }
    // Complex parts might have partial quotes or other structures
    else if (part) {
      // Try to extract any useful content
      const quoteMatch = part.match(/["']([^"']+)["']/);
      if (quoteMatch) {
        tokens.push({
          type: 'string',
          value: quoteMatch[1]
        });
      } else {
        tokens.push({
          type: 'unknown',
          value: part
        });
      }
    }
  }
  
  return tokens;
}

/**
 * Reconstruct the XPath from tokenized constructor args
 */
function reconstructXPathFromTokens(tokens, paramsList) {
  let xpath = "";
  const paramPositions = {};
  let inXPath = false;
  
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    
    // Start of XPath marker
    if (token.type === 'string' && token.value.includes('xpath=') && !inXPath) {
      inXPath = true;
      const xpathStart = token.value.substring(token.value.indexOf('xpath=') + 6);
      xpath += xpathStart;
      continue;
    }
    
    // End of XPath marker
    if (inXPath && token.type === 'string' && 
        (token.value.includes('","desc"') || token.value.includes('"}'))) {
      // Extract up to the marker
      const endMarkers = ['","desc"', '"}'];
      for (const marker of endMarkers) {
        if (token.value.includes(marker)) {
          xpath += token.value.substring(0, token.value.indexOf(marker));
          inXPath = false;
          break;
        }
      }
      continue;
    }
    
    // Parameter token in XPath
    if (inXPath && token.type === 'parameter') {
      // Verify this is a valid parameter
      const param = paramsList.find(p => p.name === token.name);
      if (param) {
        // Store parameter position
        paramPositions[param.name] = xpath.length;
        
        // Next and previous tokens might give context
        const prevToken = i > 0 ? tokens[i-1] : null;
        const nextToken = i < tokens.length - 1 ? tokens[i+1] : null;
        
        // Add placeholder based on context
        if (prevToken?.value?.includes('position()=')) {
          xpath += "POSITION_PARAM";
        } 
        else if (prevToken?.value?.includes('text()=\'')) {
          xpath += "TEXT_PARAM";
        }
        else if (prevToken?.value?.includes('contains(')) {
          xpath += "CONTAINS_PARAM";
        }
        else {
          // Generic placeholder based on type
          xpath += param.type === 'int' || param.type === 'Integer' ? "NUMERIC_PARAM" : "STRING_PARAM";
        }
      }
      continue;
    }
    
    // Regular string token in XPath
    if (inXPath && token.type === 'string') {
      xpath += token.value;
    }
  }
  
  return { xpath, paramPositions };
}

/**
 * Analyze parameters to determine their context in the XPath
 */
function analyzeParameterContexts(constructorArgs, paramsList) {
  const contexts = {};
  
  for (const param of paramsList) {
    // Different context detection strategies based on parameter type
    if (param.type === 'int' || param.type === 'Integer' || param.type === 'number') {
      // Check for position() usage
      if (constructorArgs.includes(`position()="+${param.name}+"`)) {
        contexts[param.name] = {
          type: 'position',
          replacement: `\${${param.name}}`
        };
      }
    }
    
    if (param.type === 'String' || param.type === 'string') {
      // Check for text() usage
      if (constructorArgs.includes(`text()='"+${param.name}+"'`)) {
        contexts[param.name] = {
          type: 'text',
          replacement: `\${${param.name}}`
        };
      }
      // Check for contains() usage
      else if (constructorArgs.includes(`contains(`) && 
               constructorArgs.includes(`${param.name}`)) {
        contexts[param.name] = {
          type: 'contains',
          replacement: `\${${param.name}}`
        };
      }
    }
  }
  
  return contexts;
}

/**
 * Substitute parameters in the XPath using intelligent pattern matching
 */
function substituteParametersInXPath(xpath, paramPositions, contexts, paramsList) {
  let result = xpath;
  
  // Track parameters we've already processed
  const processedParams = new Set();
  
  // First pass: Use specific context replacements
  for (const param of paramsList) {
    if (contexts[param.name]) {
      const context = contexts[param.name];
      
      switch (context.type) {
        case 'position':
          // Replace position()=X with position()=${param}
          result = result.replace(/position\(\)\s*=\s*(POSITION_PARAM|NUMERIC_PARAM|\d+)/g, 
                                 `position()=\${${param.name}}`);
          processedParams.add(param.name);
          break;
          
        case 'text':
          // Replace text()='X' with text()='${param}'
          result = result.replace(/text\(\)\s*=\s*['"]?(TEXT_PARAM|STRING_PARAM|[^'"]+)['"]?/g, 
                                 `text()='\${${param.name}}'`);
          processedParams.add(param.name);
          break;
          
        case 'contains':
          // Replace contains(..., 'X') with contains(..., '${param}')
          result = result.replace(/contains\([^,]+,\s*['"]?(CONTAINS_PARAM|STRING_PARAM|[^'"]+)['"]?\)/g, 
                                 `contains($1, '\${${param.name}}')`);
          processedParams.add(param.name);
          break;
      }
    }
  }
  
  // Second pass: Generic replacements for remaining parameters
  for (const param of paramsList) {
    if (processedParams.has(param.name)) continue;
    
    if (param.type === 'int' || param.type === 'Integer' || param.type === 'number') {
      // Try to replace any position-like pattern
      if (result.includes("POSITION_PARAM")) {
        result = result.replace("POSITION_PARAM", `\${${param.name}}`);
        continue;
      }
      if (result.includes("NUMERIC_PARAM")) {
        result = result.replace("NUMERIC_PARAM", `\${${param.name}}`);
        continue;
      }
    }
    
    if (param.type === 'String' || param.type === 'string') {
      // Try to replace any text-like pattern
      if (result.includes("TEXT_PARAM")) {
        result = result.replace("TEXT_PARAM", `\${${param.name}}`);
        continue;
      }
      if (result.includes("STRING_PARAM")) {
        result = result.replace("STRING_PARAM", `\${${param.name}}`);
        continue;
      }
    }
  }
  
  // Final cleanup of any remaining placeholders
  result = result
    .replace(/POSITION_PARAM/g, "1")
    .replace(/NUMERIC_PARAM/g, "1")
    .replace(/TEXT_PARAM/g, "value")
    .replace(/STRING_PARAM/g, "value")
    .replace(/CONTAINS_PARAM/g, "value");
  
  return result;
}
