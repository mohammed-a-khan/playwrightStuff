/**
 * Improved extraction and conversion of methods with switch statements
 */
function extractAndConvertComplexMethods(content: string, returnType: string): MethodInfo[] {
  const methodsList: MethodInfo[] = [];
  
  // Find methods with switch statements that return an element
  const switchMethodRegex = new RegExp(
    `(?:public|private|protected)\\s+${returnType}\\s+(\\w+)\\s*\\(([^)]*)\\)\\s*\\{([\\s\\S]*?)switch\\s*\\(([^)]*)\\)\\s*\\{([\\s\\S]*?)\\}([\\s\\S]*?)return\\s+([\\s\\S]+?);\\s*\\}`, 
    'gs'
  );
  
  let methodMatch: RegExpExecArray | null;
  while ((methodMatch = switchMethodRegex.exec(content)) !== null) {
    try {
      const methodName = methodMatch[1];
      const params = methodMatch[2] || '';
      const beforeSwitch = methodMatch[3] || '';
      const switchVar = methodMatch[4] || '';
      const switchBody = methodMatch[5] || '';
      const afterSwitch = methodMatch[6] || '';
      const returnStatement = methodMatch[7] || '';
      
      if (DEBUG) {
        console.log(`Found complex method: ${methodName}`);
        console.log(`Switch variable: ${switchVar}`);
      }
      
      // Extract parameter information
      const paramsList = extractParameters(params);
      
      // Extract enum parameters - important for switch statements that use enum values
      const enumParams = findEnumParameters(paramsList, content);
      
      // Extract case statements
      const cases = extractCases(switchBody, paramsList);
      
      if (DEBUG) {
        console.log(`Found ${cases.length} cases`);
        cases.forEach((c, i) => console.log(`Case ${i}: ${c.value} - Has condition: ${c.hasCondition}`));
      }
      
      // Create the complex method info
      methodsList.push({
        name: methodName,
        params: paramsList,
        locator: 'COMPLEX_METHOD', // Special marker indicating complex implementation needed
        type: returnType,
        isList: false,
        isComplex: true,
        complexData: {
          switchVar,
          cases,
          beforeSwitch,
          afterSwitch,
          enumParams,
          returnStatement
        }
      });
    } catch (error) {
      console.error(`Error processing complex method: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  return methodsList;
}

/**
 * Find parameters that are enum types
 */
function findEnumParameters(params: MethodParam[], content: string): MethodParam[] {
  const enumParams: MethodParam[] = [];
  
  // Look for each parameter type in enum declarations
  for (const param of params) {
    const enumRegex = new RegExp(`\\benum\\s+${param.type}\\b`);
    if (enumRegex.test(content)) {
      enumParams.push(param);
    }
  }
  
  return enumParams;
}

/**
 * Extract case statements from a switch body with improved enum handling
 */
function extractCases(switchBody: string, params: MethodParam[]): CaseInfo[] {
  const cases: CaseInfo[] = [];
  
  // Regex to extract case statements - handles both string literals and enum constants
  const caseRegex = /case\s+(?:["']([^"']+)["']|([A-Z_][A-Z0-9_]*)):\s*([^}]*?)(?=case|default|break;|$)/gs;
  
  let caseMatch;
  while ((caseMatch = caseRegex.exec(switchBody)) !== null) {
    const stringValue = caseMatch[1]; // String literal value (if present)
    const enumValue = caseMatch[2];   // Enum constant value (if present)
    const value = stringValue || enumValue; // One of these will be set
    
    if (!value) continue; // Skip if neither is set (shouldn't happen)
    
    const caseBody = caseMatch[3];
    
    // Look for element assignment in the case body
    const elementAssignmentRegex = /element\s*=\s*new\s+CSWebElement\(\s*([^;]+?)\);/;
    const assignmentMatch = caseBody.match(elementAssignmentRegex);
    
    if (assignmentMatch) {
      const constructorArgs = assignmentMatch[1];
      
      // Clean up the constructor args and extract the XPath
      let locator = '';
      try {
        // Extract the XPath from JSON or direct string
        locator = extractLocatorFromConstructorArgs(constructorArgs, params);
      } catch (e) {
        console.error(`Error extracting locator for case ${value}:`, e);
        locator = `//Error-extracting-locator-for-${value}`;
      }
      
      // Check if this case has conditions (if/else blocks)
      const hasCondition = caseBody.includes('if') && 
                          (caseBody.includes('else') || 
                           caseBody.trim().split('if').length > 2);
      
      if (hasCondition) {
        // Extract conditions and their locators
        const conditions: string[] = [];
        const locators: Array<{ condition: string | null; locator: string }> = [];
        
        extractConditionsAndLocators(caseBody, conditions, locators, params);
        
        cases.push({
          value,
          hasCondition: true,
          conditions,
          locators
        });
      } else {
        // Simple case with just one locator
        cases.push({
          value,
          hasCondition: false,
          conditions: [],
          locators: [{
            condition: null,
            locator
          }]
        });
      }
    }
  }
  
  return cases;
}

/**
 * Extract locator from constructor arguments with improved parameter handling
 */
function extractLocatorFromConstructorArgs(constructorArgs: string, params: MethodParam[]): string {
  // First, clean up the constructor args
  constructorArgs = constructorArgs.replace(/\\"/g, '"').trim();
  
  // Extract the XPath part from JSON or direct string
  let xpathValue = '';
  
  // Look for JSON format like {"locator":"xpath=..."}
  const jsonMatch = constructorArgs.match(/"locator"\s*:\s*"xpath=([^"]+)"/);
  if (jsonMatch) {
    xpathValue = jsonMatch[1];
  } else {
    // Try direct string format
    const directMatch = constructorArgs.match(/xpath=([^"]+)/);
    if (directMatch) {
      xpathValue = directMatch[1];
    } else {
      // If no match found, return placeholder
      return '//Unable-to-extract-xpath';
    }
  }
  
  // Process parameters in the XPath
  let finalXPath = xpathValue;
  
  // Replace each parameter reference in the XPath
  for (const param of params) {
    // Look for concatenation patterns containing this parameter
    const patterns = [
      `"+${param.name}+"`,
      `" + ${param.name} + "`,
      `"+${param.name} + "`,
      `" + ${param.name}+"`
    ];
    
    // Try each pattern
    let found = false;
    for (const pattern of patterns) {
      if (constructorArgs.includes(pattern)) {
        // Find where this parameter is used in the XPath
        const segments = finalXPath.split("'+");
        
        // If there are multiple segments, try to figure out which one contains this parameter
        if (segments.length > 1) {
          for (let i = 0; i < segments.length; i++) {
            // Look for pattern end in this segment
            if (segments[i].includes("+'") || segments[i].endsWith("'")) {
              // Replace string value with parameter template
              segments[i] = segments[i].replace(/[^']+'/, `\${${param.name}}'`);
              found = true;
              break;
            }
          }
          
          if (found) {
            finalXPath = segments.join("'+");
          }
        } else {
          // For simpler cases, try direct replacement of common patterns
          const stringParams = [
            /text\(\)\s*=\s*'[^']*'/,
            /contains\([^,]+,\s*'[^']*'\)/,
            /@[^=]+=\s*'[^']*'/
          ];
          
          for (const patternRegex of stringParams) {
            const match = finalXPath.match(patternRegex);
            if (match) {
              // Replace the match with a template using the parameter
              const original = match[0];
              const quoted = original.match(/'[^']*'/);
              
              if (quoted) {
                const replacedStr = original.replace(quoted[0], `'\${${param.name}}'`);
                finalXPath = finalXPath.replace(original, replacedStr);
                found = true;
                break;
              }
            }
          }
        }
        
        if (found) break;
      }
    }
    
    // If we couldn't find a match with the patterns, try a more aggressive approach
    if (!found && constructorArgs.includes(param.name)) {
      // Look for string literals in the XPath that might contain the parameter
      const stringLiteralRegex = /'([^']+)'/g;
      let match;
      let replaced = false;
      
      // Try replacing one string literal at a time
      while (!replaced && (match = stringLiteralRegex.exec(finalXPath)) !== null) {
        const stringValue = match[1];
        
        // Replace this string literal with the parameter
        const replacedXPath = finalXPath.replace(`'${stringValue}'`, `'\${${param.name}}'`);
        
        // If the replacement made a difference, use it
        if (replacedXPath !== finalXPath) {
          finalXPath = replacedXPath;
          replaced = true;
        }
      }
    }
  }
  
  // Clean up the XPath
  finalXPath = finalXPath
    .replace(/\\'/g, "'")
    .replace(/\\"/g, '"')
    .replace(/\\\\/g, '\\');
  
  return finalXPath;
}

/**
 * Extract conditions and locators from if-else blocks with improved parameter handling
 */
function extractConditionsAndLocators(
  caseBody: string, 
  conditions: string[], 
  locators: Array<{ condition: string | null; locator: string }>,
  params: MethodParam[]
): void {
  // Extract if conditions
  const ifRegex = /if\s*\(([^)]+)\)\s*\{([^}]*)\}/gs;
  let ifMatch;
  
  while ((ifMatch = ifRegex.exec(caseBody)) !== null) {
    const condition = ifMatch[1].trim();
    const ifBody = ifMatch[2];
    
    conditions.push(condition);
    
    // Extract locator from if body
    const locatorMatch = ifBody.match(/new\s+CSWebElement\(\s*([^;)]+)[;)]/);
    if (locatorMatch) {
      const constructorArgs = locatorMatch[1];
      const locator = extractLocatorFromConstructorArgs(constructorArgs, params);
      
      locators.push({
        condition,
        locator
      });
    }
  }
  
  // Extract else blocks
  const elseRegex = /else\s*\{([^}]*)\}/gs;
  let elseMatch;
  
  while ((elseMatch = elseRegex.exec(caseBody)) !== null) {
    const elseBody = elseMatch[1];
    
    // Extract locator from else body
    const locatorMatch = elseBody.match(/new\s+CSWebElement\(\s*([^;)]+)[;)]/);
    if (locatorMatch) {
      const constructorArgs = locatorMatch[1];
      const locator = extractLocatorFromConstructorArgs(constructorArgs, params);
      
      // Use a negated condition for the else
      const elseCondition = conditions.length > 0 ? `!(${conditions[conditions.length - 1]})` : null;
      
      locators.push({
        condition: elseCondition,
        locator
      });
    }
  }
}

/**
 * Generate TypeScript method for complex methods with switch statements
 */
function generateComplexMethod(method: MethodInfo): string {
  if (!method.isComplex || !method.complexData) {
    return '';
  }
  
  const { switchVar, cases, enumParams } = method.complexData;
  const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
  
  let output = `  ${method.name}(${paramList}) {\n`;
  output += `    // Complex method with switch/case logic\n`;
  output += `    let locator = '';\n`;
  output += `    \n`;
  
  // Convert the switch variable expression to accommodate enum parameters
  let switchExpression = switchVar.trim();
  
  // If the switch is on an enum parameter, use lowercase comparison
  const enumParam = enumParams.find(p => switchExpression === p.name);
  if (enumParam) {
    switchExpression = `${enumParam.name}.toLowerCase()`;
  }
  
  // Generate the switch statement
  output += `    switch (${switchExpression}) {\n`;
  
  // Generate each case
  cases.forEach(c => {
    // For enum cases, use lowercase value
    const caseValue = c.value.toLowerCase();
    output += `      case '${caseValue}':\n`;
    
    if (c.hasCondition && c.locators.length > 0) {
      // Generate if-else logic
      c.locators.forEach((l, index) => {
        if (l.condition) {
          const condition = convertJavaConditionToTS(l.condition);
          
          if (index === 0) {
            output += `        if (${condition}) {\n`;
          } else if (!l.condition.startsWith('!(')) {
            output += `        else if (${condition}) {\n`;
          } else {
            output += `        else {\n`;
          }
          
          output += `          locator = \`${l.locator}\`;\n`;
          output += `        }\n`;
        } else {
          output += `        else {\n`;
          output += `          locator = \`${l.locator}\`;\n`;
          output += `        }\n`;
        }
      });
    } else if (c.locators.length > 0) {
      // Simple case with no conditions
      output += `        locator = \`${c.locators[0].locator}\`;\n`;
    }
    
    output += `        break;\n`;
  });
  
  // Default case
  output += `      default:\n`;
  output += `        locator = \`//div[contains(@class, "not-found")]\`;\n`;
  output += `        break;\n`;
  
  // Close switch
  output += `    }\n`;
  output += `    \n`;
  output += `    return this.page.locator(locator);\n`;
  output += `  }\n\n`;
  
  return output;
}
