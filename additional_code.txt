import * as fs from 'fs';
import * as path from 'path';

/**
 * Focused QAF to Playwright Converter that handles specific patterns exactly
 */
function convertFile(inputFile: string, outputFile: string): void {
  console.log(`Converting ${inputFile} to ${outputFile}`);
  
  try {
    // Read the file content
    const content = fs.readFileSync(inputFile, 'utf8');
    
    // Split into lines to handle multi-line declarations
    const lines = content.split('\n');
    let result = "import { Page } from '@playwright/test';\n\n";
    
    // Process class definition
    const classMatch = content.match(/public\s+class\s+(\w+)/);
    if (classMatch) {
      const className = classMatch[1];
      result += `export class ${className} {\n  constructor(private page: Page) {}\n\n`;
    } else {
      result += "export class PageObject {\n  constructor(private page: Page) {}\n\n";
    }
    
    // Process file line by line
    let i = 0;
    while (i < lines.length) {
      let line = lines[i];
      
      // Check for @FindBy
      if (line.includes('@FindBy')) {
        // Collect the complete declaration
        let declaration = line;
        let j = i + 1;
        while (j < lines.length && !lines[j].includes(';')) {
          declaration += '\n' + lines[j];
          j++;
        }
        if (j < lines.length) {
          declaration += '\n' + lines[j];
        }
        
        // Extract element name
        const elementNameMatch = declaration.match(/CSWebElement\s+(\w+)\s*;/);
        if (elementNameMatch) {
          const elementName = elementNameMatch[1];
          
          // Check for JSON format
          if (declaration.includes('locator = "{\\') || declaration.includes('locator = "{"')) {
            // Extract xpath from JSON
            const xpathMatch = declaration.match(/"locator"(?:\\)?:(?:\\)?"xpath=([^"]+)(?:\\)?"/);
            if (xpathMatch) {
              const xpathValue = xpathMatch[1];
              result += `  private readonly ${elementName} = this.page.locator(\`${xpathValue}\`);\n`;
            }
          } 
          // Check for direct xpath format
          else if (declaration.includes('locator="xpath=')) {
            const xpathMatch = declaration.match(/locator="xpath=([^"]+)"/);
            if (xpathMatch) {
              const xpathValue = xpathMatch[1];
              result += `  private readonly ${elementName} = this.page.locator(\`${xpathValue}\`);\n`;
            }
          }
        }
        
        // Skip processed lines
        i = j + 1;
        continue;
      }
      
      // Check for method-style declaration
      if (line.includes('public CSWebElement')) {
        // Collect the complete method
        let methodDeclaration = line;
        let braceCount = line.split('{').length - line.split('}').length;
        let j = i + 1;
        
        while (j < lines.length && braceCount > 0) {
          methodDeclaration += '\n' + lines[j];
          braceCount += lines[j].split('{').length - lines[j].split('}').length;
          j++;
        }
        
        // Extract method name and parameter
        const methodMatch = methodDeclaration.match(/public\s+CSWebElement\s+(\w+)\s*\(\s*String\s+(\w+)\s*\)/);
        if (methodMatch) {
          const methodName = methodMatch[1];
          const paramName = methodMatch[2];
          
          // Check for different xpath patterns in method
          // 1. JSON format with concatenation
          const jsonXpathMatch = methodDeclaration.match(/"locator"(?:\\)?:(?:\\)?"xpath=([^']+)'"\s*\+\s*(\w+)\s*\+\s*"'([^"]+)(?:\\)?"/);
          if (jsonXpathMatch) {
            const prefix = jsonXpathMatch[1];
            const suffix = jsonXpathMatch[3];
            result += `  private ${methodName} = (${paramName}: string) => this.page.locator(\`${prefix}\${${paramName}}${suffix}\`);\n`;
          } 
          // 2. Direct xpath with concatenation
          else if (methodDeclaration.includes('xpath=')) {
            const directXpathMatch = methodDeclaration.match(/xpath=([^']+)'"\s*\+\s*(\w+)\s*\+\s*"'([^"]+)/);
            if (directXpathMatch) {
              const prefix = directXpathMatch[1];
              const suffix = directXpathMatch[3];
              result += `  private ${methodName} = (${paramName}: string) => this.page.locator(\`${prefix}\${${paramName}}${suffix}\`);\n`;
            }
          }
          // 3. Simple ID concatenation
          else if (methodDeclaration.includes('id="')) {
            result += `  private ${methodName} = (${paramName}: string) => this.page.locator(\`#\${${paramName}}\`);\n`;
          }
        }
        
        // Skip processed lines
        i = j;
        continue;
      }
      
      i++;
    }
    
    // Close class
    result += '}\n';
    
    // Create output directory if it doesn't exist
    const outputDir = path.dirname(outputFile);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Write output file
    fs.writeFileSync(outputFile, result);
    console.log(`Successfully converted: ${outputFile}`);
    
  } catch (error) {
    console.error(`Error converting file ${inputFile}:`, error);
  }
}

/**
 * Process a directory of files
 */
function processDirectory(inputDir: string, outputDir: string): void {
  try {
    // Get all Java files
    const files = getJavaFiles(inputDir);
    console.log(`Found ${files.length} Java files to process`);
    
    // Create output directory if it doesn't exist
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Process each file
    for (const file of files) {
      const relativePath = path.relative(inputDir, file);
      const outputFile = path.join(outputDir, relativePath.replace('.java', '.ts'));
      convertFile(file, outputFile);
    }
    
    console.log('Conversion completed successfully!');
  } catch (error) {
    console.error('Error processing directory:', error);
  }
}

/**
 * Get all Java files in a directory and its subdirectories
 */
function getJavaFiles(dir: string): string[] {
  const files: string[] = [];
  
  try {
    const items = fs.readdirSync(dir);
    
    for (const item of items) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory()) {
        files.push(...getJavaFiles(fullPath));
      } else if (item.endsWith('.java')) {
        files.push(fullPath);
      }
    }
  } catch (error) {
    console.error(`Error reading directory ${dir}:`, error);
  }
  
  return files;
}

/**
 * Main function
 */
function main(): void {
  try {
    // Get command line arguments
    const args = process.argv.slice(2);
    const inputDir = args[0];
    const outputDir = args[1];
    
    if (!inputDir || !outputDir) {
      console.error('Usage: npx ts-node qaf-converter.ts <input-directory> <output-directory>');
      process.exit(1);
    }
    
    console.log(`Converting QAF files from ${inputDir} to ${outputDir}`);
    processDirectory(inputDir, outputDir);
    
  } catch (error) {
    console.error('Error:', error);
    process.exit(1);
  }
}

// Run the program
main();
