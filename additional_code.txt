const fs = require('fs');
const path = require('path');

// Very simple converter focusing on what worked before
function convertFile(inputFile, outputFile) {
  console.log(`Converting ${inputFile} to ${outputFile}`);
  
  try {
    // Read the file
    let content = fs.readFileSync(inputFile, 'utf8');
    
    // Add Playwright imports
    let result = "import { Page } from '@playwright/test';\n\n";
    
    // Convert class
    result += content.replace(/public class (\w+)[\s\S]*?\{/, 'export class $1 {\n  constructor(private page: Page) {}\n');
    
    // Convert @FindBy simple format (this worked before)
    result = result.replace(
      /@FindBy\(locator="xpath=([^"]+)"\)\s*public\s+CSWebElement\s+(\w+);/g,
      '  private readonly $2 = this.page.locator(`$1`);'
    );
    
    // Convert @FindBy JSON format (this worked before)
    result = result.replace(
      /@FindBy\(locator = "\{.*?"locator":\s*"xpath=([^"]+)".*?\}"\)\s*public\s+CSWebElement\s+(\w+);/g,
      '  private readonly $2 = this.page.locator(`$1`);'
    );
    
    // Convert method-style element declarations
    const methodRegex = /public\s+CSWebElement\s+(\w+)\(String\s+(\w+)\)\s*\{[\s\S]*?return new CSWebElement\(.*?"xpath=([^']+)'"\s*\+\s*(\w+)\s*\+\s*"'([^"]+)".*?\);\s*\}/g;
    
    // Extract method declarations and convert them one by one
    let match;
    while ((match = methodRegex.exec(content)) !== null) {
      const [fullMatch, methodName, paramName, prefix, param, suffix] = match;
      const converted = `  private ${methodName} = (${paramName}) => this.page.locator(\`${prefix}\${${paramName}}${suffix}\`);`;
      
      // Replace the method declaration in the result
      result = result.replace(fullMatch, converted);
    }
    
    // Clean up Java imports and package declarations
    result = result.replace(/import\s+[^;]+;/g, '');
    result = result.replace(/package\s+[^;]+;/g, '');
    
    // Clean up any multiple line breaks
    result = result.replace(/\n\s*\n\s*\n/g, '\n\n');
    
    // Write the output file
    const outputDir = path.dirname(outputFile);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    fs.writeFileSync(outputFile, result);
    console.log(`Conversion completed: ${outputFile}`);
    
  } catch (error) {
    console.error(`Error converting file: ${error.message}`);
  }
}

// Process a directory
function processDirectory(inputDir, outputDir) {
  const files = getJavaFiles(inputDir);
  console.log(`Found ${files.length} Java files to process`);
  
  files.forEach(file => {
    const relativePath = path.relative(inputDir, file);
    const outputFile = path.join(outputDir, relativePath.replace('.java', '.ts'));
    convertFile(file, outputFile);
  });
  
  console.log('Conversion process completed.');
}

// Get all Java files in a directory and its subdirectories
function getJavaFiles(dir) {
  const files = [];
  
  const items = fs.readdirSync(dir);
  
  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stat = fs.statSync(fullPath);
    
    if (stat.isDirectory()) {
      files.push(...getJavaFiles(fullPath));
    } else if (item.endsWith('.java')) {
      files.push(fullPath);
    }
  });
  
  return files;
}

// Get command line arguments
const args = process.argv.slice(2);
const inputDir = args[0];
const outputDir = args[1];

if (!inputDir || !outputDir) {
  console.error('Usage: node simple-converter.js <input-directory> <output-directory>');
  process.exit(1);
}

// Run the conversion
console.log(`Converting files from ${inputDir} to ${outputDir}`);
processDirectory(inputDir, outputDir);
