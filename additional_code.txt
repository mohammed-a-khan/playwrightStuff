#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

/**
 * QAF BDD Selenium Java to Playwright TypeScript Converter
 */
function convertFile(inputFile: string, outputFile: string): void {
  try {
    console.log(`Reading ${inputFile}...`);
    if (!fs.existsSync(inputFile)) {
      console.error(`Error: Input file ${inputFile} does not exist`);
      process.exit(1);
    }
    
    const content = fs.readFileSync(inputFile, 'utf8');
    debugLog(`File content length: ${content.length} characters`);
    
    // Extract class and package information
    const packageInfo = extractPackageInfo(content);
    debugLog(`Package info: ${packageInfo || 'Not found'}`);
    
    const className = extractClassName(content) || path.basename(inputFile, '.java');
    debugLog(`Class name: ${className}`);
    
    // Process elements by type
    console.log('Extracting standard elements...');
    const standardElements = extractAndConvertElements(content, 'CSWebElement');
    debugLog(`Found ${standardElements.length} standard elements`);
    
    console.log('Extracting dropdown elements...');
    const dropdownElements = extractAndConvertElements(content, 'CSDropDownListWebElement');
    debugLog(`Found ${dropdownElements.length} dropdown elements`);
    
    // Process dynamic locator methods by return type
    console.log('Extracting standard methods...');
    const standardMethods = extractAndConvertMethods(content, 'CSWebElement');
    debugLog(`Found ${standardMethods.length} standard methods`);
    
    console.log('Extracting dropdown methods...');
    const dropdownMethods = extractAndConvertMethods(content, 'CSDropDownListWebElement');
    debugLog(`Found ${dropdownMethods.length} dropdown methods`);
    
    // Detailed debug output for each element and method if in debug mode
    if (DEBUG) {
      debugLog('Standard Elements:');
      standardElements.forEach((el, idx) => {
        debugLog(`${idx + 1}. ${el.originalName} => ${el.locator}`);
      });
      
      debugLog('Dropdown Elements:');
      dropdownElements.forEach((el, idx) => {
        debugLog(`${idx + 1}. ${el.originalName} => ${el.locator}`);
      });
      
      debugLog('Standard Methods:');
      standardMethods.forEach((method, idx) => {
        debugLog(`${idx + 1}. ${method.name}(${method.params.map(p => p.type + ' ' + p.name).join(', ')}) => ${method.locator}`);
      });
      
      debugLog('Dropdown Methods:');
      dropdownMethods.forEach((method, idx) => {
        debugLog(`${idx + 1}. ${method.name}(${method.params.map(p => p.type + ' ' + p.name).join(', ')}) => ${method.locator}`);
      });
    }
    
    // Generate the final TypeScript output
    console.log('Generating TypeScript output...');
    const finalOutput = generateTypeScriptOutput(
      className, 
      packageInfo,
      standardElements, 
      dropdownElements,
      standardMethods, 
      dropdownMethods
    );
    
    // Write the result
    const outputDir = path.dirname(outputFile);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    fs.writeFileSync(outputFile, finalOutput);
    console.log(`Converted file successfully written to ${outputFile}`);
  } catch (error) {
    console.error(`Error converting file: ${error instanceof Error ? error.message : String(error)}`);
    if (error instanceof Error && error.stack) {
      console.error(error.stack);
    }
    process.exit(1);
  }
}

/**
 * Extract the package name from Java content
 */
function extractPackageInfo(content: string): string | null {
  const packageMatch = content.match(/package\s+([\w.]+)\s*;/);
  return packageMatch ? packageMatch[1] : null;
}

/**
 * Extract the class name from Java content
 */
function extractClassName(content: string): string | null {
  const classMatch = content.match(/public\s+class\s+(\w+)/);
  return classMatch ? classMatch[1] : null;
}

interface ElementInfo {
  name: string;
  originalName: string;
  locator: string;
  type: string;
}

/**
 * Extract and convert elements of a specific type from Java to Playwright format
 */
function extractAndConvertElements(content: string, elementType: string): ElementInfo[] {
  const elementsList: ElementInfo[] = [];
  
  // FindBy pattern for both CSWebElement and CSDropDownListWebElement
  const findByRegex = new RegExp(
    `@FindBy\\(locator\\s*=\\s*"(.*?)"\\)\\s*(?:public|private|protected)?\\s*${elementType}\\s+(\\w+)\\s*;`, 
    'gs'
  );
  
  // Process elements
  let match: RegExpExecArray | null;
  while ((match = findByRegex.exec(content)) !== null) {
    const locatorStr = match[1];
    const elementName = match[2];
    
    debugLog(`\nFound ${elementType}: ${elementName}`);
    debugLog(`Locator string: ${locatorStr}`);
    
    const locatorValue = extractLocatorValue(locatorStr);
    debugLog(`Extracted locator value: ${locatorValue}`);
    
    elementsList.push({
      name: elementName.charAt(0).toLowerCase() + elementName.slice(1),
      originalName: elementName,
      locator: locatorValue,
      type: elementType
    });
  }
  
  return elementsList;
}

/**
 * Extract locator value from various formats
 */
function extractLocatorValue(locatorStr: string): string {
  // Debug the input
  debugLog(`Extracting locator from: ${locatorStr}`);
  debugLog(`String starts with: "${locatorStr.substring(0, 10)}..."`);
  
  // Check for both escaped and unescaped versions of "locator"
  const hasEscapedLocator = locatorStr.includes('\\"locator\\"');
  const hasUnescapedLocator = locatorStr.includes('"locator"');
  
  debugLog(`String contains: escaped "locator": ${hasEscapedLocator} | unescaped "locator": ${hasUnescapedLocator}`);
  
  // Handle JSON format with {"locator":"xpath=..."}
  if (hasEscapedLocator || hasUnescapedLocator) {
    debugLog('Found "locator" keyword in string (escaped or unescaped)');
    try {
      // Check if we need to parse a real JSON or just extract with regex
      let locatorObj;
      
      // Extract the locator value directly using regex - most reliable method
      debugLog('Attempting direct regex extraction with both escaped and unescaped patterns');
      
      // Patterns for both escaped and unescaped formats
      const escapedXpathPattern = /\\"locator\\"\\s*:\\s*\\"xpath=([^"]+)\\"/;
      const escapedPathPattern = /\\"locator\\"\\s*:\\s*\\"path=([^"]+)\\"/;
      const unescapedXpathPattern = /"locator"\s*:\s*"xpath=([^"]+)"/;
      const unescapedPathPattern = /"locator"\s*:\s*"path=([^"]+)"/;
      
      // Try each pattern
      let match = null;
      let extractedLocator = null;
      
      // Check escaped xpath format
      match = locatorStr.match(escapedXpathPattern);
      if (match && match[1]) {
        extractedLocator = match[1];
        debugLog(`Found xpath from escaped pattern: ${extractedLocator}`);
        return extractedLocator;
      }
      
      // Check escaped path format
      match = locatorStr.match(escapedPathPattern);
      if (match && match[1]) {
        extractedLocator = match[1];
        debugLog(`Found path from escaped pattern: ${extractedLocator}`);
        return extractedLocator;
      }
      
      // Check unescaped xpath format
      match = locatorStr.match(unescapedXpathPattern);
      if (match && match[1]) {
        extractedLocator = match[1];
        debugLog(`Found xpath from unescaped pattern: ${extractedLocator}`);
        return extractedLocator;
      }
      
      // Check unescaped path format
      match = locatorStr.match(unescapedPathPattern);
      if (match && match[1]) {
        extractedLocator = match[1];
        debugLog(`Found path from unescaped pattern: ${extractedLocator}`);
        return extractedLocator;
      }
        
        debugLog(`Attempting to parse JSON: ${fixedJson}`);
        
        // Handle cases where there might be unescaped quotes inside the string
        try {
          locatorObj = JSON.parse(fixedJson);
          debugLog('JSON parsed successfully:', locatorObj);
        } catch (parseError) {
          // If parsing fails, try to extract the main parts with regex
          debugLog(`JSON parsing failed, trying regex: ${parseError instanceof Error ? parseError.message : String(parseError)}`);
        }
      }
      
      // If we have a valid locator object from JSON parsing
      if (locatorObj && locatorObj.locator && typeof locatorObj.locator === 'string') {
        const locatorValue = locatorObj.locator;
        debugLog(`Found locator from JSON: ${locatorValue}`);
        
        // Remove prefix like xpath= or path=
        if (locatorValue.startsWith('xpath=')) {
          return locatorValue.substring(6);
        } else if (locatorValue.startsWith('path=')) {
          return locatorValue.substring(5);
        } else {
          return locatorValue;
        }
      } else {
        // If JSON parsing failed or didn't yield expected results, try regex
        debugLog('JSON parsing did not yield expected results, trying regex');
        const locatorMatch = locatorStr.match(/"locator"\s*:\s*"([^"]+)"/);
        if (locatorMatch && locatorMatch[1]) {
          const fullLocator = locatorMatch[1];
          debugLog(`Found locator from regex: ${fullLocator}`);
          
          if (fullLocator.startsWith('xpath=')) {
            return fullLocator.substring(6);
          } else if (fullLocator.startsWith('path=')) {
            return fullLocator.substring(5);
          } else {
            return fullLocator;
          }
        }
      }
    } catch (e) {
      console.warn(`Error extracting JSON locator: ${e instanceof Error ? e.message : String(e)}`);
      debugLog('Error details:', e);
      
      // Last resort: try simple regex for just the path
      debugLog('Trying last resort regex patterns');
      const pathMatch = locatorStr.match(/path=([^"]+)/);
      if (pathMatch && pathMatch[1]) {
        debugLog(`Found path match: ${pathMatch[1]}`);
        return pathMatch[1];
      }
      
      const xpathMatch = locatorStr.match(/xpath=([^"]+)/);
      if (xpathMatch && xpathMatch[1]) {
        debugLog(`Found xpath match: ${xpathMatch[1]}`);
        return xpathMatch[1];
      }
    }
  } else if (locatorStr.startsWith('xpath=')) {
    // Direct xpath format
    return locatorStr.substring(6);
  } else if (locatorStr.startsWith('path=')) {
    // Direct path format
    return locatorStr.substring(5);
  }
  
  // For simple direct locators without prefix
  const directXpathMatch = locatorStr.match(/^\/\/.+/);
  if (directXpathMatch) {
    return locatorStr;
  }
  
  // Default - just return as is, but log a warning
  console.warn(`Could not extract locator properly from: ${locatorStr.substring(0, 50)}...`);
  return locatorStr;
}

interface MethodParam {
  type: string;
  name: string;
}

interface MethodInfo {
  name: string;
  params: MethodParam[];
  locator: string;
  type: string;
}

/**
 * Extract and convert all dynamic locator methods for a specific return type
 */
function extractAndConvertMethods(content: string, returnType: string): MethodInfo[] {
  const methodsList: MethodInfo[] = [];
  
  // Find all methods that return the specified element type
  const methodRegex = new RegExp(
    `(?:public|private|protected)\\s+${returnType}\\s+(\\w+)\\s*\\(([^)]*)\\)\\s*\\{([\\s\\S]*?)return\\s+new\\s+${returnType}\\s*\\(([\\s\\S]*?)\\)\\s*;\\s*\\}`, 
    'gs'
  );
  
  let methodMatch: RegExpExecArray | null;
  while ((methodMatch = methodRegex.exec(content)) !== null) {
    try {
      const methodName = methodMatch[1];
      const params = methodMatch[2] || '';
      const methodBody = methodMatch[3] || '';
      const constructorArgs = methodMatch[4] || '';
      
      // Extract parameter information
      const paramsList = params.split(',').map(param => {
        const parts = param.trim().split(/\s+/);
        // Handle syntax errors in the Java code
        if (parts.length < 2) return null;
        
        // Fix common typos in the Java code
        let paramType = parts[0].replace(/Sring/, 'String');
        let paramName = parts[1].replace(/["']/g, ''); // Remove any quotes
        
        return { type: paramType, name: paramName };
      }).filter((param): param is MethodParam => param !== null);
      
      // Try to extract locator pattern
      const locator = extractDynamicLocator(constructorArgs, methodBody, paramsList);
      
      // Create the converted method
      methodsList.push({
        name: methodName,
        params: paramsList,
        locator: locator,
        type: returnType
      });
    } catch (error) {
      console.warn(`Warning: Failed to process method matching ${methodMatch[1]}: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  return methodsList;
}

/**
 * Extract dynamic locator from method body and constructor args
 */
function extractDynamicLocator(constructorArgs: string, methodBody: string, paramsList: MethodParam[]): string {
  let locator = "";
  
  try {
    // JSON locator pattern with concatenation
    const jsonConcatPattern = /"locator"\s*:\s*"xpath=([^"]*?)"\s*\+\s*(\w+)\s*\+\s*"([^"]*?)"/;
    const match = constructorArgs.match(jsonConcatPattern);
    
    if (match) {
      const prefix = match[1] || '';
      const variable = match[2] || '';
      const suffix = match[3] || '';
      
      // Find which parameter this variable refers to
      const param = paramsList.find(p => p.name === variable);
      if (param) {
        locator = `${prefix}\${${variable}}${suffix}`;
      } else {
        // It might be a method call
        const methodCallPattern = new RegExp(`(\\w+)\\(([^)]*)\\)`, 'g');
        const methodCallMatch = methodCallPattern.exec(constructorArgs);
        if (methodCallMatch) {
          const methodName = methodCallMatch[1];
          const methodParams = methodCallMatch[2];
          
          // Look for the method definition
          const methodDefPattern = new RegExp(`String\\s+${methodName}\\s*\\(([^)]*)\\)\\s*\\{([\\s\\S]*?)return\\s+"([^"]*)"\\s*\\+\\s*(\\w+)\\s*\\+\\s*"([^"]*)"`, 'g');
          const methodDefMatch = methodDefPattern.exec(methodBody);
          
          if (methodDefMatch) {
            const returnPrefix = methodDefMatch[3] || '';
            const returnVar = methodDefMatch[4] || '';
            const returnSuffix = methodDefMatch[5] || '';
            
            // Use the parameters from the method call
            const methodCallParams = methodParams.split(',').map(p => p.trim());
            if (methodCallParams.length > 0) {
              locator = `${returnPrefix}\${${methodCallParams[0]}}${returnSuffix}`;
            }
          }
        }
      }
    } else {
      // Try direct pattern for method calls in constructor arguments
      const methodPattern = new RegExp(`(\\w+)\\(([^)]*)\\)\\+?"([^"]*?)"\s*\\+\\s*(\\w+)\\s*\\+\\s*"([^"]*)"`, 'g');
      const methodMatch = methodPattern.exec(constructorArgs);
      
      if (methodMatch) {
        const methodName = methodMatch[1];
        const methodParams = methodMatch[2];
        const midText = methodMatch[3] || '';
        const variable = methodMatch[4] || '';
        const suffix = methodMatch[5] || '';
        
        // Look for the method implementation
        const methodImplPattern = new RegExp(`String\\s+${methodName}\\s*\\(([^)]*)\\)\\s*\\{([\\s\\S]*?)return\\s+"([^"]*)"\\s*\\+\\s*(\\w+)\\s*\\+\\s*"([^"]*)"`, 'g');
        const methodImplMatch = methodImplPattern.exec(methodBody);
        
        if (methodImplMatch) {
          const returnPrefix = methodImplMatch[3] || '';
          const returnVar = methodImplMatch[4] || '';
          const returnSuffix = methodImplMatch[5] || '';
          
          // Use the parameters from the method call
          const methodCallParams = methodParams.split(',').map(p => p.trim());
          if (methodCallParams.length > 0) {
            locator = `${returnPrefix}\${${methodCallParams[0]}}${returnSuffix}${midText}\${${variable}}${suffix}`;
          }
        } else {
          // If method implementation not found, make a best guess
          locator = `\${${methodName}(${methodParams})}${midText}\${${variable}}${suffix}`;
        }
      } else {
        // Final fallback for simple string concatenation
        const simpleConcatPattern = /"([^"]*?)"\s*\+\s*(\w+)\s*\+\s*"([^"]*?)"/;
        const simpleConcatMatch = constructorArgs.match(simpleConcatPattern);
        
        if (simpleConcatMatch) {
          const prefix = simpleConcatMatch[1] || '';
          const variable = simpleConcatMatch[2] || '';
          const suffix = simpleConcatMatch[3] || '';
          
          locator = `${prefix}\${${variable}}${suffix}`;
        }
      }
    }
  } catch (error) {
    console.warn(`Warning: Failed to extract dynamic locator: ${error instanceof Error ? error.message : String(error)}`);
  }
  
  // If all patterns failed, create a placeholder
  if (!locator) {
    locator = `//TODO-CONVERT-LOCATOR-FOR-PARAMETERS-${paramsList.map(p => p.name).join('-')}`;
  }
  
  return locator;
}

/**
 * Generate the final TypeScript output
 */
function generateTypeScriptOutput(
  className: string, 
  packageInfo: string | null,
  standardElements: ElementInfo[], 
  dropdownElements: ElementInfo[],
  standardMethods: MethodInfo[], 
  dropdownMethods: MethodInfo[]
): string {
  // Build imports
  let output = `// Converted from ${packageInfo ? packageInfo + '.' : ''}${className}\n`;
  output += `import { Page, Locator } from '@playwright/test';\n\n`;
  
  // Add helper interface for dropdown interaction
  output += `// Helper interface for dropdown functionality\n`;
  output += `interface DropdownOptions {\n`;
  output += `  selectByText: (text: string) => Promise<void>;\n`;
  output += `  selectByValue: (value: string) => Promise<void>;\n`;
  output += `  selectByIndex: (index: number) => Promise<void>;\n`;
  output += `  getOptions: () => Promise<string[]>;\n`;
  output += `}\n\n`;
  
  // Start class definition
  output += `export class ${className} {\n`;
  output += `  constructor(private page: Page) {}\n\n`;
  
  // Add standard element locators
  if (standardElements.length > 0) {
    output += `  // Standard Element Locators\n`;
    standardElements.forEach(element => {
      output += `  private readonly ${element.name} = \`${element.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add dropdown element locators
  if (dropdownElements.length > 0) {
    output += `  // Dropdown Element Locators\n`;
    dropdownElements.forEach(element => {
      output += `  private readonly ${element.name} = \`${element.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add standard dynamic locator methods
  if (standardMethods.length > 0) {
    output += `  // Dynamic Standard Locators\n`;
    standardMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      output += `  private readonly ${method.name} = (${paramList}): string => \`${method.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add dropdown dynamic locator methods
  if (dropdownMethods.length > 0) {
    output += `  // Dynamic Dropdown Locators\n`;
    dropdownMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      output += `  private readonly ${method.name} = (${paramList}): string => \`${method.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add getters for standard elements
  if (standardElements.length > 0) {
    output += `  // Standard Element Getters\n`;
    standardElements.forEach(element => {
      const capitalizedName = element.originalName;
      output += `  get ${capitalizedName}(): Locator {\n`;
      output += `    return this.page.locator(this.${element.name});\n`;
      output += `  }\n\n`;
    });
  }
  
  // Add getters for dropdown elements
  if (dropdownElements.length > 0) {
    output += `  // Dropdown Element Getters with enhanced functionality\n`;
    dropdownElements.forEach(element => {
      const capitalizedName = element.originalName;
      output += `  get ${capitalizedName}(): Locator & DropdownOptions {\n`;
      output += `    const baseLocator = this.page.locator(this.${element.name});\n`;
      output += `    \n`;
      output += `    // Add dropdown specific functionality\n`;
      output += `    const dropdown = baseLocator as Locator & DropdownOptions;\n`;
      output += `    \n`;
      output += `    dropdown.selectByText = async (text: string): Promise<void> => {\n`;
      output += `      await baseLocator.selectOption({ label: text });\n`;
      output += `    };\n`;
      output += `    \n`;
      output += `    dropdown.selectByValue = async (value: string): Promise<void> => {\n`;
      output += `      await baseLocator.selectOption({ value });\n`;
      output += `    };\n`;
      output += `    \n`;
      output += `    dropdown.selectByIndex = async (index: number): Promise<void> => {\n`;
      output += `      await baseLocator.selectOption({ index });\n`;
      output += `    };\n`;
      output += `    \n`;
      output += `    dropdown.getOptions = async (): Promise<string[]> => {\n`;
      output += `      return baseLocator.locator('option').allTextContents();\n`;
      output += `    };\n`;
      output += `    \n`;
      output += `    return dropdown;\n`;
      output += `  }\n\n`;
    });
  }
  
  // Add methods for standard dynamic locators
  if (standardMethods.length > 0) {
    output += `  // Dynamic Standard Element Getters\n`;
    standardMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      const paramNames = method.params.map(p => p.name).join(', ');
      
      output += `  ${method.name}(${paramList}): Locator {\n`;
      output += `    return this.page.locator(this.${method.name}(${paramNames}));\n`;
      output += `  }\n\n`;
    });
  }
  
  // Add methods for dropdown dynamic locators
  if (dropdownMethods.length > 0) {
    output += `  // Dynamic Dropdown Element Getters\n`;
    dropdownMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      const paramNames = method.params.map(p => p.name).join(', ');
      
      output += `  ${method.name}(${paramList}): Locator & DropdownOptions {\n`;
      output += `    const baseLocator = this.page.locator(this.${method.name}(${paramNames}));\n`;
      output += `    \n`;
      output += `    // Add dropdown specific functionality\n`;
      output += `    const dropdown = baseLocator as Locator & DropdownOptions;\n`;
      output += `    \n`;
      output += `    dropdown.selectByText = async (text: string): Promise<void> => {\n`;
      output += `      await baseLocator.selectOption({ label: text });\n`;
      output += `    };\n`;
      output += `    \n`;
      output += `    dropdown.selectByValue = async (value: string): Promise<void> => {\n`;
      output += `      await baseLocator.selectOption({ value });\n`;
      output += `    };\n`;
      output += `    \n`;
      output += `    dropdown.selectByIndex = async (index: number): Promise<void> => {\n`;
      output += `      await baseLocator.selectOption({ index });\n`;
      output += `    };\n`;
      output += `    \n`;
      output += `    dropdown.getOptions = async (): Promise<string[]> => {\n`;
      output += `      return baseLocator.locator('option').allTextContents();\n`;
      output += `    };\n`;
      output += `    \n`;
      output += `    return dropdown;\n`;
      output += `  }\n\n`;
    });
  }
  
  // Common page actions converted from the original class
  output += `  // Common Page Actions\n`;
  output += `  async waitForPageToLoad(): Promise<void> {\n`;
  output += `    await this.page.waitForLoadState('networkidle');\n`;
  output += `  }\n\n`;
  
  output += `  async clickBurgerMenu(): Promise<void> {\n`;
  output += `    await this.BurgerMenu.click();\n`;
  output += `  }\n\n`;
  
  output += `  async clickReportsLink(): Promise<void> {\n`;
  output += `    await this.ReportsLink.click();\n`;
  output += `  }\n\n`;
  
  output += `  async sleep(ms: number): Promise<void> {\n`;
  output += `    return new Promise(resolve => setTimeout(resolve, ms));\n`;
  output += `  }\n`;
  
  // Close class
  output += `}\n`;
  
  return output;
}

/**
 * Map Java types to TypeScript types
 */
function mapJavaTypeToTypeScript(javaType: string): string {
  const typeMap: Record<string, string> = {
    'String': 'string',
    'int': 'number',
    'Integer': 'number',
    'boolean': 'boolean',
    'Boolean': 'boolean',
    'double': 'number',
    'Double': 'number',
    'long': 'number',
    'Long': 'number',
    'float': 'number',
    'Float': 'number',
    'Object': 'any',
    'List': 'Array<any>',
    'ArrayList': 'Array<any>',
    'Map': 'Record<string, any>',
    'HashMap': 'Record<string, any>'
  };
  
  // Check for generic types like List<String>
  const genericMatch = javaType.match(/(\w+)<(\w+)>/);
  if (genericMatch) {
    const container = genericMatch[1];
    const innerType = genericMatch[2];
    
    if (container === 'List' || container === 'ArrayList') {
      return `Array<${mapJavaTypeToTypeScript(innerType)}>`;
    } else if (container === 'Map' || container === 'HashMap') {
      return `Record<string, ${mapJavaTypeToTypeScript(innerType)}>`;
    }
  }
  
  return typeMap[javaType] || 'any';
}

// Global debug flag
let DEBUG = false;

/**
 * Debug logging function
 */
function debugLog(...args: any[]): void {
  if (DEBUG) {
    console.log('[DEBUG]', ...args);
  }
}

// Process command line arguments
if (require.main === module) {
  const args = process.argv.slice(2);
  
  // Check for debug flag
  if (args.includes('--debug') || args.includes('-d')) {
    DEBUG = true;
    // Remove debug flag from args
    const debugIndex = args.indexOf('--debug') !== -1 ? args.indexOf('--debug') : args.indexOf('-d');
    args.splice(debugIndex, 1);
    console.log('Running in DEBUG mode - verbose logging enabled');
  }
  
  if (args.length !== 2) {
    console.log('Usage: node qaf-to-playwright-converter.js [--debug|-d] <input-file> <output-file>');
    process.exit(1);
  }
  
  // Convert the file
  convertFile(args[0], args[1]);
}

module.exports = {
  convertFile
};
