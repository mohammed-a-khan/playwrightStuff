import * as fs from 'fs';
import * as path from 'path';

/**
 * Enhanced QAF to Playwright Converter
 * Specifically handles @FindBy patterns and method-style element declarations
 */
function convertFile(inputFile: string, outputFile: string): void {
  console.log(`Converting ${inputFile} to ${outputFile}`);
  
  try {
    // Read the file
    let content = fs.readFileSync(inputFile, 'utf8');
    
    // Remove Java-style comments
    content = content.replace(/\/\/.*$/gm, ''); // Remove single-line comments
    content = content.replace(/\/\*[\s\S]*?\*\//g, ''); // Remove multi-line comments
    
    // Add Playwright imports at the top of the file
    content = "import { Page, Locator } from '@playwright/test';\n\n" + content;
    
    // Convert classes
    content = content.replace(
      /public\s+class\s+(\w+)(?:\s+extends\s+(\w+))?\s*\{/g,
      (match: string, className: string, parentClass?: string) => {
        if (parentClass) {
          return `export class ${className} extends ${parentClass} {\n  constructor(private page: Page) {\n    super(page);\n  }\n`;
        } else {
          return `export class ${className} {\n  constructor(private page: Page) {}\n`;
        }
      }
    );
    
    // Convert @FindBy with JSON format (with double quotes)
    content = content.replace(
      /@FindBy\s*\(\s*locator\s*=\s*"(\{.*?\"locator\":\s*\"xpath=([^\"]+)\".*?\})"\s*\)\s*public\s+CSWebElement\s+(\w+)\s*;/g,
      (match: string, jsonStr: string, xpathValue: string, elementName: string) => {
        return `  private readonly ${elementName} = this.page.locator(\`${xpathValue}\`);`;
      }
    );
    
    // Convert @FindBy with direct xpath
    content = content.replace(
      /@FindBy\s*\(\s*locator\s*=\s*"xpath=([^\"]+)"\s*\)\s*public\s+CSWebElement\s+(\w+)\s*;/g,
      (match: string, xpathValue: string, elementName: string) => {
        return `  private readonly ${elementName} = this.page.locator(\`${xpathValue}\`);`;
      }
    );
    
    // Method-style element declarations - more flexible pattern
    content = content.replace(
      /public\s+CSWebElement\s+(\w+)\s*\(\s*String\s+(\w+)\s*\)\s*\{\s*return\s+new\s+CSWebElement\s*\(\s*"(.*?)"\s*\+\s*(\w+)\s*\+\s*"(.*?)"\s*\)\s*;\s*\}/g,
      (match: string, methodName: string, paramName: string, prefix: string, paramRef: string, suffix: string) => {
        // Extract xpath from the prefix if it's in JSON format
        let xpathPrefix = prefix;
        const jsonMatch = prefix.match(/\{.*?"locator":\s*"xpath=([^"]+)/);
        if (jsonMatch) {
          xpathPrefix = jsonMatch[1];
        } else if (prefix.includes("xpath=")) {
          xpathPrefix = prefix.split("xpath=")[1];
        }
        
        return `  private ${methodName} = (${paramName}: string): Locator => this.page.locator(\`${xpathPrefix}\${${paramName}}${suffix}\`);`;
      }
    );
    
    // Special case for method-style declarations with JSON string
    content = content.replace(
      /public\s+CSWebElement\s+(\w+)\s*\(\s*String\s+(\w+)\s*\)\s*\{\s*return\s+new\s+CSWebElement\s*\(\s*"\{\\?"locator\\?":\s*\\?"xpath=([^']+)'"\s*\+\s*(\w+)\s*\+\s*"'([^\"]+)\\?".*?\}"\s*\)\s*;\s*\}/g,
      (match: string, methodName: string, paramName: string, prefix: string, paramRef: string, suffix: string) => {
        return `  private ${methodName} = (${paramName}: string): Locator => this.page.locator(\`${prefix}\${${paramName}}${suffix}\`);`;
      }
    );
    
    // Clean up Java imports and package declarations
    content = content.replace(/import\s+[^;]+;/g, '');
    content = content.replace(/package\s+[^;]+;/g, '');
    
    // Clean up empty lines
    content = content.replace(/\n\s*\n\s*\n/g, '\n\n');
    
    // Write the output file
    const outputDir = path.dirname(outputFile);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    fs.writeFileSync(outputFile, content);
    console.log(`Conversion completed: ${outputFile}`);
    
  } catch (error) {
    console.error(`Error converting file: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Process a directory
function processDirectory(inputDir: string, outputDir: string): void {
  const files = getJavaFiles(inputDir);
  console.log(`Found ${files.length} Java files to process`);
  
  files.forEach(file => {
    const relativePath = path.relative(inputDir, file);
    const outputFile = path.join(outputDir, relativePath.replace('.java', '.ts'));
    convertFile(file, outputFile);
  });
  
  console.log('Conversion process completed.');
}

// Get all Java files in a directory and its subdirectories
function getJavaFiles(dir: string): string[] {
  const files: string[] = [];
  
  const items = fs.readdirSync(dir);
  
  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stat = fs.statSync(fullPath);
    
    if (stat.isDirectory()) {
      files.push(...getJavaFiles(fullPath));
    } else if (item.endsWith('.java')) {
      files.push(fullPath);
    }
  });
  
  return files;
}

// Main function with better error handling
function main(): void {
  try {
    // Get command line arguments
    const args = process.argv.slice(2);
    const inputDir = args[0];
    const outputDir = args[1];

    if (!inputDir || !outputDir) {
      console.error('Usage: npx ts-node qaf-converter.ts <input-directory> <output-directory>');
      process.exit(1);
    }

    // Check if directories exist
    if (!fs.existsSync(inputDir)) {
      console.error(`Input directory does not exist: ${inputDir}`);
      process.exit(1);
    }

    // Create output directory if it doesn't exist
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Run the conversion
    console.log(`Converting files from ${inputDir} to ${outputDir}`);
    processDirectory(inputDir, outputDir);
    
  } catch (error) {
    console.error('Error during conversion:', error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}

// Run the program
main();
