#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

/**
 * Simple focused converter that directly addresses your example
 */
function convertFile(inputFile, outputFile) {
  console.log(`Reading ${inputFile}...`);
  const content = fs.readFileSync(inputFile, 'utf8');
  
  // First convert all element declarations
  let convertedContent = convertElements(content);
  
  // Then convert the dynamic locator methods
  convertedContent = convertMethods(content, convertedContent);
  
  // Create basic class structure
  const className = path.basename(inputFile, '.java');
  let finalOutput = `import { Page, Locator } from '@playwright/test';\n\n`;
  finalOutput += `export class ${className} {\n`;
  finalOutput += `  constructor(private page: Page) {}\n\n`;
  finalOutput += convertedContent;
  finalOutput += `}\n`;
  
  // Write the result
  const outputDir = path.dirname(outputFile);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  fs.writeFileSync(outputFile, finalOutput);
  console.log(`Converted file written to ${outputFile}`);
}

/**
 * Convert @FindBy elements to the requested format
 */
function convertElements(content) {
  // Extract all @FindBy elements
  const elementRegex = /@FindBy\(locator\s*=\s*"(.*?)"\)\s*(?:public|private|protected)?\s*CSWebElement\s+(\w+)\s*;/gs;
  
  let convertedContent = content;
  let elements = [];
  
  // Find all element declarations
  let match;
  while ((match = elementRegex.exec(content)) !== null) {
    const locatorStr = match[1];
    const elementName = match[2];
    const fullMatch = match[0];
    
    // Extract the locator value
    let locatorValue = extractLocatorValue(locatorStr);
    
    // Create the new declaration in typescript format
    const newElement = `  private readonly ${elementName.charAt(0).toLowerCase() + elementName.slice(1)} = "${locatorValue}";\n`;
    elements.push(newElement);
    
    // Remove the original declaration
    convertedContent = convertedContent.replace(fullMatch, '');
  }
  
  // Return just the element declarations
  return elements.join('\n');
}

/**
 * Extract the actual locator value from the locator string
 */
function extractLocatorValue(locatorStr) {
  // Handle JSON format with {"locator":"xpath=..."}
  if (locatorStr.includes('{"locator"')) {
    try {
      // Fix JSON string by replacing escaped quotes
      const fixedJson = locatorStr.replace(/\\"/g, '"');
      // Parse JSON
      const locatorObj = JSON.parse(fixedJson);
      if (locatorObj.locator) {
        // Remove locator prefix
        if (locatorObj.locator.startsWith('xpath=')) {
          return locatorObj.locator.substring(6);
        } else if (locatorObj.locator.startsWith('path=')) {
          return locatorObj.locator.substring(5);
        } else {
          return locatorObj.locator;
        }
      }
    } catch (e) {
      // If JSON parsing fails, try regex
      const locatorMatch = locatorStr.match(/"locator"\s*:\s*"([^"]+)"/);
      if (locatorMatch) {
        const fullLocator = locatorMatch[1];
        if (fullLocator.startsWith('xpath=')) {
          return fullLocator.substring(6);
        } else if (fullLocator.startsWith('path=')) {
          return fullLocator.substring(5);
        } else {
          return fullLocator;
        }
      }
    }
  } else if (locatorStr.startsWith('xpath=')) {
    // Direct xpath format
    return locatorStr.substring(6);
  }
  
  // Default - just return as is
  return locatorStr;
}

/**
 * Convert dynamic locator methods
 * @param {string} content - The original file content
 * @param {string} elementsOutput - The already converted elements output
 */
function convertMethods(content, elementsOutput) {
  // Find and convert methods from the actual file content
  let methodsOut = '';
  
  // Find all function declarations that return CSWebElement
  const methodRegex = /public\s+CSWebElement\s+(\w+)\s*\(\s*String\s+(\w+)(?:,\s*String\s+(\w+))?\s*\)\s*\{[\s\S]*?return\s+new\s+CSWebElement\s*\([\s\S]*?\)\s*;\s*\}/gs;
  
  let methodMatch;
  while ((methodMatch = methodRegex.exec(content)) !== null) {
    const fullMethod = methodMatch[0];
    const methodName = methodMatch[1];
    const paramName = methodMatch[2];
    const param2Name = methodMatch[3]; // Optional second parameter
    
    console.log(`Found method: ${methodName} with param: ${paramName} ${param2Name ? 'and ' + param2Name : ''}`);
    
    // Try to extract locator parts
    let locator = "";
    
    // Look for JSON locator with xpath= in it
    const jsonMatch = fullMethod.match(/return\s+new\s+CSWebElement\s*\(\s*".*?locator.*?xpath=([^"]*?)"\s*\+\s*(\w+)\s*\+\s*"([^"]*?)"/s);
    
    if (jsonMatch) {
      const prefix = jsonMatch[1] || '';
      const variable = jsonMatch[2] || '';
      const suffix = jsonMatch[3] || '';
      
      console.log(`Found locator parts: prefix=${prefix}, var=${variable}, suffix=${suffix}`);
      
      // Create the template literal format
      locator = `${prefix}\${${variable}}${suffix}`;
    } else {
      // Try other patterns like double concatenation with two variables
      const complexMatch = fullMethod.match(/return\s+new\s+CSWebElement\s*\(\s*".*?locator.*?xpath=([^"]*?)"\s*\+\s*(\w+)\s*\+\s*"([^"]*?)"\s*\+\s*(\w+)\s*\+\s*"([^"]*?)"/s);
      
      if (complexMatch) {
        const prefix = complexMatch[1] || '';
        const var1 = complexMatch[2] || '';
        const middle = complexMatch[3] || '';
        const var2 = complexMatch[4] || '';
        const suffix = complexMatch[5] || '';
        
        console.log(`Found complex locator: prefix=${prefix}, var1=${var1}, middle=${middle}, var2=${var2}, suffix=${suffix}`);
        
        // Create template literal with both variables
        locator = `${prefix}\${${var1}}${middle}\${${var2}}${suffix}`;
      } else {
        // Fallback - just use a placeholder
        locator = `//TODO-FIX-LOCATOR-FOR-${methodName}`;
      }
    }
    
    // Create the converted method with parameter list matching the original
    let convertedMethod;
    if (param2Name) {
      convertedMethod = `  private readonly ${methodName} = (${paramName}, ${param2Name}) => \`${locator}\`;\n\n`;
    } else {
      convertedMethod = `  private readonly ${methodName} = (${paramName}) => \`${locator}\`;\n\n`;
    }
    
    methodsOut += convertedMethod;
  }
  
  return elementsOutput + '\n' + methodsOut;
}

// Process command line arguments
const args = process.argv.slice(2);
if (args.length !== 2) {
  console.log('Usage: node focused-converter.js <input-file> <output-file>');
  process.exit(1);
}

// Convert the file
convertFile(args[0], args[1]);
