#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

/**
 * Main conversion function that handles the entire process
 */
function convertFile(inputFile, outputFile) {
  try {
    console.log(`Reading ${inputFile}...`);
    if (!fs.existsSync(inputFile)) {
      console.error(`Error: Input file ${inputFile} does not exist`);
      process.exit(1);
    }
    
    const content = fs.readFileSync(inputFile, 'utf8');
    
    // Extract class name from the file content
    const className = extractClassName(content) || path.basename(inputFile, '.java');
    
    // Process elements and methods
    const elements = extractAndConvertElements(content);
    const methods = extractAndConvertMethods(content);
    
    // Generate the final TypeScript output
    const finalOutput = generateTypeScriptOutput(className, elements, methods);
    
    // Write the result
    const outputDir = path.dirname(outputFile);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    fs.writeFileSync(outputFile, finalOutput);
    console.log(`Converted file successfully written to ${outputFile}`);
  } catch (error) {
    console.error(`Error converting file: ${error.message}`);
    process.exit(1);
  }
}

/**
 * Extract the class name from Java content
 */
function extractClassName(content) {
  const classMatch = content.match(/public\s+class\s+(\w+)/);
  return classMatch ? classMatch[1] : null;
}

/**
 * Extract and convert all @FindBy elements from Java to Playwright format
 */
function extractAndConvertElements(content) {
  const elementsList = [];
  
  // Various patterns for element declarations
  const patterns = [
    // Standard @FindBy pattern
    {
      regex: /@FindBy\(locator\s*=\s*"(.*?)"\)\s*(?:public|private|protected)?\s*CSWebElement\s+(\w+)\s*;/gs,
      process: (match) => {
        const locatorStr = match[1];
        const elementName = match[2];
        const locatorValue = extractLocatorValue(locatorStr);
        return {
          name: elementName.charAt(0).toLowerCase() + elementName.slice(1),
          locator: locatorValue
        };
      }
    },
    // Alternative @FindBy pattern with different attribute names
    {
      regex: /@FindBy\((?:xpath|css|id|name|className|tagName)\s*=\s*"(.*?)"\)\s*(?:public|private|protected)?\s*(?:WebElement|CSWebElement)\s+(\w+)\s*;/gs,
      process: (match) => {
        const locatorStr = match[1];
        const elementName = match[2];
        return {
          name: elementName.charAt(0).toLowerCase() + elementName.slice(1),
          locator: locatorStr // Direct locator value
        };
      }
    },
    // Look for elements initialized in constructors or methods
    {
      regex: /(?:this\.)?(\w+)\s*=\s*new\s+CSWebElement\s*\(\s*"(.*?)"\s*\)/gs,
      process: (match) => {
        const elementName = match[1];
        const locatorStr = match[2];
        const locatorValue = extractLocatorValue(locatorStr);
        return {
          name: elementName.charAt(0).toLowerCase() + elementName.slice(1),
          locator: locatorValue
        };
      }
    }
  ];
  
  // Process each pattern
  for (const pattern of patterns) {
    let match;
    while ((match = pattern.regex.exec(content)) !== null) {
      const element = pattern.process(match);
      elementsList.push(`  private readonly ${element.name} = "${element.locator}";`);
    }
  }
  
  return elementsList;
}

/**
 * Extract and convert all dynamic locator methods
 */
function extractAndConvertMethods(content) {
  const methodsList = [];
  
  // Find all methods that return CSWebElement
  const methodRegex = /(?:public|private|protected)\s+CSWebElement\s+(\w+)\s*\(\s*((?:String|int|boolean|[\w<>[\]]+)\s+\w+(?:\s*,\s*(?:String|int|boolean|[\w<>[\]]+)\s+\w+)*)\s*\)\s*\{([\s\S]*?)return\s+new\s+CSWebElement\s*\(([\s\S]*?)\)\s*;\s*\}/gs;
  
  let methodMatch;
  while ((methodMatch = methodRegex.exec(content)) !== null) {
    const methodName = methodMatch[1];
    const params = methodMatch[2];
    const methodBody = methodMatch[3];
    const constructorArgs = methodMatch[4];
    
    // Extract parameter information
    const paramsList = params.split(',').map(param => {
      const parts = param.trim().split(/\s+/);
      return parts[parts.length - 1]; // Get the parameter name
    });
    
    // Try to extract locator pattern
    const locator = extractDynamicLocator(constructorArgs, methodBody, paramsList);
    
    // Format parameters for TS function
    const formattedParams = paramsList.join(', ');
    
    // Create the converted method
    methodsList.push(`  private readonly ${methodName} = (${formattedParams}) => \`${locator}\`;`);
  }
  
  return methodsList;
}

/**
 * Extract locator value from various formats
 */
function extractLocatorValue(locatorStr) {
  // Handle JSON format with {"locator":"xpath=..."}
  if (locatorStr.includes('{"locator"')) {
    try {
      // Fix JSON string by replacing escaped quotes
      const fixedJson = locatorStr.replace(/\\"/g, '"');
      // Parse JSON
      const locatorObj = JSON.parse(fixedJson);
      if (locatorObj.locator) {
        // Remove locator prefix
        if (locatorObj.locator.startsWith('xpath=')) {
          return locatorObj.locator.substring(6);
        } else if (locatorObj.locator.startsWith('path=')) {
          return locatorObj.locator.substring(5);
        } else {
          return locatorObj.locator;
        }
      }
    } catch (e) {
      // If JSON parsing fails, try regex
      const locatorMatch = locatorStr.match(/"locator"\s*:\s*"([^"]+)"/);
      if (locatorMatch) {
        const fullLocator = locatorMatch[1];
        if (fullLocator.startsWith('xpath=')) {
          return fullLocator.substring(6);
        } else if (fullLocator.startsWith('path=')) {
          return fullLocator.substring(5);
        } else {
          return fullLocator;
        }
      }
    }
  } else if (locatorStr.startsWith('xpath=')) {
    // Direct xpath format
    return locatorStr.substring(6);
  }
  
  // Default - just return as is
  return locatorStr;
}

/**
 * Extract dynamic locator from method body and constructor args
 */
function extractDynamicLocator(constructorArgs, methodBody, paramsList) {
  let locator = "";
  
  // Common patterns for locator construction
  
  // Pattern 1: JSON locator with single parameter
  const jsonSinglePattern = /"locator"\s*:\s*"xpath=([^"]*?)"\s*\+\s*(\w+)\s*\+\s*"([^"]*?)"/;
  const match1 = constructorArgs.match(jsonSinglePattern);
  if (match1) {
    const prefix = match1[1] || '';
    const variable = match1[2] || '';
    const suffix = match1[3] || '';
    locator = `${prefix}\${${variable}}${suffix}`;
    return locator;
  }
  
  // Pattern 2: JSON locator with multiple parameters
  const jsonMultiPattern = /"locator"\s*:\s*"xpath=([^"]*?)"\s*\+\s*(\w+)\s*\+\s*"([^"]*?)"\s*\+\s*(\w+)\s*\+\s*"([^"]*?)"/;
  const match2 = constructorArgs.match(jsonMultiPattern);
  if (match2) {
    const prefix = match2[1] || '';
    const var1 = match2[2] || '';
    const middle = match2[3] || '';
    const var2 = match2[4] || '';
    const suffix = match2[5] || '';
    locator = `${prefix}\${${var1}}${middle}\${${var2}}${suffix}`;
    return locator;
  }
  
  // Pattern 3: Method call in the locator
  const methodCallPattern = /getPath\((\w+)\)/;
  const match3 = constructorArgs.match(methodCallPattern);
  if (match3) {
    const methodParam = match3[1];
    // Look for the method definition
    const methodDefPattern = new RegExp(`String\\s+getPath\\s*\\(\\s*String\\s+${methodParam}\\s*\\)\\s*\\{([\\s\\S]*?)\\}`, 'g');
    const methodDefMatch = methodDefPattern.exec(methodBody);
    if (methodDefMatch) {
      const methodDefBody = methodDefMatch[1];
      // Try to extract the logic
      const returnPattern = /return\s+"([^"]*)"\s*\+\s*(\w+)\s*\+\s*"([^"]*)"/;
      const returnMatch = methodDefBody.match(returnPattern);
      if (returnMatch) {
        const prefix = returnMatch[1] || '';
        const variable = returnMatch[2] || '';
        const suffix = returnMatch[3] || '';
        locator = `${prefix}\${${variable}}${suffix}`;
        return locator;
      }
    }
  }
  
  // Pattern 4: Complex string concatenation
  const complexConcatPattern = /"([^"]*)"\s*\+(?:\s*\+)?\s*(\w+)(?:\s*\+\s*"([^"]*)")?/g;
  let stringParts = [];
  let variableParts = [];
  let match4;
  let fullString = constructorArgs;
  
  while ((match4 = complexConcatPattern.exec(fullString)) !== null) {
    if (match4[1]) stringParts.push(match4[1]);
    if (match4[2] && paramsList.includes(match4[2])) {
      variableParts.push(match4[2]);
      stringParts.push(`\${${match4[2]}}`);
    } else if (match4[2]) {
      // It's a variable but not a parameter
      stringParts.push(`[VAR:${match4[2]}]`);
    }
    if (match4[3]) stringParts.push(match4[3]);
  }
  
  if (stringParts.length > 0) {
    locator = stringParts.join('');
    
    // Clean up the locator
    locator = locator.replace(/xpath=/g, '');
    locator = locator.replace(/\[VAR:(\w+)\]/g, (match, varName) => {
      // Try to find variable value in the method body
      const varPattern = new RegExp(`${varName}\\s*=\\s*"([^"]*)"`, 'g');
      const varMatch = varPattern.exec(methodBody);
      return varMatch ? varMatch[1] : `\${${varName}}`;
    });
    
    return locator;
  }
  
  // Fallback - create placeholder with parameter names
  locator = `//TODO-CONVERT-LOCATOR-${paramsList.map(p => `\${${p}}`).join('-')}`;
  return locator;
}

/**
 * Generate the final TypeScript output
 */
function generateTypeScriptOutput(className, elements, methods) {
  let output = `import { Page, Locator } from '@playwright/test';\n\n`;
  output += `export class ${className} {\n`;
  output += `  constructor(private page: Page) {}\n\n`;
  
  // Add elements
  if (elements.length > 0) {
    output += `  // Element Locators\n`;
    output += elements.join('\n') + '\n\n';
  }
  
  // Add methods
  if (methods.length > 0) {
    output += `  // Dynamic Locators\n`;
    output += methods.join('\n\n') + '\n\n';
  }
  
  // Add getter methods for each element
  if (elements.length > 0) {
    output += `  // Element Getters\n`;
    elements.forEach(element => {
      const match = element.match(/private readonly (\w+) = "([^"]*)";/);
      if (match) {
        const elementName = match[1];
        const capitalizedName = elementName.charAt(0).toUpperCase() + elementName.slice(1);
        output += `  get${capitalizedName}() {\n`;
        output += `    return this.page.locator(this.${elementName});\n`;
        output += `  }\n\n`;
      }
    });
  }
  
  // Add getter methods for dynamic locators
  if (methods.length > 0) {
    output += `  // Dynamic Element Getters\n`;
    methods.forEach(method => {
      const match = method.match(/private readonly (\w+) = \(([^)]*)\)/);
      if (match) {
        const methodName = match[1];
        const params = match[2];
        const capitalizedName = methodName.charAt(0).toUpperCase() + methodName.slice(1);
        output += `  get${capitalizedName}(${params}) {\n`;
        output += `    return this.page.locator(this.${methodName}(${params.split(',').map(p => p.trim()).join(', ')}));\n`;
        output += `  }\n\n`;
      }
    });
  }
  
  output += `}\n`;
  return output;
}

// Process command line arguments
const args = process.argv.slice(2);
if (args.length !== 2) {
  console.log('Usage: node java-to-playwright-converter.js <input-file> <output-file>');
  process.exit(1);
}

// Convert the file
convertFile(args[0], args[1]);
