/**
 * Enhanced version of extractAndConvertComplexMethods that properly handles enum switch cases
 * Add this to your existing code without replacing anything
 */
function extractAndConvertComplexMethods(content: string, returnType: string): MethodInfo[] {
  const methodsList: MethodInfo[] = [];
  
  // Special pattern to capture switch methods with element assignment
  // This pattern looks for "element = null" followed by a switch statement
  const switchElementMethodRegex = new RegExp(
    `(?:public|private|protected)\\s+${returnType}\\s+(\\w+)\\s*\\(([^)]*)\\)\\s*\\{\\s*${returnType}\\s+element\\s*=\\s*null;\\s*switch\\s*\\(([^)]*)\\)\\s*\\{([\\s\\S]*?)\\}\\s*return\\s+element;\\s*\\}`, 
    'gs'
  );
  
  let methodMatch: RegExpExecArray | null;
  while ((methodMatch = switchElementMethodRegex.exec(content)) !== null) {
    try {
      const methodName = methodMatch[1];
      const params = methodMatch[2] || '';
      const switchVar = methodMatch[3] || '';
      const switchBody = methodMatch[4] || '';
      
      if (DEBUG) {
        console.log(`Found switch-enum method: ${methodName}`);
        console.log(`Switch variable: ${switchVar}`);
      }
      
      // Extract parameter information
      const paramsList = extractParameters(params);
      
      // Identify the enum parameter
      let enumParam: MethodParam | undefined;
      for (const param of paramsList) {
        if (switchVar.includes(param.name)) {
          enumParam = param;
          break;
        }
      }
      
      // Extract case statements with better enum case handling
      const cases = extractEnumCases(switchBody, paramsList);
      
      if (DEBUG) {
        console.log(`Found ${cases.length} enum cases`);
      }
      
      // Create the complex method info
      methodsList.push({
        name: methodName,
        params: paramsList,
        locator: 'COMPLEX_ENUM_METHOD',  // Special marker for enum switch methods
        type: returnType,
        isList: false,
        isComplex: true,
        complexData: {
          switchVar,
          cases,
          beforeSwitch: '',
          afterSwitch: '',
          enumParams: enumParam ? [enumParam] : [],
          isEnumSwitch: true  // Flag to identify this special type of method
        }
      });
    } catch (error) {
      console.error(`Error processing complex enum method: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  // Also run the original complex method extraction to capture other patterns
  const otherComplexMethods = originalExtractAndConvertComplexMethods(content, returnType);
  
  // Merge the results, giving priority to the enum switch methods
  return [...methodsList, ...otherComplexMethods];
}

/**
 * Store a reference to the original function so we can still use it
 */
const originalExtractAndConvertComplexMethods = extractAndConvertComplexMethods;

/**
 * Extract case statements specifically for enum switch cases
 */
function extractEnumCases(switchBody: string, paramsList: MethodParam[]): CaseInfo[] {
  const cases: CaseInfo[] = [];
  
  // Pattern to match enum cases: case ENUM_VALUE: element = new CSWebElement(...); break;
  const enumCaseRegex = /case\s+([A-Z_][A-Z0-9_]*):\s*element\s*=\s*new\s+CSWebElement\(\s*([^;]+)\);\s*break;/g;
  
  let caseMatch;
  while ((caseMatch = enumCaseRegex.exec(switchBody)) !== null) {
    const enumValue = caseMatch[1];  // The enum value (e.g., FIELD_LABEL)
    const constructorArgs = caseMatch[2];  // The CSWebElement constructor args
    
    // Extract the locator from the constructor args
    let locator = '';
    try {
      // First unescape any escaped quotes
      const unescapedArgs = constructorArgs.replace(/\\"/g, '"');
      
      // Look for JSON format with locator key
      const jsonMatch = unescapedArgs.match(/"locator"\s*:\s*"xpath=([^"]+)"/);
      if (jsonMatch) {
        locator = jsonMatch[1];
        
        // Process parameters in the locator
        for (const param of paramsList) {
          const paramPatterns = [
            `"+${param.name}+"`,
            `" + ${param.name} + "`,
            `"+${param.name} + "`,
            `" + ${param.name}+"`
          ];
          
          // Try each pattern
          for (const pattern of paramPatterns) {
            if (unescapedArgs.includes(pattern)) {
              // Found a parameter reference, replace with template literal
              // This is a simple text replacement to handle parameters in the locator
              locator = locator.replace(/text\(\)\s*=\s*'[^']*'/, `text()='\${${param.name}}'`);
              break;
            }
          }
        }
      }
    } catch (e) {
      console.error(`Error extracting locator for case ${enumValue}:`, e);
      locator = `//Error-extracting-locator-for-${enumValue}`;
    }
    
    // Add the case info
    cases.push({
      value: enumValue,
      hasCondition: false,
      conditions: [],
      locators: [{
        condition: null,
        locator
      }]
    });
  }
  
  return cases;
}

/**
 * Enhanced complex method generator that handles enum switch statements specifically
 * Add this to your code - don't replace the existing complex method generator
 */
function generateComplexMethodEnhanced(method: MethodInfo): string {
  if (!method.isComplex || !method.complexData) {
    return '';
  }
  
  // Check if this is an enum switch method
  if (method.complexData.isEnumSwitch) {
    const { switchVar, cases, enumParams } = method.complexData;
    const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
    
    // Find the enum parameter
    const enumParam = enumParams && enumParams.length > 0 ? enumParams[0] : null;
    
    let output = `  ${method.name}(${paramList}) {\n`;
    output += `    // Method with enum switch/case logic\n`;
    output += `    let locator = '';\n`;
    output += `    \n`;
    
    // Generate the switch statement
    if (enumParam) {
      output += `    switch (${switchVar.trim()}) {\n`;
      
      // Generate each case
      cases.forEach(c => {
        output += `      case ${c.value}:\n`;
        
        if (c.locators.length > 0) {
          // Simple case with a single locator
          output += `        locator = \`${c.locators[0].locator}\`;\n`;
        }
        
        output += `        break;\n`;
      });
      
      // Default case
      output += `      default:\n`;
      output += `        locator = \`//element-not-found\`;\n`;
      output += `        break;\n`;
      
      // Close switch
      output += `    }\n`;
    } else {
      // Fallback for when we can't identify the enum parameter
      output += `    // Unable to identify enum parameter, using first case\n`;
      if (cases.length > 0 && cases[0].locators.length > 0) {
        output += `    locator = \`${cases[0].locators[0].locator}\`;\n`;
      } else {
        output += `    locator = \`//element-not-found\`;\n`;
      }
    }
    
    output += `    \n`;
    output += `    return this.page.locator(locator);\n`;
    output += `  }\n\n`;
    
    return output;
  }
  
  // For non-enum switch methods, use the original generator
  return generateComplexMethod(method);
}

/**
 * Update your generateTypeScriptOutput function to use the enhanced method generator
 * This doesn't replace your function, just shows the change needed
 */
function generateTypeScriptOutputWithEnhancement(
  // Existing parameters...
) {
  // Your existing code...
  
  // Add complex methods with switch/case logic
  if (complexMethods.length > 0) {
    output += `  // Complex Methods with Switch/Case Logic\n`;
    complexMethods.forEach(method => {
      // Use the enhanced generator - it will handle both regular and enum switch methods
      output += generateComplexMethodEnhanced(method);
    });
  }
  
  // Rest of your existing code...
}
