/**
 * Extract enum switch methods specifically
 * This function handles switch statements with enum cases
 */
function extractEnumSwitchMethods(content: string, returnType: string): MethodInfo[] {
  const methodsList: MethodInfo[] = [];
  
  // Special pattern to capture switch methods with element assignment
  // This pattern looks for "element = null" followed by a switch statement
  const switchElementMethodRegex = new RegExp(
    `(?:public|private|protected)\\s+${returnType}\\s+(\\w+)\\s*\\(([^)]*)\\)\\s*\\{\\s*${returnType}\\s+element\\s*=\\s*null;\\s*switch\\s*\\(([^)]*)\\)\\s*\\{([\\s\\S]*?)\\}\\s*return\\s+element;\\s*\\}`, 
    'gs'
  );
  
  let methodMatch: RegExpExecArray | null;
  while ((methodMatch = switchElementMethodRegex.exec(content)) !== null) {
    try {
      const methodName = methodMatch[1];
      const params = methodMatch[2] || '';
      const switchVar = methodMatch[3] || '';
      const switchBody = methodMatch[4] || '';
      
      if (DEBUG) {
        console.log(`Found switch-enum method: ${methodName}`);
        console.log(`Switch variable: ${switchVar}`);
      }
      
      // Extract parameter information
      const paramsList = extractParameters(params);
      
      // Identify the enum parameter
      let enumParam: MethodParam | undefined;
      for (const param of paramsList) {
        if (switchVar.includes(param.name)) {
          enumParam = param;
          break;
        }
      }
      
      // Extract case statements with better enum case handling
      const cases = extractEnumCases(switchBody, paramsList);
      
      if (DEBUG) {
        console.log(`Found ${cases.length} enum cases`);
      }
      
      // Create the complex method info
      methodsList.push({
        name: methodName,
        params: paramsList,
        locator: 'COMPLEX_ENUM_METHOD',  // Special marker for enum switch methods
        type: returnType,
        isList: false,
        isComplex: true,
        complexData: {
          switchVar,
          cases,
          beforeSwitch: '',
          afterSwitch: '',
          enumParams: enumParam ? [enumParam] : [],
          isEnumSwitch: true  // Flag to identify this special type of method
        }
      });
    } catch (error) {
      console.error(`Error processing complex enum method: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  return methodsList;
}

/**
 * Extract case statements specifically for enum switch cases
 */
function extractEnumCases(switchBody: string, paramsList: MethodParam[]): CaseInfo[] {
  const cases: CaseInfo[] = [];
  
  // Pattern to match enum cases: case ENUM_VALUE: element = new CSWebElement(...); break;
  const enumCaseRegex = /case\s+([A-Z_][A-Z0-9_]*):\s*element\s*=\s*new\s+CSWebElement\(\s*([^;]+)\);\s*break;/g;
  
  let caseMatch;
  while ((caseMatch = enumCaseRegex.exec(switchBody)) !== null) {
    const enumValue = caseMatch[1];  // The enum value (e.g., FIELD_LABEL)
    const constructorArgs = caseMatch[2];  // The CSWebElement constructor args
    
    // Extract the locator from the constructor args
    let locator = '';
    try {
      // First unescape any escaped quotes
      const unescapedArgs = constructorArgs.replace(/\\"/g, '"');
      
      // Look for JSON format with locator key
      const jsonMatch = unescapedArgs.match(/"locator"\s*:\s*"xpath=([^"]+)"/);
      if (jsonMatch) {
        locator = jsonMatch[1];
        
        // Process parameters in the locator
        for (const param of paramsList) {
          const paramPatterns = [
            `"+${param.name}+"`,
            `" + ${param.name} + "`,
            `"+${param.name} + "`,
            `" + ${param.name}+"`
          ];
          
          // Try each pattern
          for (const pattern of paramPatterns) {
            if (unescapedArgs.includes(pattern)) {
              // Found a parameter reference, replace with template literal
              locator = locator.replace(/text\(\)\s*=\s*'[^']*'/, `text()='\${${param.name}}'`);
              break;
            }
          }
        }
      }
    } catch (e) {
      console.error(`Error extracting locator for case ${enumValue}:`, e);
      locator = `//Error-extracting-locator-for-${enumValue}`;
    }
    
    // Add the case info
    cases.push({
      value: enumValue,
      hasCondition: false,
      conditions: [],
      locators: [{
        condition: null,
        locator
      }]
    });
  }
  
  return cases;
}

/**
 * Enhanced complex method generator that handles enum switch statements specifically
 */
function generateEnumSwitchMethod(method: MethodInfo): string {
  if (!method.isComplex || !method.complexData || !method.complexData.isEnumSwitch) {
    return '';
  }
  
  const { switchVar, cases, enumParams } = method.complexData;
  const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
  
  // Find the enum parameter
  const enumParam = enumParams && enumParams.length > 0 ? enumParams[0] : null;
  
  let output = `  ${method.name}(${paramList}) {\n`;
  output += `    // Method with enum switch/case logic\n`;
  output += `    let locator = '';\n`;
  output += `    \n`;
  
  // Generate the switch statement
  if (enumParam) {
    output += `    switch (${switchVar.trim()}) {\n`;
    
    // Generate each case
    cases.forEach(c => {
      output += `      case ${c.value}:\n`;
      
      if (c.locators.length > 0) {
        // Simple case with a single locator
        output += `        locator = \`${c.locators[0].locator}\`;\n`;
      }
      
      output += `        break;\n`;
    });
    
    // Default case
    output += `      default:\n`;
    output += `        locator = \`//element-not-found\`;\n`;
    output += `        break;\n`;
    
    // Close switch
    output += `    }\n`;
  } else {
    // Fallback for when we can't identify the enum parameter
    output += `    // Unable to identify enum parameter, using first case\n`;
    if (cases.length > 0 && cases[0].locators.length > 0) {
      output += `    locator = \`${cases[0].locators[0].locator}\`;\n`;
    } else {
      output += `    locator = \`//element-not-found\`;\n`;
    }
  }
  
  output += `    \n`;
  output += `    return this.page.locator(locator);\n`;
  output += `  }\n\n`;
  
  return output;
}

/**
 * Enhance the MethodInfo interface to support enum switch methods
 */
interface EnhancedMethodInfo extends MethodInfo {
  complexData?: {
    switchVar: string;
    cases: CaseInfo[];
    beforeSwitch: string;
    afterSwitch: string;
    enumParams?: MethodParam[];
    isEnumSwitch?: boolean;
    returnStatement?: string;
  };
}

/**
 * Update your convertFile function to include enum switch methods
 */
function convertFile(inputFile: string, outputFile: string): void {
  try {
    console.log(`Reading ${inputFile}...`);
    if (!fs.existsSync(inputFile)) {
      console.error(`Error: Input file ${inputFile} does not exist`);
      process.exit(1);
    }
    
    // Read the file content
    const content = fs.readFileSync(inputFile, 'utf8');
    
    // Remove comments from the Java code
    const contentWithoutComments = removeJavaComments(content);
    
    // Extract class and package information
    const packageInfo = extractPackageInfo(contentWithoutComments);
    const className = extractClassName(contentWithoutComments) || path.basename(inputFile, '.java');
    
    // Check if we need to add List import
    const hasListElements = contentWithoutComments.includes('List<WebElement>') || 
                           contentWithoutComments.includes('List<CSWebElement>') ||
                           contentWithoutComments.includes('List<CSDropDownListWebElement>');
    
    // Extract enums from the Java code
    const enumsList = extractEnums(contentWithoutComments);
    
    // Process elements - all elements are processed in a single pass
    console.log('Extracting WebElement and CSWebElement elements...');
    const allWebElements = extractAndConvertElements(contentWithoutComments, 'CSWebElement');
    
    // Process WebElement separately if needed
    console.log('Checking for direct WebElement elements...');
    const directWebElements = extractAndConvertElements(contentWithoutComments, 'WebElement');
    
    // Process dropdown elements
    console.log('Extracting dropdown elements...');
    const dropdownElements = extractAndConvertElements(contentWithoutComments, 'CSDropDownListWebElement');
    
    // Merge direct WebElements into the standard elements list if they don't exist already
    const standardElements = [...allWebElements];
    directWebElements.forEach(element => {
      const exists = standardElements.some(e => e.originalName === element.originalName);
      if (!exists) {
        standardElements.push(element);
      }
    });
    
    // Process dynamic locator methods by return type
    console.log('Extracting standard methods...');
    const standardMethods = extractAndConvertMethods(contentWithoutComments, 'CSWebElement');
    
    console.log('Extracting dropdown methods...');
    const dropdownMethods = extractAndConvertMethods(contentWithoutComments, 'CSDropDownListWebElement');
    
    // Extract regular complex methods
    console.log('Extracting complex methods with switch statements...');
    const complexStandardMethods = extractAndConvertComplexMethods(contentWithoutComments, 'CSWebElement');
    const complexDropdownMethods = extractAndConvertComplexMethods(contentWithoutComments, 'CSDropDownListWebElement');
    
    // Extract enum switch methods
    console.log('Extracting enum switch methods...');
    const enumSwitchMethods = extractEnumSwitchMethods(contentWithoutComments, 'CSWebElement');
    
    // Combine all complex methods
    const complexMethods = [
      ...complexStandardMethods, 
      ...complexDropdownMethods,
      ...enumSwitchMethods
    ];
    
    // Generate the final TypeScript output
    const finalOutput = generateTypeScriptOutput(
      className, 
      packageInfo,
      standardElements, 
      dropdownElements,
      standardMethods, 
      dropdownMethods,
      complexMethods,
      hasListElements,
      enumsList
    );
    
    // Write the result
    const outputDir = path.dirname(outputFile);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    fs.writeFileSync(outputFile, finalOutput);
    console.log(`Converted file successfully written to ${outputFile}`);
  } catch (error) {
    console.error(`Error converting file: ${error instanceof Error ? error.message : String(error)}`);
    if (error instanceof Error && error.stack) {
      console.error(error.stack);
    }
  }
}

/**
 * Enhanced generateTypeScriptOutput that handles enum switch methods
 */
function generateTypeScriptOutput(
  className: string, 
  packageInfo: string | null,
  standardElements: ElementInfo[], 
  dropdownElements: ElementInfo[],
  standardMethods: MethodInfo[], 
  dropdownMethods: MethodInfo[],
  complexMethods: EnhancedMethodInfo[],
  hasListElements: boolean,
  enums: EnumInfo[]
): string {
  // Build imports with the enhanced import statements
  let output = `// Converted from ${packageInfo ? packageInfo + '.' : ''}${className}\n`;
  output += `import { Page } from 'playwright';\n`;
  output += `import { BasePage } from './base.page';\n`;
  output += `import { Logger } from '../utils/logger';\n`;
  output += `import config from '@config/environment.config';\n\n`;
  
  // Add enum definitions
  if (enums && enums.length > 0) {
    output += generateEnumTypeScript(enums);
  }
  
  // Start class definition with BasePage extension
  output += `export class ${className} extends BasePage {\n`;
  
  // Add the enhanced constructor with logger
  output += `  constructor(page: Page, logger: Logger) {\n`;
  output += `    super(page, logger, '');\n`;
  output += `  }\n\n`;
  
  // Add standard element locators
  if (standardElements.length > 0) {
    output += `  // Standard Element Locators\n`;
    standardElements.forEach(element => {
      output += `  private readonly ${element.name} = \`${element.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add dropdown element locators
  if (dropdownElements.length > 0) {
    output += `  // Dropdown Element Locators\n`;
    dropdownElements.forEach(element => {
      output += `  private readonly ${element.name} = \`${element.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add standard dynamic locator methods
  if (standardMethods.length > 0) {
    output += `  // Dynamic Standard Locators\n`;
    standardMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      output += `  private readonly ${method.name} = (${paramList}): string => \`${method.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add dropdown dynamic locator methods
  if (dropdownMethods.length > 0) {
    output += `  // Dynamic Dropdown Locators\n`;
    dropdownMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      output += `  private readonly ${method.name} = (${paramList}): string => \`${method.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add getters for standard elements
  if (standardElements.length > 0) {
    output += `  // Standard Element Getters\n`;
    standardElements.forEach(element => {
      const capitalizedName = element.originalName;
      
      if (element.isList) {
        // For List<WebElement> types, create a method that returns an array of Locators
        output += `  get${capitalizedName}() {\n`;
        output += `    return this.page.locator(this.${element.name});\n`;
        output += `  }\n\n`;
        
        // Add an additional method to get all elements
        output += `  async getAll${capitalizedName}() {\n`;
        output += `    const elements = this.page.locator(this.${element.name});\n`;
        output += `    const count = await elements.count();\n`;
        output += `    const result = [];\n`;
        output += `    for (let i = 0; i < count; i++) {\n`;
        output += `      result.push(elements.nth(i));\n`;
        output += `    }\n`;
        output += `    return result;\n`;
        output += `  }\n\n`;
      } else {
        // Standard element getter
        output += `  get${capitalizedName}() {\n`;
        output += `    return this.page.locator(this.${element.name});\n`;
        output += `  }\n\n`;
      }
    });
  }
  
  // Add getters for dropdown elements
  if (dropdownElements.length > 0) {
    output += `  // Dropdown Element Getters\n`;
    dropdownElements.forEach(element => {
      const capitalizedName = element.originalName;
      
      if (element.isList) {
        // For list of dropdown elements
        output += `  get${capitalizedName}() {\n`;
        output += `    return this.page.locator(this.${element.name});\n`;
        output += `  }\n\n`;
        
        // Add method to get all dropdown elements
        output += `  async getAll${capitalizedName}() {\n`;
        output += `    const elements = this.page.locator(this.${element.name});\n`;
        output += `    const count = await elements.count();\n`;
        output += `    const result = [];\n`;
        output += `    for (let i = 0; i < count; i++) {\n`;
        output += `      result.push(elements.nth(i));\n`;
        output += `    }\n`;
        output += `    return result;\n`;
        output += `  }\n\n`;
      } else {
        // Standard dropdown element
        output += `  get${capitalizedName}() {\n`;
        output += `    return this.page.locator(this.${element.name});\n`;
        output += `  }\n\n`;
      }
    });
  }
  
  // Add methods for standard dynamic locators
  if (standardMethods.length > 0) {
    output += `  // Dynamic Standard Element Getters\n`;
    standardMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      const paramNames = method.params.map(p => p.name).join(', ');
      
      if (method.isList) {
        // Method for list type elements
        output += `  ${method.name}(${paramList}) {\n`;
        output += `    return this.page.locator(this.${method.name}(${paramNames}));\n`;
        output += `  }\n\n`;
        
        // Add method to get all elements
        output += `  async getAll${method.name.charAt(0).toUpperCase() + method.name.slice(1)}(${paramList}) {\n`;
        output += `    const selector = this.${method.name}(${paramNames});\n`;
        output += `    const elements = this.page.locator(selector);\n`;
        output += `    const count = await elements.count();\n`;
        output += `    const result = [];\n`;
        output += `    for (let i = 0; i < count; i++) {\n`;
        output += `      result.push(elements.nth(i));\n`;
        output += `    }\n`;
        output += `    return result;\n`;
        output += `  }\n\n`;
      } else {
        // Standard method for single element
        output += `  ${method.name}(${paramList}) {\n`;
        output += `    return this.page.locator(this.${method.name}(${paramNames}));\n`;
        output += `  }\n\n`;
      }
    });
  }
  
  // Add methods for dropdown dynamic locators
  if (dropdownMethods.length > 0) {
    output += `  // Dynamic Dropdown Element Getters\n`;
    dropdownMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      const paramNames = method.params.map(p => p.name).join(', ');
      
      if (method.isList) {
        // For list of dropdown elements
        output += `  ${method.name}(${paramList}) {\n`;
        output += `    return this.page.locator(this.${method.name}(${paramNames}));\n`;
        output += `  }\n\n`;
        
        // Add method to get all dropdown elements
        output += `  async getAll${method.name.charAt(0).toUpperCase() + method.name.slice(1)}(${paramList}) {\n`;
        output += `    const selector = this.${method.name}(${paramNames});\n`;
        output += `    const elements = this.page.locator(selector);\n`;
        output += `    const count = await elements.count();\n`;
        output += `    const result = [];\n`;
        output += `    for (let i = 0; i < count; i++) {\n`;
        output += `      result.push(elements.nth(i));\n`;
        output += `    }\n`;
        output += `    return result;\n`;
        output += `  }\n\n`;
      } else {
        // Standard method for single element
        output += `  ${method.name}(${paramList}) {\n`;
        output += `    return this.page.locator(this.${method.name}(${paramNames}));\n`;
        output += `  }\n\n`;
      }
    });
  }
  
  // Add complex methods with switch/case logic
  if (complexMethods.length > 0) {
    output += `  // Complex Methods with Switch/Case Logic\n`;
    complexMethods.forEach(method => {
      // Check if this is an enum switch method
      if (method.complexData?.isEnumSwitch) {
        output += generateEnumSwitchMethod(method);
      } else {
        // Use the original method generator for regular complex methods
        output += generateComplexMethod(method);
      }
    });
  }
  
  // Common page actions 
  output += `  // Common Page Actions\n`;
  output += `  async waitForPageToLoad(): Promise<void> {\n`;
  output += `    await this.page.waitForLoadState('networkidle');\n`;
  output += `  }\n\n`;
  
  output += `  async sleep(ms: number): Promise<void> {\n`;
  output += `    return new Promise(resolve => setTimeout(resolve, ms));\n`;
  output += `  }\n`;
  
  // Close class
  output += `}\n`;
  
  return output;
}
