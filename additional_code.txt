const fs = require('fs');
const path = require('path');

/**
 * Direct QAF to Playwright converter
 * Converts QAF elements and methods to the exact format requested
 */
function convertFile(inputPath, outputPath) {
  console.log(`Processing: ${inputPath}`);
  
  // Read input file
  const content = fs.readFileSync(inputPath, 'utf8');
  
  // Start output content
  let output = `import { Page, Locator } from '@playwright/test';\n\n`;
  output += `export class ${path.basename(inputPath, '.java')} {\n`;
  output += `  constructor(private page: Page) {}\n\n`;
  
  // Extract and convert all FindBy elements
  const elements = extractElements(content);
  for (const element of elements) {
    output += `  private readonly ${element.name} = "${element.locator}";\n`;
  }
  
  output += '\n';
  
  // Extract and convert all methods
  const methods = extractMethods(content);
  for (const method of methods) {
    output += `  private readonly ${method.name} = (${method.params}) => \`${method.locator}\`;\n\n`;
  }
  
  // Convert business methods
  const businessMethods = extractBusinessMethods(content);
  for (const method of businessMethods) {
    output += method.converted;
    output += '\n\n';
  }
  
  // Close class
  output += `}\n`;
  
  // Create output directory if it doesn't exist
  const dir = path.dirname(outputPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  
  // Write to output file
  fs.writeFileSync(outputPath, output);
  console.log(`Wrote: ${outputPath}`);
}

/**
 * Extract all FindBy elements from content
 */
function extractElements(content) {
  const elements = [];
  const regex = /@FindBy\(locator\s*=\s*"(.*?)"\)\s*(?:public|private|protected)?\s*CSWebElement\s+(\w+)\s*;/gs;
  
  let match;
  while ((match = regex.exec(content)) !== null) {
    const locatorStr = match[1];
    const elementName = match[2].charAt(0).toLowerCase() + match[2].slice(1);
    
    // Extract locator
    let locator = '';
    if (locatorStr.includes('{"locator"')) {
      // JSON format locator
      try {
        // Fix JSON string by replacing escaped quotes
        const fixedJson = locatorStr.replace(/\\"/g, '"');
        // Try to parse as JSON
        const jsonObj = JSON.parse(fixedJson);
        if (jsonObj.locator) {
          // Get locator and remove prefix
          if (jsonObj.locator.startsWith('xpath=')) {
            locator = jsonObj.locator.substring(6);
          } else if (jsonObj.locator.startsWith('path=')) {
            locator = jsonObj.locator.substring(5);
          } else if (jsonObj.locator.startsWith('css=')) {
            locator = jsonObj.locator.substring(4);
          } else {
            locator = jsonObj.locator;
          }
        }
      } catch (e) {
        // If JSON parsing fails, try regex
        const locatorMatch = locatorStr.match(/"locator"\s*:\s*"([^"]+)"/);
        if (locatorMatch) {
          const fullLocator = locatorMatch[1];
          if (fullLocator.startsWith('xpath=')) {
            locator = fullLocator.substring(6);
          } else if (fullLocator.startsWith('path=')) {
            locator = fullLocator.substring(5);
          } else if (fullLocator.startsWith('css=')) {
            locator = fullLocator.substring(4);
          } else {
            locator = fullLocator;
          }
        }
      }
    } else if (locatorStr.startsWith('xpath=')) {
      // Direct xpath format
      locator = locatorStr.substring(6);
    } else if (locatorStr.startsWith('css=')) {
      locator = locatorStr.substring(4);
    } else {
      locator = locatorStr;
    }
    
    elements.push({
      name: elementName,
      locator: locator
    });
  }
  
  return elements;
}

/**
 * Extract all dynamic locator methods
 */
function extractMethods(content) {
  const methods = [];
  
  // Regex to find method declarations that return CSWebElement
  const regex = /public\s+CSWebElement\s+(\w+)\s*\(([^)]*)\)\s*\{([\s\S]*?)return\s+new\s+CSWebElement\s*\(([\s\S]*?)\);([\s\S]*?)\}/g;
  
  let match;
  while ((match = regex.exec(content)) !== null) {
    const methodName = match[1];
    const params = match[2];
    const methodBody = match[3];
    const returnStmt = match[4];
    
    // Process parameters - remove type declarations
    const processedParams = params.split(',')
      .map(p => {
        const parts = p.trim().split(/\s+/);
        return parts[parts.length - 1]; // Just take parameter name
      })
      .join(', ');
    
    // Extract the locator from return statement
    let locator = '';
    
    // Check if return has string concatenation with variables
    if (returnStmt.includes('+')) {
      // For complex locator with string concatenation
      if (returnStmt.includes('{"locator"')) {
        // Try to extract from JSON format
        try {
          // Get all parts separated by +
          const parts = returnStmt.split('+').map(p => p.trim());
          let locatorParts = [];
          
          for (let i = 0; i < parts.length; i++) {
            let part = parts[i];
            if (part.startsWith('"') && part.includes('locator')) {
              // JSON part - extract locator
              const locatorMatch = part.match(/"locator"\s*:\s*"([^"]+)/);
              if (locatorMatch) {
                // Get the locator prefix and remove xpath= if present
                let locatorPrefix = locatorMatch[1];
                if (locatorPrefix.startsWith('xpath=')) {
                  locatorPrefix = locatorPrefix.substring(6);
                }
                locatorParts.push(locatorPrefix);
              }
            } else if (part.startsWith('"') && part.endsWith('"')) {
              // String literal part
              locatorParts.push(part.replace(/^"|"$/g, ''));
            } else {
              // Variable part or combined part
              // Extract just variable name
              const varMatch = part.match(/([a-zA-Z0-9_]+)/);
              if (varMatch) {
                locatorParts.push(`\${${varMatch[1]}}`);
              }
            }
          }
          
          locator = locatorParts.join('');
        } catch (e) {
          // Fallback to simple concatenation
          locator = "Could not extract locator, please fix manually";
        }
      } else {
        // Simple string concatenation
        locator = returnStmt.replace(/"/g, '').replace(/\s*\+\s*/g, '');
      }
    } else {
      // Simple string locator
      locator = returnStmt.replace(/^"|"$/g, '');
    }
    
    methods.push({
      name: methodName,
      params: processedParams,
      locator: locator
    });
  }
  
  return methods;
}

/**
 * Extract and convert business methods
 */
function extractBusinessMethods(content) {
  const methods = [];
  
  // Regex to find void methods
  const regex = /public\s+void\s+(\w+)\s*\(([^)]*)\)\s*(?:throws\s+[\w,\s]+)?\s*\{([\s\S]*?)\}/g;
  
  let match;
  while ((match = regex.exec(content)) !== null) {
    const methodName = match[1];
    const params = match[2];
    let methodBody = match[3];
    
    // Process parameters - remove type declarations
    const processedParams = params.split(',')
      .map(p => {
        if (!p.trim()) return '';
        const parts = p.trim().split(/\s+/);
        const paramName = parts[parts.length - 1];
        return paramName + ': any'; // Simple typing for now
      })
      .filter(p => p)
      .join(', ');
    
    // Convert Java syntax to TypeScript
    methodBody = convertJavaToTypeScript(methodBody);
    
    // Format the converted method
    const converted = `  async ${methodName}(${processedParams}) {\n${methodBody}\n  }`;
    
    methods.push({
      name: methodName,
      params: processedParams,
      body: methodBody,
      converted: converted
    });
  }
  
  return methods;
}

/**
 * Convert Java syntax to TypeScript
 */
function convertJavaToTypeScript(javaCode) {
  let tsCode = javaCode;
  
  // Replace common Java patterns
  tsCode = tsCode
    // Add awaits to element interactions
    .replace(/(\w+)\.click\(\)/g, 'await this.page.locator(this.$1).click()')
    .replace(/(\w+)\.sendKeys\(([^)]+)\)/g, 'await this.page.locator(this.$1).fill($2)')
    .replace(/(\w+)\.clear\(\)/g, 'await this.page.locator(this.$1).clear()')
    .replace(/(\w+)\.getText\(\)/g, 'await this.page.locator(this.$1).textContent()')
    .replace(/(\w+)\.isDisplayed\(\)/g, 'await this.page.locator(this.$1).isVisible()')
    
    // Replace method calls
    .replace(/getFilterSectiondropdoen\(([^)]+)\)/g, 'this.getFilterSectiondropdoen($1)')
    
    // Java file operations
    .replace(/FileInputStream\s+(\w+)\s*=\s*new\s*FileInputStream\(([^)]+)\);/g, 
             'const $1 = fs.readFileSync($2, "utf8");')
    
    // Property operations
    .replace(/Properties\s+(\w+)\s*=\s*new\s*Properties\(\);/g, 'const $1 = {};')
    .replace(/(\w+)\.load\((\w+)\);/g, '// load properties from $2')
    .replace(/(\w+)\.getProperty\(([^)]+)\)/g, '$1[$2]')
    
    // System.out.println
    .replace(/System\.out\.println\(([^)]+)\);/g, 'console.log($1);')
    
    // Fix common Java constructs
    .replace(/String\s+(\w+)\s*=\s*/g, 'const $1 = ')
    
    // Enhanced for loop
    .replace(/for\s*\(\s*String\s+(\w+)\s*:\s*(\w+)\s*\)\s*\{/g, 'for (const $1 of $2) {')
    
    // Add proper indentation
    .split('\n')
    .map(line => '    ' + line.trim())
    .join('\n');
  
  return tsCode;
}

// Parse command line arguments
if (process.argv.length < 4) {
  console.log('Usage: node direct-converter.js <input-file> <output-file>');
  process.exit(1);
}

const inputFile = process.argv[2];
const outputFile = process.argv[3];

// Run converter
convertFile(inputFile, outputFile);
