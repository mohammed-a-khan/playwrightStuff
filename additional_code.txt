/**
 * Generate the final TypeScript output
 */
function generateTypeScriptOutput(
  className: string, 
  packageInfo: string | null,
  standardElements: ElementInfo[], 
  dropdownElements: ElementInfo[],
  standardMethods: MethodInfo[], 
  dropdownMethods: MethodInfo[],
  hasListElements: boolean = false
): string {
  // Build imports
  let output = `// Converted from ${packageInfo ? packageInfo + '.' : ''}${className}\n`;
  output += `import { Page } from 'playwright';\n`;
  output += `import { BasePage } from './base.page';\n`;
  output += `import { Logger } from '../utils/logger';\n`;
  output += `import config from '@config/environment.config';\n\n`;
  
  // Start class definition with inheritance
  output += `export class ${className} extends BasePage {\n`;
  output += `  constructor(page: Page, logger: Logger) { super(page, logger, ''); }\n\n`;
  
  // Add standard element locators
  if (standardElements.length > 0) {
    output += `  // Standard Element Locators\n`;
    standardElements.forEach(element => {
      output += `  private readonly ${element.name} = \`${element.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add dropdown element locators
  if (dropdownElements.length > 0) {
    output += `  // Dropdown Element Locators\n`;
    dropdownElements.forEach(element => {
      output += `  private readonly ${element.name} = \`${element.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add standard dynamic locator methods
  if (standardMethods.length > 0) {
    output += `  // Dynamic Standard Locators\n`;
    standardMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      output += `  private readonly ${method.name} = (${paramList}): string => \`${method.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add dropdown dynamic locator methods
  if (dropdownMethods.length > 0) {
    output += `  // Dynamic Dropdown Locators\n`;
    dropdownMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      output += `  private readonly ${method.name} = (${paramList}): string => \`${method.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add getters for standard elements
  if (standardElements.length > 0) {
    output += `  // Standard Element Getters\n`;
    standardElements.forEach(element => {
      const capitalizedName = element.originalName;
      
      if (element.isList) {
        // For List<WebElement> types, create a method that returns a Locator
        output += `  get${capitalizedName}(): Locator {\n`;
        output += `    return this.page.locator(this.${element.name});\n`;
        output += `  }\n\n`;
        
        // Add an additional method to get all elements
        output += `  async getAll${capitalizedName}(): Promise<Locator[]> {\n`;
        output += `    const elements = this.page.locator(this.${element.name});\n`;
        output += `    const count = await elements.count();\n`;
        output += `    const result: Locator[] = [];\n`;
        output += `    for (let i = 0; i < count; i++) {\n`;
        output += `      result.push(elements.nth(i));\n`;
        output += `    }\n`;
        output += `    return result;\n`;
        output += `  }\n\n`;
      } else {
        // Standard element getter
        output += `  get${capitalizedName}(): Locator {\n`;
        output += `    return this.page.locator(this.${element.name});\n`;
        output += `  }\n\n`;
      }
    });
  }
  
  // Add getters for dropdown elements
  if (dropdownElements.length > 0) {
    output += `  // Dropdown Element Getters\n`;
    dropdownElements.forEach(element => {
      const capitalizedName = element.originalName;
      
      if (element.isList) {
        // For list of dropdown elements
        output += `  get${capitalizedName}(): Locator {\n`;
        output += `    return this.page.locator(this.${element.name});\n`;
        output += `  }\n\n`;
        
        // Add method to get all dropdown elements
        output += `  async getAll${capitalizedName}(): Promise<Locator[]> {\n`;
        output += `    const elements = this.page.locator(this.${element.name});\n`;
        output += `    const count = await elements.count();\n`;
        output += `    const result: Locator[] = [];\n`;
        output += `    for (let i = 0; i < count; i++) {\n`;
        output += `      result.push(elements.nth(i));\n`;
        output += `    }\n`;
        output += `    return result;\n`;
        output += `  }\n\n`;
      } else {
        // Standard dropdown element
        output += `  get${capitalizedName}(): Locator {\n`;
        output += `    return this.page.locator(this.${element.name});\n`;
        output += `  }\n\n`;
      }
    });
  }
  
  // Add methods for standard dynamic locators
  if (standardMethods.length > 0) {
    output += `  // Dynamic Standard Element Getters\n`;
    standardMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      const paramNames = method.params.map(p => p.name).join(', ');
      
      if (method.isList) {
        // Method for list type elements
        output += `  ${method.name}(${paramList}): Locator {\n`;
        output += `    return this.page.locator(this.${method.name}(${paramNames}));\n`;
        output += `  }\n\n`;
        
        // Add method to get all elements
        output += `  async getAll${method.name.charAt(0).toUpperCase() + method.name.slice(1)}(${paramList}): Promise<Locator[]> {\n`;
        output += `    const selector = this.${method.name}(${paramNames});\n`;
        output += `    const elements = this.page.locator(selector);\n`;
        output += `    const count = await elements.count();\n`;
        output += `    const result: Locator[] = [];\n`;
        output += `    for (let i = 0; i < count; i++) {\n`;
        output += `      result.push(elements.nth(i));\n`;
        output += `    }\n`;
        output += `    return result;\n`;
        output += `  }\n\n`;
      } else {
        // Standard method for single element
        output += `  ${method.name}(${paramList}): Locator {\n`;
        output += `    return this.page.locator(this.${method.name}(${paramNames}));\n`;
        output += `  }\n\n`;
      }
    });
  }
  
  // Add methods for dropdown dynamic locators
  if (dropdownMethods.length > 0) {
    output += `  // Dynamic Dropdown Element Getters\n`;
    dropdownMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      const paramNames = method.params.map(p => p.name).join(', ');
      
      if (method.isList) {
        // For list of dropdown elements
        output += `  ${method.name}(${paramList}): Locator {\n`;
        output += `    return this.page.locator(this.${method.name}(${paramNames}));\n`;
        output += `  }\n\n`;
        
        // Add method to get all dropdown elements
        output += `  async getAll${method.name.charAt(0).toUpperCase() + method.name.slice(1)}(${paramList}): Promise<Locator[]> {\n`;
        output += `    const selector = this.${method.name}(${paramNames});\n`;
        output += `    const elements = this.page.locator(selector);\n`;
        output += `    const count = await elements.count();\n`;
        output += `    const result: Locator[] = [];\n`;
        output += `    for (let i = 0; i < count; i++) {\n`;
        output += `      result.push(elements.nth(i));\n`;
        output += `    }\n`;
        output += `    return result;\n`;
        output += `  }\n\n`;
      } else {
        // Standard dropdown method for single element
        output += `  ${method.name}(${paramList}): Locator {\n`;
        output += `    return this.page.locator(this.${method.name}(${paramNames}));\n`;
        output += `  }\n\n`;
      }
    });
  }
  
  // Common page actions converted from the original class
  output += `  // Common Page Actions\n`;
  output += `  async waitForPageToLoad(): Promise<void> {\n`;
  output += `    await this.page.waitForLoadState('networkidle');\n`;
  output += `  }\n\n`;
  
  output += `  async sleep(ms: number): Promise<void> {\n`;
  output += `    return new Promise(resolve => setTimeout(resolve, ms));\n`;
  output += `  }\n`;
  
  // Close class
  output += `}\n`;
  
  return output;
}
