/**
 * Generate the final TypeScript output with enhanced imports and class structure
 */
function generateTypeScriptOutput(
  className: string, 
  packageInfo: string | null,
  standardElements: ElementInfo[], 
  dropdownElements: ElementInfo[],
  standardMethods: MethodInfo[], 
  dropdownMethods: MethodInfo[],
  hasListElements: boolean
): string {
  // Build imports with the enhanced import statements
  let output = `// Converted from ${packageInfo ? packageInfo + '.' : ''}${className}\n`;
  output += `import { Page } from 'playwright';\n`;
  output += `import { BasePage } from './base.page';\n`;
  output += `import { Logger } from '../utils/logger';\n`;
  output += `import config from '@config/environment.config';\n\n`;
  
  // Add helper interface for dropdown interaction
  output += `// Helper interface for dropdown functionality\n`;
  output += `interface DropdownOptions {\n`;
  output += `  selectByText: (text: string) => Promise<void>;\n`;
  output += `  selectByValue: (value: string) => Promise<void>;\n`;
  output += `  selectByIndex: (index: number) => Promise<void>;\n`;
  output += `  getOptions: () => Promise<string[]>;\n`;
  output += `}\n\n`;
  
  // Start class definition with BasePage extension
  output += `export class ${className} extends BasePage {\n`;
  
  // Add the enhanced constructor with logger
  output += `  constructor(page: Page, logger: Logger) {\n`;
  output += `    super(page, logger, '');\n`;
  output += `  }\n\n`;
  
  // Add standard element locators
  if (standardElements.length > 0) {
    output += `  // Standard Element Locators\n`;
    standardElements.forEach(element => {
      output += `  private readonly ${element.name} = \`${element.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add dropdown element locators
  if (dropdownElements.length > 0) {
    output += `  // Dropdown Element Locators\n`;
    dropdownElements.forEach(element => {
      output += `  private readonly ${element.name} = \`${element.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add standard dynamic locator methods
  if (standardMethods.length > 0) {
    output += `  // Dynamic Standard Locators\n`;
    standardMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      output += `  private readonly ${method.name} = (${paramList}): string => \`${method.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add dropdown dynamic locator methods
  if (dropdownMethods.length > 0) {
    output += `  // Dynamic Dropdown Locators\n`;
    dropdownMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      output += `  private readonly ${method.name} = (${paramList}): string => \`${method.locator}\`;\n`;
    });
    output += `\n`;
  }
  
  // Add getters for standard elements
  if (standardElements.length > 0) {
    output += `  // Standard Element Getters\n`;
    standardElements.forEach(element => {
      const capitalizedName = element.originalName;
      
      if (element.isList) {
        // For List<WebElement> types, create a method that returns an array of Locators
        output += `  get ${capitalizedName}() {\n`;
        output += `    return this.page.locator(this.${element.name});\n`;
        output += `  }\n\n`;
        
        // Add an additional method to get all elements
        output += `  async getAll${capitalizedName}() {\n`;
        output += `    const elements = this.page.locator(this.${element.name});\n`;
        output += `    const count = await elements.count();\n`;
        output += `    const result = [];\n`;
        output += `    for (let i = 0; i < count; i++) {\n`;
        output += `      result.push(elements.nth(i));\n`;
        output += `    }\n`;
        output += `    return result;\n`;
        output += `  }\n\n`;
      } else {
        // Standard element getter
        output += `  get ${capitalizedName}() {\n`;
        output += `    return this.page.locator(this.${element.name});\n`;
        output += `  }\n\n`;
      }
    });
  }
  
  // Add getters for dropdown elements
  if (dropdownElements.length > 0) {
    output += `  // Dropdown Element Getters with enhanced functionality\n`;
    dropdownElements.forEach(element => {
      const capitalizedName = element.originalName;
      
      if (element.isList) {
        // For list of dropdown elements
        output += `  get ${capitalizedName}() {\n`;
        output += `    const baseLocator = this.page.locator(this.${element.name});\n`;
        output += `    \n`;
        output += `    // Add dropdown specific functionality\n`;
        output += `    const dropdown = baseLocator as any;\n`;
        output += `    \n`;
        output += `    dropdown.selectByText = async (text: string): Promise<void> => {\n`;
        output += `      await baseLocator.selectOption({ label: text });\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    dropdown.selectByValue = async (value: string): Promise<void> => {\n`;
        output += `      await baseLocator.selectOption({ value });\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    dropdown.selectByIndex = async (index: number): Promise<void> => {\n`;
        output += `      await baseLocator.selectOption({ index });\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    dropdown.getOptions = async (): Promise<string[]> => {\n`;
        output += `      return baseLocator.locator('option').allTextContents();\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    return dropdown;\n`;
        output += `  }\n\n`;
        
        // Add method to get all dropdown elements
        output += `  async getAll${capitalizedName}() {\n`;
        output += `    const elements = this.page.locator(this.${element.name});\n`;
        output += `    const count = await elements.count();\n`;
        output += `    const result = [];\n`;
        output += `    \n`;
        output += `    for (let i = 0; i < count; i++) {\n`;
        output += `      const baseLocator = elements.nth(i);\n`;
        output += `      const dropdown = baseLocator as any;\n`;
        output += `      \n`;
        output += `      dropdown.selectByText = async (text: string): Promise<void> => {\n`;
        output += `        await baseLocator.selectOption({ label: text });\n`;
        output += `      };\n`;
        output += `      \n`;
        output += `      dropdown.selectByValue = async (value: string): Promise<void> => {\n`;
        output += `        await baseLocator.selectOption({ value });\n`;
        output += `      };\n`;
        output += `      \n`;
        output += `      dropdown.selectByIndex = async (index: number): Promise<void> => {\n`;
        output += `        await baseLocator.selectOption({ index });\n`;
        output += `      };\n`;
        output += `      \n`;
        output += `      dropdown.getOptions = async (): Promise<string[]> => {\n`;
        output += `        return baseLocator.locator('option').allTextContents();\n`;
        output += `      };\n`;
        output += `      \n`;
        output += `      result.push(dropdown);\n`;
        output += `    }\n`;
        output += `    \n`;
        output += `    return result;\n`;
        output += `  }\n\n`;
      } else {
        // Standard dropdown element
        output += `  get ${capitalizedName}() {\n`;
        output += `    const baseLocator = this.page.locator(this.${element.name});\n`;
        output += `    \n`;
        output += `    // Add dropdown specific functionality\n`;
        output += `    const dropdown = baseLocator as any;\n`;
        output += `    \n`;
        output += `    dropdown.selectByText = async (text: string): Promise<void> => {\n`;
        output += `      await baseLocator.selectOption({ label: text });\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    dropdown.selectByValue = async (value: string): Promise<void> => {\n`;
        output += `      await baseLocator.selectOption({ value });\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    dropdown.selectByIndex = async (index: number): Promise<void> => {\n`;
        output += `      await baseLocator.selectOption({ index });\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    dropdown.getOptions = async (): Promise<string[]> => {\n`;
        output += `      return baseLocator.locator('option').allTextContents();\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    return dropdown;\n`;
        output += `  }\n\n`;
      }
    });
  }
  
  // Add methods for standard dynamic locators
  if (standardMethods.length > 0) {
    output += `  // Dynamic Standard Element Getters\n`;
    standardMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      const paramNames = method.params.map(p => p.name).join(', ');
      
      if (method.isList) {
        // Method for list type elements
        output += `  ${method.name}(${paramList}) {\n`;
        output += `    return this.page.locator(this.${method.name}(${paramNames}));\n`;
        output += `  }\n\n`;
        
        // Add method to get all elements
        output += `  async getAll${method.name.charAt(0).toUpperCase() + method.name.slice(1)}(${paramList}) {\n`;
        output += `    const selector = this.${method.name}(${paramNames});\n`;
        output += `    const elements = this.page.locator(selector);\n`;
        output += `    const count = await elements.count();\n`;
        output += `    const result = [];\n`;
        output += `    for (let i = 0; i < count; i++) {\n`;
        output += `      result.push(elements.nth(i));\n`;
        output += `    }\n`;
        output += `    return result;\n`;
        output += `  }\n\n`;
      } else {
        // Standard method for single element
        output += `  ${method.name}(${paramList}) {\n`;
        output += `    return this.page.locator(this.${method.name}(${paramNames}));\n`;
        output += `  }\n\n`;
      }
    });
  }
  
  // Add methods for dropdown dynamic locators
  if (dropdownMethods.length > 0) {
    output += `  // Dynamic Dropdown Element Getters\n`;
    dropdownMethods.forEach(method => {
      const paramList = method.params.map(p => `${p.name}: ${mapJavaTypeToTypeScript(p.type)}`).join(', ');
      const paramNames = method.params.map(p => p.name).join(', ');
      
      if (method.isList) {
        // For list of dropdown elements
        output += `  ${method.name}(${paramList}) {\n`;
        output += `    const baseLocator = this.page.locator(this.${method.name}(${paramNames}));\n`;
        output += `    \n`;
        output += `    // Add dropdown specific functionality\n`;
        output += `    const dropdown = baseLocator as any;\n`;
        output += `    \n`;
        output += `    dropdown.selectByText = async (text: string): Promise<void> => {\n`;
        output += `      await baseLocator.selectOption({ label: text });\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    dropdown.selectByValue = async (value: string): Promise<void> => {\n`;
        output += `      await baseLocator.selectOption({ value });\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    dropdown.selectByIndex = async (index: number): Promise<void> => {\n`;
        output += `      await baseLocator.selectOption({ index });\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    dropdown.getOptions = async (): Promise<string[]> => {\n`;
        output += `      return baseLocator.locator('option').allTextContents();\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    return dropdown;\n`;
        output += `  }\n\n`;
        
        // Add method to get all dropdown elements
        output += `  async getAll${method.name.charAt(0).toUpperCase() + method.name.slice(1)}(${paramList}) {\n`;
        output += `    const selector = this.${method.name}(${paramNames});\n`;
        output += `    const elements = this.page.locator(selector);\n`;
        output += `    const count = await elements.count();\n`;
        output += `    const result = [];\n`;
        output += `    \n`;
        output += `    for (let i = 0; i < count; i++) {\n`;
        output += `      const baseLocator = elements.nth(i);\n`;
        output += `      const dropdown = baseLocator as any;\n`;
        output += `      \n`;
        output += `      dropdown.selectByText = async (text: string): Promise<void> => {\n`;
        output += `        await baseLocator.selectOption({ label: text });\n`;
        output += `      };\n`;
        output += `      \n`;
        output += `      dropdown.selectByValue = async (value: string): Promise<void> => {\n`;
        output += `        await baseLocator.selectOption({ value });\n`;
        output += `      };\n`;
        output += `      \n`;
        output += `      dropdown.selectByIndex = async (index: number): Promise<void> => {\n`;
        output += `        await baseLocator.selectOption({ index });\n`;
        output += `      };\n`;
        output += `      \n`;
        output += `      dropdown.getOptions = async (): Promise<string[]> => {\n`;
        output += `        return baseLocator.locator('option').allTextContents();\n`;
        output += `      };\n`;
        output += `      \n`;
        output += `      result.push(dropdown);\n`;
        output += `    }\n`;
        output += `    \n`;
        output += `    return result;\n`;
        output += `  }\n\n`;
      } else {
        // Standard dropdown method for single element
        output += `  ${method.name}(${paramList}) {\n`;
        output += `    const baseLocator = this.page.locator(this.${method.name}(${paramNames}));\n`;
        output += `    \n`;
        output += `    // Add dropdown specific functionality\n`;
        output += `    const dropdown = baseLocator as any;\n`;
        output += `    \n`;
        output += `    dropdown.selectByText = async (text: string): Promise<void> => {\n`;
        output += `      await baseLocator.selectOption({ label: text });\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    dropdown.selectByValue = async (value: string): Promise<void> => {\n`;
        output += `      await baseLocator.selectOption({ value });\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    dropdown.selectByIndex = async (index: number): Promise<void> => {\n`;
        output += `      await baseLocator.selectOption({ index });\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    dropdown.getOptions = async (): Promise<string[]> => {\n`;
        output += `      return baseLocator.locator('option').allTextContents();\n`;
        output += `    };\n`;
        output += `    \n`;
        output += `    return dropdown;\n`;
        output += `  }\n\n`;
      }
    });
  }
  
  // Common page actions 
  output += `  // Common Page Actions\n`;
  output += `  async waitForPageToLoad(): Promise<void> {\n`;
  output += `    await this.page.waitForLoadState('networkidle');\n`;
  output += `  }\n\n`;
  
  output += `  async sleep(ms: number): Promise<void> {\n`;
  output += `    return new Promise(resolve => setTimeout(resolve, ms));\n`;
  output += `  }\n`;
  
  // Close class
  output += `}\n`;
  
  return output;
}
