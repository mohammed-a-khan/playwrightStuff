package com.cssmart.core.element;

import java.io.File;
import java.time.Duration;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.openqa.selenium.*;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.Color;
import org.openqa.selenium.support.ui.ExpectedCondition;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.Select;
import org.openqa.selenium.support.ui.WebDriverWait;

import com.cssmart.ai.healing.SelfHealingLocator;
import com.cssmart.ai.visual.VisualAssertions;
import com.cssmart.config.PropertyManager;
import com.cssmart.core.driver.CSSmartDriverFactory;
import com.cssmart.core.exceptions.ElementInteractionException;

/**
 * Enhanced element implementation with AI capabilities and extensive utility methods
 */
public class CSSmartElement {

    private By locator;
    private String elementName;
    private CSSmartWebElement element;
    private PropertyManager propertyManager = PropertyManager.getInstance();
    
    /**
     * Create a new smart element
     * @param locator The locator
     * @param elementName Descriptive name of the element
     */
    public CSSmartElement(By locator, String elementName) {
        this.locator = locator;
        this.elementName = elementName;
    }
    
    /**
     * Get the underlying CSSmartWebElement
     * @return The CSSmartWebElement
     */
    public CSSmartWebElement getElement() {
        if (element == null) {
            element = new CSSmartWebElement(locator, elementName);
        }
        return element;
    }
    
    /**
     * Get the underlying WebElement
     * @return WebElement
     */
    public WebElement getWebElement() {
        return getElement();
    }
    
    /**
     * Get the locator used for this element
     * @return By locator
     */
    public By getLocator() {
        return locator;
    }
    
    /**
     * Get element name
     * @return Element name
     */
    public String getElementName() {
        return elementName;
    }
    
    // Basic Web Element Operations
    
    /**
     * Type text into the element with automatic visibility wait
     * @param text Text to type
     * @return This element for chaining
     */
    public CSSmartElement type(String text) {
        waitVisible();
        getElement().type(text);
        return this;
    }
    
    /**
     * Clear and type text into the element
     * @param text Text to type
     * @return This element for chaining
     */
    public CSSmartElement clearAndType(String text) {
        waitVisible();
        getElement().clear();
        getElement().type(text);
        return this;
    }
    
    /**
     * Clear the element
     * @return This element for chaining
     */
    public CSSmartElement clear() {
        waitVisible();
        getElement().clear();
        return this;
    }
    
    /**
     * Click the element with automatic clickability wait
     * @return This element for chaining
     */
    public CSSmartElement click() {
        waitClickable();
        getElement().click();
        return this;
    }
    
    /**
     * Double-click the element
     * @return This element for chaining
     */
    public CSSmartElement doubleClick() {
        waitClickable();
        new Actions(CSSmartDriverFactory.getDriver())
            .doubleClick(getElement())
            .perform();
        return this;
    }
    
    /**
     * Right-click the element
     * @return This element for chaining
     */
    public CSSmartElement rightClick() {
        waitClickable();
        new Actions(CSSmartDriverFactory.getDriver())
            .contextClick(getElement())
            .perform();
        return this;
    }
    
    /**
     * Click with retry logic for unstable elements
     * @return This element for chaining
     */
    public CSSmartElement clickWithRetry() {
        waitClickable();
        getElement().clickWithRetry();
        return this;
    }
    
    /**
     * Hover over the element
     * @return This element for chaining
     */
    public CSSmartElement hover() {
        waitVisible();
        new Actions(CSSmartDriverFactory.getDriver())
            .moveToElement(getElement())
            .perform();
        return this;
    }
    
    /**
     * Drag and drop this element to target element
     * @param target Target element to drop onto
     * @return This element for chaining
     */
    public CSSmartElement dragAndDropTo(CSSmartElement target) {
        waitVisible();
        target.waitVisible();
        
        new Actions(CSSmartDriverFactory.getDriver())
            .dragAndDrop(getElement(), target.getElement())
            .perform();
        
        return this;
    }
    
    /**
     * Drag and drop by offset
     * @param xOffset X offset
     * @param yOffset Y offset
     * @return This element for chaining
     */
    public CSSmartElement dragAndDropBy(int xOffset, int yOffset) {
        waitVisible();
        
        new Actions(CSSmartDriverFactory.getDriver())
            .dragAndDropBy(getElement(), xOffset, yOffset)
            .perform();
        
        return this;
    }
    
    /**
     * Press and hold the element
     * @param holdTimeMs Time to hold in milliseconds
     * @return This element for chaining
     */
    public CSSmartElement clickAndHold(long holdTimeMs) {
        waitVisible();
        
        Actions actions = new Actions(CSSmartDriverFactory.getDriver());
        actions.clickAndHold(getElement()).perform();
        
        try {
            Thread.sleep(holdTimeMs);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        actions.release().perform();
        return this;
    }
    
    /**
     * Submit a form
     * @return This element for chaining
     */
    public CSSmartElement submit() {
        waitVisible();
        getElement().submit();
        return this;
    }
    
    /**
     * Send keys to element without clearing first
     * @param keysToSend Keys to send
     * @return This element for chaining
     */
    public CSSmartElement sendKeys(CharSequence... keysToSend) {
        waitVisible();
        getElement().sendKeys(keysToSend);
        return this;
    }
    
    /**
     * Press key combination on element (Ctrl+A, Ctrl+C, etc)
     * @param modifier Modifier key (Keys.CONTROL, Keys.ALT, etc)
     * @param key Key to press
     * @return This element for chaining
     */
    public CSSmartElement sendKeysWithModifier(Keys modifier, CharSequence key) {
        waitVisible();
        
        new Actions(CSSmartDriverFactory.getDriver())
            .click(getElement())
            .keyDown(modifier)
            .sendKeys(key)
            .keyUp(modifier)
            .build()
            .perform();
            
        return this;
    }
    
    /**
     * Select all text in the element (Ctrl+A)
     * @return This element for chaining
     */
    public CSSmartElement selectAll() {
        return sendKeysWithModifier(Keys.CONTROL, "a");
    }
    
    /**
     * Cut text from the element (Ctrl+X)
     * @return This element for chaining
     */
    public CSSmartElement cut() {
        return sendKeysWithModifier(Keys.CONTROL, "x");
    }
    
    /**
     * Copy text from the element (Ctrl+C)
     * @return This element for chaining
     */
    public CSSmartElement copy() {
        return sendKeysWithModifier(Keys.CONTROL, "c");
    }
    
    /**
     * Paste text to the element (Ctrl+V)
     * @return This element for chaining
     */
    public CSSmartElement paste() {
        return sendKeysWithModifier(Keys.CONTROL, "v");
    }
    
    /**
     * Type text slowly with delay between keystrokes
     * @param text Text to type
     * @param delayMillis Delay between keystrokes in milliseconds
     * @return This element for chaining
     */
    public CSSmartElement typeSlowly(String text, long delayMillis) {
        waitVisible();
        click();
        
        for (char c : text.toCharArray()) {
            getElement().sendKeys(String.valueOf(c));
            try {
                Thread.sleep(delayMillis);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        return this;
    }
    
    /**
     * Press Enter key on element
     * @return This element for chaining
     */
    public CSSmartElement pressEnter() {
        waitVisible();
        getElement().sendKeys(Keys.ENTER);
        return this;
    }
    
    /**
     * Press Tab key on element
     * @return This element for chaining
     */
    public CSSmartElement pressTab() {
        waitVisible();
        getElement().sendKeys(Keys.TAB);
        return this;
    }
    
    /**
     * Press Escape key on element
     * @return This element for chaining
     */
    public CSSmartElement pressEscape() {
        waitVisible();
        getElement().sendKeys(Keys.ESCAPE);
        return this;
    }
    
    // Select element operations
    
    /**
     * Select option by visible text (for SELECT elements)
     * @param text Visible text
     * @return This element for chaining
     */
    public CSSmartElement selectByVisibleText(String text) {
        waitVisible();
        new Select(getElement()).selectByVisibleText(text);
        return this;
    }
    
    /**
     * Select option by value (for SELECT elements)
     * @param value Option value
     * @return This element for chaining
     */
    public CSSmartElement selectByValue(String value) {
        waitVisible();
        new Select(getElement()).selectByValue(value);
        return this;
    }
    
    /**
     * Select option by index (for SELECT elements)
     * @param index Option index
     * @return This element for chaining
     */
    public CSSmartElement selectByIndex(int index) {
        waitVisible();
        new Select(getElement()).selectByIndex(index);
        return this;
    }
    
    /**
     * Deselect all options (for multi-select elements)
     * @return This element for chaining
     */
    public CSSmartElement deselectAll() {
        waitVisible();
        new Select(getElement()).deselectAll();
        return this;
    }
    
    /**
     * Get selected option text (for SELECT elements)
     * @return Selected option text
     */
    public String getSelectedText() {
        waitVisible();
        return new Select(getElement()).getFirstSelectedOption().getText();
    }
    
    /**
     * Get all available options from a select element
     * @return List of option text values
     */
    public List<String> getOptions() {
        waitVisible();
        return new Select(getElement()).getOptions()
            .stream()
            .map(WebElement::getText)
            .collect(Collectors.toList());
    }
    
    /**
     * Get all selected options from a multi-select
     * @return List of selected option text values
     */
    public List<String> getAllSelectedOptions() {
        waitVisible();
        return new Select(getElement()).getAllSelectedOptions()
            .stream()
            .map(WebElement::getText)
            .collect(Collectors.toList());
    }
    
    /**
     * Check if select element supports multiple selections
     * @return true if multiple selections supported
     */
    public boolean isMultipleSelect() {
        waitVisible();
        return new Select(getElement()).isMultiple();
    }
    
    // Checkbox and Radio button operations
    
    /**
     * Check a checkbox (if not already checked)
     * @return This element for chaining
     */
    public CSSmartElement check() {
        waitClickable();
        if (!isSelected()) {
            click();
        }
        return this;
    }
    
    /**
     * Uncheck a checkbox (if checked)
     * @return This element for chaining
     */
    public CSSmartElement uncheck() {
        waitClickable();
        if (isSelected()) {
            click();
        }
        return this;
    }
    
    /**
     * Set checkbox to specified state
     * @param check True to check, false to uncheck
     * @return This element for chaining
     */
    public CSSmartElement setChecked(boolean check) {
        return check ? check() : uncheck();
    }
    
    // Property getters
    
    /**
     * Get text from element
     * @return Text content
     */
    public String getText() {
        waitVisible();
        return getElement().getTextSafe();
    }
    
    /**
     * Get text content including hidden text
     * @return Text content
     */
    public String getTextContent() {
        return (String) executeScript("return arguments[0].textContent", getElement());
    }
    
    /**
     * Get inner HTML of element
     * @return Inner HTML
     */
    public String getInnerHtml() {
        return executeJsMethod("innerHTML");
    }
    
    /**
     * Get outer HTML of element
     * @return Outer HTML
     */
    public String getOuterHtml() {
        return executeJsMethod("outerHTML");
    }
    
    /**
     * Get value attribute
     * @return Value attribute
     */
    public String getValue() {
        return getAttribute("value");
    }
    
    /**
     * Set value directly via JavaScript
     * @param value Value to set
     * @return This element for chaining
     */
    public CSSmartElement setValue(String value) {
        executeScript("arguments[0].value = arguments[1]", getElement(), value);
        return this;
    }
    
    /**
     * Get placeholder attribute
     * @return Placeholder text
     */
    public String getPlaceholder() {
        return getAttribute("placeholder");
    }
    
    /**
     * Get href attribute (for links)
     * @return Link URL
     */
    public String getHref() {
        return getAttribute("href");
    }
    
    /**
     * Get title attribute
     * @return Title text
     */
    public String getTitle() {
        return getAttribute("title");
    }
    
    /**
     * Get ID attribute
     * @return Element ID
     */
    public String getId() {
        return getAttribute("id");
    }
    
    /**
     * Get attribute value
     * @param attribute Attribute name
     * @return Attribute value
     */
    public String getAttribute(String attribute) {
        try {
            return getElement().getAttribute(attribute);
        } catch (Exception e) {
            return null;
        }
    }
    
    /**
     * Get CSS property value
     * @param propertyName CSS property name
     * @return CSS property value
     */
    public String getCssValue(String propertyName) {
        return getElement().getCssValue(propertyName);
    }
    
    /**
     * Get color as hex value
     * @return Hex color value
     */
    public String getColor() {
        String rgbColor = getCssValue("color");
        return Color.fromString(rgbColor).asHex();
    }
    
    /**
     * Get background color as hex value
     * @return Hex background color value
     */
    public String getBackgroundColor() {
        String rgbColor = getCssValue("background-color");
        return Color.fromString(rgbColor).asHex();
    }
    
    /**
     * Get font size
     * @return Font size
     */
    public String getFontSize() {
        return getCssValue("font-size");
    }
    
    /**
     * Get element width
     * @return Width in pixels
     */
    public int getWidth() {
        return getElement().getSize().getWidth();
    }
    
    /**
     * Get element height
     * @return Height in pixels
     */
    public int getHeight() {
        return getElement().getSize().getHeight();
    }
    
    /**
     * Get element location X
     * @return X coordinate
     */
    public int getX() {
        return getElement().getLocation().getX();
    }
    
    /**
     * Get element location Y
     * @return Y coordinate
     */
    public int getY() {
        return getElement().getLocation().getY();
    }
    
    /**
     * Execute JavaScript method on element
     * @param method Method name
     * @return Result as string
     */
    public String executeJsMethod(String method) {
        return (String) executeScript("return arguments[0]." + method, getElement());
    }
    
    /**
     * Execute JavaScript on element
     * @param script JavaScript to execute
     * @param args Script arguments
     * @return Result of script execution
     */
    public Object executeScript(String script, Object... args) {
        try {
            WebDriver driver = CSSmartDriverFactory.getDriver();
            if (driver instanceof JavascriptExecutor) {
                return ((JavascriptExecutor) driver).executeScript(script, args);
            }
        } catch (Exception e) {
            throw new ElementInteractionException("Failed to execute script on element: " + elementName, e);
        }
        return null;
    }
    
    // State checking methods
    
    /**
     * Check if element exists
     * @return true if element exists
     */
    public boolean exists() {
        return getElement().exists();
    }
    
    /**
     * Check if element is displayed
     * @return true if element is displayed
     */
    public boolean isDisplayed() {
        if (!exists()) {
            return false;
        }
        try {
            return getElement().isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Check if element is enabled
     * @return true if element is enabled
     */
    public boolean isEnabled() {
        if (!exists()) {
            return false;
        }
        try {
            return getElement().isEnabled();
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Check if element is selected (checkboxes, radio buttons)
     * @return true if element is selected
     */
    public boolean isSelected() {
        if (!exists()) {
            return false;
        }
        try {
            return getElement().isSelected();
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Check if element has class
     * @param className Class name to check
     * @return true if element has class
     */
    public boolean hasClass(String className) {
        String classes = getAttribute("class");
        if (classes == null) {
            return false;
        }
        for (String cls : classes.split("\\s+")) {
            if (cls.equals(className)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Check if element has attribute
     * @param attribute Attribute name
     * @return true if attribute exists
     */
    public boolean hasAttribute(String attribute) {
        return getAttribute(attribute) != null;
    }
    
    /**
     * Check if element is visible in viewport
     * @return true if element is in viewport
     */
    public boolean isInViewport() {
        return (Boolean) executeScript(
            "var rect = arguments[0].getBoundingClientRect();" +
            "return (" +
            "  rect.top >= 0 &&" +
            "  rect.left >= 0 &&" +
            "  rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&" +
            "  rect.right <= (window.innerWidth || document.documentElement.clientWidth)" +
            ");", 
            getElement());
    }
    
    /**
     * Check if element has focus
     * @return true if element has focus
     */
    public boolean hasFocus() {
        return (Boolean) executeScript("return document.activeElement === arguments[0]", getElement());
    }
    
    /**
     * Focus the element
     * @return This element for chaining
     */
    public CSSmartElement focus() {
        executeScript("arguments[0].focus();", getElement());
        return this;
    }
    
    /**
     * Blur (unfocus) the element
     * @return This element for chaining
     */
    public CSSmartElement blur() {
        executeScript("arguments[0].blur();", getElement());
        return this;
    }
    
    // Wait methods
    
    /**
     * Wait for element to be visible
     * @return This element for chaining
     */
    public CSSmartElement waitVisible() {
        int timeout = propertyManager.getIntProperty("element.wait.timeout", 15);
        getElement().waitForVisible(timeout);
        return this;
    }
    
    /**
     * Wait for element to be visible with custom timeout
     * @param timeoutSeconds Timeout in seconds
     * @return This element for chaining
     */
    public CSSmartElement waitVisible(int timeoutSeconds) {
        getElement().waitForVisible(timeoutSeconds);
        return this;
    }
    
    /**
     * Wait for element to be clickable
     * @return This element for chaining
     */
    public CSSmartElement waitClickable() {
        int timeout = propertyManager.getIntProperty("element.wait.timeout", 15);
        getElement().waitForClickable(timeout);
        return this;
    }
    
    /**
     * Wait for element to be clickable with custom timeout
     * @param timeoutSeconds Timeout in seconds
     * @return This element for chaining
     */
    public CSSmartElement waitClickable(int timeoutSeconds) {
        getElement().waitForClickable(timeoutSeconds);
        return this;
    }
    
    /**
     * Wait for element to contain text
     * @param text Text to wait for
     * @return This element for chaining
     */
    public CSSmartElement waitForText(String text) {
        int timeout = propertyManager.getIntProperty("element.wait.timeout", 15);
        WebDriverWait wait = new WebDriverWait(CSSmartDriverFactory.getDriver(), Duration.ofSeconds(timeout));
        wait.until(ExpectedConditions.textToBePresentInElement(getElement(), text));
        return this;
    }
    
    /**
     * Wait for element to contain value
     * @param value Value to wait for
     * @return This element for chaining
     */
    public CSSmartElement waitForValue(String value) {
        int timeout = propertyManager.getIntProperty("element.wait.timeout", 15);
        WebDriverWait wait = new WebDriverWait(CSSmartDriverFactory.getDriver(), Duration.ofSeconds(timeout));
        wait.until(ExpectedConditions.attributeToBe(getElement(), "value", value));
        return this;
    }
    
    /**
     * Wait for element to contain attribute
     * @param attribute Attribute name
     * @param value Expected value
     * @return This element for chaining
     */
    public CSSmartElement waitForAttribute(String attribute, String value) {
        int timeout = propertyManager.getIntProperty("element.wait.timeout", 15);
        WebDriverWait wait = new WebDriverWait(CSSmartDriverFactory.getDriver(), Duration.ofSeconds(timeout));
        wait.until(ExpectedConditions.attributeToBe(getElement(), attribute, value));
        return this;
    }
    
    /**
     * Wait for custom condition
     * @param condition Condition to wait for
     * @return This element for chaining
     */
    public CSSmartElement waitFor(Function<WebDriver, Boolean> condition) {
        int timeout = propertyManager.getIntProperty("element.wait.timeout", 15);
        WebDriverWait wait = new WebDriverWait(CSSmartDriverFactory.getDriver(), Duration.ofSeconds(timeout));
        wait.until(condition);
        return this;
    }
    
    /**
     * Wait for element to be invisible
     * @return This element for chaining
     */
    public CSSmartElement waitInvisible() {
        int timeout = propertyManager.getIntProperty("element.wait.timeout", 15);
        WebDriverWait wait = new WebDriverWait(CSSmartDriverFactory.getDriver(), Duration.ofSeconds(timeout));
        wait.until(ExpectedConditions.invisibilityOf(getElement()));
        return this;
    }
    
    /**
     * Wait for element to be stale (no longer attached to DOM)
     * @return This element for chaining
     */
    public CSSmartElement waitStale() {
        int timeout = propertyManager.getIntProperty("element.wait.timeout", 15);
        WebDriverWait wait = new WebDriverWait(CSSmartDriverFactory.getDriver(), Duration.ofSeconds(timeout));
        wait.until(ExpectedConditions.stalenessOf(getElement()));
        return this;
    }
    
    /**
     * Wait until element's class contains specified value
     * @param className Class name to wait for
     * @return This element for chaining
     */
    public CSSmartElement waitForClass(String className) {
        int timeout = propertyManager.getIntProperty("element.wait.timeout", 15);
        WebDriverWait wait = new WebDriverWait(CSSmartDriverFactory.getDriver(), Duration.ofSeconds(timeout));
        wait.until(driver -> {
            String classes = getElement().getAttribute("class");
            return classes != null && classes.contains(className);
        });
        return this;
    }
    
    // Navigation and scrolling
    
    /**
     * Scroll element into view
     * @return This element for chaining
     */
    public CSSmartElement scrollIntoView() {
        executeScript("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", getElement());
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return this;
    }
    
    /**
     * Scroll to element with offset
     * @param xOffset X offset
     * @param yOffset Y offset
     * @return This element for chaining
     */
    public CSSmartElement scrollWithOffset(int xOffset, int yOffset) {
        executeScript(
            "var rect = arguments[0].getBoundingClientRect();" +
            "window.scrollTo(rect.x + arguments[1], rect.y + arguments[2]);",
            getElement(), xOffset, yOffset);
        return this;
    }
    
    /**
     * Highlight element (useful for debugging)
     * @return This element for chaining
     */
    public CSSmartElement highlight() {
        String originalStyle = getElement().getAttribute("style");
        executeScript(
            "arguments[0].setAttribute('style', 'border: 2px solid red; background-color: yellow; color: black;');",
            getElement());
        
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        executeScript(
            "arguments[0].setAttribute('style', arguments[1]);", 
            getElement(),
            originalStyle == null ? "" : originalStyle);
            
        return this;
    }
    
    /**
     * Flash element for visual debugging
     * @param times Number of times to flash
     * @return This element for chaining
     */
    public CSSmartElement flash(int times) {
        String originalStyle = getElement().getAttribute("style");
        String highlightStyle = "border: 2px solid red; background-color: yellow; color: black;";
        
        for (int i = 0; i < times; i++) {
            executeScript(
                "arguments[0].setAttribute('style', arguments[1]);",
                getElement(), highlightStyle);
            
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
            
            executeScript(
                "arguments[0].setAttribute('style', arguments[1]);", 
                getElement(),
                originalStyle == null ? "" : originalStyle);
                
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        return this;
    }
    
    /**
     * Take screenshot of this element
     * @param fileName Filename to save screenshot
     * @return This element for chaining
     */
    public CSSmartElement takeScreenshot(String fileName) {
        try {
            getElement().waitForVisible(5);
            File screenshot = getElement().getScreenshotAs(OutputType.FILE);
            String screenshotDir = propertyManager.getProperty("screenshot.path", "target/screenshots");
            File directory = new File(screenshotDir);
            if (!directory.exists()) {
                directory.mkdirs();
            }
            
            File dest = new File(directory, fileName);
            org.apache.commons.io.FileUtils.copyFile(screenshot, dest);
        } catch (Exception e) {
            System.err.println("Failed to take element screenshot: " + e.getMessage());
        }
        return this;
    }
    
    // AI-powered methods
    
    /**
     * Verify element visually matches baseline
     * @return true if visual match
     */
    public boolean visuallyMatches() {
        waitVisible();
        return VisualAssertions.assertElementLooksTheSame(getElement(), elementName);
    }
    
    /**
     * Verify element visually matches baseline with custom threshold
     * @param threshold Difference threshold (0.0-1.0)
     * @return true if visual match
     */
    public boolean visuallyMatches(double threshold) {
        waitVisible();
        return VisualAssertions.assertElementLooksTheSame(getElement(), elementName, threshold);
    }
    
    /**
     * Self-heal locator if element not found
     * @return Healed element or null if not found
     */
    public CSSmartElement selfHeal() {
        try {
            By healedLocator = SelfHealingLocator.findAlternativeLocator(locator);
            if (healedLocator != null) {
                this.locator = healedLocator;
                this.element = null; // Force re-fetch with new locator
                return this;
            }
        } catch (Exception e) {
            System.err.println("Failed to self-heal element: " + e.getMessage());
        }
        return null;
    }
    
    /**
     * Find child element
     * @param childLocator Locator for child
     * @param name Element name
     * @return New CSSmartElement for the child
     */
    public CSSmartElement findElement(By childLocator, String name) {
        waitVisible();
        WebElement childElement = getElement().findElement(childLocator);
        return new CSSmartElement(childLocator, name);
    }
    
    /**
     * Find child elements
     * @param childLocator Locator for children
     * @param namePrefix Prefix for element names
     * @return List of CSSmartElements
     */
    public List<CSSmartElement> findElements(By childLocator, String namePrefix) {
        waitVisible();
        List<WebElement> elements = getElement().findElements(childLocator);
        
        List<CSSmartElement> result = new ArrayList<>();
        for (int i = 0; i < elements.size(); i++) {
            result.add(new CSSmartElement(childLocator, namePrefix + "-" + i));
        }
        
        return result;
    }
}



package com.cssmart.core.page;

import java.io.File;
import java.lang.reflect.Field;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import org.openqa.selenium.*;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.PageFactory;
import org.openqa.selenium.support.ui.ExpectedCondition;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.FluentWait;
import org.openqa.selenium.support.ui.WebDriverWait;

import com.cssmart.annotations.processors.FindByAnnotationProcessor;
import com.cssmart.config.EnvironmentManager;
import com.cssmart.config.PropertyManager;
import com.cssmart.core.driver.CSSmartDriverFactory;
import com.cssmart.core.element.CSSmartElement;
import com.cssmart.core.element.CSSmartWebElement;
import com.cssmart.core.exceptions.ElementInteractionException;
import com.cssmart.ai.generator.TestGenerator;

/**
 * Enhanced base page object with comprehensive functionality
 */
public class CSSmartBasePage {
    protected WebDriver driver;
    protected PropertyManager propertyManager;
    protected EnvironmentManager envManager;
    private Map<String, CSSmartElement> elementCache = new HashMap<>();
    private String pageName;
    private Set<By> waitConditions = new HashSet<>();
    
    /**
     * Default constructor
     */
    public CSSmartBasePage() {
        this.driver = CSSmartDriverFactory.getDriver();
        this.propertyManager = PropertyManager.getInstance();
        this.envManager = EnvironmentManager.getInstance();
        this.pageName = getClass().getSimpleName();
        initElements();
    }
    
    /**
     * Initialize page elements with enhanced handling
     */
    protected void initElements() {
        // First use standard PageFactory for WebElement initialization
        PageFactory.initElements(driver, this);
        
        // Then process and enhance elements
        for (Field field : getAllFields()) {
            field.setAccessible(true);
            
            // Process @FindBy annotations
            if (field.isAnnotationPresent(FindBy.class)) {
                try {
                    FindBy findBy = field.getAnnotation(FindBy.class);
                    By locator = FindByAnnotationProcessor.processAnnotation(findBy);
                    String elementName = field.getName();
                    
                    // Convert to enhanced elements
                    if (field.getType() == CSSmartElement.class) {
                        CSSmartElement element = new CSSmartElement(locator, elementName);
                        field.set(this, element);
                        elementCache.put(elementName, element);
                        
                        // Add to wait conditions if needed
                        if (shouldWaitForElement(field)) {
                            waitConditions.add(locator);
                        }
                    } else if (field.getType() == CSSmartWebElement.class) {
                        CSSmartWebElement webElement = new CSSmartWebElement(locator, elementName);
                        field.set(this, webElement);
                        // Also create a SmartElement version for the cache
                        elementCache.put(elementName, new CSSmartElement(locator, elementName));
                        
                        // Add to wait conditions if needed
                        if (shouldWaitForElement(field)) {
                            waitConditions.add(locator);
                        }
                    }
                } catch (Exception e) {
                    System.err.println("Failed to initialize element " + field.getName() + ": " + e.getMessage());
                }
            }
        }
    }
    
    /**
     * Get all fields including inherited fields
     * @return List of fields
     */
    private List<Field> getAllFields() {
        List<Field> fields = new ArrayList<>();
        Class<?> currentClass = this.getClass();
        
        while (currentClass != null && currentClass != Object.class) {
            fields.addAll(Arrays.asList(currentClass.getDeclaredFields()));
            currentClass = currentClass.getSuperclass();
        }
        
        return fields;
    }
    
    /**
     * Check if we should wait for this element when checking if page is loaded
     * @param field Field to check
     * @return true if we should wait for this element
     */
    private boolean shouldWaitForElement(Field field) {
        // Look for @WaitFor annotation or specific naming conventions
        // This is a placeholder - you'd implement your own logic
        String fieldName = field.getName().toLowerCase();
        return fieldName.contains("header") || 
               fieldName.contains("title") || 
               fieldName.contains("main") ||
               fieldName.contains("content");
    }
    
    /**
     * Get an element by name from the cache
     * @param elementName Element name
     * @return CSSmartElement instance
     */
    public CSSmartElement getElement(String elementName) {
        CSSmartElement element = elementCache.get(elementName);
        if (element == null) {
            throw new NoSuchElementException("Element not found in cache: " + elementName);
        }
        return element;
    }
    
    /**
     * Create a new element on-the-fly
     * @param locator Element locator
     * @param elementName Element name
     * @return CSSmartElement instance
     */
    public CSSmartElement createElement(By locator, String elementName) {
        CSSmartElement element = new CSSmartElement(locator, elementName);
        elementCache.put(elementName, element);
        return element;
    }
    
    /**
     * Find the first visible element matching any of the provided locators
     * @param locators Array of locators to try
     * @param name Name for the found element
     * @return First visible element or null if none found
     */
    public CSSmartElement findFirstVisible(String name, By... locators) {
        for (By locator : locators) {
            try {
                CSSmartElement element = createElement(locator, name);
                if (element.isDisplayed()) {
                    return element;
                }
            } catch (Exception e) {
                // Continue to next locator
            }
        }
        return null;
    }
    
    // Navigation methods
    
    /**
     * Open the page with the specified URL
     * @param url URL to open
     * @return This page instance
     */
    public CSSmartBasePage open(String url) {
        driver.get(url);
        waitForPageLoad();
        return this;
    }
    
    /**
     * Open the page with base URL + path
     * @param path Path to append to base URL
     * @return This page instance
     */
    public CSSmartBasePage openPath(String path) {
        String baseUrl = envManager.getBaseUrl();
        if (baseUrl.endsWith("/") && path.startsWith("/")) {
            path = path.substring(1);
        }
        
        driver.get(baseUrl + path);
        waitForPageLoad();
        return this;
    }
    
    /**
     * Refresh the current page
     * @return This page instance
     */
    public CSSmartBasePage refresh() {
        driver.navigate().refresh();
        waitForPageLoad();
        return this;
    }
    
    /**
     * Navigate back in browser history
     * @return This page instance
     */
    public CSSmartBasePage back() {
        driver.navigate().back();
        waitForPageLoad();
        return this;
    }
    
    /**
     * Navigate forward in browser history
     * @return This page instance
     */
    public CSSmartBasePage forward() {
        driver.navigate().forward();
        waitForPageLoad();
        return this;
    }
    
    /**
     * Get the page title
     * @return Page title
     */
    public String getTitle() {
        return driver.getTitle();
    }
    
    /**
     * Get the current URL
     * @return Current URL
     */
    public String getCurrentUrl() {
        return driver.getCurrentUrl();
    }
    
    /**
     * Check if the page URL contains text
     * @param text Text to check
     * @return true if URL contains text
     */
    public boolean urlContains(String text) {
        return getCurrentUrl().contains(text);
    }
    
    /**
     * Check if the page URL matches a regex pattern
     * @param pattern Regex pattern
     * @return true if URL matches pattern
     */
    public boolean urlMatches(String pattern) {
        return getCurrentUrl().matches(pattern);
    }
    
    /**
     * Get the page source
     * @return Page source
     */
    public String getPageSource() {
        return driver.getPageSource();
    }
    
    /**
     * Get query parameter value from URL
     * @param paramName Parameter name
     * @return Parameter value or null if not found
     */
    public String getQueryParam(String paramName) {
        String url = getCurrentUrl();
        int queryStart = url.indexOf('?');
        if (queryStart < 0) {
            return null;
        }
        
        String query = url.substring(queryStart + 1);
        String[] pairs = query.split("&");
        
        for (String pair : pairs) {
            String[] keyValue = pair.split("=", 2);
            if (keyValue.length == 2 && keyValue[0].equals(paramName)) {
                try {
                    return java.net.URLDecoder.decode(keyValue[1], "UTF-8");
                } catch (Exception e) {
                    return keyValue[1];
                }
            }
        }
        
        return null;
    }
    
    /**
     * Get URL fragment (part after #)
     * @return URL fragment or empty string if none
     */
    public String getUrlFragment() {
        String url = getCurrentUrl();
        int fragmentStart = url.indexOf('#');
        
        if (fragmentStart < 0) {
            return "";
        }
        
        return url.substring(fragmentStart + 1);
    }
    
    // Wait methods
    
    /**
     * Wait for page to load with default timeout
     * @return This page instance
     */
    public CSSmartBasePage waitForPageLoad() {
        int timeout = propertyManager.getIntProperty("page.load.timeout", 60);
        return waitForPageLoad(timeout);
    }
    
    /**
     * Wait for page to load with specified timeout
     * @param timeoutSeconds Timeout in seconds
     * @return This page instance
     */
    public CSSmartBasePage waitForPageLoad(int timeoutSeconds) {
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        
        // Wait for document.readyState to be complete
        wait.until((ExpectedCondition<Boolean>) driver -> {
            boolean ready = false;
            try {
                ready = ((JavascriptExecutor) driver).executeScript("return document.readyState").equals("complete");
            } catch (Exception e) {
                // If JS execution fails, assume page is not ready
            }
            return ready;
        });
        
        // Wait for jQuery to be loaded and inactive (if present)
        wait.until((ExpectedCondition<Boolean>) driver -> {
            boolean jQueryDefined = false;
            boolean jQueryActive = true;
            try {
                jQueryDefined = (Boolean) ((JavascriptExecutor) driver).executeScript("return typeof jQuery != 'undefined'");
                if (jQueryDefined) {
                    jQueryActive = (Long) ((JavascriptExecutor) driver).executeScript("return jQuery.active") > 0;
                } else {
                    // If jQuery is not defined, we consider this condition satisfied
                    jQueryActive = false;
                }
            } catch (Exception e) {
                // If JS execution fails, assume jQuery is not active
                jQueryActive = false;
            }
            return !jQueryActive;
        });
        
        // Wait for Angular (if present)
        wait.until((ExpectedCondition<Boolean>) driver -> {
            boolean angularDefined = false;
            boolean angularIdle = false;
            try {
                angularDefined = (Boolean) ((JavascriptExecutor) driver).executeScript(
                    "return typeof window.angular !== 'undefined' || " +
                    "typeof window.getAllAngularTestabilities !== 'undefined'");
                
                if (angularDefined) {
                    angularIdle = (Boolean) ((JavascriptExecutor) driver).executeScript(
                        "if (typeof window.getAllAngularTestabilities !== 'undefined') {" +
                        "  var testabilities = window.getAllAngularTestabilities();" +
                        "  if (testabilities.length > 0) {" +
                        "    for (var i = 0; i < testabilities.length; i++) {" +
                        "      if (!testabilities[i].isStable()) return false;" +
                        "    }" +
                        "    return true;" +
                        "  }" +
                        "}" +
                        "if (window.angular) {" +
                        "  var injector = window.angular.element(document.body).injector();" +
                        "  if (injector) {" +
                        "    var $http = injector.get('$http');" +
                        "    return $http.pendingRequests.length === 0;" +
                        "  }" +
                        "}" +
                        "return true;");
                } else {
                    // If Angular is not defined, we consider this condition satisfied
                    angularIdle = true;
                }
            } catch (Exception e) {
                // If JS execution fails, assume Angular is idle
                angularIdle = true;
            }
            return angularIdle;
        });
        
        // Wait for React
        wait.until((ExpectedCondition<Boolean>) driver -> {
            try {
                return (Boolean) ((JavascriptExecutor) driver).executeScript(
                    "return (typeof window.React === 'undefined') || " +
                    "!(typeof window.__REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && " +
                    "  window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers && " +
                    "  Object.keys(window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).length > 0 && " +
                    "  window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers[1]._rendering);"
                );
            } catch (Exception e) {
                // If JS execution fails, assume React is done
                return true;
            }
        });
        
        // Wait for custom wait conditions (core page elements)
        for (By locator : waitConditions) {
            try {
                wait.until(ExpectedConditions.presenceOfElementLocated(locator));
            } catch (Exception e) {
                // Continue with other wait conditions if one fails
                System.err.println("Wait condition failed for locator: " + locator);
            }
        }
        
        return this;
    }
    
    /**
     * Wait for title to contain text
     * @param title Title text to wait for
     * @return This page instance
     */
    public CSSmartBasePage waitForTitle(String title) {
        int timeout = propertyManager.getIntProperty("page.load.timeout", 60);
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeout));
        wait.until(ExpectedConditions.titleContains(title));
        return this;
    }
    
    /**
     * Wait for URL to contain text
     * @param urlText URL text to wait for
     * @return This page instance
     */
    public CSSmartBasePage waitForUrl(String urlText) {
        int timeout = propertyManager.getIntProperty("page.load.timeout", 60);
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeout));
        wait.until(ExpectedConditions.urlContains(urlText));
        return this;
    }
    
    /**
     * Wait for URL to match pattern
     * @param urlPattern URL regex pattern to match
     * @return This page instance
     */
    public CSSmartBasePage waitForUrlMatches(String urlPattern) {
        int timeout = propertyManager.getIntProperty("page.load.timeout", 60);
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeout));
        wait.until(ExpectedConditions.urlMatches(urlPattern));
        return this;
    }
    
    /**
     * Wait for an element to be visible
     * @param locator Element locator
     * @param timeoutSeconds Timeout in seconds
     * @return The found element
     */
    public WebElement waitForVisible(By locator, int timeoutSeconds) {
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        return wait.until(ExpectedConditions.visibilityOfElementLocated(locator));
    }
    
    /**
     * Wait for element to be clickable
     * @param locator Element locator
     * @param timeoutSeconds Timeout in seconds
     * @return The found element
     */
    public WebElement waitForClickable(By locator, int timeoutSeconds) {
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        return wait.until(ExpectedConditions.elementToBeClickable(locator));
    }
    
    /**
     * Wait for element to be present
     * @param locator Element locator
     * @param timeoutSeconds Timeout in seconds
     * @return The found element
     */
    public WebElement waitForPresence(By locator, int timeoutSeconds) {
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
        return wait.until(ExpectedConditions.presenceOfElementLocated(locator));
    }
    
    /**
     * Wait for a condition with custom message
     * @param condition The condition to wait for
     * @param message Error message if timeout occurs
     * @param timeoutSeconds Timeout in seconds
     * @return This page instance
     */
    public CSSmartBasePage waitFor(ExpectedCondition<?> condition, String message, int timeoutSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
            wait.withMessage(message).until(condition);
        } catch (TimeoutException e) {
            // Optionally add additional error handling here
            throw e;
        }
        return this;
    }
    
    /**
     * Wait with fluent wait pattern and custom polling
     * @param condition Condition to wait for
     * @param timeoutSeconds Timeout in seconds
     * @param pollingMillis Polling interval in milliseconds
     * @return This page instance
     */
    public CSSmartBasePage fluentWait(ExpectedCondition<?> condition, int timeoutSeconds, long pollingMillis) {
        FluentWait<WebDriver> wait = new FluentWait<>(driver)
            .withTimeout(Duration.ofSeconds(timeoutSeconds))
            .pollingEvery(Duration.ofMillis(pollingMillis))
            .ignoring(NoSuchElementException.class)
            .ignoring(StaleElementReferenceException.class);
            
        wait.until(condition);
        return this;
    }
    
    /**
     * Wait for any of the specified conditions to be met
     * @param timeoutSeconds Timeout in seconds
     * @param conditions Conditions to wait for
     * @return Index of the first condition met, or -1 if timeout
     */
    public int waitForAny(int timeoutSeconds, ExpectedCondition<?>... conditions) {
        long endTime = System.currentTimeMillis() + (timeoutSeconds * 1000);
        
        while (System.currentTimeMillis() < endTime) {
            for (int i = 0; i < conditions.length; i++) {
                try {
                    if (conditions[i].apply(driver) != null) {
                        return i;
                    }
                } catch (Exception e) {
                    // Continue to next condition
                }
            }
            
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        return -1;
    }
    
    // JavaScript execution methods
    
    /**
     * Execute JavaScript
     * @param script Script to execute
     * @param args Script arguments
     * @return Result of script execution
     */
    public Object executeScript(String script, Object... args) {
        try {
            if (driver instanceof JavascriptExecutor) {
                return ((JavascriptExecutor) driver).executeScript(script, args);
            }
        } catch (Exception e) {
            throw new ElementInteractionException("Failed to execute script", e);
        }
        throw new UnsupportedOperationException("Driver does not support JavaScript execution");
    }
    
    /**
     * Execute asynchronous JavaScript
     * @param script Script to execute
     * @param args Script arguments
     * @return Result of script execution
     */
    public Object executeAsyncScript(String script, Object... args) {
        try {
            if (driver instanceof JavascriptExecutor) {
                return ((JavascriptExecutor) driver).executeAsyncScript(script, args);
            }
        } catch (Exception e) {
            throw new ElementInteractionException("Failed to execute async script", e);
        }
        throw new UnsupportedOperationException("Driver does not support asynchronous JavaScript execution");
    }
    
    /**
     * Scroll to top of page
     * @return This page instance
     */
    public CSSmartBasePage scrollToTop() {
        executeScript("window.scrollTo(0, 0);");
        return this;
    }
    
    /**
     * Scroll to bottom of page
     * @return This page instance
     */
    public CSSmartBasePage scrollToBottom() {
        executeScript("window.scrollTo(0, document.body.scrollHeight);");
        return this;
    }
    
    /**
     * Scroll to specific position
     * @param x X coordinate
     * @param y Y coordinate
     * @return This page instance
     */
    public CSSmartBasePage scrollTo(int x, int y) {
        executeScript("window.scrollTo(arguments[0], arguments[1]);", x, y);
        return this;
    }
    
    /**
     * Scroll by offset
     * @param x X offset
     * @param y Y offset
     * @return This page instance
     */
    public CSSmartBasePage scrollBy(int x, int y) {
        executeScript("window.scrollBy(arguments[0], arguments[1]);", x, y);
        return this;
    }
    
    /**
     * Scroll to element
     * @param element Element to scroll to
     * @return This page instance
     */
    public CSSmartBasePage scrollToElement(CSSmartElement element) {
        executeScript("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", element.getElement());
        // Small pause to allow scroll animation to complete
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return this;
    }
    
    /**
     * Scroll to element
     * @param locator Locator for element to scroll to
     * @return This page instance
     */
    public CSSmartBasePage scrollToElement(By locator) {
        WebElement element = driver.findElement(locator);
        executeScript("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", element);
        // Small pause to allow scroll animation to complete
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return this;
    }
    
    // Frame handling
    
    /**
     * Switch to frame by index
     * @param index Frame index
     * @return This page instance
     */
    public CSSmartBasePage switchToFrame(int index) {
        driver.switchTo().frame(index);
        return this;
    }
    
    /**
     * Switch to frame by name or ID
     * @param nameOrId Frame name or ID
     * @return This page instance
     */
    public CSSmartBasePage switchToFrame(String nameOrId) {
        driver.switchTo().frame(nameOrId);
        return this;
    }
    
    /**
     * Switch to frame by element
     * @param element Frame element
     * @return This page instance
     */
    public CSSmartBasePage switchToFrame(CSSmartElement element) {
        driver.switchTo().frame(element.getElement());
        return this;
    }
    
    /**
     * Switch to frame by locator
     * @param locator Frame locator
     * @return This page instance
     */
    public CSSmartBasePage switchToFrame(By locator) {
        WebElement frameElement = waitForVisible(locator, 10);
        driver.switchTo().frame(frameElement);
        return this;
    }
    
    /**
     * Switch to parent frame
     * @return This page instance
     */
    public CSSmartBasePage switchToParentFrame() {
        driver.switchTo().parentFrame();
        return this;
    }
    
    /**
     * Switch to default content (main document)
     * @return This page instance
     */
    public CSSmartBasePage switchToDefaultContent() {
        driver.switchTo().defaultContent();
        return this;
    }
    
    // Alert handling
    
    /**
     * Check if alert is present
     * @param timeoutSeconds Timeout in seconds
     * @return true if alert is present
     */
    public boolean isAlertPresent(int timeoutSeconds) {
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeoutSeconds));
            wait.until(ExpectedConditions.alertIsPresent());
            return true;
        } catch (TimeoutException e) {
            return false;
        }
    }
    
    /**
     * Get alert text
     * @return Alert text
     */
    public String getAlertText() {
        return driver.switchTo().alert().getText();
    }
    
    /**
     * Accept alert
     * @return This page instance
     */
    public CSSmartBasePage acceptAlert() {
        driver.switchTo().alert().accept();
        return this;
    }
    
    /**
     * Dismiss alert
     * @return This page instance
     */
    public CSSmartBasePage dismissAlert() {
        driver.switchTo().alert().dismiss();
        return this;
    }
    
    /**
     * Enter text in alert
     * @param text Text to enter
     * @return This page instance
     */
    public CSSmartBasePage alertSendKeys(String text) {
        driver.switchTo().alert().sendKeys(text);
        return this;
    }
    
    /**
     * Wait for and accept alert
     * @param timeoutSeconds Timeout in seconds
     * @return This page instance
     */
    public CSSmartBasePage waitAndAcceptAlert(int timeoutSeconds) {
        if (isAlertPresent(timeoutSeconds)) {
            acceptAlert();
        }
        return this;
    }
    
    /**
     * Wait for and dismiss alert
     * @param timeoutSeconds Timeout in seconds
     * @return This page instance
     */
    public CSSmartBasePage waitAndDismissAlert(int timeoutSeconds) {
        if (isAlertPresent(timeoutSeconds)) {
            dismissAlert();
        }
        return this;
    }
    
    // Window handling
    
    /**
     * Get current window handle
     * @return Window handle
     */
    public String getWindowHandle() {
        return driver.getWindowHandle();
    }
    
    /**
     * Get all window handles
     * @return Set of window handles
     */
    public Set<String> getWindowHandles() {
        return driver.getWindowHandles();
    }
    
    /**
     * Switch to window by handle
     * @param windowHandle Window handle
     * @return This page instance
     */
    public CSSmartBasePage switchToWindow(String windowHandle) {
        driver.switchTo().window(windowHandle);
        return this;
    }
    
    /**
     * Switch to window by title
     * @param title Window title
     * @param exactMatch Whether to require exact title match
     * @return This page instance
     */
    public CSSmartBasePage switchToWindowByTitle(String title, boolean exactMatch) {
        String currentHandle = driver.getWindowHandle();
        Set<String> handles = driver.getWindowHandles();
        
        for (String handle : handles) {
            driver.switchTo().window(handle);
            String windowTitle = driver.getTitle();
            
            if (exactMatch ? windowTitle.equals(title) : windowTitle.contains(title)) {
                return this;
            }
        }
        
        // Switch back to original window if no match found
        driver.switchTo().window(currentHandle);
        throw new NoSuchWindowException("No window with title '" + title + "' found");
    }
    
    /**
     * Switch to window by URL
     * @param url URL to match
     * @param exactMatch Whether to require exact URL match
     * @return This page instance
     */
    public CSSmartBasePage switchToWindowByUrl(String url, boolean exactMatch) {
        String currentHandle = driver.getWindowHandle();
        Set<String> handles = driver.getWindowHandles();
        
        for (String handle : handles) {
            driver.switchTo().window(handle);
            String windowUrl = driver.getCurrentUrl();
            
            if (exactMatch ? windowUrl.equals(url) : windowUrl.contains(url)) {
                return this;
            }
        }
        
        // Switch back to original window if no match found
        driver.switchTo().window(currentHandle);
        throw new NoSuchWindowException("No window with URL '" + url + "' found");
    }
    
    /**
     * Switch to new window
     * @return This page instance
     */
    public CSSmartBasePage switchToNewWindow() {
        String currentHandle = driver.getWindowHandle();
        Set<String> handles = driver.getWindowHandles();
        
        for (String handle : handles) {
            if (!handle.equals(currentHandle)) {
                driver.switchTo().window(handle);
                return this;
            }
        }
        
        return this;
    }
    
    /**
     * Open URL in new window
     * @param url URL to open
     * @return This page instance
     */
    public CSSmartBasePage openInNewWindow(String url) {
        executeScript("window.open(arguments[0], '_blank');", url);
        return switchToNewWindow();
    }
    
    /**
     * Close current window
     * @return This page instance
     */
    public CSSmartBasePage closeWindow() {
        driver.close();
        return switchToNewWindow();
    }
    
    /**
     * Maximize window
     * @return This page instance
     */
    public CSSmartBasePage maximizeWindow() {
        driver.manage().window().maximize();
        return this;
    }
    
    /**
     * Minimize window
     * @return This page instance
     */
    public CSSmartBasePage minimizeWindow() {
        driver.manage().window().minimize();
        return this;
    }
    
    /**
     * Set window size
     * @param width Width in pixels
     * @param height Height in pixels
     * @return This page instance
     */
    public CSSmartBasePage setWindowSize(int width, int height) {
        driver.manage().window().setSize(new Dimension(width, height));
        return this;
    }
    
    /**
     * Set window position
     * @param x X coordinate
     * @param y Y coordinate
     * @return This page instance
     */
    public CSSmartBasePage setWindowPosition(int x, int y) {
        driver.manage().window().setPosition(new Point(x, y));
        return this;
    }
    
    /**
     * Get window size
     * @return Dimension object with width and height
     */
    public Dimension getWindowSize() {
        return driver.manage().window().getSize();
    }
    
    /**
     * Get window position
     * @return Point object with x and y coordinates
     */
    public Point getWindowPosition() {
        return driver.manage().window().getPosition();
    }
    
    // Cookie handling
    
    /**
     * Get cookies as a map
     * @return Map of cookie name-value pairs
     */
    public Map<String, String> getCookies() {
        Map<String, String> cookieMap = new HashMap<>();
        driver.manage().getCookies().forEach(cookie -> cookieMap.put(cookie.getName(), cookie.getValue()));
        return cookieMap;
    }
    
    /**
     * Get cookie by name
     * @param name Cookie name
     * @return Cookie value or null if not found
     */
    public String getCookie(String name) {
        Cookie cookie = driver.manage().getCookieNamed(name);
        return cookie != null ? cookie.getValue() : null;
    }
    
    /**
     * Add a cookie
     * @param name Cookie name
     * @param value Cookie value
     * @return This page instance
     */
    public CSSmartBasePage addCookie(String name, String value) {
        Cookie cookie = new Cookie(name, value);
        driver.manage().addCookie(cookie);
        return this;
    }
    
    /**
     * Add a cookie with advanced options
     * @param name Cookie name
     * @param value Cookie value
     * @param domain Domain
     * @param path Path
     * @param expiry Expiry date
     * @param secure Whether cookie is secure
     * @param httpOnly Whether cookie is HTTP only
     * @return This page instance
     */
    public CSSmartBasePage addCookie(String name, String value, String domain, String path, Date expiry, boolean secure, boolean httpOnly) {
        Cookie.Builder builder = new Cookie.Builder(name, value);
        
        if (domain != null) {
            builder.domain(domain);
        }
        
        if (path != null) {
            builder.path(path);
        }
        
        if (expiry != null) {
            builder.expiresOn(expiry);
        }
        
        if (secure) {
            builder.secure(true);
        }
        
        if (httpOnly) {
            builder.isHttpOnly(true);
        }
        
        driver.manage().addCookie(builder.build());
        return this;
    }
    
    /**
     * Delete a cookie
     * @param name Cookie name
     * @return This page instance
     */
    public CSSmartBasePage deleteCookie(String name) {
        driver.manage().deleteCookieNamed(name);
        return this;
    }
    
    /**
     * Delete all cookies
     * @return This page instance
     */
    public CSSmartBasePage deleteAllCookies() {
        driver.manage().deleteAllCookies();
        return this;
    }
    
    // Screen capture
    
    /**
     * Take a screenshot of the page
     * @param fileName File name for the screenshot
     * @return This page instance
     */
    public CSSmartBasePage takeScreenshot(String fileName) {
        try {
            TakesScreenshot takesScreenshot = (TakesScreenshot) driver;
            File screenshot = takesScreenshot.getScreenshotAs(OutputType.FILE);
            
            String screenshotDir = propertyManager.getProperty("screenshot.path", "target/screenshots");
            File directory = new File(screenshotDir);
            if (!directory.exists()) {
                directory.mkdirs();
            }
            
            File dest = new File(directory, fileName);
            org.apache.commons.io.FileUtils.copyFile(screenshot, dest);
            System.out.println("Screenshot saved: " + dest.getAbsolutePath());
        } catch (Exception e) {
            System.err.println("Failed to take screenshot: " + e.getMessage());
        }
        return this;
    }
    
    /**
     * Take a screenshot with timestamp
     * @param prefix File name prefix
     * @return This page instance
     */
    public CSSmartBasePage takeScreenshotWithTimestamp(String prefix) {
        String timestamp = new java.text.SimpleDateFormat("yyyyMMdd_HHmmss").format(new java.util.Date());
        return takeScreenshot(prefix + "_" + timestamp + ".png");
    }
    
    /**
     * Take a screenshot on condition
     * @param condition Condition to check
     * @param fileName File name
     * @return This page instance
     */
    public CSSmartBasePage takeScreenshotIf(boolean condition, String fileName) {
        if (condition) {
            takeScreenshot(fileName);
        }
        return this;
    }
    
    // Advanced interaction methods
    
    /**
     * Perform drag and drop
     * @param source Source element
     * @param target Target element
     * @return This page instance
     */
    public CSSmartBasePage dragAndDrop(CSSmartElement source, CSSmartElement target) {
        new Actions(driver)
            .dragAndDrop(source.getElement(), target.getElement())
            .perform();
        return this;
    }
    
    /**
     * Perform drag and drop by offset
     * @param source Source element
     * @param xOffset X offset
     * @param yOffset Y offset
     * @return This page instance
     */
    public CSSmartBasePage dragAndDropBy(CSSmartElement source, int xOffset, int yOffset) {
        new Actions(driver)
            .dragAndDropBy(source.getElement(), xOffset, yOffset)
            .perform();
        return this;
    }
    
    /**
     * Move mouse to element
     * @param element Element to hover over
     * @return This page instance
     */
    public CSSmartBasePage moveToElement(CSSmartElement element) {
        new Actions(driver)
            .moveToElement(element.getElement())
            .perform();
        return this;
    }
    
    /**
     * Move mouse to element with offset
     * @param element Element to move to
     * @param xOffset X offset from center
     * @param yOffset Y offset from center
     * @return This page instance
     */
    public CSSmartBasePage moveToElement(CSSmartElement element, int xOffset, int yOffset) {
        new Actions(driver)
            .moveToElement(element.getElement(), xOffset, yOffset)
            .perform();
        return this;
    }
    
    /**
     * Move mouse by offset
     * @param xOffset X offset
     * @param yOffset Y offset
     * @return This page instance
     */
    public CSSmartBasePage moveByOffset(int xOffset, int yOffset) {
        new Actions(driver)
            .moveByOffset(xOffset, yOffset)
            .perform();
        return this;
    }
    
    /**
     * Press key combination
     * @param keyDown Keys to press down
     * @param key Key to press
     * @return This page instance
     */
    public CSSmartBasePage keyDown(Keys keyDown, CharSequence key) {
        new Actions(driver)
            .keyDown(keyDown)
            .sendKeys(key)
            .keyUp(keyDown)
            .perform();
        return this;
    }
    
    /**
     * Press key on element
     * @param element Element to focus
     * @param key Key to press
     * @return This page instance
     */
    public CSSmartBasePage sendKey(CSSmartElement element, Keys key) {
        new Actions(driver)
            .moveToElement(element.getElement())
            .sendKeys(key)
            .perform();
        return this;
    }
    
    /**
     * Perform a double click
     * @param element Element to double click
     * @return This page instance
     */
    public CSSmartBasePage doubleClick(CSSmartElement element) {
        new Actions(driver)
            .doubleClick(element.getElement())
            .perform();
        return this;
    }
    
    /**
     * Perform a right click
     * @param element Element to right click
     * @return This page instance
     */
    public CSSmartBasePage rightClick(CSSmartElement element) {
        new Actions(driver)
            .contextClick(element.getElement())
            .perform();
        return this;
    }
    
    /**
     * Perform a click and hold
     * @param element Element to click and hold
     * @param holdTimeMs Time to hold in milliseconds
     * @return This page instance
     */
    public CSSmartBasePage clickAndHold(CSSmartElement element, long holdTimeMs) {
        Actions actions = new Actions(driver);
        actions.clickAndHold(element.getElement()).perform();
        
        try {
            Thread.sleep(holdTimeMs);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        actions.release().perform();
        return this;
    }
    
    // AI-powered page operations
    
    /**
     * Generate page object for current page
     * @param packageName Package name for generated class
     * @return true if generation was successful
     */
    public boolean generatePageObject(String packageName) {
        return TestGenerator.generatePageObject(pageName, packageName);
    }
    
    /**
     * Generate BDD feature file based on current page
     * @return true if generation was successful
     */
    public boolean generateFeatureFile() {
        return TestGenerator.generateFeatureFile(pageName, getTitle(), null);
    }
    
    /**
     * Check if page is loaded based on key elements
     * @return true if loaded
     */
    public boolean isLoaded() {
        // Default implementation - override in subclasses
        return true;
    }
    
    /**
     * Get the name of this page
     * @return Page name
     */
    public String getPageName() {
        return pageName;
    }
}


package com.cssmart.config;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Enhanced property manager with automatic configuration 
 * and simplified setup for CS Smart Automation Framework
 */
public class CSSmartConfig {
    
    private static CSSmartConfig instance;
    private final Map<String, String> configCache = new ConcurrentHashMap<>();
    private final Map<String, String> overrides = new ConcurrentHashMap<>();
    private boolean initialized = false;
    
    // Default configuration values
    private static final Map<String, String> DEFAULT_CONFIG = new HashMap<>();
    
    static {
        // Driver settings
        DEFAULT_CONFIG.put("browser", "chrome");
        DEFAULT_CONFIG.put("headless", "false");
        DEFAULT_CONFIG.put("implicit.wait", "0");
        DEFAULT_CONFIG.put("page.load.timeout", "60");
        DEFAULT_CONFIG.put("element.wait.timeout", "15");
        DEFAULT_CONFIG.put("execution.mode", "local");
        
        // Framework settings
        DEFAULT_CONFIG.put("framework.mode", "auto");
        DEFAULT_CONFIG.put("screenshot.path", "target/screenshots");
        DEFAULT_CONFIG.put("screenshot.on.failure", "true");
        DEFAULT_CONFIG.put("report.path", "target/cssmart-reports");
        
        // BDD settings
        DEFAULT_CONFIG.put("features.path", "src/test/resources/features");
        DEFAULT_CONFIG.put("bdd.autorun", "true");
        DEFAULT_CONFIG.put("bdd.stepdef.packages", "");
        
        // AI features
        DEFAULT_CONFIG.put("ai.self.healing", "true");
        DEFAULT_CONFIG.put("ai.visual.testing", "true");
        DEFAULT_CONFIG.put("ai.test.optimization", "false");
        DEFAULT_CONFIG.put("ai.test.generation", "false");
        
        // Environment
        DEFAULT_CONFIG.put("environment", "dev");
        DEFAULT_CONFIG.put("base.url", "");
    }
    
    /**
     * Private constructor for singleton
     */
    private CSSmartConfig() {
        // Initialize with default values
        configCache.putAll(DEFAULT_CONFIG);
    }
    
    /**
     * Get singleton instance
     * @return CSSmartConfig instance
     */
    public static synchronized CSSmartConfig getInstance() {
        if (instance == null) {
            instance = new CSSmartConfig();
            instance.initialize();
        }
        return instance;
    }
    
    /**
     * Initialize the configuration system
     */
    private void initialize() {
        if (initialized) {
            return;
        }
        
        // Load order (later ones override earlier ones):
        // 1. Default values
        // 2. cssmart.properties in classpath
        // 3. Custom property file specified by cssmart.config system property
        // 4. Environment-specific properties
        // 5. System properties
        // 6. Programmatic overrides
        
        // Load from classpath
        loadFromClasspath("cssmart.properties");
        
        // Load from custom property file if specified
        String customConfig = System.getProperty("cssmart.config");
        if (customConfig != null && !customConfig.isEmpty()) {
            loadFromFile(new File(customConfig));
        }
        
        // Load environment-specific properties
        String environment = getProperty("environment");
        if (environment != null && !environment.isEmpty()) {
            loadFromClasspath("env/" + environment + ".properties");
            loadFromFile(new File("config/env/" + environment + ".properties"));
        }
        
        // Load from system properties - overrides all file-based properties
        loadFromSystemProperties();
        
        initialized = true;
        
        // Log configuration status
        System.out.println("CSSmartConfig initialized with environment: " + environment);
    }
    
    /**
     * Load configuration from classpath resource
     * @param resourcePath Resource path
     */
    private void loadFromClasspath(String resourcePath) {
        try (InputStream is = getClass().getClassLoader().getResourceAsStream(resourcePath)) {
            if (is != null) {
                Properties props = new Properties();
                props.load(is);
                for (String name : props.stringPropertyNames()) {
                    configCache.put(name, props.getProperty(name));
                }
                System.out.println("Loaded configuration from classpath: " + resourcePath);
            }
        } catch (IOException e) {
            // Silently ignore - file might not exist
        }
    }
    
    /**
     * Load configuration from file
     * @param file File to load
     */
    private void loadFromFile(File file) {
        if (file.exists() && file.isFile()) {
            try (FileInputStream fis = new FileInputStream(file)) {
                Properties props = new Properties();
                props.load(fis);
                for (String name : props.stringPropertyNames()) {
                    configCache.put(name, props.getProperty(name));
                }
                System.out.println("Loaded configuration from file: " + file.getAbsolutePath());
            } catch (IOException e) {
                System.err.println("Failed to load configuration from " + file.getAbsolutePath() + ": " + e.getMessage());
            }
        }
    }
    
    /**
     * Load from system properties
     */
    private void loadFromSystemProperties() {
        // Add all cssmart.* properties
        System.getProperties().stringPropertyNames().stream()
            .filter(name -> name.startsWith("cssmart."))
            .forEach(name -> {
                String key = name.substring("cssmart.".length());
                configCache.put(key, System.getProperty(name));
            });
        
        // Add specific properties that don't have cssmart prefix
        String[] directProps = {"browser", "environment", "headless", "base.url"};
        for (String prop : directProps) {
            if (System.getProperty(prop) != null) {
                configCache.put(prop, System.getProperty(prop));
            }
        }
    }
    
    /**
     * Get property
     * @param key Property key
     * @return Property value or null if not found
     */
    public String getProperty(String key) {
        // Check overrides first
        if (overrides.containsKey(key)) {
            return overrides.get(key);
        }
        
        // Then check system properties with cssmart prefix
        String sysProp = System.getProperty("cssmart." + key);
        if (sysProp != null) {
            return sysProp;
        }
        
        // Then check direct system properties for common values
        if (key.equals("browser") || key.equals("environment") || 
            key.equals("headless") || key.equals("base.url")) {
            sysProp = System.getProperty(key);
            if (sysProp != null) {
                return sysProp;
            }
        }
        
        // Finally check config cache
        return configCache.get(key);
    }
    
    /**
     * Get property with default value
     * @param key Property key
     * @param defaultValue Default value if property is not found
     * @return Property value or default value if not found
     */
    public String getProperty(String key, String defaultValue) {
        String value = getProperty(key);
        return value != null ? value : defaultValue;
    }
    
    /**
     * Get property as boolean
     * @param key Property key
     * @param defaultValue Default value if property is not found
     * @return Property value as boolean
     */
    public boolean getBooleanProperty(String key, boolean defaultValue) {
        String value = getProperty(key);
        return value != null ? Boolean.parseBoolean(value) : defaultValue;
    }
    
    /**
     * Get property as integer
     * @param key Property key
     * @param defaultValue Default value if property is not found
     * @return Property value as integer
     */
    public int getIntProperty(String key, int defaultValue) {
        String value = getProperty(key);
        if (value != null) {
            try {
                return Integer.parseInt(value);
            } catch (NumberFormatException e) {
                // Ignore and return default
            }
        }
        return defaultValue;
    }
    
    /**
     * Get property as long
     * @param key Property key
     * @param defaultValue Default value if property is not found
     * @return Property value as long
     */
    public long getLongProperty(String key, long defaultValue) {
        String value = getProperty(key);
        if (value != null) {
            try {
                return Long.parseLong(value);
            } catch (NumberFormatException e) {
                // Ignore and return default
            }
        }
        return defaultValue;
    }
    
    /**
     * Get property as double
     * @param key Property key
     * @param defaultValue Default value if property is not found
     * @return Property value as double
     */
    public double getDoubleProperty(String key, double defaultValue) {
        String value = getProperty(key);
        if (value != null) {
            try {
                return Double.parseDouble(value);
            } catch (NumberFormatException e) {
                // Ignore and return default
            }
        }
        return defaultValue;
    }
    
    /**
     * Set property (programmatic override)
     * @param key Property key
     * @param value Property value
     */
    public void setProperty(String key, String value) {
        overrides.put(key, value);
    }
    
    /**
     * Set property as boolean
     * @param key Property key
     * @param value Property value
     */
    public void setProperty(String key, boolean value) {
        setProperty(key, Boolean.toString(value));
    }
    
    /**
     * Set property as integer
     * @param key Property key
     * @param value Property value
     */
    public void setProperty(String key, int value) {
        setProperty(key, Integer.toString(value));
    }
    
    /**
     * Set property as long
     * @param key Property key
     * @param value Property value
     */
    public void setProperty(String key, long value) {
        setProperty(key, Long.toString(value));
    }
    
    /**
     * Set property as double
     * @param key Property key
     * @param value Property value
     */
    public void setProperty(String key, double value) {
        setProperty(key, Double.toString(value));
    }
    
    /**
     * Remove property override
     * @param key Property key
     */
    public void removeProperty(String key) {
        overrides.remove(key);
    }
    
    /**
     * Clear all property overrides
     */
    public void clearOverrides() {
        overrides.clear();
    }
    
    /**
     * Get all property keys
     * @return Set of property keys
     */
    public Set<String> getPropertyKeys() {
        return configCache.keySet();
    }
    
    /**
     * Get all properties as map
     * @return Map of properties
     */
    public Map<String, String> getAllProperties() {
        Map<String, String> result = new HashMap<>(configCache);
        // Apply overrides
        result.putAll(overrides);
        return result;
    }
    
    /**
     * Print all configuration to console - useful for debugging
     */
    public void printConfiguration() {
        System.out.println("===== CS Smart Framework Configuration =====");
        Map<String, String> allProps = getAllProperties();
        allProps.keySet().stream()
            .sorted()
            .forEach(key -> System.out.println(key + " = " + allProps.get(key)));
        System.out.println("============================================");
    }
    
    /**
     * Reinitialize the configuration
     * This is useful if configuration files have changed
     */
    public void reinitialize() {
        initialized = false;
        configCache.clear();
        configCache.putAll(DEFAULT_CONFIG);
        initialize();
    }
}

/**
 * Simplified interface to make the CSSmartConfig easier to use
 */
public class CSSmartConfigHelper {
    
    /**
     * Get property
     * @param key Property key
     * @return Property value
     */
    public static String get(String key) {
        return CSSmartConfig.getInstance().getProperty(key);
    }
    
    /**
     * Get property with default
     * @param key Property key
     * @param defaultValue Default value
     * @return Property value or default
     */
    public static String get(String key, String defaultValue) {
        return CSSmartConfig.getInstance().getProperty(key, defaultValue);
    }
    
    /**
     * Get boolean property
     * @param key Property key
     * @return Property value as boolean
     */
    public static boolean getBoolean(String key) {
        return CSSmartConfig.getInstance().getBooleanProperty(key, false);
    }
    
    /**
     * Get boolean property with default
     * @param key Property key
     * @param defaultValue Default value
     * @return Property value as boolean or default
     */
    public static boolean getBoolean(String key, boolean defaultValue) {
        return CSSmartConfig.getInstance().getBooleanProperty(key, defaultValue);
    }
    
    /**
     * Get int property
     * @param key Property key
     * @return Property value as int
     */
    public static int getInt(String key) {
        return CSSmartConfig.getInstance().getIntProperty(key, 0);
    }
    
    /**
     * Get int property with default
     * @param key Property key
     * @param defaultValue Default value
     * @return Property value as int or default
     */
    public static int getInt(String key, int defaultValue) {
        return CSSmartConfig.getInstance().getIntProperty(key, defaultValue);
    }
    
    /**
     * Set property
     * @param key Property key
     * @param value Property value
     */
    public static void set(String key, String value) {
        CSSmartConfig.getInstance().setProperty(key, value);
    }
    
    /**
     * Set boolean property
     * @param key Property key
     * @param value Property value
     */
    public static void set(String key, boolean value) {
        CSSmartConfig.getInstance().setProperty(key, value);
    }
    
    /**
     * Set int property
     * @param key Property key
     * @param value Property value
     */
    public static void set(String key, int value) {
        CSSmartConfig.getInstance().setProperty(key, value);
    }
    
    /**
     * Get the base URL
     * @return Base URL
     */
    public static String getBaseUrl() {
        return CSSmartConfig.getInstance().getProperty("base.url", "");
    }
    
    /**
     * Get the current environment
     * @return Environment name
     */
    public static String getEnvironment() {
        return CSSmartConfig.getInstance().getProperty("environment", "dev");
    }
    
    /**
     * Check if a feature is enabled
     * @param feature Feature name
     * @return true if enabled
     */
    public static boolean isFeatureEnabled(String feature) {
        return CSSmartConfig.getInstance().getBooleanProperty(feature + ".enabled", false);
    }
    
    /**
     * Print configuration - useful for debugging
     */
    public static void printConfig() {
        CSSmartConfig.getInstance().printConfiguration();
    }
}


package com.cssmart.core;

import java.io.File;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import org.openqa.selenium.WebDriver;
import org.testng.ITestContext;
import org.testng.ITestResult;
import org.testng.annotations.*;

import com.cssmart.bdd.CSSmartAutoBDDRunner;
import com.cssmart.config.CSSmartConfig;
import com.cssmart.config.CSSmartConfigHelper;
import com.cssmart.core.driver.CSSmartDriverFactory;
import com.cssmart.reporting.CSSmartReporter;

/**
 * CS Smart Framework initializer - just extend this class to get all functionality
 * without any additional setup required
 */
public class CSSmartTest {
    
    protected WebDriver driver;
    protected static CSSmartReporter reporter;
    private long testStartTime;
    private static boolean frameworkInitialized = false;
    
    /**
     * Suite setup - automatically initializes the framework
     * @param context TestNG context
     */
    @BeforeSuite(alwaysRun = true)
    public void suiteSetup(ITestContext context) {
        if (!frameworkInitialized) {
            initializeFramework(context);
            frameworkInitialized = true;
        }
    }
    
    /**
     * Initialize the framework
     * @param context TestNG context
     */
    protected void initializeFramework(ITestContext context) {
        // Initialize configuration
        CSSmartConfig.getInstance();
        
        // Apply any TestNG parameters to configuration
        applyTestNGParameters(context);
        
        // Initialize reporter
        reporter = new CSSmartReporter();
        reporter.initializeReporter(context);
        
        // Print configuration for debugging
        if (CSSmartConfigHelper.getBoolean("debug.config", false)) {
            CSSmartConfigHelper.printConfig();
        }
        
        // If auto BDD is enabled, initialize the BDD runner
        if (CSSmartConfigHelper.getBoolean("bdd.autorun", true)) {
            CSSmartAutoBDDRunner.initialize();
        }
        
        System.out.println("CS Smart Framework initialized");
    }
    
    /**
     * Apply TestNG parameters to configuration
     * @param context TestNG context
     */
    private void applyTestNGParameters(ITestContext context) {
        context.getSuite().getXmlSuite().getAllParameters().forEach((key, value) -> {
            CSSmartConfigHelper.set(key, value);
        });
        
        // Also apply test-specific parameters
        context.getCurrentXmlTest().getAllParameters().forEach((key, value) -> {
            CSSmartConfigHelper.set(key, value);
        });
    }
    
    /**
     * Test setup - automatically initializes the driver
     * @param context TestNG context
     * @param method Test method
     */
    @BeforeMethod(alwaysRun = true)
    public void testSetup(ITestContext context, java.lang.reflect.Method method) {
        // Get driver if needed
        driver = CSSmartDriverFactory.getDriver();
        
        // Record test start time
        testStartTime = System.currentTimeMillis();
        
        // Log test start
        System.out.println("Starting test: " + method.getName());
        reporter.testStarted(context.getName(), method.getName());
    }
    
    /**
     * Test teardown - handle reporting and cleanup
     * @param result TestNG test result
     */
    @AfterMethod(alwaysRun = true)
    public void testTeardown(ITestResult result) {
        long duration = System.currentTimeMillis() - testStartTime;
        
        // Take screenshot on failure if enabled
        if (result.getStatus() == ITestResult.FAILURE && 
            CSSmartConfigHelper.getBoolean("screenshot.on.failure", true)) {
            takeScreenshot(result);
        }
        
        // Report test result
        if (result.getStatus() == ITestResult.SUCCESS) {
            reporter.testPassed(result.getName(), duration);
            System.out.println("Test passed: " + result.getName() + " (" + formatDuration(duration) + ")");
        } else if (result.getStatus() == ITestResult.FAILURE) {
            reporter.testFailed(result.getName(), result.getThrowable(), duration);
            System.out.println("Test failed: " + result.getName() + " (" + formatDuration(duration) + ")");
        } else if (result.getStatus() == ITestResult.SKIP) {
            reporter.testSkipped(result.getName(), duration);
            System.out.println("Test skipped: " + result.getName());
        }
        
        // Quit driver if configured to do so after each test
        if (CSSmartConfigHelper.getBoolean("driver.quit.after.test", false)) {
            CSSmartDriverFactory.quitDriver();
        }
    }
    
    /**
     * Suite teardown - cleanup all resources
     */
    @AfterSuite(alwaysRun = true)
    public void suiteTeardown() {
        // Generate final report
        reporter.generateReport();
        
        // Quit all drivers
        CSSmartDriverFactory.quitAllDrivers();
        
        System.out.println("CS Smart Framework shutdown complete");
    }
    
    /**
     * Take screenshot
     * @param result Test result
     */
    protected void takeScreenshot(ITestResult result) {
        try {
            String screenshotDir = CSSmartConfigHelper.get("screenshot.path", "target/screenshots");
            
            // Create screenshot directory if it doesn't exist
            File directory = new File(screenshotDir);
            if (!directory.exists()) {
                directory.mkdirs();
            }
            
            // Take screenshot
            String fileName = result.getTestClass().getName() + "_" + 
                result.getName() + "_" + System.currentTimeMillis() + ".png";
            reporter.takeScreenshot(fileName);
        } catch (Exception e) {
            System.err.println("Failed to take screenshot: " + e.getMessage());
        }
    }
    
    /**
     * Format duration
     * @param durationMs Duration in milliseconds
     * @return Formatted duration string
     */
    protected String formatDuration(long durationMs) {
        if (durationMs < 1000) {
            return durationMs + "ms";
        } else if (durationMs < 60000) {
            return String.format("%.1fs", durationMs / 1000.0);
        } else {
            long minutes = java.util.concurrent.TimeUnit.MILLISECONDS.toMinutes(durationMs);
            long seconds = java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(durationMs) - 
                java.util.concurrent.TimeUnit.MINUTES.toSeconds(minutes);
            return String.format("%dm %ds", minutes, seconds);
        }
    }
    
    /**
     * Run a BDD feature file
     * @param featureFile Path to feature file
     */
    protected void runFeature(String featureFile) {
        CSSmartAutoBDDRunner.runFeature(featureFile);
    }
    
    /**
     * Run all BDD features matching tag filter
     * @param featuresPath Path to features directory
     * @param tagFilter Tag filter
     */
    protected void runFeatures(String featuresPath, String tagFilter) {
        CSSmartAutoBDDRunner.runFeatures(featuresPath, tagFilter);
    }
}

package com.cssmart.testng;

import java.util.Arrays;
import java.util.List;

import org.testng.IAlterSuiteListener;
import org.testng.xml.XmlClass;
import org.testng.xml.XmlInclude;
import org.testng.xml.XmlSuite;
import org.testng.xml.XmlTest;

import com.cssmart.bdd.CSSmartAutoBDDRunner;
import com.cssmart.config.CSSmartConfigHelper;

/**
 * TestNG listener that automatically creates test cases for all BDD feature files
 * This allows running BDD tests without creating any Java test classes
 */
public class CSSmartBDDSuiteBuilder implements IAlterSuiteListener {

    @Override
    public void alter(List<XmlSuite> suites) {
        if (suites.isEmpty()) {
            return;
        }
        
        // Skip if auto-discovery is disabled
        if (!CSSmartConfigHelper.getBoolean("bdd.discover", true)) {
            return;
        }
        
        // Get main suite
        XmlSuite mainSuite = suites.get(0);
        
        // Create BDD test suite if it doesn't exist
        XmlSuite bddSuite = findOrCreateBddSuite(suites);
        
        // Get features path and tag filter
        String featuresPath = CSSmartConfigHelper.get("features.path", "src/test/resources/features");
        String tagFilter = CSSmartConfigHelper.get("tag.filter", "");
        
        // Find all feature files
        List<String> featureFiles = CSSmartAutoBDDRunner.findAllFeatureFiles(featuresPath, tagFilter);
        
        if (featureFiles.isEmpty()) {
            System.out.println("No feature files found matching criteria.");
            return;
        }
        
        System.out.println("Found " + featureFiles.size() + " feature files to run.");
        
        // Create a test for each feature file
        for (String featureFile : featureFiles) {
            createTestForFeature(bddSuite, featureFile);
        }
    }
    
    /**
     * Find or create BDD suite
     * @param suites List of XML suites
     * @return BDD suite
     */
    private XmlSuite findOrCreateBddSuite(List<XmlSuite> suites) {
        // First, look for existing BDD suite
        for (XmlSuite suite : suites) {
            if ("CS Smart BDD Suite".equals(suite.getName())) {
                return suite;
            }
        }
        
        // Create new BDD suite
        XmlSuite bddSuite = new XmlSuite();
        bddSuite.setName("CS Smart BDD Suite");
        
        // Copy parameters from main suite
        bddSuite.setParameters(suites.get(0).getAllParameters());
        
        // Add default listener
        bddSuite.addListener("com.cssmart.testng.CSSmartTestListener");
        
        // Set parallel mode if enabled
        if (CSSmartConfigHelper.getBoolean("bdd.parallel", false)) {
            bddSuite.setParallel(XmlSuite.ParallelMode.TESTS);
            bddSuite.setThreadCount(CSSmartConfigHelper.getInt("bdd.thread.count", 5));
        }
        
        // Add to the list of suites
        suites.add(bddSuite);
        
        return bddSuite;
    }
    
    /**
     * Create test for feature file
     * @param suite XML suite
     * @param featureFile Feature file path
     */
    private void createTestForFeature(XmlSuite suite, String featureFile) {
        // Get feature name from file path
        String featureName = new java.io.File(featureFile).getName().replace(".feature", "");
        
        // Create test
        XmlTest test = new XmlTest(suite);
        test.setName("Feature: " + featureName);
        
        // Add parameters
        test.addParameter("featureFile", featureFile);
        
        // Create class for this test
        XmlClass xmlClass = new XmlClass("com.cssmart.bdd.CSSmartFeatureRunner");
        
        // Add method to run this specific feature
        XmlInclude include = new XmlInclude("runFeature");
        include.setParameterValues(Arrays.asList(
            new Object[]{"featureFile", featureFile}
        ));
        xmlClass.getIncludedMethods().add(include);
        
        test.setXmlClasses(Arrays.asList(xmlClass));
    }
}

/**
 * Auto-discovered feature runner class
 */
package com.cssmart.bdd;

import org.testng.annotations.Parameters;
import org.testng.annotations.Test;

import com.cssmart.core.CSSmartTest;

/**
 * Feature runner that executes a single feature file
 */
public class CSSmartFeatureRunner extends CSSmartTest {
    
    /**
     * Run a feature file
     * @param featureFile Path to feature file
     */
    @Test
    @Parameters({"featureFile"})
    public void runFeature(String featureFile) {
        CSSmartAutoBDDRunner.runFeature(featureFile);
    }
}


package com.cssmart.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.openqa.selenium.support.How;

/**
 * Enhanced version of FindBy that includes a description field.
 * This allows for better reporting and documentation of page elements.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.TYPE})
public @interface SmartFindBy {
    /**
     * How to find the element
     */
    How how() default How.UNSET;
    
    /**
     * The identifying value
     */
    String using() default "";
    
    /**
     * ID finding
     */
    String id() default "";
    
    /**
     * Name finding
     */
    String name() default "";
    
    /**
     * Class name finding
     */
    String className() default "";
    
    /**
     * Tag name finding
     */
    String tagName() default "";
    
    /**
     * Link text finding
     */
    String linkText() default "";
    
    /**
     * Partial link text finding
     */
    String partialLinkText() default "";
    
    /**
     * CSS finding
     */
    String css() default "";
    
    /**
     * XPath finding
     */
    String xpath() default "";
    
    /**
     * Human-readable description of the element
     * This is used for reporting and documentation
     */
    String description() default "";
    
    /**
     * Timeout in seconds for finding this element
     * Overrides the default timeout
     */
    int timeoutSeconds() default -1;
}


package com.cssmart.core.element;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.List;

import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.FindBy;
import org.openqa.selenium.support.FindBys;
import org.openqa.selenium.support.pagefactory.DefaultFieldDecorator;
import org.openqa.selenium.support.pagefactory.ElementLocator;
import org.openqa.selenium.support.pagefactory.ElementLocatorFactory;

import com.cssmart.annotations.SmartFindBy;
import com.cssmart.core.reporting.Reporter;

/**
 * Custom field decorator to support SmartFindBy annotation
 * and enhanced CSSmartElement functionality
 */
public class SmartFieldDecorator extends DefaultFieldDecorator {

    private final WebDriver driver;

    public SmartFieldDecorator(ElementLocatorFactory factory, WebDriver driver) {
        super(factory);
        this.driver = driver;
    }

    @Override
    public Object decorate(ClassLoader loader, Field field) {
        // Check if the field has our custom SmartFindBy annotation
        SmartFindBy smartAnnotation = field.getAnnotation(SmartFindBy.class);
        
        // If it doesn't have our custom annotation, use the default behavior
        if (smartAnnotation == null) {
            return super.decorate(loader, field);
        }
        
        // Check if the field type is compatible with CSSmartElement
        if (!CSSmartElement.class.isAssignableFrom(field.getType()) && 
            !List.class.isAssignableFrom(field.getType())) {
            return super.decorate(loader, field);
        }
        
        // Extract description for reporting purposes
        final String description = smartAnnotation.description().isEmpty() ? 
                field.getName() : smartAnnotation.description();
        
        // Create element locator using superclass functionality
        ElementLocator locator = factory.createLocator(field);
        if (locator == null) {
            return null;
        }
        
        // Handle CSSmartElement type
        if (CSSmartElement.class.isAssignableFrom(field.getType())) {
            return createCSSmartElement(loader, locator, description, smartAnnotation.timeoutSeconds());
        }
        
        // Handle List<CSSmartElement> type
        if (List.class.isAssignableFrom(field.getType())) {
            return createCSSmartElementList(loader, locator, description, smartAnnotation.timeoutSeconds());
        }
        
        return null;
    }
    
    /**
     * Create a CSSmartElement with the given locator and description
     */
    private CSSmartElement createCSSmartElement(ClassLoader loader, ElementLocator locator, 
            String description, int timeoutSeconds) {
        WebElement element = proxyElement(loader, locator, description);
        return new CSSmartElement(driver, element, description, timeoutSeconds > 0 ? timeoutSeconds : null);
    }
    
    /**
     * Create a List of CSSmartElements with the given locator and description
     */
    @SuppressWarnings("unchecked")
    private List<CSSmartElement> createCSSmartElementList(ClassLoader loader, ElementLocator locator, 
            String description, int timeoutSeconds) {
        // This implementation depends on project needs and may need refinement
        // based on how list element proxying should work in your framework
        InvocationHandler handler = new SmartElementListHandler(locator, description, timeoutSeconds, driver);
        return (List<CSSmartElement>) Proxy.newProxyInstance(
                loader, new Class[] {List.class}, handler);
    }
    
    /**
     * Create a proxy WebElement that reports actions
     */
    private WebElement proxyElement(ClassLoader loader, ElementLocator locator, String description) {
        InvocationHandler handler = new SmartElementHandler(locator, description);
        return (WebElement) Proxy.newProxyInstance(
                loader, new Class[] {WebElement.class}, handler);
    }
    
    /**
     * Handler for CSSmartElement that adds reporting
     */
    private class SmartElementHandler implements InvocationHandler {
        private final ElementLocator locator;
        private final String description;
        
        public SmartElementHandler(ElementLocator locator, String description) {
            this.locator = locator;
            this.description = description;
        }
        
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            WebElement element;
            try {
                element = locator.findElement();
            } catch (Exception e) {
                Reporter.logError("Failed to locate element: " + description);
                throw e;
            }
            
            // Log element interactions for better reporting
            if (method.getName().equals("click")) {
                Reporter.log("Clicking on " + description);
            } else if (method.getName().equals("sendKeys")) {
                Reporter.log("Typing into " + description + ": " + args[0]);
            } else if (method.getName().equals("clear")) {
                Reporter.log("Clearing " + description);
            }
            
            try {
                return method.invoke(element, args);
            } catch (InvocationTargetException e) {
                throw e.getCause();
            }
        }
    }
    
    /**
     * Handler for List<CSSmartElement> that adds reporting
     */
    private class SmartElementListHandler implements InvocationHandler {
        private final ElementLocator locator;
        private final String description;
        private final Integer timeoutSeconds;
        private final WebDriver driver;
        
        public SmartElementListHandler(ElementLocator locator, String description, 
                int timeoutSeconds, WebDriver driver) {
            this.locator = locator;
            this.description = description;
            this.timeoutSeconds = timeoutSeconds > 0 ? timeoutSeconds : null;
            this.driver = driver;
        }
        
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            List<WebElement> elements;
            try {
                elements = locator.findElements();
                Reporter.log("Found " + elements.size() + " elements for " + description);
            } catch (Exception e) {
                Reporter.logError("Failed to locate elements: " + description);
                throw e;
            }
            
            // Convert regular WebElements to CSSmartElements
            if (method.getName().equals("size") || method.getName().equals("isEmpty")) {
                try {
                    return method.invoke(elements, args);
                } catch (InvocationTargetException e) {
                    throw e.getCause();
                }
            } else if (method.getName().equals("get")) {
                WebElement element = elements.get((Integer) args[0]);
                return new CSSmartElement(driver, element, 
                        description + "[" + args[0] + "]", timeoutSeconds);
            }
            
            // For other methods, we need to create a list of CSSmartElements
            List<CSSmartElement> smartElements = new java.util.ArrayList<>();
            for (int i = 0; i < elements.size(); i++) {
                WebElement element = elements.get(i);
                smartElements.add(new CSSmartElement(driver, element, 
                        description + "[" + i + "]", timeoutSeconds));
            }
            
            try {
                return method.invoke(smartElements, args);
            } catch (InvocationTargetException e) {
                throw e.getCause();
            }
        }
    }
}


package com.cssmart.core.element;

import java.time.Duration;
import java.util.List;

import org.openqa.selenium.By;
import org.openqa.selenium.Dimension;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.Point;
import org.openqa.selenium.Rectangle;
import org.openqa.selenium.StaleElementReferenceException;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebDriverException;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import com.cssmart.config.CSSmartConfigHelper;
import com.cssmart.core.driver.CSSmartDriverFactory;
import com.cssmart.core.reporting.Reporter;

/**
 * Enhanced WebElement that provides additional functionality and reporting
 */
public class CSSmartElement implements WebElement {
    private WebElement element;
    private WebDriver driver;
    private String description;
    private Integer timeoutSeconds;
    private final int DEFAULT_TIMEOUT = CSSmartConfigHelper.getInt("element.timeout.seconds", 30);
    
    /**
     * Constructor for wrapping an existing WebElement
     * 
     * @param driver WebDriver instance
     * @param element WebElement to wrap
     * @param description Human-readable description of the element
     * @param timeoutSeconds Timeout in seconds for operations (null for default)
     */
    public CSSmartElement(WebDriver driver, WebElement element, String description, Integer timeoutSeconds) {
        this.driver = driver;
        this.element = element;
        this.description = description;
        this.timeoutSeconds = timeoutSeconds;
    }
    
    /**
     * Create a new CSSmartElement using a By locator
     * 
     * @param by Locator strategy
     * @param description Human-readable description
     * @return New CSSmartElement instance
     */
    public static CSSmartElement create(By by, String description) {
        WebDriver driver = CSSmartDriverFactory.getDriver();
        return create(driver, by, description, null);
    }
    
    /**
     * Create a new CSSmartElement using a By locator with custom timeout
     * 
     * @param by Locator strategy
     * @param description Human-readable description
     * @param timeoutSeconds Timeout in seconds for finding the element
     * @return New CSSmartElement instance
     */
    public static CSSmartElement create(By by, String description, int timeoutSeconds) {
        WebDriver driver = CSSmartDriverFactory.getDriver();
        return create(driver, by, description, timeoutSeconds);
    }
    
    /**
     * Create a new CSSmartElement using a By locator with specific driver
     * 
     * @param driver WebDriver instance
     * @param by Locator strategy
     * @param description Human-readable description
     * @param timeoutSeconds Timeout in seconds for finding the element (null for default)
     * @return New CSSmartElement instance
     */
    public static CSSmartElement create(WebDriver driver, By by, String description, Integer timeoutSeconds) {
        Reporter.log("Finding element: " + description + " using " + by);
        
        int timeout = timeoutSeconds != null ? timeoutSeconds : 
                CSSmartConfigHelper.getInt("element.timeout.seconds", 30);
        
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeout));
            WebElement element = wait.until(ExpectedConditions.presenceOfElementLocated(by));
            return new CSSmartElement(driver, element, description, timeoutSeconds);
        } catch (Exception e) {
            Reporter.logError("Failed to find element: " + description + " using " + by);
            throw e;
        }
    }
    
    /**
     * Create a new CSSmartElement with ID locator
     * 
     * @param id Element ID
     * @param description Human-readable description
     * @return New CSSmartElement instance
     */
    public static CSSmartElement createById(String id, String description) {
        return create(By.id(id), description);
    }
    
    /**
     * Create a new CSSmartElement with Name locator
     * 
     * @param name Element name attribute
     * @param description Human-readable description
     * @return New CSSmartElement instance
     */
    public static CSSmartElement createByName(String name, String description) {
        return create(By.name(name), description);
    }
    
    /**
     * Create a new CSSmartElement with XPath locator
     * 
     * @param xpath XPath expression
     * @param description Human-readable description
     * @return New CSSmartElement instance
     */
    public static CSSmartElement createByXPath(String xpath, String description) {
        return create(By.xpath(xpath), description);
    }
    
    /**
     * Create a new CSSmartElement with CSS selector
     * 
     * @param css CSS selector
     * @param description Human-readable description
     * @return New CSSmartElement instance
     */
    public static CSSmartElement createByCss(String css, String description) {
        return create(By.cssSelector(css), description);
    }
    
    /**
     * Create a new CSSmartElement with Class Name locator
     * 
     * @param className Class name
     * @param description Human-readable description
     * @return New CSSmartElement instance
     */
    public static CSSmartElement createByClassName(String className, String description) {
        return create(By.className(className), description);
    }
    
    /**
     * Create a new CSSmartElement with Link Text locator
     * 
     * @param linkText Link text
     * @param description Human-readable description
     * @return New CSSmartElement instance
     */
    public static CSSmartElement createByLinkText(String linkText, String description) {
        return create(By.linkText(linkText), description);
    }
    
    /**
     * Create a new CSSmartElement with Partial Link Text locator
     * 
     * @param partialLinkText Partial link text
     * @param description Human-readable description
     * @return New CSSmartElement instance
     */
    public static CSSmartElement createByPartialLinkText(String partialLinkText, String description) {
        return create(By.partialLinkText(partialLinkText), description);
    }
    
    /**
     * Create a new CSSmartElement with Tag Name locator
     * 
     * @param tagName Tag name
     * @param description Human-readable description
     * @return New CSSmartElement instance
     */
    public static CSSmartElement createByTagName(String tagName, String description) {
        return create(By.tagName(tagName), description);
    }
    
    /**
     * Find all elements matching a locator and return as CSSmartElements
     * 
     * @param by Locator strategy
     * @param description Base description for elements
     * @return List of CSSmartElements
     */
    public static List<CSSmartElement> findAll(By by, String description) {
        WebDriver driver = CSSmartDriverFactory.getDriver();
        return findAll(driver, by, description, null);
    }
    
    /**
     * Find all elements matching a locator and return as CSSmartElements with custom timeout
     * 
     * @param driver WebDriver instance
     * @param by Locator strategy
     * @param description Base description for elements
     * @param timeoutSeconds Timeout in seconds for finding elements (null for default)
     * @return List of CSSmartElements
     */
    public static List<CSSmartElement> findAll(WebDriver driver, By by, String description, Integer timeoutSeconds) {
        Reporter.log("Finding all elements: " + description + " using " + by);
        
        int timeout = timeoutSeconds != null ? timeoutSeconds : 
                CSSmartConfigHelper.getInt("element.timeout.seconds", 30);
        
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeout));
            wait.until(ExpectedConditions.presenceOfAllElementsLocatedBy(by));
            
            List<WebElement> elements = driver.findElements(by);
            List<CSSmartElement> smartElements = new java.util.ArrayList<>();
            
            for (int i = 0; i < elements.size(); i++) {
                smartElements.add(new CSSmartElement(driver, elements.get(i), 
                        description + "[" + i + "]", timeoutSeconds));
            }
            
            Reporter.log("Found " + smartElements.size() + " elements matching: " + description);
            return smartElements;
        } catch (Exception e) {
            Reporter.logError("Failed to find elements: " + description + " using " + by);
            throw e;
        }
    }
    
    // Enhanced WebElement methods with reporting
    
    @Override
    public void click() {
        Reporter.log("Clicking on " + description);
        try {
            waitForElementToBeClickable();
            element.click();
        } catch (Exception e) {
            Reporter.logError("Failed to click on " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public void submit() {
        Reporter.log("Submitting form using " + description);
        try {
            element.submit();
        } catch (Exception e) {
            Reporter.logError("Failed to submit form using " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public void sendKeys(CharSequence... keysToSend) {
        StringBuilder keys = new StringBuilder();
        for (CharSequence key : keysToSend) {
            keys.append(key);
        }
        
        Reporter.log("Typing '" + keys + "' into " + description);
        try {
            waitForElementToBeVisible();
            element.sendKeys(keysToSend);
        } catch (Exception e) {
            Reporter.logError("Failed to type into " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public void clear() {
        Reporter.log("Clearing " + description);
        try {
            waitForElementToBeVisible();
            element.clear();
        } catch (Exception e) {
            Reporter.logError("Failed to clear " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public String getTagName() {
        try {
            return element.getTagName();
        } catch (Exception e) {
            Reporter.logError("Failed to get tag name for " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public String getAttribute(String name) {
        try {
            return element.getAttribute(name);
        } catch (Exception e) {
            Reporter.logError("Failed to get attribute '" + name + "' for " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public boolean isSelected() {
        try {
            return element.isSelected();
        } catch (Exception e) {
            Reporter.logError("Failed to check if " + description + " is selected: " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public boolean isEnabled() {
        try {
            return element.isEnabled();
        } catch (Exception e) {
            Reporter.logError("Failed to check if " + description + " is enabled: " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public String getText() {
        try {
            return element.getText();
        } catch (Exception e) {
            Reporter.logError("Failed to get text from " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public List<WebElement> findElements(By by) {
        try {
            return element.findElements(by);
        } catch (Exception e) {
            Reporter.logError("Failed to find elements within " + description + " using " + by + ": " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public WebElement findElement(By by) {
        try {
            return element.findElement(by);
        } catch (Exception e) {
            Reporter.logError("Failed to find element within " + description + " using " + by + ": " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public boolean isDisplayed() {
        try {
            return element.isDisplayed();
        } catch (NoSuchElementException | StaleElementReferenceException e) {
            Reporter.log(description + " is not displayed (element not found or stale)");
            return false;
        } catch (Exception e) {
            Reporter.logError("Error checking if " + description + " is displayed: " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public Point getLocation() {
        try {
            return element.getLocation();
        } catch (Exception e) {
            Reporter.logError("Failed to get location of " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public Dimension getSize() {
        try {
            return element.getSize();
        } catch (Exception e) {
            Reporter.logError("Failed to get size of " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public Rectangle getRect() {
        try {
            return element.getRect();
        } catch (Exception e) {
            Reporter.logError("Failed to get rect of " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public String getCssValue(String propertyName) {
        try {
            return element.getCssValue(propertyName);
        } catch (Exception e) {
            Reporter.logError("Failed to get CSS value '" + propertyName + "' for " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    @Override
    public <X> X getScreenshotAs(OutputType<X> target) throws WebDriverException {
        try {
            return element.getScreenshotAs(target);
        } catch (Exception e) {
            Reporter.logError("Failed to take screenshot of " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    // Enhanced functions beyond standard WebElement interface
    
    /**
     * Wait for element to be visible
     * 
     * @return this element for chaining
     */
    public CSSmartElement waitForVisible() {
        Reporter.log("Waiting for " + description + " to be visible");
        waitForElementToBeVisible();
        return this;
    }
    
    /**
     * Wait for element to be clickable
     * 
     * @return this element for chaining
     */
    public CSSmartElement waitForClickable() {
        Reporter.log("Waiting for " + description + " to be clickable");
        waitForElementToBeClickable();
        return this;
    }
    
    /**
     * Check if element exists without waiting the full timeout
     * 
     * @return true if element exists, false otherwise
     */
    public boolean exists() {
        try {
            return element != null;
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Hover over the element
     * 
     * @return this element for chaining
     */
    public CSSmartElement hover() {
        Reporter.log("Hovering over " + description);
        try {
            waitForElementToBeVisible();
            Actions actions = new Actions(driver);
            actions.moveToElement(element).perform();
            return this;
        } catch (Exception e) {
            Reporter.logError("Failed to hover over " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Click element using JavaScript
     * 
     * @return this element for chaining
     */
    public CSSmartElement jsClick() {
        Reporter.log("JavaScript clicking on " + description);
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            js.executeScript("arguments[0].click();", element);
            return this;
        } catch (Exception e) {
            Reporter.logError("Failed to JavaScript click on " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Set value using JavaScript (bypasses events triggered by sendKeys)
     * 
     * @param value Value to set
     * @return this element for chaining
     */
    public CSSmartElement jsSetValue(String value) {
        Reporter.log("JavaScript setting value '" + value + "' to " + description);
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            js.executeScript("arguments[0].value = arguments[1];", element, value);
            return this;
        } catch (Exception e) {
            Reporter.logError("Failed to JavaScript set value for " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Get value of input element
     * 
     * @return input value
     */
    public String getValue() {
        Reporter.log("Getting value from " + description);
        try {
            return getAttribute("value");
        } catch (Exception e) {
            Reporter.logError("Failed to get value from " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Scroll element into view
     * 
     * @return this element for chaining
     */
    public CSSmartElement scrollIntoView() {
        Reporter.log("Scrolling " + description + " into view");
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            js.executeScript("arguments[0].scrollIntoView(true);", element);
            return this;
        } catch (Exception e) {
            Reporter.logError("Failed to scroll " + description + " into view: " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Take screenshot of this element
     * 
     * @param fileName File name for screenshot
     * @return Path to screenshot
     */
    public String takeScreenshot(String fileName) {
        Reporter.log("Taking screenshot of " + description);
        try {
            scrollIntoView();
            return Reporter.takeElementScreenshot(this, fileName);
        } catch (Exception e) {
            Reporter.logError("Failed to take screenshot of " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Type text with a delay between each character
     * 
     * @param text Text to type
     * @param delayMillis Delay in milliseconds between characters
     * @return this element for chaining
     */
    public CSSmartElement typeWithDelay(String text, int delayMillis) {
        Reporter.log("Typing with delay '" + text + "' into " + description);
        try {
            waitForElementToBeVisible();
            for (char c : text.toCharArray()) {
                element.sendKeys(String.valueOf(c));
                Thread.sleep(delayMillis);
            }
            return this;
        } catch (Exception e) {
            Reporter.logError("Failed to type with delay into " + description + ": " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Check if element contains specified text
     * 
     * @param text Text to check for
     * @return true if element contains text, false otherwise
     */
    public boolean containsText(String text) {
        try {
            String elementText = getText();
            return elementText != null && elementText.contains(text);
        } catch (Exception e) {
            Reporter.logError("Failed to check if " + description + " contains text '" + text + "': " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Get the wrapped WebElement
     * 
     * @return The wrapped WebElement
     */
    public WebElement getWebElement() {
        return element;
    }
    
    /**
     * Get the element description
     * 
     * @return Element description
     */
    public String getDescription() {
        return description;
    }
    
    // Helper methods
    
    private void waitForElementToBeVisible() {
        int timeout = timeoutSeconds != null ? timeoutSeconds : DEFAULT_TIMEOUT;
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeout));
            wait.until(ExpectedConditions.visibilityOf(element));
        } catch (Exception e) {
            Reporter.logError(description + " did not become visible within " + timeout + " seconds");
            throw e;
        }
    }
    
    private void waitForElementToBeClickable() {
        int timeout = timeoutSeconds != null ? timeoutSeconds : DEFAULT_TIMEOUT;
        try {
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(timeout));
            wait.until(ExpectedConditions.elementToBeClickable(element));
        } catch (Exception e) {
            Reporter.logError(description + " did not become clickable within " + timeout + " seconds");
            throw e;
        }
    }
}




package com.cssmart.core.reporting;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.commons.io.FileUtils;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.testng.ITestResult;

import com.cssmart.config.CSSmartConfigHelper;
import com.cssmart.core.driver.CSSmartDriverFactory;
import com.cssmart.core.element.CSSmartElement;

/**
 * Enhanced reporting system for CS Smart Framework
 */
public class Reporter {
    
    private static final ThreadLocal<TestReport> currentTestReport = new ThreadLocal<>();
    private static final Map<String, TestReport> allReports = new ConcurrentHashMap<>();
    private static final String REPORT_DIR = CSSmartConfigHelper.get("report.path", "target/cssmart-reports");
    private static final String SCREENSHOT_DIR = CSSmartConfigHelper.get("screenshot.path", "target/screenshots");
    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyyMMdd_HHmmss");
    private static final AtomicInteger stepCounter = new AtomicInteger(1);
    private static boolean reportingInitialized = false;
    
    /**
     * Initialize reporting system
     */
    public static synchronized void initialize() {
        if (reportingInitialized) {
            return;
        }
        
        // Create report directory
        new File(REPORT_DIR).mkdirs();
        new File(SCREENSHOT_DIR).mkdirs();
        
        // Copy CSS, JS, and other assets
        copyReportAssets();
        
        reportingInitialized = true;
    }
    
    /**
     * Start a new test
     * @param testName Test name
     * @param testClass Test class
     */
    public static void startTest(String testName, String testClass) {
        initialize();
        
        TestReport report = new TestReport(testName, testClass);
        currentTestReport.set(report);
        allReports.put(testName, report);
        
        report.setStartTime(System.currentTimeMillis());
        log("Starting test: " + testName);
    }
    
    /**
     * End current test
     * @param status Test status
     * @param error Error if test failed
     */
    public static void endTest(TestStatus status, Throwable error) {
        TestReport report = currentTestReport.get();
        if (report == null) {
            return;
        }
        
        report.setEndTime(System.currentTimeMillis());
        report.setStatus(status);
        report.setError(error);
        
        log("Test " + status + ": " + report.getTestName());
        
        // Take screenshot on failure
        if (status == TestStatus.FAILED && CSSmartConfigHelper.getBoolean("screenshot.on.failure", true)) {
            takeScreenshot("Failure_" + report.getTestName() + ".png");
        }
        
        // Generate individual test report
        generateTestReport(report);
        
        // Also update summary report
        generateSummaryReport();
        
        currentTestReport.remove();
    }
    
    /**
     * Log a message to the report
     * @param message Message to log
     */
    public static void log(String message) {
        System.out.println("[CS Smart] " + message);
        
        TestReport report = currentTestReport.get();
        if (report != null) {
            LogEntry entry = new LogEntry(
                stepCounter.getAndIncrement(),
                System.currentTimeMillis(),
                LogLevel.INFO,
                message
            );
            report.addLogEntry(entry);
        }
    }
    
    /**
     * Log an info message
     * @param message Message to log
     */
    public static void logInfo(String message) {
        log(message);
    }
    
    /**
     * Log a warning message
     * @param message Message to log
     */
    public static void logWarning(String message) {
        System.out.println("[CS Smart] WARNING: " + message);
        
        TestReport report = currentTestReport.get();
        if (report != null) {
            LogEntry entry = new LogEntry(
                stepCounter.getAndIncrement(),
                System.currentTimeMillis(),
                LogLevel.WARNING,
                message
            );
            report.addLogEntry(entry);
        }
    }
    
    /**
     * Log an error message
     * @param message Message to log
     */
    public static void logError(String message) {
        System.err.println("[CS Smart] ERROR: " + message);
        
        TestReport report = currentTestReport.get();
        if (report != null) {
            LogEntry entry = new LogEntry(
                stepCounter.getAndIncrement(),
                System.currentTimeMillis(),
                LogLevel.ERROR,
                message
            );
            report.addLogEntry(entry);
        }
    }
    
    /**
     * Take a screenshot and add to report
     * @param fileName Screenshot file name
     * @return Path to screenshot
     */
    public static String takeScreenshot(String fileName) {
        try {
            WebDriver driver = CSSmartDriverFactory.getDriver();
            if (driver instanceof TakesScreenshot) {
                File screenshotFile = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
                File destFile = new File(SCREENSHOT_DIR, fileName);
                FileUtils.copyFile(screenshotFile, destFile);
                
                TestReport report = currentTestReport.get();
                if (report != null) {
                    report.addScreenshot("screenshots/" + fileName);
                    LogEntry entry = new LogEntry(
                        stepCounter.getAndIncrement(),
                        System.currentTimeMillis(),
                        LogLevel.INFO,
                        "Screenshot captured: " + fileName
                    );
                    entry.setScreenshot("screenshots/" + fileName);
                    report.addLogEntry(entry);
                }
                
                return destFile.getAbsolutePath();
            }
        } catch (Exception e) {
            logError("Failed to take screenshot: " + e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Take a screenshot of a specific element and add to report
     * @param element Element to screenshot
     * @param fileName Screenshot file name
     * @return Path to screenshot
     */
    public static String takeElementScreenshot(WebElement element, String fileName) {
        try {
            File screenshotFile = element.getScreenshotAs(OutputType.FILE);
            File destFile = new File(SCREENSHOT_DIR, fileName);
            FileUtils.copyFile(screenshotFile, destFile);
            
            TestReport report = currentTestReport.get();
            if (report != null) {
                report.addScreenshot("screenshots/" + fileName);
                LogEntry entry = new LogEntry(
                    stepCounter.getAndIncrement(),
                    System.currentTimeMillis(),
                    LogLevel.INFO,
                    "Element screenshot captured: " + fileName
                );
                entry.setScreenshot("screenshots/" + fileName);
                report.addLogEntry(entry);
            }
            
            return destFile.getAbsolutePath();
        } catch (Exception e) {
            logError("Failed to take element screenshot: " + e.getMessage());
            return null;
        }
    }
    
    /**
     * Take a screenshot of a CSSmartElement and add to report
     * @param element CSSmartElement to screenshot
     * @param fileName Screenshot file name
     * @return Path to screenshot
     */
    public static String takeElementScreenshot(CSSmartElement element, String fileName) {
        try {
            String description = element.getDescription();
            WebElement webElement = element.getWebElement();
            
            File screenshotFile = webElement.getScreenshotAs(OutputType.FILE);
            File destFile = new File(SCREENSHOT_DIR, fileName);
            FileUtils.copyFile(screenshotFile, destFile);
            
            TestReport report = currentTestReport.get();
            if (report != null) {
                report.addScreenshot("screenshots/" + fileName);
                LogEntry entry = new LogEntry(
                    stepCounter.getAndIncrement(),
                    System.currentTimeMillis(),
                    LogLevel.INFO,
                    "Element screenshot captured for " + description + ": " + fileName
                );
                entry.setScreenshot("screenshots/" + fileName);
                report.addLogEntry(entry);
            }
            
            return destFile.getAbsolutePath();
        } catch (Exception e) {
            logError("Failed to take element screenshot: " + e.getMessage());
            return null;
        }
    }
    
    /**
     * Add a file attachment to the report
     * @param sourceFile Source file
     * @param attachmentName Name to use in report
     * @param fileType File type (MIME type)
     */
    public static void attachFile(File sourceFile, String attachmentName, String fileType) {
        try {
            File attachmentsDir = new File(REPORT_DIR, "attachments");
            if (!attachmentsDir.exists()) {
                attachmentsDir.mkdirs();
            }
            
            File destFile = new File(attachmentsDir, attachmentName);
            FileUtils.copyFile(sourceFile, destFile);
            
            TestReport report = currentTestReport.get();
            if (report != null) {
                report.addAttachment("attachments/" + attachmentName, fileType);
                LogEntry entry = new LogEntry(
                    stepCounter.getAndIncrement(),
                    System.currentTimeMillis(),
                    LogLevel.INFO,
                    "File attached: " + attachmentName
                );
                entry.setAttachment("attachments/" + attachmentName);
                report.addLogEntry(entry);
            }
        } catch (Exception e) {
            logError("Failed to attach file: " + e.getMessage());
        }
    }
    
    /**
     * Start a test step
     * @param stepName Step name
     */
    public static void startStep(String stepName) {
        TestReport report = currentTestReport.get();
        if (report != null) {
            TestStep step = new TestStep(stepCounter.getAndIncrement(), stepName);
            step.setStartTime(System.currentTimeMillis());
            report.startStep(step);
            
            log("Starting step: " + stepName);
        }
    }
    
    /**
     * End current step
     * @param status Step status
     */
    public static void endStep(TestStatus status) {
        TestReport report = currentTestReport.get();
        if (report != null) {
            TestStep currentStep = report.getCurrentStep();
            if (currentStep != null) {
                currentStep.setEndTime(System.currentTimeMillis());
                currentStep.setStatus(status);
                report.endStep();
                
                log("Step " + status + ": " + currentStep.getName());
                
                // Take screenshot for step completion
                if (CSSmartConfigHelper.getBoolean("screenshot.per.step", false) ||
                    (status == TestStatus.FAILED && CSSmartConfigHelper.getBoolean("screenshot.on.step.failure", true))) {
                    takeScreenshot("Step_" + currentStep.getStepNumber() + "_" + 
                        sanitizeFileName(currentStep.getName()) + ".png");
                }
            }
        }
    }
    
    /**
     * Log element action for better reporting
     * @param elementDescription Element description
     * @param action Action performed
     * @param value Optional value (for sendKeys, etc.)
     */
    public static void logElementAction(String elementDescription, String action, String value) {
        StringBuilder message = new StringBuilder("Element action: ");
        message.append(action).append(" on ").append(elementDescription);
        
        if (value != null && !value.isEmpty()) {
            message.append(" with value '").append(value).append("'");
        }
        
        log(message.toString());
        
        // Take screenshots of element actions if configured
        if (CSSmartConfigHelper.getBoolean("screenshot.on.element.action", false)) {
            SimpleDateFormat dateFormat = new SimpleDateFormat("HHmmss_SSS");
            String timestamp = dateFormat.format(new Date());
            String fileName = "Action_" + action + "_" + sanitizeFileName(elementDescription) + "_" + timestamp + ".png";
            takeScreenshot(fileName);
        }
    }
    
    /**
     * Add a comment to the report (for documentation purposes)
     * @param comment Comment text
     */
    public static void comment(String comment) {
        System.out.println("[CS Smart] COMMENT: " + comment);
        
        TestReport report = currentTestReport.get();
        if (report != null) {
            LogEntry entry = new LogEntry(
                stepCounter.getAndIncrement(),
                System.currentTimeMillis(),
                LogLevel.COMMENT,
                comment
            );
            report.addLogEntry(entry);
        }
    }
    
    /**
     * Mark a verification point in the report
     * @param verificationPoint Description of verification
     * @param actual Actual value
     * @param expected Expected value
     * @param passed Whether verification passed
     */
    public static void verify(String verificationPoint, Object actual, Object expected, boolean passed) {
        String status = passed ? "PASSED" : "FAILED";
        String message = "Verification: " + verificationPoint + 
            " - Expected: '" + expected + "', Actual: '" + actual + "' - " + status;
        
        if (passed) {
            log(message);
        } else {
            logError(message);
            
            // Take screenshot on verification failure if configured
            if (CSSmartConfigHelper.getBoolean("screenshot.on.verification.failure", true)) {
                String fileName = "Verification_" + sanitizeFileName(verificationPoint) + ".png";
                takeScreenshot(fileName);
            }
        }
        
        TestReport report = currentTestReport.get();
        if (report != null) {
            LogEntry entry = new LogEntry(
                stepCounter.getAndIncrement(),
                System.currentTimeMillis(),
                passed ? LogLevel.INFO : LogLevel.ERROR,
                message
            );
            
            // Add verification metadata
            Map<String, Object> metadata = new HashMap<>();
            metadata.put("type", "verification");
            metadata.put("point", verificationPoint);
            metadata.put("expected", expected != null ? expected.toString() : "null");
            metadata.put("actual", actual != null ? actual.toString() : "null");
            metadata.put("passed", passed);
            entry.setMetadata(metadata);
            
            report.addLogEntry(entry);
        }
    }
    
    /**
     * Generate test report for a specific test
     * @param report Test report
     */
    private static void generateTestReport(TestReport report) {
        try {
            String reportName = "test_" + sanitizeFileName(report.getTestName()) + ".html";
            File reportFile = new File(REPORT_DIR, reportName);
            
            try (FileWriter writer = new FileWriter(reportFile)) {
                writer.write(generateTestReportHtml(report));
            }
            
            System.out.println("Test report generated: " + reportFile.getAbsolutePath());
        } catch (Exception e) {
            System.err.println("Failed to generate test report: " + e.getMessage());
        }
    }
    
    /**
     * Generate summary report for all tests
     */
    private static void generateSummaryReport() {
        try {
            File reportFile = new File(REPORT_DIR, "index.html");
            
            try (FileWriter writer = new FileWriter(reportFile)) {
                writer.write(generateSummaryReportHtml());
            }
            
            System.out.println("Summary report generated: " + reportFile.getAbsolutePath());
        } catch (Exception e) {
            System.err.println("Failed to generate summary report: " + e.getMessage());
        }
    }
    
    /**
     * Generate HTML for test report
     * @param report Test report
     * @return HTML content
     */
    private static String generateTestReportHtml(TestReport report) {
        StringBuilder html = new StringBuilder();
        
        // HTML header
        html.append("<!DOCTYPE html>\n");
        html.append("<html lang=\"en\">\n");
        html.append("<head>\n");
        html.append("  <meta charset=\"UTF-8\">\n");
        html.append("  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
        html.append("  <title>CS Smart Test Report - ").append(report.getTestName()).append("</title>\n");
        html.append("  <link rel=\"stylesheet\" href=\"assets/css/report.css\">\n");
        html.append("  <script src=\"assets/js/report.js\"></script>\n");
        html.append("</head>\n");
        html.append("<body>\n");
        
        // Report header
        html.append("  <header class=\"report-header\">\n");
        html.append("    <div class=\"logo\">CS Smart Framework</div>\n");
        html.append("    <h1>Test Report: ").append(report.getTestName()).append("</h1>\n");
        html.append("    <div class=\"meta\">\n");
        html.append("      <div class=\"meta-item\"><span>Class:</span> ").append(report.getTestClass()).append("</div>\n");
        html.append("      <div class=\"meta-item\"><span>Start Time:</span> ").append(formatTimestamp(report.getStartTime())).append("</div>\n");
        html.append("      <div class=\"meta-item\"><span>End Time:</span> ").append(formatTimestamp(report.getEndTime())).append("</div>\n");
        html.append("      <div class=\"meta-item\"><span>Duration:</span> ").append(formatDuration(report.getEndTime() - report.getStartTime())).append("</div>\n");
        html.append("      <div class=\"meta-item status-").append(report.getStatus().toString().toLowerCase()).append("\"><span>Status:</span> ").append(report.getStatus()).append("</div>\n");
        html.append("    </div>\n");
        html.append("  </header>\n");
        
        // Test details
        html.append("  <div class=\"test-container\">\n");
        
        // Test steps
        html.append("    <section class=\"test-steps\">\n");
        html.append("      <h2>Test Steps</h2>\n");
        html.append("      <div class=\"steps-container\">\n");
        
        for (TestStep step : report.getSteps()) {
            html.append("        <div class=\"step status-").append(step.getStatus().toString().toLowerCase()).append("\">\n");
            html.append("          <div class=\"step-header\" onclick=\"toggleStep(this)\">\n");
            html.append("            <div class=\"step-number\">").append(step.getStepNumber()).append("</div>\n");
            html.append("            <div class=\"step-name\">").append(step.getName()).append("</div>\n");
            html.append("            <div class=\"step-duration\">").append(formatDuration(step.getEndTime() - step.getStartTime())).append("</div>\n");
            html.append("            <div class=\"step-status\">").append(step.getStatus()).append("</div>\n");
            html.append("          </div>\n");
            html.append("          <div class=\"step-details\">\n");
            
            // Step logs
            List<LogEntry> stepLogs = new ArrayList<>();
            for (LogEntry log : report.getLogs()) {
                if (log.getTimestamp() >= step.getStartTime() && log.getTimestamp() <= step.getEndTime()) {
                    stepLogs.add(log);
                }
            }
            
            if (!stepLogs.isEmpty()) {
                html.append("            <div class=\"step-logs\">\n");
                for (LogEntry log : stepLogs) {
                    html.append("              <div class=\"log-entry level-").append(log.getLevel().toString().toLowerCase()).append("\">\n");
                    html.append("                <span class=\"log-time\">").append(formatTime(log.getTimestamp())).append("</span>\n");
                    html.append("                <span class=\"log-message\">").append(log.getMessage()).append("</span>\n");
                    
                    // Verification details if any
                    if (log.getMetadata() != null && "verification".equals(log.getMetadata().get("type"))) {
                        html.append("                <div class=\"verification-details\">\n");
                        html.append("                  <div class=\"verification-expected\">Expected: ").append(log.getMetadata().get("expected")).append("</div>\n");
                        html.append("                  <div class=\"verification-actual\">Actual: ").append(log.getMetadata().get("actual")).append("</div>\n");
                        html.append("                </div>\n");
                    }
                    
                    // Screenshot if any
                    if (log.getScreenshot() != null) {
                        html.append("                <div class=\"log-screenshot\">\n");
                        html.append("                  <a href=\"").append(log.getScreenshot()).append("\" target=\"_blank\">\n");
                        html.append("                    <img src=\"").append(log.getScreenshot()).append("\" alt=\"Screenshot\" width=\"200\">\n");
                        html.append("                  </a>\n");
                        html.append("                </div>\n");
                    }
                    
                    // Attachment if any
                    if (log.getAttachment() != null) {
                        html.append("                <div class=\"log-attachment\">\n");
                        html.append("                  <a href=\"").append(log.getAttachment()).append("\" target=\"_blank\">View Attachment</a>\n");
                        html.append("                </div>\n");
                    }
                    
                    html.append("              </div>\n");
                }
                html.append("            </div>\n");
            }
            
            html.append("          </div>\n");
            html.append("        </div>\n");
        }
        
        html.append("      </div>\n");
        html.append("    </section>\n");
        
        // Test logs
        html.append("    <section class=\"test-logs\">\n");
        html.append("      <h2>Test Logs</h2>\n");
        html.append("      <div class=\"logs-container\">\n");
        
        for (LogEntry log : report.getLogs()) {
            html.append("        <div class=\"log-entry level-").append(log.getLevel().toString().toLowerCase()).append("\">\n");
            html.append("          <span class=\"log-time\">").append(formatTime(log.getTimestamp())).append("</span>\n");
            html.append("          <span class=\"log-level\">").append(log.getLevel()).append("</span>\n");
            html.append("          <span class=\"log-message\">").append(log.getMessage()).append("</span>\n");
            
            // Verification details if any
            if (log.getMetadata() != null && "verification".equals(log.getMetadata().get("type"))) {
                html.append("          <div class=\"verification-details\">\n");
                html.append("            <div class=\"verification-expected\">Expected: ").append(log.getMetadata().get("expected")).append("</div>\n");
                html.append("            <div class=\"verification-actual\">Actual: ").append(log.getMetadata().get("actual")).append("</div>\n");
                html.append("          </div>\n");
            }
            
            // Screenshot if any
            if (log.getScreenshot() != null) {
                html.append("          <div class=\"log-screenshot\">\n");
                html.append("            <a href=\"").append(log.getScreenshot()).append("\" target=\"_blank\">\n");
                html.append("              <img src=\"").append(log.getScreenshot()).append("\" alt=\"Screenshot\" width=\"200\">\n");
                html.append("            </a>\n");
                html.append("          </div>\n");
            }
            
            // Attachment if any
            if (log.getAttachment() != null) {
                html.append("          <div class=\"log-attachment\">\n");
                html.append("            <a href=\"").append(log.getAttachment()).append("\" target=\"_blank\">View Attachment</a>\n");
                html.append("          </div>\n");
            }
            
            html.append("        </div>\n");
        }
        
        html.append("      </div>\n");
        html.append("    </section>\n");
        
        // Screenshots
        if (!report.getScreenshots().isEmpty()) {
            html.append("    <section class=\"test-screenshots\">\n");
            html.append("      <h2>Screenshots</h2>\n");
            html.append("      <div class=\"screenshots-container\">\n");
            
            for (String screenshot : report.getScreenshots()) {
                html.append("        <div class=\"screenshot\">\n");
                html.append("          <a href=\"").append(screenshot).append("\" target=\"_blank\">\n");
                html.append("            <img src=\"").append(screenshot).append("\" alt=\"Screenshot\">\n");
                html.append("          </a>\n");
                html.append("        </div>\n");
            }
            
            html.append("      </div>\n");
            html.append("    </section>\n");
        }
        
        // Error details if any
        if (report.getStatus() == TestStatus.FAILED && report.getError() != null) {
            html.append("    <section class=\"test-error\">\n");
            html.append("      <h2>Error Details</h2>\n");
            html.append("      <div class=\"error-container\">\n");
            html.append("        <div class=\"error-message\">").append(report.getError().getMessage()).append("</div>\n");
            html.append("        <div class=\"error-stacktrace\">\n");
            html.append("          <pre>").append(getStackTraceAsString(report.getError())).append("</pre>\n");
            html.append("        </div>\n");
            html.append("      </div>\n");
            html.append("    </section>\n");
        }
        
        html.append("  </div>\n");
        
        // Footer
        html.append("  <footer class=\"report-footer\">\n");
        html.append("    <div>Generated by <strong>CS Smart Automation Framework</strong> on ").append(formatTimestamp(System.currentTimeMillis())).append("</div>\n");
        html.append("  </footer>\n");
        
        html.append("</body>\n");
        html.append("</html>\n");
        
        return html.toString();
    }
    
    /**
     * Sanitize a file name
     * @param name Name to sanitize
     * @return Sanitized name
     */
    private static String sanitizeFileName(String name) {
        return name.replaceAll("[^a-zA-Z0-9.-]", "_");
    }
    
    /**
     * Format a timestamp
     * @param timestamp Timestamp to format
     * @return Formatted timestamp
     */
    private static String formatTimestamp(long timestamp) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        return dateFormat.format(new Date(timestamp));
    }
    
    /**
     * Format a time
     * @param timestamp Timestamp to format
     * @return Formatted time
     */
    private static String formatTime(long timestamp) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss.SSS");
        return dateFormat.format(new Date(timestamp));
    }
    
    /**
     * Format a duration
     * @param durationMillis Duration in milliseconds
     * @return Formatted duration
     */
    private static String formatDuration(long durationMillis) {
        long seconds = durationMillis / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;
        
        seconds %= 60;
        minutes %= 60;
        
        if (hours > 0) {
            return String.format("%d h %d min %d s", hours, minutes, seconds);
        } else if (minutes > 0) {
            return String.format("%d min %d s", minutes, seconds);
        } else {
            return String.format("%d s", seconds);
        }
    }
    
    /**
     * Get stack trace as string
     * @param throwable Throwable
     * @return Stack trace as string
     */
    private static String getStackTraceAsString(Throwable throwable) {
        if (throwable == null) {
            return "";
        }
        
        StringBuilder sb = new StringBuilder();
        sb.append(throwable.toString()).append("\n");
        
        for (StackTraceElement element : throwable.getStackTrace()) {
            sb.append("\tat ").append(element.toString()).append("\n");
        }
        
        return sb.toString();
    }
    
    /**
     * Copy report assets (CSS, JS, etc.) to report directory
     */
    private static void copyReportAssets() {
        try {
            File assetsDir = new File(REPORT_DIR, "assets");
            File cssDir = new File(assetsDir, "css");
            File jsDir = new File(assetsDir, "js");
            
            cssDir.mkdirs();
            jsDir.mkdirs();
            
            // Create CSS file
            try (FileWriter writer = new FileWriter(new File(cssDir, "report.css"))) {
                writer.write(getReportCss());
            }
            
            // Create JS file
            try (FileWriter writer = new FileWriter(new File(jsDir, "report.js"))) {
                writer.write(getReportJs());
            }
            
            // Download Chart.js
            try (FileWriter writer = new FileWriter(new File(jsDir, "chart.min.js"))) {
                writer.write(getChartJs());
            }
        } catch (IOException e) {
            System.err.println("Failed to copy report assets: " + e.getMessage());
        }
    }
    
    /**
     * Get CSS content for report
     * @return CSS content
     */
    private static String getReportCss() {
        return "/* CS Smart Report CSS */\n" +
               "* {\n" +
               "  box-sizing: border-box;\n" +
               "  margin: 0;\n" +
               "  padding: 0;\n" +
               "}\n" +
               "\n" +
               "body {\n" +
               "  font-family: 'Segoe UI', Arial, sans-serif;\n" +
               "  line-height: 1.6;\n" +
               "  color: #333;\n" +
               "  background-color: #f5f5f5;\n" +
               "}\n" +
               "\n" +
               "/* Header styles */\n" +
               ".report-header {\n" +
               "  background: linear-gradient(135deg, #3a7bd5, #00d2ff);\n" +
               "  color: white;\n" +
               "  padding: 20px;\n" +
               "  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n" +
               "}\n" +
               "\n" +
               ".logo {\n" +
               "  font-size: 16px;\n" +
               "  font-weight: 600;\n" +
               "  margin-bottom: 10px;\n" +
               "}\n" +
               "\n" +
               "h1 {\n" +
               "  font-size: 24px;\n" +
               "  margin-bottom: 15px;\n" +
               "}\n" +
               "\n" +
               ".meta {\n" +
               "  display: flex;\n" +
               "  flex-wrap: wrap;\n" +
               "  gap: 15px;\n" +
               "}\n" +
               "\n" +
               ".meta-item {\n" +
               "  font-size: 14px;\n" +
               "}\n" +
               "\n" +
               ".meta-item span {\n" +
               "  font-weight: 600;\n" +
               "  margin-right: 5px;\n" +
               "}\n" +
               "\n" +
               "/* Summary dashboard */\n" +
               ".summary-dashboard {\n" +
               "  display: flex;\n" +
               "  flex-wrap: wrap;\n" +
               "  padding: 20px;\n" +
               "  gap: 20px;\n" +
               "}\n" +
               "\n" +
               ".summary-container {\n" +
               "  display: flex;\n" +
               "  flex: 1;\n" +
               "  gap: 15px;\n" +
               "  min-width: 300px;\n" +
               "}\n" +
               "\n" +
               ".summary-card {\n" +
               "  flex: 1;\n" +
               "  background-color: white;\n" +
               "  border-radius: 8px;\n" +
               "  padding: 20px;\n" +
               "  text-align: center;\n" +
               "  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n" +
               "}\n" +
               "\n" +
               ".card-count {\n" +
               "  font-size: 32px;\n" +
               "  font-weight: 700;\n" +
               "  margin-bottom: 5px;\n" +
               "}\n" +
               "\n" +
               ".card-label {\n" +
               "  font-size: 14px;\n" +
               "  color: #666;\n" +
               "}\n" +
               "\n" +
               ".summary-card.total .card-count {\n" +
               "  color: #3a7bd5;\n" +
               "}\n" +
               "\n" +
               ".summary-card.passed .card-count {\n" +
               "  color: #4CAF50;\n" +
               "}\n" +
               "\n" +
               ".summary-card.failed .card-count {\n" +
               "  color: #F44336;\n" +
               "}\n" +
               "\n" +
               ".summary-card.skipped .card-count {\n" +
               "  color: #FFC107;\n" +
               "}\n" +
               "\n" +
               ".chart-container {\n" +
               "  flex: 1;\n" +
               "  min-width: 300px;\n" +
               "  height: 250px;\n" +
               "  background-color: white;\n" +
               "  border-radius: 8px;\n" +
               "  padding: 20px;\n" +
               "  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n" +
               "}\n" +
               "\n" +
               "/* Test container */\n" +
               ".test-container, .test-results {\n" +
               "  padding: 20px;\n" +
               "}\n" +
               "\n" +
               "h2 {\n" +
               "  font-size: 20px;\n" +
               "  margin-bottom: 15px;\n" +
               "  color: #333;\n" +
               "}\n" +
               "\n" +
               "/* Test steps */\n" +
               ".steps-container, .logs-container, .screenshots-container, .error-container, .results-container {\n" +
               "  background-color: white;\n" +
               "  border-radius: 8px;\n" +
               "  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n" +
               "  margin-bottom: 20px;\n" +
               "  overflow: hidden;\n" +
               "}\n" +
               "\n" +
               ".step {\n" +
               "  border-bottom: 1px solid #eee;\n" +
               "}\n" +
               "\n" +
               ".step:last-child {\n" +
               "  border-bottom: none;\n" +
               "}\n" +
               "\n" +
               ".step-header {\n" +
               "  display: flex;\n" +
               "  align-items: center;\n" +
               "  padding: 15px;\n" +
               "  cursor: pointer;\n" +
               "}\n" +
               "\n" +
               ".step-header:hover {\n" +
               "  background-color: #f9f9f9;\n" +
               "}\n" +
               "\n" +
               ".step-number {\n" +
               "  width: 30px;\n" +
               "  height: 30px;\n" +
               "  border-radius: 50%;\n" +
               "  background-color: #3a7bd5;\n" +
               "  color: white;\n" +
               "  display: flex;\n" +
               "  align-items: center;\n" +
               "  justify-content: center;\n" +
               "  margin-right: 15px;\n" +
               "  font-weight: 600;\n" +
               "  font-size: 14px;\n" +
               "}\n" +
               "\n" +
               ".step-name {\n" +
               "  flex: 1;\n" +
               "  font-weight: 500;\n" +
               "}\n" +
               "\n" +
               ".step-duration {\n" +
               "  margin-right: 15px;\n" +
               "  font-size: 14px;\n" +
               "  color: #666;\n" +
               "}\n" +
               "\n" +
               ".step-status {\n" +
               "  font-weight: 600;\n" +
               "  padding: 3px 8px;\n" +
               "  border-radius: 4px;\n" +
               "  font-size: 12px;\n" +
               "}\n" +
               "\n" +
               ".step-details {\n" +
               "  display: none;\n" +
               "  padding: 15px;\n" +
               "  background-color: #f9f9f9;\n" +
               "  border-top: 1px solid #eee;\n" +
               "}\n" +
               "\n" +
               ".step.expanded .step-details {\n" +
               "  display: block;\n" +
               "}\n" +
               "\n" +
               "/* Log entries */\n" +
               ".log-entry {\n" +
               "  padding: 10px 15px;\n" +
               "  border-bottom: 1px solid #eee;\n" +
               "  display: flex;\n" +
               "  flex-wrap: wrap;\n" +
               "  align-items: center;\n" +
               "}\n" +
               "\n" +
               ".log-entry:last-child {\n" +
               "  border-bottom: none;\n" +
               "}\n" +
               "\n" +
               ".log-time {\n" +
               "  font-family: monospace;\n" +
               "  margin-right: 10px;\n" +
               "  color: #666;\n" +
               "}\n" +
               "\n" +
               ".log-level {\n" +
               "  margin-right: 10px;\n" +
               "  padding: 2px 6px;\n" +
               "  border-radius: 4px;\n" +
               "  font-size: 12px;\n" +
               "  font-weight: 600;\n" +
               "}\n" +
               "\n" +
               ".log-message {\n" +
               "  flex: 1;\n" +
               "}\n" +
               "\n" +
               ".verification-details {\n" +
               "  margin-top: 8px;\n" +
               "  padding: 8px;\n" +
               "  background-color: #f0f0f0;\n" +
               "  border-radius: 4px;\n" +
               "  width: 100%;\n" +
               "  font-family: monospace;\n" +
               "  font-size: 13px;\n" +
               "}\n" +
               "\n" +
               ".log-screenshot, .log-attachment {\n" +
               "  margin-top: 10px;\n" +
               "  width: 100%;\n" +
               "}\n" +
               "\n" +
               ".log-screenshot img {\n" +
               "  border: 1px solid #ddd;\n" +
               "  border-radius: 4px;\n" +
               "  max-width: 100%;\n" +
               "}\n" +
               "\n" +
               ".log-attachment a {\n" +
               "  display: inline-block;\n" +
               "  padding: 5px 10px;\n" +
               "  background-color: #eee;\n" +
               "  border-radius: 4px;\n" +
               "  text-decoration: none;\n" +
               "  color: #333;\n" +
               "}\n" +
               "\n" +
               "/* Screenshots */\n" +
               ".screenshots-container {\n" +
               "  display: flex;\n" +
               "  flex-wrap: wrap;\n" +
               "  padding: 15px;\n" +
               "  gap: 15px;\n" +
               "}\n" +
               "\n" +
               ".screenshot {\n" +
               "  flex: 1;\n" +
               "  min-width: 300px;\n" +
               "  max-width: 500px;\n" +
               "}\n" +
               "\n" +
               ".screenshot img {\n" +
               "  width: 100%;\n" +
               "  border: 1px solid #ddd;\n" +
               "  border-radius: 4px;\n" +
               "}\n" +
               "\n" +
               "/* Error details */\n" +
               ".error-container {\n" +
               "  padding: 15px;\n" +
               "}\n" +
               "\n" +
               ".error-message {\n" +
               "  padding: 10px;\n" +
               "  background-color: #ffebee;\n" +
               "  border-left: 4px solid #f44336;\n" +
               "  margin-bottom: 10px;\n" +
               "  font-weight: 500;\n" +
               "}\n" +
               "\n" +
               ".error-stacktrace {\n" +
               "  background-color: #f5f5f5;\n" +
               "  padding: 15px;\n" +
               "  border-radius: 4px;\n" +
               "  overflow-x: auto;\n" +
               "}\n" +
               "\n" +
               ".error-stacktrace pre {\n" +
               "  font-family: monospace;\n" +
               "  font-size: 13px;\n" +
               "  line-height: 1.5;\n" +
               "}\n" +
               "\n" +
               "/* Status colors */\n" +
               ".status-passed .step-status, .level-info .log-level {\n" +
               "  background-color: #e8f5e9;\n" +
               "  color: #4CAF50;\n" +
               "}\n" +
               "\n" +
               ".status-failed .step-status, .level-error .log-level {\n" +
               "  background-color: #ffebee;\n" +
               "  color: #F44336;\n" +
               "}\n" +
               "\n" +
               ".status-skipped .step-status {\n" +
               "  background-color: #fff8e1;\n" +
               "  color: #FFC107;\n" +
               "}\n" +
               "\n" +
               ".level-warning .log-level {\n" +
               "  background-color: #fff8e1;\n" +
               "  color: #FF9800;\n" +
               "}\n" +
               "\n" +
               ".level-comment .log-level {\n" +
               "  background-color: #e3f2fd;\n" +
               "  color: #2196F3;\n" +
               "}\n" +
               "\n" +
               "/* Results table */\n" +
               ".results-table {\n" +
               "  width: 100%;\n" +
               "  border-collapse: collapse;\n" +
               "}\n" +
               "\n" +
               ".results-table th {\n" +
               "  text-align: left;\n" +
               "  padding: 12px 15px;\n" +
               "  background-color: #f5f5f5;\n" +
               "  border-bottom: 2px solid #ddd;\n" +
               "}\n" +
               "\n" +
               ".results-table td {\n" +
               "  padding: 10px 15px;\n" +
               "  border-bottom: 1px solid #eee;\n" +
               "}\n" +
               "\n" +
               ".results-table tr:hover {\n" +
               "  background-color: #f9f9f9;\n" +
               "}\n" +
               "\n" +
               ".results-table a {\n" +
               "  display: inline-block;\n" +
               "  padding: 5px 10px;\n" +
               "  background-color: #eee;\n" +
               "  border-radius: 4px;\n" +
               "  text-decoration: none;\n" +
               "  color: #333;\n" +
               "}\n" +
               "\n" +
               ".results-table a:hover {\n" +
               "  background-color: #e0e0e0;\n" +
               "}\n" +
               "\n" +
               "/* Footer */\n" +
               ".report-footer {\n" +
               "  text-align: center;\n" +
               "  padding: 20px;\n" +
               "  color: #666;\n" +
               "  font-size: 14px;\n" +
               "  border-top: 1px solid #eee;\n" +
               "}\n" +
               "\n" +
               "/* Responsive */\n" +
               "@media (max-width: 768px) {\n" +
               "  .meta {\n" +
               "    flex-direction: column;\n" +
               "    gap: 5px;\n" +
               "  }\n" +
               "  \n" +
               "  .summary-container {\n" +
               "    flex-direction: column;\n" +
               "  }\n" +
               "  \n" +
               "  .step-header {\n" +
               "    flex-wrap: wrap;\n" +
               "  }\n" +
               "  \n" +
               "  .step-name {\n" +
               "    width: 100%;\n" +
               "    margin-bottom: 10px;\n" +
               "  }\n" +
               "}\n";
    }
    
    /**
     * Get JavaScript content for report
     * @return JavaScript content
     */
    private static String getReportJs() {
        return "/* CS Smart Report JavaScript */\n" +
               "function toggleStep(element) {\n" +
               "  var step = element.parentElement;\n" +
               "  step.classList.toggle('expanded');\n" +
               "}\n" +
               "\n" +
               "// Filter results\n" +
               "function filterResults(status) {\n" +
               "  var rows = document.querySelectorAll('.results-table tbody tr');\n" +
               "  \n" +
               "  if (status === 'all') {\n" +
               "    rows.forEach(row => {\n" +
               "      row.style.display = '';\n" +
               "    });\n" +
               "    return;\n" +
               "  }\n" +
               "  \n" +
               "  rows.forEach(row => {\n" +
               "    if (row.classList.contains('status-' + status)) {\n" +
               "      row.style.display = '';\n" +
               "    } else {\n" +
               "      row.style.display = 'none';\n" +
               "    }\n" +
               "  });\n" +
               "}\n" +
               "\n" +
               "// Search results\n" +
               "function searchResults() {\n" +
               "  var input = document.getElementById('searchInput');\n" +
               "  var filter = input.value.toLowerCase();\n" +
               "  var rows = document.querySelectorAll('.results-table tbody tr');\n" +
               "  \n" +
               "  rows.forEach(row => {\n" +
               "    var text = row.textContent.toLowerCase();\n" +
               "    if (text.indexOf(filter) > -1) {\n" +
               "      row.style.display = '';\n" +
               "    } else {\n" +
               "      row.style.display = 'none';\n" +
               "    }\n" +
               "  });\n" +
               "}\n" +
               "\n" +
               "// Toggle details for all steps\n" +
               "function toggleAllSteps(expand) {\n" +
               "  var steps = document.querySelectorAll('.step');\n" +
               "  steps.forEach(step => {\n" +
               "    if (expand) {\n" +
               "      step.classList.add('expanded');\n" +
               "    } else {\n" +
               "      step.classList.remove('expanded');\n" +
               "    }\n" +
               "  });\n" +
               "}\n";
    }
    
    /**
     * Get Chart.js content
     * @return Chart.js content
     */
    private static String getChartJs() {
        // In a real implementation, you might download Chart.js from CDN
        // For this example, we'll return a placeholder
        return "/* Chart.js would go here */\n" +
               "class Chart {\n" +
               "  constructor(ctx, config) {\n" +
               "    console.log('Chart created');\n" +
               "  }\n" +
               "}\n";
    }
    
    /**
     * Generate HTML for summary report
     * @return HTML content
     */
    private static String generateSummaryReportHtml() {
        StringBuilder html = new StringBuilder();
        
        // Count test results
        int totalTests = allReports.size();
        int passedTests = 0;
        int failedTests = 0;
        int skippedTests = 0;
        
        for (TestReport report : allReports.values()) {
            switch (report.getStatus()) {
                case PASSED:
                    passedTests++;
                    break;
                case FAILED:
                    failedTests++;
                    break;
                case SKIPPED:
                    skippedTests++;
                    break;
                default:
                    break;
            }
        }
        
        // HTML header
        html.append("<!DOCTYPE html>\n");
        html.append("<html lang=\"en\">\n");
        html.append("<head>\n");
        html.append("  <meta charset=\"UTF-8\">\n");
        html.append("  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n");
        html.append("  <title>CS Smart Test Summary Report</title>\n");
        html.append("  <link rel=\"stylesheet\" href=\"assets/css/report.css\">\n");
        html.append("  <script src=\"assets/js/report.js\"></script>\n");
        html.append("</head>\n");
        html.append("<body>\n");
        
        // Report header
        html.append("  <header class=\"report-header\">\n");
        html.append("    <div class=\"logo\">CS Smart Framework</div>\n");
        html.append("    <h1>Test Summary Report</h1>\n");
        html.append("    <div class=\"meta\">\n");
        html.append("      <div class=\"meta-item\"><span>Generated:</span> ").append(formatTimestamp(System.currentTimeMillis())).append("</div>\n");
        html.append("      <div class=\"meta-item\"><span>Browser:</span> ").append(CSSmartConfigHelper.get("browser", "chrome")).append("</div>\n");
        html.append("      <div class=\"meta-item\"><span>Environment:</span> ").append(CSSmartConfigHelper.get("environment", "dev")).append("</div>\n");
        html.append("    </div>\n");
        html.append("  </header>\n");
        
        // Summary dashboard
        html.append("  <div class=\"summary-dashboard\">\n");
        
        // Test status summary
        html.append("    <div class=\"summary-container\">\n");
        html.append("      <div class=\"summary-card total\">\n");
        html.append("        <div class=\"card-count\">").append(totalTests).append("</div>\n");
        html.append("        <div class=\"card-label\">Total Tests</div>\n");
        html.append("      </div>\n");
        html.append("      <div class=\"summary-card passed\">\n");
        html.append("        <div class=\"card-count\">").append(passedTests).append("</div>\n");
        html.append("        <div class=\"card-label\">Passed</div>\n");
        html.append("      </div>\n");
        html.append("      <div class=\"summary-card failed\">\n");
        html.append("        <div class=\"card-count\">").append(failedTests).append("</div>\n");
        html.append("        <div class=\"card-label\">Failed</div>\n");
        html.append("      </div>\n");
        html.append("      <div class=\"summary-card skipped\">\n");
        html.append("        <div class=\"card-count\">").append(skippedTests).append("</div>\n");
        html.append("        <div class=\"card-label\">Skipped</div>\n");
        html.append("      </div>\n");
        html.append("    </div>\n");
        
        // Donut chart for test status
        html.append("    <div class=\"chart-container\">\n");
        html.append("      <canvas id=\"statusChart\"></canvas>\n");
        html.append("      <script>\n");
        html.append("        window.onload = function() {\n");
        html.append("          var ctx = document.getElementById('statusChart').getContext('2d');\n");
        html.append("          var data = {\n");
        html.append("            datasets: [{\n");
        html.append("              data: [").append(passedTests).append(", ").append(failedTests).append(", ").append(skippedTests).append("],\n");
        html.append("              backgroundColor: ['#4CAF50', '#F44336', '#FFC107']\n");
        html.append("            }],\n");
        html.append("            labels: ['Passed', 'Failed', 'Skipped']\n");
        html.append("          };\n");
        html.append("          var options = {\n");
        html.append("            responsive: true,\n");
        html.append("            maintainAspectRatio: false,\n");
        html.append("            legend: { position: 'right' },\n");
        html.append("            title: { display: true, text: 'Test Results' }\n");
        html.append("          };\n");
        html.append("          new Chart(ctx, { type: 'doughnut', data: data, options: options });\n");
        html.append("        };\n");
        html.append("      </script>\n");
        html.append("    </div>\n");
        html.append("  </div>\n");
        
        // Test results table
        html.append("  <div class=\"test-results\">\n");
        html.append("    <h2>Test Results</h2>\n");
        html.append("    <div class=\"results-container\">\n");
        html.append("      <table class=\"results-table\">\n");
        html.append("        <thead>\n");
        html.append("          <tr>\n");
        html.append("            <th>Test Name</th>\n");
        html.append("            <th>Class</th>\n");
        html.append("            <th>Status</th>\n");
        html.append("            <th>Duration</th>\n");
        html.append("            <th>Details</th>\n");
        html.append("          </tr>\n");
        html.append("        </thead>\n");
        html.append("        <tbody>\n");
        
        for (TestReport report : allReports.values()) {
            html.append("          <tr class=\"status-").append(report.getStatus().toString().toLowerCase()).append("\">\n");
            html.append("            <td>").append(report.getTestName()).append("</td>\n");
            html.append("            <td>").append(report.getTestClass()).append("</td>\n");
            html.append("            <td>").append(report.getStatus()).append("</td>\n");
            html.append("            <td>").append(formatDuration(report.getEndTime() - report.getStartTime())).append("</td>\n");
            html.append("            <td><a href=\"test_").append(sanitizeFileName(report.getTestName())).append(".html\">View Report</a></td>\n");
            html.append("          </tr>\n");
        }
        
        html.append("        </tbody>\n");
        html.append("      </table>\n");
        html.append("    </div>\n");
        html.append("  </div>\n");
        
        // Footer
        html.append("  <footer class=\"report-footer\">\n");
        html.append("    <div>Generated by <strong>CS Smart Automation Framework</strong> on ").append(formatTimestamp(System.currentTimeMillis())).append("</div>\n");
        html.append("  </footer>\n");
        
        // Include Chart.js
        html.append("  <script src=\"assets/js/chart.min.js\"></script>\n");
        
        html.append("</body>\n");
        html.append("</html>\n");
        
        return html.toString();
    }



package com.cssmart.core.reporting;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Represents the status of a test or test step
 */
enum TestStatus {
    PASSED,
    FAILED,
    SKIPPED,
    IN_PROGRESS
}

/**
 * Represents the log level
 */
enum LogLevel {
    INFO,
    WARNING,
    ERROR,
    COMMENT
}

/**
 * Represents a log entry in the report
 */
class LogEntry {
    private final int stepNumber;
    private final long timestamp;
    private final LogLevel level;
    private final String message;
    private String screenshot;
    private String attachment;
    private Map<String, Object> metadata;
    
    /**
     * Create a new log entry
     * 
     * @param stepNumber Step number
     * @param timestamp Timestamp
     * @param level Log level
     * @param message Log message
     */
    public LogEntry(int stepNumber, long timestamp, LogLevel level, String message) {
        this.stepNumber = stepNumber;
        this.timestamp = timestamp;
        this.level = level;
        this.message = message;
    }
    
    /**
     * Get the step number
     * 
     * @return Step number
     */
    public int getStepNumber() {
        return stepNumber;
    }
    
    /**
     * Get the timestamp
     * 
     * @return Timestamp
     */
    public long getTimestamp() {
        return timestamp;
    }
    
    /**
     * Get the log level
     * 
     * @return Log level
     */
    public LogLevel getLevel() {
        return level;
    }
    
    /**
     * Get the log message
     * 
     * @return Log message
     */
    public String getMessage() {
        return message;
    }
    
    /**
     * Get the screenshot path
     * 
     * @return Screenshot path or null
     */
    public String getScreenshot() {
        return screenshot;
    }
    
    /**
     * Set the screenshot path
     * 
     * @param screenshot Screenshot path
     */
    public void setScreenshot(String screenshot) {
        this.screenshot = screenshot;
    }
    
    /**
     * Get the attachment path
     * 
     * @return Attachment path or null
     */
    public String getAttachment() {
        return attachment;
    }
    
    /**
     * Set the attachment path
     * 
     * @param attachment Attachment path
     */
    public void setAttachment(String attachment) {
        this.attachment = attachment;
    }
    
    /**
     * Get additional metadata
     * 
     * @return Metadata map or null
     */
    public Map<String, Object> getMetadata() {
        return metadata;
    }
    
    /**
     * Set additional metadata
     * 
     * @param metadata Metadata map
     */
    public void setMetadata(Map<String, Object> metadata) {
        this.metadata = metadata;
    }
}

/**
 * Represents a test step in the report
 */
class TestStep {
    private final int stepNumber;
    private final String name;
    private long startTime;
    private long endTime;
    private TestStatus status = TestStatus.IN_PROGRESS;
    
    /**
     * Create a new test step
     * 
     * @param stepNumber Step number
     * @param name Step name
     */
    public TestStep(int stepNumber, String name) {
        this.stepNumber = stepNumber;
        this.name = name;
    }
    
    /**
     * Get the step number
     * 
     * @return Step number
     */
    public int getStepNumber() {
        return stepNumber;
    }
    
    /**
     * Get the step name
     * 
     * @return Step name
     */
    public String getName() {
        return name;
    }
    
    /**
     * Get the start time
     * 
     * @return Start time
     */
    public long getStartTime() {
        return startTime;
    }
    
    /**
     * Set the start time
     * 
     * @param startTime Start time
     */
    public void setStartTime(long startTime) {
        this.startTime = startTime;
    }
    
    /**
     * Get the end time
     * 
     * @return End time
     */
    public long getEndTime() {
        return endTime;
    }
    
    /**
     * Set the end time
     * 
     * @param endTime End time
     */
    public void setEndTime(long endTime) {
        this.endTime = endTime;
    }
    
    /**
     * Get the step status
     * 
     * @return Step status
     */
    public TestStatus getStatus() {
        return status;
    }
    
    /**
     * Set the step status
     * 
     * @param status Step status
     */
    public void setStatus(TestStatus status) {
        this.status = status;
    }
}

/**
 * Represents a test report
 */
class TestReport {
    private final String testName;
    private final String testClass;
    private long startTime;
    private long endTime;
    private TestStatus status = TestStatus.IN_PROGRESS;
    private Throwable error;
    private final List<TestStep> steps = new ArrayList<>();
    private TestStep currentStep;
    private final List<LogEntry> logs = new ArrayList<>();
    private final List<String> screenshots = new ArrayList<>();
    private final List<String> attachments = new ArrayList<>();
    
    /**
     * Create a new test report
     * 
     * @param testName Test name
     * @param testClass Test class
     */
    public TestReport(String testName, String testClass) {
        this.testName = testName;
        this.testClass = testClass;
    }
    
    /**
     * Get the test name
     * 
     * @return Test name
     */
    public String getTestName() {
        return testName;
    }
    
    /**
     * Get the test class
     * 
     * @return Test class
     */
    public String getTestClass() {
        return testClass;
    }
    
    /**
     * Get the start time
     * 
     * @return Start time
     */
    public long getStartTime() {
        return startTime;
    }
    
    /**
     * Set the start time
     * 
     * @param startTime Start time
     */
    public void setStartTime(long startTime) {
        this.startTime = startTime;
    }
    
    /**
     * Get the end time
     * 
     * @return End time
     */
    public long getEndTime() {
        return endTime;
    }
    
    /**
     * Set the end time
     * 
     * @param endTime End time
     */
    public void setEndTime(long endTime) {
        this.endTime = endTime;
    }
    
    /**
     * Get the test status
     * 
     * @return Test status
     */
    public TestStatus getStatus() {
        return status;
    }
    
    /**
     * Set the test status
     * 
     * @param status Test status
     */
    public void setStatus(TestStatus status) {
        this.status = status;
    }
    
    /**
     * Get the error if test failed
     * 
     * @return Error or null
     */
    public Throwable getError() {
        return error;
    }
    
    /**
     * Set the error if test failed
     * 
     * @param error Error
     */
    public void setError(Throwable error) {
        this.error = error;
    }
    
    /**
     * Get all test steps
     * 
     * @return List of test steps
     */
    public List<TestStep> getSteps() {
        return steps;
    }
    
    /**
     * Start a new test step
     * 
     * @param step Test step to start
     */
    public void startStep(TestStep step) {
        if (currentStep != null) {
            endStep();
        }
        
        steps.add(step);
        currentStep = step;
    }
    
    /**
     * End the current test step
     */
    public void endStep() {
        currentStep = null;
    }
    
    /**
     * Get the current test step
     * 
     * @return Current test step or null
     */
    public TestStep getCurrentStep() {
        return currentStep;
    }
    
    /**
     * Get all log entries
     * 
     * @return List of log entries
     */
    public List<LogEntry> getLogs() {
        return logs;
    }
    
    /**
     * Add a log entry
     * 
     * @param entry Log entry to add
     */
    public void addLogEntry(LogEntry entry) {
        logs.add(entry);
    }
    
    /**
     * Get all screenshots
     * 
     * @return List of screenshot paths
     */
    public List<String> getScreenshots() {
        return screenshots;
    }
    
    /**
     * Add a screenshot
     * 
     * @param screenshot Screenshot path to add
     */
    public void addScreenshot(String screenshot) {
        screenshots.add(screenshot);
    }
    
    /**
     * Get all attachments
     * 
     * @return List of attachment paths
     */
    public List<String> getAttachments() {
        return attachments;
    }
    
    /**
     * Add an attachment
     * 
     * @param attachment Attachment path to add
     * @param fileType File type (MIME type)
     */
    public void addAttachment(String attachment, String fileType) {
        attachments.add(attachment);
    }
}



package com.cssmart.core.page;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.support.PageFactory;
import org.openqa.selenium.support.pagefactory.DefaultElementLocatorFactory;
import org.openqa.selenium.support.pagefactory.ElementLocatorFactory;

import com.cssmart.annotations.SmartFindBy;
import com.cssmart.core.element.SmartFieldDecorator;
import com.cssmart.core.reporting.Reporter;

/**
 * Enhanced page factory that supports SmartFindBy annotations and CSSmartElement
 */
public class SmartPageFactory {
    
    /**
     * Initialize a page object using SmartFindBy and enhanced elements
     * @param driver WebDriver instance
     * @param pageObject Page object to initialize
     * @return Initialized page object
     */
    public static <T> T initElements(WebDriver driver, T pageObject) {
        Reporter.log("Initializing page object: " + pageObject.getClass().getSimpleName());
        
        ElementLocatorFactory factory = new DefaultElementLocatorFactory(driver);
        SmartFieldDecorator decorator = new SmartFieldDecorator(factory, driver);
        
        // Initialize the page object fields
        PageFactory.initElements(decorator, pageObject);
        
        // Document the page structure if enabled
        if (Boolean.parseBoolean(System.getProperty("cssmart.document.pages", "false"))) {
            documentPageStructure(pageObject);
        }
        
        return pageObject;
    }
    
    /**
     * Create a new page object instance and initialize it
     * @param driver WebDriver instance
     * @param pageObjectClass Page object class
     * @return Initialized page object
     */
    public static <T> T initElements(WebDriver driver, Class<T> pageObjectClass) {
        try {
            Constructor<T> constructor = pageObjectClass.getConstructor(WebDriver.class);
            T page = constructor.newInstance(driver);
            return initElements(driver, page);
        } catch (NoSuchMethodException | SecurityException | InstantiationException | 
                 IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
            Reporter.logError("Failed to create page object instance: " + pageObjectClass.getSimpleName());
            throw new RuntimeException("Failed to create page object instance", e);
        }
    }
    
    /**
     * Document the page structure for better test documentation
     * @param pageObject Page object to document
     */
    private static void documentPageStructure(Object pageObject) {
        StringBuilder doc = new StringBuilder();
        doc.append("Page Object Structure: ").append(pageObject.getClass().getSimpleName()).append("\n");
        doc.append("-------------------------------------------------------------------------\n");
        
        // Get all fields in the class
        Field[] fields = pageObject.getClass().getDeclaredFields();
        
        for (Field field : fields) {
            // Look for SmartFindBy annotations
            SmartFindBy smartAnnotation = field.getAnnotation(SmartFindBy.class);
            if (smartAnnotation != null) {
                field.setAccessible(true);
                
                // Add field info to documentation
                doc.append("Field: ").append(field.getName()).append("\n");
                doc.append("  Type: ").append(field.getType().getSimpleName()).append("\n");
                
                // Add locator info
                doc.append("  Locator: ");
                if (!smartAnnotation.id().isEmpty()) {
                    doc.append("id=").append(smartAnnotation.id());
                } else if (!smartAnnotation.name().isEmpty()) {
                    doc.append("name=").append(smartAnnotation.name());
                } else if (!smartAnnotation.className().isEmpty()) {
                    doc.append("className=").append(smartAnnotation.className());
                } else if (!smartAnnotation.css().isEmpty()) {
                    doc.append("css=").append(smartAnnotation.css());
                } else if (!smartAnnotation.xpath().isEmpty()) {
                    doc.append("xpath=").append(smartAnnotation.xpath());
                } else if (!smartAnnotation.tagName().isEmpty()) {
                    doc.append("tagName=").append(smartAnnotation.tagName());
                } else if (!smartAnnotation.linkText().isEmpty()) {
                    doc.append("linkText=").append(smartAnnotation.linkText());
                } else if (!smartAnnotation.partialLinkText().isEmpty()) {
                    doc.append("partialLinkText=").append(smartAnnotation.partialLinkText());
                }
                doc.append("\n");
                
                // Add description if available
                if (!smartAnnotation.description().isEmpty()) {
                    doc.append("  Description: ").append(smartAnnotation.description()).append("\n");
                }
                
                // Add timeout if specified
                if (smartAnnotation.timeoutSeconds() > 0) {
                    doc.append("  Timeout: ").append(smartAnnotation.timeoutSeconds()).append(" seconds\n");
                }
                
                doc.append("\n");
            }
        }
        
        // Log the documentation
        Reporter.comment("Page Structure Documentation:\n" + doc.toString());
        
        // Write to file if needed
        // You could add code here to save the documentation to a file
    }
}



package com.cssmart.example.pages;

import java.time.Duration;
import java.util.List;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.support.FindBy;

import com.cssmart.annotations.SmartFindBy;
import com.cssmart.core.element.CSSmartElement;
import com.cssmart.core.page.SmartPageFactory;
import com.cssmart.core.reporting.Reporter;

/**
 * Sample login page that demonstrates the enhanced framework features
 */
public class LoginPage {
    
    private final WebDriver driver;
    
    @SmartFindBy(id = "username", description = "Username input field", timeoutSeconds = 10)
    private CSSmartElement usernameInput;
    
    @SmartFindBy(id = "password", description = "Password input field")
    private CSSmartElement passwordInput;
    
    @SmartFindBy(css = "button[type='submit'], input[type='submit']", description = "Login button")
    private CSSmartElement loginButton;
    
    @SmartFindBy(css = ".error-message", description = "Error message display")
    private CSSmartElement errorMessage;
    
    @SmartFindBy(css = ".remember-me", description = "Remember me checkbox")
    private CSSmartElement rememberMeCheckbox;
    
    @SmartFindBy(linkText = "Forgot Password?", description = "Forgot password link")
    private CSSmartElement forgotPasswordLink;
    
    @SmartFindBy(css = ".social-login-button", description = "Social login buttons")
    private List<CSSmartElement> socialLoginButtons;
    
    /**
     * Initialize the login page
     * 
     * @param driver WebDriver instance
     */
    public LoginPage(WebDriver driver) {
        this.driver = driver;
        SmartPageFactory.initElements(driver, this);
        
        // Verify page is loaded
        boolean isLoaded = usernameInput.isDisplayed() && passwordInput.isDisplayed() && loginButton.isDisplayed();
        Reporter.verify("Login page is loaded", isLoaded, true, isLoaded);
    }
    
    /**
     * Navigate to the login page
     * 
     * @param baseUrl Base URL of the application
     * @return This page object
     */
    public LoginPage navigateTo(String baseUrl) {
        Reporter.startStep("Navigate to Login Page");
        
        driver.get(baseUrl + "/login");
        Reporter.log("Navigated to: " + driver.getCurrentUrl());
        
        // Take screenshot after navigation
        Reporter.takeScreenshot("LoginPage_Initial.png");
        
        Reporter.endStep(isLoaded() ? TestStatus.PASSED : TestStatus.FAILED);
        return this;
    }
    
    /**
     * Check if the page is loaded
     * 
     * @return true if the page is loaded, false otherwise
     */
    public boolean isLoaded() {
        return usernameInput.exists() && passwordInput.exists() && loginButton.exists();
    }
    
    /**
     * Enter username
     * 
     * @param username Username to enter
     * @return This page object
     */
    public LoginPage enterUsername(String username) {
        Reporter.startStep("Enter username: " + username);
        
        usernameInput.waitForVisible().clear().sendKeys(username);
        
        Reporter.endStep(TestStatus.PASSED);
        return this;
    }
    
    /**
     * Enter password
     * 
     * @param password Password to enter
     * @return This page object
     */
    public LoginPage enterPassword(String password) {
        Reporter.startStep("Enter password");
        
        passwordInput.waitForVisible().clear().sendKeys(password);
        
        Reporter.endStep(TestStatus.PASSED);
        return this;
    }
    
    /**
     * Set "Remember Me" option
     * 
     * @param remember Whether to check the Remember Me checkbox
     * @return This page object
     */
    public LoginPage setRememberMe(boolean remember) {
        Reporter.startStep("Set Remember Me to: " + remember);
        
        boolean isChecked = rememberMeCheckbox.isSelected();
        
        if (isChecked != remember) {
            rememberMeCheckbox.click();
            Reporter.log("Changed Remember Me checkbox state");
        } else {
            Reporter.log("Remember Me checkbox already in desired state");
        }
        
        Reporter.endStep(TestStatus.PASSED);
        return this;
    }
    
    /**
     * Click login button
     * 
     * @return Dashboard page or this page depending on login success
     */
    public Object clickLoginButton() {
        Reporter.startStep("Click Login Button");
        
        loginButton.waitForClickable().click();
        Reporter.takeScreenshot("After_Login_Click.png");
        
        // Wait for page transition or error message
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(5));
        
        // Check for error message
        if (errorMessage.exists() && errorMessage.isDisplayed()) {
            Reporter.logWarning("Login failed: " + errorMessage.getText());
            Reporter.endStep(TestStatus.FAILED);
            return this;
        }
        
        Reporter.log("Login successful, redirecting to Dashboard");
        Reporter.endStep(TestStatus.PASSED);
        
        // Return the dashboard page object
        return new DashboardPage(driver);
    }
    
    /**
     * Perform login
     * 
     * @param username Username
     * @param password Password
     * @param rememberMe Whether to check Remember Me
     * @return Dashboard page or this page depending on login success
     */
    public Object login(String username, String password, boolean rememberMe) {
        Reporter.startStep("Login with username: " + username);
        
        enterUsername(username);
        enterPassword(password);
        setRememberMe(rememberMe);
        Object result = clickLoginButton();
        
        Reporter.endStep(result instanceof DashboardPage ? TestStatus.PASSED : TestStatus.FAILED);
        return result;
    }
    
    /**
     * Click on "Forgot Password" link
     * 
     * @return ForgotPasswordPage object
     */
    public ForgotPasswordPage clickForgotPassword() {
        Reporter.startStep("Click Forgot Password");
        
        forgotPasswordLink.waitForClickable().click();
        
        Reporter.endStep(TestStatus.PASSED);
        return new ForgotPasswordPage(driver);
    }
    
    /**
     * Click a social login button
     * 
     * @param socialNetwork Social network name (e.g., "Google", "Facebook")
     * @return This page object
     */
    public LoginPage clickSocialLogin(String socialNetwork) {
        Reporter.startStep("Click Social Login: " + socialNetwork);
        
        boolean found = false;
        for (CSSmartElement button : socialLoginButtons) {
            if (button.getText().contains(socialNetwork) || 
                button.getAttribute("title").contains(socialNetwork) ||
                button.getAttribute("data-provider").contains(socialNetwork.toLowerCase())) {
                
                Reporter.log("Found social login button for: " + socialNetwork);
                button.scrollIntoView().click();
                found = true;
                break;
            }
        }
        
        if (!found) {
            Reporter.logError("Social login button for " + socialNetwork + " not found");
            Reporter.endStep(TestStatus.FAILED);
        } else {
            Reporter.endStep(TestStatus.PASSED);
        }
        
        return this;
    }
    
    /**
     * On-the-fly element example - finding an element dynamically
     * 
     * @param tooltipText Tooltip text to find
     * @return Element with the specified tooltip
     */
    public CSSmartElement getElementByTooltip(String tooltipText) {
        return CSSmartElement.createByXPath(
            "//*[@title='" + tooltipText + "' or @data-tooltip='" + tooltipText + "']",
            "Element with tooltip: " + tooltipText
        );
    }
    
    /**
     * Dynamic elements - create elements on the fly for custom scenarios
     * 
     * @param fieldLabel Label text
     * @return Input field associated with the label
     */
    public CSSmartElement getInputByLabel(String fieldLabel) {
        // First strategy: try to find an input with a label pointing to it
        CSSmartElement labelElement = CSSmartElement.createByXPath(
            "//label[contains(text(), '" + fieldLabel + "')]",
            "Label with text: " + fieldLabel
        );
        
        if (labelElement.exists()) {
            String forId = labelElement.getAttribute("for");
            if (forId != null && !forId.isEmpty()) {
                return CSSmartElement.createById(forId, "Input field for: " + fieldLabel);
            }
        }
        
        // Second strategy: look for placeholder
        return CSSmartElement.createByXPath(
            "//input[@placeholder='" + fieldLabel + "' or contains(@placeholder, '" + fieldLabel + "')]",
            "Input with placeholder: " + fieldLabel
        );
    }
}

/**
 * Placeholder for Dashboard page class
 */
class DashboardPage {
    public DashboardPage(WebDriver driver) {
        // Initialize dashboard page
    }
}

/**
 * Placeholder for Forgot Password page class
 */
class ForgotPasswordPage {
    public ForgotPasswordPage(WebDriver driver) {
        // Initialize forgot password page
    }
}



package com.cssmart.example.tests;

import org.openqa.selenium.WebDriver;
import org.testng.Assert;
import org.testng.ITestResult;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

import com.cssmart.core.driver.CSSmartDriverFactory;
import com.cssmart.core.reporting.Reporter;
import com.cssmart.example.pages.LoginPage;

/**
 * Sample test class that demonstrates the enhanced framework features
 */
public class LoginTest {
    
    private WebDriver driver;
    
    @BeforeMethod
    public void setUp() {
        // Initialize test report
        Reporter.startTest("Login Test", this.getClass().getName());
        
        // Get WebDriver instance
        driver = CSSmartDriverFactory.getDriver();
        
        // Configure driver
        driver.manage().window().maximize();
        
        Reporter.log("Test setup completed");
    }
    
    @Test(description = "Verify successful login with valid credentials")
    public void testSuccessfulLogin() {
        // Navigate to login page using our enhanced page object
        LoginPage loginPage = new LoginPage(driver);
        loginPage.navigateTo("https://demo.example.com");
        
        // Verify page is loaded
        Assert.assertTrue(loginPage.isLoaded(), "Login page is not loaded properly");
        
        // Perform login
        Object dashboardPage = loginPage.login("validUser", "validPassword", true);
        
        // Verify login was successful
        Assert.assertTrue(dashboardPage instanceof DashboardPage, "Login failed, did not redirect to dashboard");
        
        // Further verification on dashboard could be done here
    }
    
    @Test(description = "Verify failed login with invalid credentials")
    public void testFailedLogin() {
        // Navigate to login page
        LoginPage loginPage = new LoginPage(driver);
        loginPage.navigateTo("https://demo.example.com");
        
        // Enter invalid credentials
        loginPage.enterUsername("invalidUser");
        loginPage.enterPassword("invalidPassword");
        
        // Attempt login
        Object result = loginPage.clickLoginButton();
        
        // Verify login failed
        Assert.assertTrue(result instanceof LoginPage, "Invalid login redirected away from login page");
        
        // Additional verifications could be added here to check error messages, etc.
    }
    
    @Test(description = "Verify social login options")
    public void testSocialLoginOptions() {
        // Navigate to login page
        LoginPage loginPage = new LoginPage(driver);
        loginPage.navigateTo("https://demo.example.com");
        
        // Verify page is loaded
        Assert.assertTrue(loginPage.isLoaded(), "Login page is not loaded properly");
        
        // Use dynamic element creation to find elements
        loginPage.clickSocialLogin("Google");
        
        // Further verification would depend on the application behavior
    }
    
    @Test(description = "Demonstrate dynamic element location")
    public void testDynamicElementLocation() {
        // Navigate to login page
        LoginPage loginPage = new LoginPage(driver);
        loginPage.navigateTo("https://demo.example.com");
        
        // Use dynamic element finding to locate a field by its label
        loginPage.getInputByLabel("Email").sendKeys("test@example.com");
        
        // Find an element by tooltip
        boolean hasHelpIcon = loginPage.getElementByTooltip("Need help?").exists();
        Reporter.verify("Help icon exists", hasHelpIcon, true, hasHelpIcon);
        
        // Additional assertions would depend on the application
    }
    
    @AfterMethod
    public void tearDown(ITestResult result) {
        // Determine test status
        TestStatus status;
        switch (result.getStatus()) {
            case ITestResult.SUCCESS:
                status = TestStatus.PASSED;
                break;
            case ITestResult.FAILURE:
                status = TestStatus.FAILED;
                break;
            case ITestResult.SKIP:
                status = TestStatus.SKIPPED;
                break;
            default:
                status = TestStatus.FAILED;
        }
        
        // End test reporting
        Reporter.endTest(status, result.getThrowable());
        
        // Close the browser
        if (driver != null) {
            driver.quit();
        }
    }
}




package com.cssmart.core.test;

import org.openqa.selenium.WebDriver;
import org.testng.ITestResult;
import org.testng.annotations.AfterClass;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Listeners;

import com.cssmart.config.CSSmartConfigHelper;
import com.cssmart.core.driver.CSSmartDriverFactory;
import com.cssmart.core.listeners.CSSmartTestListener;
import com.cssmart.core.reporting.Reporter;
import com.cssmart.core.reporting.TestStatus;

/**
 * Base class for all CS Smart UI test classes.
 * Provides automatic setup, teardown, and reporting.
 * Test classes should extend this class to inherit the framework functionality.
 */
@Listeners(CSSmartTestListener.class)
public abstract class CSSmartBaseTest {
    
    protected WebDriver driver;
    private boolean parallelExecution = CSSmartConfigHelper.getBoolean("test.parallel", false);
    private ThreadLocal<WebDriver> threadLocalDriver = new ThreadLocal<>();
    
    /**
     * Setup before test class execution.
     * Creates test resources, initializes reporting, etc.
     */
    @BeforeClass
    public void baseSetUpClass() {
        Reporter.log("Starting test class: " + this.getClass().getName());
        
        // Initialize any class-level resources
        // This can be overridden by child classes if needed
        onSetUpClass();
    }
    
    /**
     * Setup before each test method.
     * Creates WebDriver, initializes test reporting, etc.
     * 
     * @param method Test method
     * @param params Test parameters
     */
    @BeforeMethod
    public void baseSetUp(java.lang.reflect.Method method, Object[] params) {
        // Get test name from method
        String testName = method.getName();
        String testDescription = "";
        
        // Check if the method has a Test annotation with a description
        if (method.isAnnotationPresent(org.testng.annotations.Test.class)) {
            org.testng.annotations.Test testAnnotation = method.getAnnotation(org.testng.annotations.Test.class);
            if (!testAnnotation.description().isEmpty()) {
                testDescription = testAnnotation.description();
                testName = testDescription;
            }
        }
        
        // Initialize test reporting
        Reporter.startTest(testName, this.getClass().getName());
        
        // Initialize WebDriver based on parallel execution setting
        if (parallelExecution) {
            // For parallel execution, use thread-local driver
            WebDriver threadDriver = CSSmartDriverFactory.createDriver();
            threadLocalDriver.set(threadDriver);
            driver = threadDriver;
        } else {
            // For sequential execution, use standard driver
            driver = CSSmartDriverFactory.getDriver();
        }
        
        // Configure driver
        configureDriver(driver);
        
        // Call hook for additional setup
        onSetUp(method, params);
        
        Reporter.log("Test setup completed for: " + testName);
    }
    
    /**
     * Teardown after each test method.
     * Closes WebDriver, finalizes test reporting, etc.
     * 
     * @param result Test result
     */
    @AfterMethod
    public void baseTearDown(ITestResult result) {
        // Determine test status
        TestStatus status;
        switch (result.getStatus()) {
            case ITestResult.SUCCESS:
                status = TestStatus.PASSED;
                break;
            case ITestResult.FAILURE:
                status = TestStatus.FAILED;
                break;
            case ITestResult.SKIP:
                status = TestStatus.SKIPPED;
                break;
            default:
                status = TestStatus.FAILED;
        }
        
        // Call hook for additional teardown
        onTearDown(result);
        
        // End test reporting
        Reporter.endTest(status, result.getThrowable());
        
        // Close the browser based on parallel execution setting
        if (parallelExecution) {
            WebDriver threadDriver = threadLocalDriver.get();
            if (threadDriver != null) {
                threadDriver.quit();
                threadLocalDriver.remove();
            }
        } else if (CSSmartConfigHelper.getBoolean("driver.quit.after.test", true)) {
            // Only quit the driver if configuration allows
            CSSmartDriverFactory.quitDriver();
        }
    }
    
    /**
     * Teardown after test class execution.
     * Cleans up class-level resources, etc.
     */
    @AfterClass
    public void baseTearDownClass() {
        // Call hook for additional class-level teardown
        onTearDownClass();
        
        Reporter.log("Completed test class: " + this.getClass().getName());
    }
    
    /**
     * Configure the WebDriver instance.
     * Can be overridden by child classes to add custom configuration.
     * 
     * @param driver WebDriver instance to configure
     */
    protected void configureDriver(WebDriver driver) {
        // Default configuration
        if (CSSmartConfigHelper.getBoolean("browser.maximize", true)) {
            driver.manage().window().maximize();
        }
        
        int implicitWait = CSSmartConfigHelper.getInt("driver.implicit.wait.seconds", 0);
        if (implicitWait > 0) {
            driver.manage().timeouts().implicitlyWait(java.time.Duration.ofSeconds(implicitWait));
        }
    }
    
    /**
     * Hook for additional setup at class level.
     * Override in child classes if needed.
     */
    protected void onSetUpClass() {
        // Default implementation does nothing
    }
    
    /**
     * Hook for additional setup at method level.
     * Override in child classes if needed.
     * 
     * @param method Test method
     * @param params Test parameters
     */
    protected void onSetUp(java.lang.reflect.Method method, Object[] params) {
        // Default implementation does nothing
    }
    
    /**
     * Hook for additional teardown at method level.
     * Override in child classes if needed.
     * 
     * @param result Test result
     */
    protected void onTearDown(ITestResult result) {
        // Default implementation does nothing
    }
    
    /**
     * Hook for additional teardown at class level.
     * Override in child classes if needed.
     */
    protected void onTearDownClass() {
        // Default implementation does nothing
    }
}


package com.cssmart.core.page;

import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.support.ui.WebDriverWait;

import com.cssmart.config.CSSmartConfigHelper;
import com.cssmart.core.reporting.Reporter;

/**
 * Base class for all CS Smart page objects.
 * Provides common page functionality and automatic initialization.
 */
public abstract class CSSmartBasePage {
    
    protected final WebDriver driver;
    protected final String pageName;
    protected final int defaultTimeout;
    
    /**
     * Constructor for base page.
     * 
     * @param driver WebDriver instance
     */
    public CSSmartBasePage(WebDriver driver) {
        this.driver = driver;
        this.pageName = this.getClass().getSimpleName();
        this.defaultTimeout = CSSmartConfigHelper.getInt("element.timeout.seconds", 30);
        
        // Initialize page elements using Smart Page Factory
        CSSmartPageFactory.initElements(driver, this);
        
        // Wait for page to load
        waitForPageLoad();
        
        // Verify page is loaded correctly
        if (!isPageLoaded()) {
            Reporter.logWarning("Page " + pageName + " may not be fully loaded");
        } else {
            Reporter.log("Page " + pageName + " loaded successfully");
        }
    }
    
    /**
     * Check if the page is loaded.
     * Should be implemented by each page class.
     * 
     * @return true if the page is loaded, false otherwise
     */
    public abstract boolean isPageLoaded();
    
    /**
     * Wait for page to load completely.
     * Uses document.readyState to check for page load completion.
     */
    protected void waitForPageLoad() {
        Reporter.log("Waiting for page to load: " + pageName);
        
        new WebDriverWait(driver, java.time.Duration.ofSeconds(defaultTimeout))
            .until(webDriver -> ((JavascriptExecutor) webDriver)
                .executeScript("return document.readyState").equals("complete"));
        
        // Additional wait for any animations or dynamic content
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    /**
     * Wait for AJAX requests to complete.
     * Uses jQuery to check for active AJAX requests.
     */
    protected void waitForAjax() {
        Reporter.log("Waiting for AJAX requests to complete");
        
        // First check if jQuery is available
        Boolean jQueryDefined = (Boolean) ((JavascriptExecutor) driver)
            .executeScript("return typeof jQuery != 'undefined'");
        
        if (jQueryDefined) {
            new WebDriverWait(driver, java.time.Duration.ofSeconds(defaultTimeout))
                .until(webDriver -> (Boolean) ((JavascriptExecutor) webDriver)
                    .executeScript("return jQuery.active == 0"));
        }
    }
    
    /**
     * Navigate to a URL.
     * 
     * @param url URL to navigate to
     * @return This page object
     */
    public CSSmartBasePage navigateTo(String url) {
        Reporter.log("Navigating to URL: " + url);
        driver.get(url);
        waitForPageLoad();
        return this;
    }
    
    /**
     * Get the current page URL.
     * 
     * @return Current URL
     */
    public String getCurrentUrl() {
        return driver.getCurrentUrl();
    }
    
    /**
     * Get the current page title.
     * 
     * @return Page title
     */
    public String getPageTitle() {
        return driver.getTitle();
    }
    
    /**
     * Refresh the page.
     * 
     * @return This page object
     */
    public CSSmartBasePage refreshPage() {
        Reporter.log("Refreshing page: " + pageName);
        driver.navigate().refresh();
        waitForPageLoad();
        return this;
    }
    
    /**
     * Execute JavaScript on the page.
     * 
     * @param script JavaScript to execute
     * @param args Script arguments
     * @return Result of script execution
     */
    protected Object executeScript(String script, Object... args) {
        return ((JavascriptExecutor) driver).executeScript(script, args);
    }
    
    /**
     * Take a screenshot of the current page.
     * 
     * @param fileName File name for screenshot
     * @return Path to screenshot
     */
    public String takeScreenshot(String fileName) {
        return Reporter.takeScreenshot(fileName);
    }
}



package com.cssmart.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.openqa.selenium.support.How;

/**
 * Enhanced version of FindBy that includes a description field.
 * This allows for better reporting and documentation of page elements.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.TYPE})
public @interface CSSmartFindBy {
    /**
     * How to find the element
     */
    How how() default How.UNSET;
    
    /**
     * The identifying value
     */
    String using() default "";
    
    /**
     * ID finding
     */
    String id() default "";
    
    /**
     * Name finding
     */
    String name() default "";
    
    /**
     * Class name finding
     */
    String className() default "";
    
    /**
     * Tag name finding
     */
    String tagName() default "";
    
    /**
     * Link text finding
     */
    String linkText() default "";
    
    /**
     * Partial link text finding
     */
    String partialLinkText() default "";
    
    /**
     * CSS finding
     */
    String css() default "";
    
    /**
     * XPath finding
     */
    String xpath() default "";
    
    /**
     * Human-readable description of the element
     * This is used for reporting and documentation
     */
    String description() default "";
    
    /**
     * Timeout in seconds for finding this element
     * Overrides the default timeout
     */
    int timeoutSeconds() default -1;
}



package com.cssmart.core.parallel;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import org.openqa.selenium.WebDriver;
import org.testng.ITestContext;
import org.testng.xml.XmlTest;

import com.cssmart.config.CSSmartConfigHelper;
import com.cssmart.core.driver.CSSmartDriverFactory;
import com.cssmart.core.reporting.Reporter;

/**
 * Parallel execution manager for CS Smart framework.
 * Handles thread-safe driver and resource management for parallel test execution.
 */
public class CSSmartParallelManager {
    
    private static final ThreadLocal<String> currentTestId = new ThreadLocal<>();
    private static final ThreadLocal<WebDriver> threadLocalDriver = new ThreadLocal<>();
    private static final ConcurrentHashMap<String, WebDriver> testDriverMap = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<String, Map<String, Object>> testDataMap = new ConcurrentHashMap<>();
    private static final AtomicInteger activeThreads = new AtomicInteger(0);
    
    /**
     * Start a parallel test execution.
     * 
     * @param testName Test name
     * @param testClass Test class
     * @param context TestNG context
     * @return WebDriver instance for this test
     */
    public static WebDriver startParallelTest(String testName, String testClass, ITestContext context) {
        String testId = generateTestId(testName, testClass);
        currentTestId.set(testId);
        
        Reporter.log("[Thread " + Thread.currentThread().getId() + "] Starting parallel test: " + testId);
        
        // Initialize test report
        Reporter.startTest(testName, testClass);
        
        // Create driver for this thread
        WebDriver driver = CSSmartDriverFactory.createDriver();
        threadLocalDriver.set(driver);
        testDriverMap.put(testId, driver);
        
        // Initialize test data map
        testDataMap.put(testId, new HashMap<>());
        
        // Track active threads
        activeThreads.incrementAndGet();
        
        // Configure parallel thread count for reporting
        if (context != null) {
            XmlTest xmlTest = context.getCurrentXmlTest();
            if (xmlTest != null) {
                int threadCount = xmlTest.getThreadCount();
                Reporter.setParallelThreadCount(threadCount);
            }
        }
        
        return driver;
    }
    
    /**
     * End a parallel test execution.
     * 
     * @param status Test status
     * @param error Error if test failed
     */
    public static void endParallelTest(TestStatus status, Throwable error) {
        String testId = currentTestId.get();
        
        if (testId != null) {
            Reporter.log("[Thread " + Thread.currentThread().getId() + "] Ending parallel test: " + testId);
            
            // End test reporting
            Reporter.endTest(status, error);
            
            // Quit WebDriver
            WebDriver driver = testDriverMap.get(testId);
            if (driver != null) {
                try {
                    driver.quit();
                } catch (Exception e) {
                    Reporter.logError("Error quitting WebDriver: " + e.getMessage());
                }
                testDriverMap.remove(testId);
            }
            
            // Clean up resources
            testDataMap.remove(testId);
            threadLocalDriver.remove();
            currentTestId.remove();
            
            // Track active threads
            activeThreads.decrementAndGet();
        }
    }
    
    /**
     * Get the current WebDriver for this thread.
     * 
     * @return WebDriver instance or null if not initialized
     */
    public static WebDriver getDriver() {
        return threadLocalDriver.get();
    }
    
    /**
     * Store data for the current test.
     * 
     * @param key Data key
     * @param value Data value
     */
    public static void setTestData(String key, Object value) {
        String testId = currentTestId.get();
        if (testId != null) {
            Map<String, Object> dataMap = testDataMap.get(testId);
            if (dataMap != null) {
                dataMap.put(key, value);
            }
        }
    }
    
    /**
     * Get data for the current test.
     * 
     * @param key Data key
     * @return Data value or null if not found
     */
    public static Object getTestData(String key) {
        String testId = currentTestId.get();
        if (testId != null) {
            Map<String, Object> dataMap = testDataMap.get(testId);
            if (dataMap != null) {
                return dataMap.get(key);
            }
        }
        return null;
    }
    
    /**
     * Get the number of active test threads.
     * 
     * @return Active thread count
     */
    public static int getActiveThreadCount() {
        return activeThreads.get();
    }
    
    /**
     * Generate a unique test ID.
     * 
     * @param testName Test name
     * @param testClass Test class
     * @return Unique test ID
     */
    private static String generateTestId(String testName, String testClass) {
        return testClass + "." + testName + "." + Thread.currentThread().getId();
    }
    
    /**
     * Get maximum parallel threads from configuration.
     * 
     * @return Maximum parallel threads
     */
    public static int getMaxThreads() {
        return CSSmartConfigHelper.getInt("parallel.max.threads", 
            Runtime.getRuntime().availableProcessors());
    }
}



package com.cssmart.core.cicd;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import com.cssmart.config.CSSmartConfigHelper;
import com.cssmart.core.reporting.Reporter;
import com.cssmart.core.util.CSSmartJsonUtil;

/**
 * Azure DevOps integration for CS Smart framework.
 * Provides capabilities to update test results, create work items, and trigger pipelines.
 */
public class CSSmartAzureDevOpsIntegration {
    
    private static final String ADO_BASE_URL = CSSmartConfigHelper.get("ado.base.url", "");
    private static final String ADO_PROJECT = CSSmartConfigHelper.get("ado.project", "");
    private static final String ADO_PAT = CSSmartConfigHelper.get("ado.pat", "");
    private static final String ADO_API_VERSION = CSSmartConfigHelper.get("ado.api.version", "7.1");
    
    private static final Map<String, Object> testResultCache = new ConcurrentHashMap<>();
    
    /**
     * Update test result in Azure DevOps.
     * 
     * @param testRunId Test run ID
     * @param testCaseId Test case ID
     * @param testName Test name
     * @param passed Test result (true for pass, false for fail)
     * @param errorMessage Error message if test failed
     * @param durationMs Test duration in milliseconds
     * @return true if update successful, false otherwise
     */
    public static boolean updateTestResult(String testRunId, String testCaseId, 
                                          String testName, boolean passed, 
                                          String errorMessage, long durationMs) {
        try {
            Reporter.log("Updating test result in Azure DevOps: " + testName);
            
            // Build the request URL
            String endpoint = String.format("/test/runs/%s/results", testRunId);
            
            // Build the request payload
            Map<String, Object> testResult = new HashMap<>();
            testResult.put("testCaseTitle", testName);
            testResult.put("state", "Completed");
            testResult.put("outcome", passed ? "Passed" : "Failed");
            testResult.put("durationInMs", durationMs);
            
            if (testCaseId != null && !testCaseId.isEmpty()) {
                testResult.put("testCaseId", testCaseId);
            }
            
            if (errorMessage != null && !errorMessage.isEmpty()) {
                testResult.put("errorMessage", errorMessage);
            }
            
            Map<String, Object> requestBody = new HashMap<>();
            requestBody.put("results", List.of(testResult));
            
            // Send the update request
            String response = sendRequest("PATCH", endpoint, requestBody);
            
            // Cache the result
            testResultCache.put(testName, testResult);
            
            return response != null && !response.isEmpty();
            
        } catch (Exception e) {
            Reporter.logError("Failed to update test result in Azure DevOps: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Create a test run in Azure DevOps.
     * 
     * @param testRunName Test run name
     * @param testPlanId Test plan ID
     * @param testSuiteId Test suite ID
     * @return Test run ID or null if creation failed
     */
    public static String createTestRun(String testRunName, String testPlanId, String testSuiteId) {
        try {
            Reporter.log("Creating test run in Azure DevOps: " + testRunName);
            
            // Build the request URL
            String endpoint = "/test/runs";
            
            // Build the request payload
            Map<String, Object> requestBody = new HashMap<>();
            requestBody.put("name", testRunName);
            requestBody.put("automated", true);
            
            if (testPlanId != null && !testPlanId.isEmpty()) {
                requestBody.put("plan", new HashMap<String, Object>() {{
                    put("id", testPlanId);
                }});
            }
            
            if (testSuiteId != null && !testSuiteId.isEmpty()) {
                requestBody.put("pointIds", List.of(testSuiteId));
            }
            
            // Send the create request
            String response = sendRequest("POST", endpoint, requestBody);
            
            // Parse the response to get the test run ID
            if (response != null && !response.isEmpty()) {
                Map<String, Object> responseMap = CSSmartJsonUtil.jsonToMap(response);
                return responseMap.get("id").toString();
            }
            
            return null;
            
        } catch (Exception e) {
            Reporter.logError("Failed to create test run in Azure DevOps: " + e.getMessage());
            return null;
        }
    }
    
    /**
     * Create a work item in Azure DevOps for a test failure.
     * 
     * @param testName Test name
     * @param errorMessage Error message
     * @param stackTrace Stack trace
     * @return Work item ID or null if creation failed
     */
    public static String createBugWorkItem(String testName, String errorMessage, String stackTrace) {
        try {
            Reporter.log("Creating bug work item in Azure DevOps for failed test: " + testName);
            
            // Build the request URL
            String endpoint = "/wit/workitems/$Bug";
            
            // Build the request payload
            // ADO uses a specific JSON patch format for work item updates
            List<Map<String, Object>> operations = List.of(
                createOperation("add", "/fields/System.Title", "Test Failure: " + testName),
                createOperation("add", "/fields/System.Description", 
                    String.format("Test '%s' failed with error: %s\n\n```\n%s\n```", 
                        testName, errorMessage, stackTrace)),
                createOperation("add", "/fields/Microsoft.VSTS.TCM.ReproSteps", 
                    "This bug was automatically created from a failed automated test."),
                createOperation("add", "/fields/System.Tags", "Automated;Test Failure")
            );
            
            // Send the create request with special content type for JSON patch
            String response = sendJsonPatchRequest(endpoint, operations);
            
            // Parse the response to get the work item ID
            if (response != null && !response.isEmpty()) {
                Map<String, Object> responseMap = CSSmartJsonUtil.jsonToMap(response);
                return responseMap.get("id").toString();
            }
            
            return null;
            
        } catch (Exception e) {
            Reporter.logError("Failed to create bug work item in Azure DevOps: " + e.getMessage());
            return null;
        }
    }
    
    /**
     * Trigger a pipeline in Azure DevOps.
     * 
     * @param pipelineId Pipeline ID
     * @param branch Branch name
     * @param parameters Map of pipeline parameters
     * @return Build ID or null if trigger failed
     */
    public static String triggerPipeline(String pipelineId, String branch, Map<String, Object> parameters) {
        try {
            Reporter.log("Triggering pipeline in Azure DevOps: " + pipelineId);
            
            // Build the request URL
            String endpoint = String.format("/pipelines/%s/runs", pipelineId);
            
            // Build the request payload
            Map<String, Object> requestBody = new HashMap<>();
            
            if (branch != null && !branch.isEmpty()) {
                Map<String, Object> resources = new HashMap<>();
                Map<String, Object> repositories = new HashMap<>();
                Map<String, Object> self = new HashMap<>();
                self.put("refName", "refs/heads/" + branch);
                repositories.put("self", self);
                resources.put("repositories", repositories);
                requestBody.put("resources", resources);
            }
            
            if (parameters != null && !parameters.isEmpty()) {
                requestBody.put("templateParameters", parameters);
            }
            
            // Send the trigger request
            String response = sendRequest("POST", endpoint, requestBody);
            
            // Parse the response to get the build ID
            if (response != null && !response.isEmpty()) {
                Map<String, Object> responseMap = CSSmartJsonUtil.jsonToMap(response);
                return responseMap.get("id").toString();
            }
            
            return null;
            
        } catch (Exception e) {
            Reporter.logError("Failed to trigger pipeline in Azure DevOps: " + e.getMessage());
            return null;
        }
    }
    
    /**
     * Upload test results attachment to Azure DevOps.
     * 
     * @param testRunId Test run ID
     * @param testResultId Test result ID
     * @param attachmentName Attachment name
     * @param attachmentPath Path to attachment file
     * @param attachmentType MIME type of attachment
     * @return true if upload successful, false otherwise
     */
    public static boolean uploadTestResultAttachment(String testRunId, String testResultId, 
                                                    String attachmentName, String attachmentPath, 
                                                    String attachmentType) {
        try {
            Reporter.log("Uploading test result attachment to Azure DevOps: " + attachmentName);
            
            // Build the request URL
            String endpoint = String.format("/test/runs/%s/results/%s/attachments", 
                testRunId, testResultId);
            
            // Read file content (simplified for example)
            java.io.File file = new java.io.File(attachmentPath);
            byte[] fileContent = java.nio.file.Files.readAllBytes(file.toPath());
            String base64Content = Base64.getEncoder().encodeToString(fileContent);
            
            // Build the request payload
            Map<String, Object> requestBody = new HashMap<>();
            requestBody.put("fileName", attachmentName);
            requestBody.put("attachmentType", attachmentType);
            requestBody.put("stream", base64Content);
            
            // Send the upload request
            String response = sendRequest("POST", endpoint, requestBody);
            
            return response != null && !response.isEmpty();
            
        } catch (Exception e) {
            Reporter.logError("Failed to upload test result attachment to Azure DevOps: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Send an HTTP request to Azure DevOps API.
     * 
     * @param method HTTP method (GET, POST, PATCH, etc.)
     * @param endpoint API endpoint (without base URL)
     * @param requestBody Request body as map (will be converted to JSON)
     * @return Response as string or null if request failed
     * @throws IOException If request fails
     */
    private static String sendRequest(String method, String endpoint, 
                                      Map<String, Object> requestBody) throws IOException {
        // Build the full URL
        String apiUrl = ADO_BASE_URL + "/" + ADO_PROJECT + "/_apis" + endpoint;
        if (!apiUrl.contains("?")) {
            apiUrl += "?";
        } else {
            apiUrl += "&";
        }
        apiUrl += "api-version=" + ADO_API_VERSION;
        
        // Create the connection
        URL url = new URL(apiUrl);
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setRequestMethod(method);
        
        // Set headers
        connection.setRequestProperty("Content-Type", "application/json");
        connection.setRequestProperty("Accept", "application/json");
        
        // Set authorization header with PAT
        if (ADO_PAT != null && !ADO_PAT.isEmpty()) {
            String auth = ":" + ADO_PAT;
            String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));
            connection.setRequestProperty("Authorization", "Basic " + encodedAuth);
        }
        
        // Set request body if not GET
        if (!method.equals("GET") && requestBody != null) {
            connection.setDoOutput(true);
            String jsonBody = CSSmartJsonUtil.mapToJson(requestBody);
            
            try (OutputStream os = connection.getOutputStream()) {
                byte[] input = jsonBody.getBytes(StandardCharsets.UTF_8);
                os.write(input, 0, input.length);
            }
        }
        
        // Get response
        int responseCode = connection.getResponseCode();
        
        if (responseCode >= 200 && responseCode < 300) {
            // Success response
            try (BufferedReader br = new BufferedReader(
                    new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8))) {
                StringBuilder response = new StringBuilder();
                String responseLine;
                while ((responseLine = br.readLine()) != null) {
                    response.append(responseLine.trim());
                }
                return response.toString();
            }
        } else {
            // Error response
            try (BufferedReader br = new BufferedReader(
                    new InputStreamReader(connection.getErrorStream(), StandardCharsets.UTF_8))) {
                StringBuilder response = new StringBuilder();
                String responseLine;
                while ((responseLine = br.readLine()) != null) {
                    response.append(responseLine.trim());
                }
                Reporter.logError("Azure DevOps API error: " + response.toString());
            } catch (Exception e) {
                Reporter.logError("Failed to read error response: " + e.getMessage());
            }
            return null;
        }
    }
    
    /**
     * Send a JSON Patch request to Azure DevOps API.
     * 
     * @param endpoint API endpoint (without base URL)
     * @param operations List of JSON patch operations
     * @return Response as string or null if request failed
     * @throws IOException If request fails
     */
    private static String sendJsonPatchRequest(String endpoint, 
                                              List<Map<String, Object>> operations) throws IOException {
        // Build the full URL
        String apiUrl = ADO_BASE_URL + "/" + ADO_PROJECT + "/_apis" + endpoint;
        if (!apiUrl.contains("?")) {
            apiUrl += "?";
        } else {
            apiUrl += "&";
        }
        apiUrl += "api-version=" + ADO_API_VERSION;
        
        // Create the connection
        URL url = new URL(apiUrl);
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setRequestMethod("PATCH");
        
        // Set headers for JSON Patch
        connection.setRequestProperty("Content-Type", "application/json-patch+json");
        connection.setRequestProperty("Accept", "application/json");
        
        // Set authorization header with PAT
        if (ADO_PAT != null && !ADO_PAT.isEmpty()) {
            String auth = ":" + ADO_PAT;
            String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));
            connection.setRequestProperty("Authorization", "Basic " + encodedAuth);
        }
        
        // Set request body
        connection.setDoOutput(true);
        String jsonBody = CSSmartJsonUtil.objectToJson(operations);
        
        try (OutputStream os = connection.getOutputStream()) {
            byte[] input = jsonBody.getBytes(StandardCharsets.UTF_8);
            os.write(input, 0, input.length);
        }
        
        // Get response
        int responseCode = connection.getResponseCode();
        
        if (responseCode >= 200 && responseCode < 300) {
            // Success response
            try (BufferedReader br = new BufferedReader(
                    new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8))) {
                StringBuilder response = new StringBuilder();
                String responseLine;
                while ((responseLine = br.readLine()) != null) {
                    response.append(responseLine.trim());
                }
                return response.toString();
            }
        } else {
            // Error response
            try (BufferedReader br = new BufferedReader(
                    new InputStreamReader(connection.getErrorStream(), StandardCharsets.UTF_8))) {
                StringBuilder response = new StringBuilder();
                String responseLine;
                while ((responseLine = br.readLine()) != null) {
                    response.append(responseLine.trim());
                }
                Reporter.logError("Azure DevOps API error: " + response.toString());
            } catch (Exception e) {
                Reporter.logError("Failed to read error response: " + e.getMessage());
            }
            return null;
        }
    }
    
    /**
     * Create a JSON patch operation.
     * 
     * @param op Operation type (add, replace, remove)
     * @param path Operation path
     * @param value Operation value
     * @return Operation map
     */
    private static Map<String, Object> createOperation(String op, String path, Object value) {
        Map<String, Object> operation = new HashMap<>();
        operation.put("op", op);
        operation.put("path", path);
        operation.put("value", value);
        return operation;
    }
}



package com.cssmart.core.api;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.KeyStore;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import com.cssmart.config.CSSmartConfigHelper;
import com.cssmart.core.reporting.Reporter;
import com.cssmart.core.util.CSSmartJsonUtil;

/**
 * API testing capabilities for CS Smart framework.
 * Uses native Java HTTP library for API requests and provides
 * extensive validation capabilities.
 */
public class CSSmartApiClient {
    
    private final Map<String, String> headers = new HashMap<>();
    private final Map<String, String> cookies = new HashMap<>();
    private String baseUrl;
    private int connectionTimeout = 30000; // 30 seconds
    private int readTimeout = 60000; // 60 seconds
    private boolean followRedirects = true;
    private String lastResponseBody;
    private Map<String, List<String>> lastResponseHeaders;
    private int lastResponseStatus;
    private long lastRequestTime;
    
    // SSL/TLS configuration
    private SSLContext sslContext;
    private String pfxCertPath;
    private String pfxCertPassword;
    
    /**
     * Create a new API client with default configuration.
     */
    public CSSmartApiClient() {
        this(CSSmartConfigHelper.get("api.base.url", ""));
    }
    
    /**
     * Create a new API client with specified base URL.
     * 
     * @param baseUrl Base URL for API requests
     */
    public CSSmartApiClient(String baseUrl) {
        this.baseUrl = baseUrl;
        
        // Add default headers
        headers.put("Accept", "application/json");
        headers.put("Content-Type", "application/json");
        headers.put("User-Agent", "CSSmartApiClient/1.0");
    }
    
    /**
     * Set base URL for API requests.
     * 
     * @param baseUrl Base URL
     * @return This client for chaining
     */
    public CSSmartApiClient setBaseUrl(String baseUrl) {
        this.baseUrl = baseUrl;
        return this;
    }
    
    /**
     * Set connection timeout.
     * 
     * @param timeoutMs Timeout in milliseconds
     * @return This client for chaining
     */
    public CSSmartApiClient setConnectionTimeout(int timeoutMs) {
        this.connectionTimeout = timeoutMs;
        return this;
    }
    
    /**
     * Set read timeout.
     * 
     * @param timeoutMs Timeout in milliseconds
     * @return This client for chaining
     */
    public CSSmartApiClient setReadTimeout(int timeoutMs) {
        this.readTimeout = timeoutMs;
        return this;
    }
    
    /**
     * Set whether to follow redirects.
     * 
     * @param follow Whether to follow redirects
     * @return This client for chaining
     */
    public CSSmartApiClient setFollowRedirects(boolean follow) {
        this.followRedirects = follow;
        return this;
    }
    
    /**
     * Set a request header.
     * 
     * @param name Header name
     * @param value Header value
     * @return This client for chaining
     */
    public CSSmartApiClient setHeader(String name, String value) {
        headers.put(name, value);
        return this;
    }
    
    /**
     * Set multiple request headers.
     * 
     * @param headers Map of headers
     * @return This client for chaining
     */
    public CSSmartApiClient setHeaders(Map<String, String> headers) {
        this.headers.putAll(headers);
        return this;
    }
    
    /**
     * Set a cookie.
     * 
     * @param name Cookie name
     * @param value Cookie value
     * @return This client for chaining
     */
    public CSSmartApiClient setCookie(String name, String value) {
        cookies.put(name, value);
        return this;
    }
    
    /**
     * Set basic authentication.
     * 
     * @param username Username
     * @param password Password
     * @return This client for chaining
     */
    public CSSmartApiClient setBasicAuth(String username, String password) {
        String auth = username + ":" + password;
        String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));
        headers.put("Authorization", "Basic " + encodedAuth);
        return this;
    }
    
    /**
     * Set bearer token authentication.
     * 
     * @param token Bearer token
     * @return This client for chaining
     */
    public CSSmartApiClient setBearerToken(String token) {
        headers.put("Authorization", "Bearer " + token);
        return this;
    }
    
    /**
     * Set PFX certificate for client authentication.
     * 
     * @param pfxPath Path to PFX certificate file
     * @param password Certificate password
     * @return This client for chaining
     */
    public CSSmartApiClient setCertificate(String pfxPath, String password) {
        this.pfxCertPath = pfxPath;
        this.pfxCertPassword = password;
        
        try {
            // Load the PFX certificate
            File pfxFile = new File(pfxPath);
            if (!pfxFile.exists()) {
                Reporter.logError("PFX certificate file not found: " + pfxPath);
                return this;
            }
            
            KeyStore keyStore = KeyStore.getInstance("PKCS12");
            keyStore.load(Files.newInputStream(pfxFile.toPath()), password.toCharArray());
            
            // Set up key manager factory
            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
            keyManagerFactory.init(keyStore, password.toCharArray());
            
            // Set up trust manager that trusts all certificates
            TrustManager[] trustAllCerts = new TrustManager[] {
                new X509TrustManager() {
                    public X509Certificate[] getAcceptedIssuers() { return null; }
                    public void checkClientTrusted(X509Certificate[] certs, String authType) throws CertificateException { }
                    public void checkServerTrusted(X509Certificate[] certs, String authType) throws CertificateException { }
                }
            };
            
            // Set up SSL context
            sslContext = SSLContext.getInstance("TLS");
            sslContext.init(keyManagerFactory.getKeyManagers(), trustAllCerts, new java.security.SecureRandom());
            
            Reporter.log("PFX certificate loaded successfully: " + pfxPath);
            
        } catch (Exception e) {
            Reporter.logError("Failed to load PFX certificate: " + e.getMessage());
        }
        
        return this;
    }
    
    /**
     * Perform a GET request.
     * 
     * @param endpoint API endpoint
     * @return API response
     */
    public CSSmartApiResponse get(String endpoint) {
        return request("GET", endpoint, null);
    }
    
    /**
     * Perform a GET request with query parameters.
     * 
     * @param endpoint API endpoint
     * @param queryParams Query parameters
     * @return API response
     */
    public CSSmartApiResponse get(String endpoint, Map<String, String> queryParams) {
        String url = buildUrlWithQueryParams(endpoint, queryParams);
        return request("GET", url, null);
    }
    
    /**
     * Perform a POST request.
     * 
     * @param endpoint API endpoint
     * @param body Request body
     * @return API response
     */
    public CSSmartApiResponse post(String endpoint, String body) {
        return request("POST", endpoint, body);
    }
    
    /**
     * Perform a POST request with JSON body.
     * 
     * @param endpoint API endpoint
     * @param bodyObj Request body object (will be converted to JSON)
     * @return API response
     */
    public CSSmartApiResponse post(String endpoint, Object bodyObj) {
        String body = CSSmartJsonUtil.objectToJson(bodyObj);
        return post(endpoint, body);
    }
    
    /**
     * Perform a PUT request.
     * 
     * @param endpoint API endpoint
     * @param body Request body
     * @return API response
     */
    public CSSmartApiResponse put(String endpoint, String body) {
        return request("PUT", endpoint, body);
    }
    
    /**
     * Perform a PUT request with JSON body.
     * 
     * @param endpoint API endpoint
     * @param bodyObj Request body object (will be converted to JSON)
     * @return API response
     */
    public CSSmartApiResponse put(String endpoint, Object bodyObj) {
        String body = CSSmartJsonUtil.objectToJson(bodyObj);
        return put(endpoint, body);
    }
    
    /**
     * Perform a PATCH request.
     * 
     * @param endpoint API endpoint
     * @param body Request body
     * @return API response
     */
    public CSSmartApiResponse patch(String endpoint, String body) {
        return request("PATCH", endpoint, body);
    }
    
    /**
     * Perform a PATCH request with JSON body.
     * 
     * @param endpoint API endpoint
     * @param bodyObj Request body object (will be converted to JSON)
     * @return API response
     */
    public CSSmartApiResponse patch(String endpoint, Object bodyObj) {
        String body = CSSmartJsonUtil.objectToJson(bodyObj);
        return patch(endpoint, body);
    }
    
    /**
     * Perform a DELETE request.
     * 
     * @param endpoint API endpoint
     * @return API response
     */
    public CSSmartApiResponse delete(String endpoint) {
        return request("DELETE", endpoint, null);
    }
    
    /**
     * Perform a DELETE request with body.
     * 
     * @param endpoint API endpoint
     * @param body Request body
     * @return API response
     */
    public CSSmartApiResponse delete(String endpoint, String body) {
        return request("DELETE", endpoint, body);
    }
    
    /**
     * Perform an API request.
     * 
     * @param method HTTP method
     * @param endpoint API endpoint
     * @param body Request body
     * @return API response
     */
    public CSSmartApiResponse request(String method, String endpoint, String body) {
        HttpURLConnection connection = null;
        long startTime = System.currentTimeMillis();
        
        try {
            // Build the full URL
            String url = endpoint.startsWith("http") ? endpoint : baseUrl + endpoint;
            
            Reporter.log("Sending " + method + " request to: " + url);
            
            // Create the connection
            connection = createConnection(url, method);
            
            // Set headers
            for (Map.Entry<String, String> header : headers.entrySet()) {
                connection.setRequestProperty(header.getKey(), header.getValue());
            }
            
            // Set cookies
            if (!cookies.isEmpty()) {
                StringBuilder cookieHeader = new StringBuilder();
                for (Map.Entry<String, String> cookie : cookies.entrySet()) {
                    if (cookieHeader.length() > 0) {
                        cookieHeader.append("; ");
                    }
                    cookieHeader.append(cookie.getKey()).append("=").append(cookie.getValue());
                }
                connection.setRequestProperty("Cookie", cookieHeader.toString());
            }
            
            // Set request body if not GET or DELETE
            if (body != null && !method.equals("GET")) {
                connection.setDoOutput(true);
                try (OutputStream os = connection.getOutputStream()) {
                    byte[] input = body.getBytes(StandardCharsets.UTF_8);
                    os.write(input, 0, input.length);
                }
                
                Reporter.log("Request body: " + body);
            }
            
            // Get response
            int responseCode = connection.getResponseCode();
            lastResponseStatus = responseCode;
            lastResponseHeaders = connection.getHeaderFields();
            
            // Read response body
            try (BufferedReader br = new BufferedReader(
                    new InputStreamReader(
                        responseCode >= 400 
                            ? connection.getErrorStream() 
                            : connection.getInputStream(), 
                        StandardCharsets.UTF_8))) {
                
                lastResponseBody = br.lines().collect(Collectors.joining(System.lineSeparator()));
            }
            
            // Record request time
            lastRequestTime = System.currentTimeMillis() - startTime;
            
            Reporter.log("Response status: " + responseCode);
            Reporter.log("Response time: " + lastRequestTime + " ms");
            
            // Create response object
            return new CSSmartApiResponse(
                lastResponseStatus,
                lastResponseBody,
                lastResponseHeaders,
                lastRequestTime
            );
            
        } catch (Exception e) {
            Reporter.logError("API request failed: " + e.getMessage());
            return new CSSmartApiResponse(
                -1,
                "Request failed: " + e.getMessage(),
                null,
                System.currentTimeMillis() - startTime
            );
        } finally {
            if (connection != null) {
                connection.disconnect();
            }
        }
    }
    
    /**
     * Create an HTTP connection.
     * 
     * @param url URL to connect to
     * @param method HTTP method
     * @return HTTP connection
     * @throws IOException If connection creation fails
     */
    private HttpURLConnection createConnection(String url, String method) throws IOException {
        HttpURLConnection connection;
        
        if (url.startsWith("https") && sslContext != null) {
            // HTTPS with custom SSL context
            HttpsURLConnection httpsConnection = (HttpsURLConnection) new URL(url).openConnection();
            httpsConnection.setSSLSocketFactory(sslContext.getSocketFactory());
            connection = httpsConnection;
        } else {
            // Standard HTTP or HTTPS
            connection = (HttpURLConnection) new URL(url).openConnection();
        }
        
        connection.setRequestMethod(method);
        connection.setConnectTimeout(connectionTimeout);
        connection.setReadTimeout(readTimeout);
        connection.setInstanceFollowRedirects(followRedirects);
        
        return connection;
    }
    
    /**
     * Build URL with query parameters.
     * 
     * @param endpoint API endpoint
     * @param queryParams Query parameters
     * @return URL with query parameters
     */
    private String buildUrlWithQueryParams(String endpoint, Map<String, String> queryParams) {
        if (queryParams == null || queryParams.isEmpty()) {
            return endpoint;
        }
        
        StringBuilder urlBuilder = new StringBuilder(endpoint);
        
        if (!endpoint.contains("?")) {
            urlBuilder.append("?");
        } else if (!endpoint.endsWith("&") && !endpoint.endsWith("?")) {
            urlBuilder.append("&");
        }
        
        boolean first = true;
        for (Map.Entry<String, String> param : queryParams.entrySet()) {
            if (!first) {
                urlBuilder.append("&");
            }
            urlBuilder.append(param.getKey()).append("=").append(param.getValue());
            first = false;
        }
        
        return urlBuilder.toString();
    }
    
    /**
     * Load a request body from a file.
     * 
     * @param filePath Path to the file
     * @return File content as string
     */
    public static String loadBodyFromFile(String filePath) {
        try {
            return new String(Files.readAllBytes(Paths.get(filePath)), StandardCharsets.UTF_8);
        } catch (IOException e) {
            Reporter.logError("Failed to load body from file: " + e.getMessage());
            return "";
        }
    }
    
    /**
     * Replace variables in a template body.
     * Variables are in the format ${variable_name}.
     * 
     * @param template Template body
     * @param variables Map of variable names to values
     * @return Processed body
     */
    public static String processTemplate(String template, Map<String, String> variables) {
        if (template == null || variables == null || variables.isEmpty()) {
            return template;
        }
        
        String result = template;
        Pattern pattern = Pattern.compile("\\$\\{([^}]+)\\}");
        Matcher matcher = pattern.matcher(template);
        
        while (matcher.find()) {
            String variable = matcher.group(1);
            String value = variables.getOrDefault(variable, "");
            result = result.replace("${" + variable + "}", value);
        }
        
        return result;
    }
}


package com.cssmart.api.validation;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import com.cssmart.api.response.CSSmartAPIResponse;
import com.cssmart.api.utils.CSSmartJSONUtils;
import com.cssmart.database.CSSmartDatabaseManager;
import com.cssmart.utils.CSSmartDataLoader;
import com.cssmart.utils.CSSmartLogger;

/**
 * A versatile API response validator that can validate API responses against
 * different sources including JSON files, database outputs, or predefined expectations
 */
public class CSSmartAPIResponseValidator {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartAPIResponseValidator.class);
    
    /**
     * Validates API response against an expected JSON file
     * 
     * @param response The API response to validate
     * @param jsonFilePath Path to the expected JSON file
     * @param ignoreFields Fields to ignore during comparison (optional)
     * @return Validation result with details about any differences
     */
    public static ValidationResult validateAgainstJsonFile(CSSmartAPIResponse response, String jsonFilePath, String... ignoreFields) {
        try {
            String expectedJson = new String(Files.readAllBytes(Paths.get(jsonFilePath)));
            return validateJsonContent(response.getResponseBody(), expectedJson, ignoreFields);
        } catch (IOException e) {
            logger.error("Failed to read expected JSON file: " + jsonFilePath, e);
            return new ValidationResult(false, "Failed to read expected JSON file: " + e.getMessage());
        }
    }
    
    /**
     * Validates API response against database query results
     * 
     * @param response The API response to validate
     * @param dbQuery SQL query to execute for expected data
     * @param mappingRules Rules to map database columns to JSON fields
     * @param ignoreFields Fields to ignore during comparison (optional)
     * @return Validation result with details about any differences
     */
    public static ValidationResult validateAgainstDatabase(CSSmartAPIResponse response, 
                                                           String dbQuery, 
                                                           Map<String, String> mappingRules,
                                                           String... ignoreFields) {
        try {
            Connection conn = CSSmartDatabaseManager.getConnection();
            ResultSet rs = conn.createStatement().executeQuery(dbQuery);
            
            JSONArray expectedArray = new JSONArray();
            while (rs.next()) {
                JSONObject row = new JSONObject();
                for (Map.Entry<String, String> mapping : mappingRules.entrySet()) {
                    String dbColumn = mapping.getKey();
                    String jsonField = mapping.getValue();
                    row.put(jsonField, rs.getObject(dbColumn));
                }
                expectedArray.put(row);
            }
            
            return validateJsonContent(response.getResponseBody(), 
                                      expectedArray.length() == 1 ? expectedArray.get(0).toString() : expectedArray.toString(), 
                                      ignoreFields);
        } catch (SQLException e) {
            logger.error("Database validation failed", e);
            return new ValidationResult(false, "Database validation failed: " + e.getMessage());
        }
    }
    
    /**
     * Validates API response against expected values from a data source (CSV, Excel, etc.)
     * 
     * @param response The API response to validate
     * @param dataSourcePath Path to the data source file
     * @param dataSourceType Type of data source (CSV, EXCEL, etc.)
     * @param sheetName Sheet name for Excel files (optional)
     * @param rowIndex Row index for the expected data (default is 0)
     * @param ignoreFields Fields to ignore during comparison (optional)
     * @return Validation result with details about any differences
     */
    public static ValidationResult validateAgainstDataSource(CSSmartAPIResponse response,
                                                            String dataSourcePath,
                                                            CSSmartDataLoader.DataSourceType dataSourceType,
                                                            String sheetName,
                                                            int rowIndex,
                                                            String... ignoreFields) {
        try {
            Map<String, Object> expectedData = CSSmartDataLoader.loadData(dataSourcePath, dataSourceType, sheetName, rowIndex);
            JSONObject expectedJson = new JSONObject(expectedData);
            
            return validateJsonContent(response.getResponseBody(), expectedJson.toString(), ignoreFields);
        } catch (Exception e) {
            logger.error("Data source validation failed", e);
            return new ValidationResult(false, "Data source validation failed: " + e.getMessage());
        }
    }
    
    /**
     * Validates JSON schema of API response
     * 
     * @param response The API response to validate
     * @param schemaPath Path to the JSON schema file
     * @return Validation result with details about any schema violations
     */
    public static ValidationResult validateJsonSchema(CSSmartAPIResponse response, String schemaPath) {
        try {
            // Using the CSSmartJSONUtils to validate the schema
            boolean isValid = CSSmartJSONUtils.validateSchema(response.getResponseBody(), schemaPath);
            
            if (isValid) {
                return new ValidationResult(true, "Schema validation passed");
            } else {
                return new ValidationResult(false, "Schema validation failed");
            }
        } catch (Exception e) {
            logger.error("Schema validation failed", e);
            return new ValidationResult(false, "Schema validation failed: " + e.getMessage());
        }
    }
    
    /**
     * Validates specific fields in the API response
     * 
     * @param response The API response to validate
     * @param fieldValidations Map of field paths to expected values
     * @return Validation result with details about any field validation failures
     */
    public static ValidationResult validateFields(CSSmartAPIResponse response, Map<String, Object> fieldValidations) {
        try {
            JSONObject responseJson = new JSONObject(response.getResponseBody());
            ValidationResult result = new ValidationResult(true, "Field validations passed");
            
            for (Map.Entry<String, Object> validation : fieldValidations.entrySet()) {
                String fieldPath = validation.getKey();
                Object expectedValue = validation.getValue();
                
                try {
                    Object actualValue = extractValueByPath(responseJson, fieldPath);
                    
                    if (actualValue == null && expectedValue == null) {
                        continue;
                    }
                    
                    if ((actualValue == null && expectedValue != null) || 
                        (actualValue != null && !actualValue.toString().equals(expectedValue.toString()))) {
                        result.setValid(false);
                        result.addDetail("Field '" + fieldPath + "' validation failed. Expected: " + 
                                        expectedValue + ", Actual: " + actualValue);
                    }
                } catch (Exception e) {
                    result.setValid(false);
                    result.addDetail("Field '" + fieldPath + "' validation failed: " + e.getMessage());
                }
            }
            
            return result;
        } catch (JSONException e) {
            logger.error("Field validation failed", e);
            return new ValidationResult(false, "Field validation failed: " + e.getMessage());
        }
    }
    
    /**
     * Core method to validate JSON content against expected JSON
     */
    private static ValidationResult validateJsonContent(String actualJson, String expectedJson, String... ignoreFields) {
        try {
            Map<String, Object> differences = CSSmartJSONUtils.compareJson(actualJson, expectedJson, ignoreFields);
            
            ValidationResult result = new ValidationResult(differences.isEmpty(), 
                                                          differences.isEmpty() ? "Validation passed" : "Validation failed");
            
            for (Map.Entry<String, Object> diff : differences.entrySet()) {
                result.addDetail(diff.getKey() + ": " + diff.getValue());
            }
            
            return result;
        } catch (Exception e) {
            logger.error("JSON content validation failed", e);
            return new ValidationResult(false, "JSON content validation failed: " + e.getMessage());
        }
    }
    
    /**
     * Extracts a value from a JSON object using a dot-notation path
     */
    private static Object extractValueByPath(JSONObject json, String path) {
        String[] parts = path.split("\\.");
        Object current = json;
        
        for (String part : parts) {
            if (current instanceof JSONObject) {
                JSONObject jsonObj = (JSONObject) current;
                if (jsonObj.has(part)) {
                    current = jsonObj.get(part);
                } else {
                    return null;
                }
            } else if (current instanceof JSONArray) {
                try {
                    int index = Integer.parseInt(part);
                    JSONArray array = (JSONArray) current;
                    if (index >= 0 && index < array.length()) {
                        current = array.get(index);
                    } else {
                        return null;
                    }
                } catch (NumberFormatException e) {
                    return null;
                }
            } else {
                return null;
            }
        }
        
        return current;
    }
    
    /**
     * Class to hold validation results with details
     */
    public static class ValidationResult {
        private boolean isValid;
        private String message;
        private final List<String> details = new java.util.ArrayList<>();
        
        public ValidationResult(boolean isValid, String message) {
            this.isValid = isValid;
            this.message = message;
        }
        
        public boolean isValid() {
            return isValid;
        }
        
        public void setValid(boolean valid) {
            isValid = valid;
        }
        
        public String getMessage() {
            return message;
        }
        
        public void setMessage(String message) {
            this.message = message;
        }
        
        public List<String> getDetails() {
            return details;
        }
        
        public void addDetail(String detail) {
            details.add(detail);
        }
        
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("Validation ").append(isValid ? "PASSED" : "FAILED").append(": ").append(message).append("\n");
            
            if (!details.isEmpty()) {
                sb.append("Details:\n");
                for (String detail : details) {
                    sb.append("- ").append(detail).append("\n");
                }
            }
            
            return sb.toString();
        }
    }
}

