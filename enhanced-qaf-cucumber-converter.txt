import * as fs from 'fs';
import * as path from 'path';

const DEBUG = true; // Set to true to see debugging information

interface ImportMapping {
    [key: string]: string | null; // null means skip this import
}

// Map of Java imports to TypeScript/Playwright equivalents
const importMappings: ImportMapping = {
    // Standard Java imports
    'java.util.List': 'import { Locator } from \'@playwright/test\';',
    'java.util.Map': null,
    'java.util.HashMap': null,
    'java.util.ArrayList': null,
    'java.lang.String': null,
    'java.lang.Thread': null,
    // Selenium imports
    'org.openqa.selenium.WebElement': 'import { Locator } from \'@playwright/test\';',
    'org.openqa.selenium.support.FindBy': null,
    'org.openqa.selenium.support.ui.WebDriverWait': null,
    'org.openqa.selenium.By': null,
    'org.openqa.selenium.Keys': null,
    // QAF imports
    'com.qmetry.qaf.automation.ui.WebDriverTestBase': 'import { Page } from \'@playwright/test\';',
    'com.qmetry.qaf.automation.ui.webdriver.QAFWebElement': 'import { Locator } from \'@playwright/test\';',
    'com.qmetry.qaf.automation.ui.annotations.FindBy': null,
    'com.qmetry.qaf.automation.core.ConfigurationManager': null,
    'com.qmetry.qaf.automation.step.QAFTestStep': 'import { Then, When, Given } from \'@cucumber/cucumber\';',
    'com.qmetry.qaf.automation.step.QAFTestStepProvider': 'import { Then, When, Given } from \'@cucumber/cucumber\';',
    'com.qmetry.qaf.automation.testng.pro.QAFProStep': 'import { Then, When, Given } from \'@cucumber/cucumber\';',
    // TestNG imports
    'org.testng.Assert': 'import { expect } from \'@playwright/test\';',
    'org.testng.annotations.Test': 'import { test } from \'@playwright/test\';',
    // Logging
    'org.testng.Reporter': 'import { console } from \'@playwright/test\';',
    // Custom imports
    'com.example.exe.utils.CSWebElement': 'import { Locator } from \'@playwright/test\';',
};

// Classes that should be converted to Playwright Locator
const elementClasses = [
    'CSWebElement',
    'QAFWebElement',
    'WebElement',
    'Element',
    'PageElement'
];

// QAF BDD Step annotations to be converted to Cucumber
const bddStepAnnotations = [
    '@QAFTestStep',
    '@Step',
    '@Given',
    '@When',
    '@Then',
    '@And',
    '@But'
];

// Determines if a file is likely to be a BDD step definition file
function isBDDStepFile(fileContent: string): boolean {
    return bddStepAnnotations.some(annotation => fileContent.includes(annotation));
}

function convertQafToPlaywright(inputFilePath: string, outputFilePath: string): void {
    try {
        // Read the input file
        const fileContent = fs.readFileSync(inputFilePath, 'utf8');
        
        // Create debug file with line numbers
        if (DEBUG) {
            const debugLines = fileContent.split('\n').map((line, index) => `${index + 1}: ${line}`);
            fs.writeFileSync(outputFilePath + '.debug.txt', debugLines.join('\n'), 'utf8');
            console.log(`Created debug file: ${outputFilePath}.debug.txt`);
        }
        
        const lines = fileContent.split('\n');

        // Detect if file is a BDD step definition file
        const isBDD = isBDDStepFile(fileContent);
        
        // Process the file content based on the file type
        const { tsContent, skippedLines } = isBDD 
            ? processBDDStepContentCucumber(lines)
            : processPageObjectContent(lines);

        // Create the output directory if it doesn't exist
        const outputDir = path.dirname(outputFilePath);
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        // Write the output file
        fs.writeFileSync(outputFilePath, tsContent, 'utf8');
        console.log(`Converted ${inputFilePath} to ${outputFilePath} (${isBDD ? 'Cucumber Steps' : 'Page Object'})`);
        
        // Create a log of skipped lines for debugging
        if (DEBUG) {
            fs.writeFileSync(outputFilePath + '.skipped.txt', skippedLines.join('\n'), 'utf8');
            console.log(`Created skipped lines log: ${outputFilePath}.skipped.txt`);
        }
    } catch (error) {
        console.error(`Error converting ${inputFilePath}: ${error}`);
    }
}

// Process a page object class
function processPageObjectContent(lines: string[]): { tsContent: string, skippedLines: string[] } {
    const tsLines: string[] = [];
    const skippedLines: string[] = [];
    let className = '';
    let inMethod = false;
    let braceCount = 0; // Track open braces to ensure proper closing
    let hasAddedPageField = false;
    let foundImports = new Set<string>();
    let pageObjectRefs = new Set<string>(); // Track page object references

    // Add base TypeScript imports
    foundImports.add('import { Page, Locator, expect } from \'@playwright/test\';');

    // For debugging output
    const debugLine = (index: number, line: string, reason: string) => {
        if (DEBUG) {
            skippedLines.push(`Line ${index + 1}: ${line} - ${reason}`);
        }
    };

    // Analyze the code to find page object references
    analyzePageObjectReferences(lines, pageObjectRefs);

    for (let i = 0; i < lines.length; i++) {
        const originalLine = lines[i];
        const line = originalLine.trim();

        // Skip empty lines
        if (line === '') continue;

        // Skip package declarations
        if (line.startsWith('package ')) {
            debugLine(i, line, "Skipped package declaration");
            continue;
        }

        // Handle imports - convert Java imports to TypeScript equivalents
        if (line.startsWith('import ')) {
            const importPath = line.substring(7, line.endsWith(';') ? line.length - 1 : line.length).trim();
            
            // Check for direct matches first
            if (importMappings[importPath] !== undefined) {
                if (importMappings[importPath] !== null && !foundImports.has(importMappings[importPath]!)) {
                    foundImports.add(importMappings[importPath]!);
                }
                debugLine(i, line, `Mapped import to: ${importMappings[importPath]}`);
                continue;
            }
            
            // If no match, try to determine if it's a page object import
            if (importPath.includes('.pages.') || importPath.includes('.pageobjects.')) {
                const className = importPath.split('.').pop();
                if (className) {
                    foundImports.add(`import { ${className} } from './${className}';`);
                    debugLine(i, line, `Added page object import for ${className}`);
                    continue;
                }
            }
            
            // If no match, skip the import but log it
            debugLine(i, line, "No mapping found for import");
            continue;
        }

        // Extract class name
        const classMatch = line.match(/public\s+class\s+(\w+)/);
        if (classMatch) {
            className = classMatch[1];
            tsLines.push(`export class ${className} {`);
            braceCount++;
            
            // Add page field if not added already
            if (!hasAddedPageField) {
                tsLines.push('  private page: Page;');
                
                // Add fields for page objects that were found during analysis
                pageObjectRefs.forEach(ref => {
                    tsLines.push(`  private ${ref.toLowerCase()}: ${ref};`);
                });
                
                tsLines.push('');
                tsLines.push('  constructor(page: Page) {');
                braceCount++;
                tsLines.push('    this.page = page;');
                
                // Initialize page objects
                pageObjectRefs.forEach(ref => {
                    tsLines.push(`    this.${ref.toLowerCase()} = new ${ref}(page);`);
                });
                
                tsLines.push('  }');
                braceCount--; // Close constructor
                tsLines.push('');
                hasAddedPageField = true;
            }
            continue;
        }

        // Handle instance variable declarations for page objects
        const pageObjDeclPattern = /(private|protected|public)\s+(\w+)\s+(\w+)\s*;/;
        const pageObjMatch = line.match(pageObjDeclPattern);
        if (pageObjMatch && pageObjectRefs.has(pageObjMatch[2])) {
            // Skip because we already added these in the constructor
            debugLine(i, line, "Skipped page object declaration, already added in constructor");
            continue;
        }

        // Try multiple FindBy patterns to be more flexible
        const findByPatterns = [
            /@FindBy\(locator="([^"]+)"\)\s*public\s+(\w+)\s+(\w+)\s*;/,
            /@FindBy\s*\(\s*locator\s*=\s*"([^"]+)"\s*\)\s*public\s+(\w+)\s+(\w+)\s*;/,
            /@FindBy\s*\(\s*locator\s*=\s*"([^"]+)"\s*\)\s*private\s+(\w+)\s+(\w+)\s*;/,
            /@FindBy\s*\(\s*locator\s*=\s*"([^"]+)"\s*\)\s*protected\s+(\w+)\s+(\w+)\s*;/
        ];
        
        let findByMatch = null;
        for (const pattern of findByPatterns) {
            const match = line.match(pattern);
            if (match) {
                findByMatch = match;
                break;
            }
        }
        
        if (findByMatch) {
            const locator = findByMatch[1];
            const elementType = findByMatch[2];
            const elementName = findByMatch[3];
            
            // Generate getter method for this element
            tsLines.push(`  async ${elementName}() {`);
            braceCount++;
            
            // Handle different locator types
            processLocator(tsLines, locator);
            
            tsLines.push('  }');
            braceCount--;
            tsLines.push('');
            continue;
        }
        
        // Check for multi-line FindBy
        if (line.includes('@FindBy') && !line.includes(';')) {
            let combinedLine = line;
            let j = i + 1;
            let foundEnd = false;
            
            // Collect the entire FindBy statement across multiple lines
            while (j < lines.length && !lines[j].trim().includes(';')) {
                combinedLine += ' ' + lines[j].trim();
                j++;
            }
            
            if (j < lines.length) {
                combinedLine += ' ' + lines[j].trim();
                
                // Try to match the combined line with our patterns
                for (const pattern of findByPatterns) {
                    const match = combinedLine.match(pattern);
                    if (match) {
                        const locator = match[1];
                        const elementType = match[2];
                        const elementName = match[3];
                        
                        tsLines.push(`  async ${elementName}() {`);
                        braceCount++;
                        processLocator(tsLines, locator);
                        tsLines.push('  }');
                        braceCount--;
                        tsLines.push('');
                        
                        i = j; // Skip processed lines
                        foundEnd = true;
                        break;
                    }
                }
            }
            
            if (foundEnd) continue;
            
            // If we couldn't match the multi-line FindBy, log it as skipped
            debugLine(i, line, "Skipped unmatched multi-line FindBy annotation");
            continue;
        }

        // Handle CSWebElement or similar element return methods
        // This matches patterns like: public CSWebElement methodName(String someArgs) { return new CSWebElement(...); }
        const elementReturnMethodPattern = new RegExp(`public\\s+(${elementClasses.join('|')})\\s+(\\w+)\\s*\\((.*?)\\)\\s*\\{`);
        const elementReturnMatch = line.match(elementReturnMethodPattern);
        
        if (elementReturnMatch) {
            const returnType = elementReturnMatch[1];
            const methodName = elementReturnMatch[2];
            let params = elementReturnMatch[3].trim();
            
            // Convert Java parameter types to TypeScript
            params = convertJavaParamsToTypeScript(params);
            
            tsLines.push(`  async ${methodName}(${params}) {`);
            braceCount++;
            
            // Now we need to find the return statement with the locator information
            let foundReturn = false;
            let k = i + 1;
            let methodBody = '';
            
            // Collect the entire method body to analyze
            while (k < lines.length) {
                const currentLine = lines[k].trim();
                methodBody += ' ' + currentLine;
                
                if (currentLine === '}') {
                    break;
                }
                k++;
            }
            
            // Look for return new CSWebElement pattern in the method body
            const returnPattern = /return\s+new\s+\w+\s*\(\s*"(.+?)"\s*\)/;
            const returnMatch = methodBody.match(returnPattern);
            
            if (returnMatch) {
                try {
                    const locatorStr = returnMatch[1];
                    
                    // Check if it's a JSON-like structure
                    if (locatorStr.includes('{') && locatorStr.includes('}')) {
                        // Try to extract the locator from JSON-like string
                        const locatorExtract = locatorStr.match(/"locator"\s*:\s*"([^"]+)"/);
                        if (locatorExtract) {
                            const locatorValue = locatorExtract[1];
                            
                            // Check if the locator includes parameter substitution
                            const paramNames = params.split(',').map(p => p.trim().split(' ').pop()?.trim());
                            const paramReferences = paramNames.filter(p => p && methodBody.includes(p));
                            
                            if (paramReferences.length > 0) {
                                // This locator likely uses parameters for dynamic parts
                                tsLines.push(`    // Original complex locator with parameter substitution: ${locatorValue}`);
                                
                                // Try to create a template literal with parameter substitution
                                let dynamicLocator = locatorValue;
                                paramReferences.forEach(param => {
                                    if (param) {
                                        dynamicLocator = dynamicLocator.replace(new RegExp(`'\\s*\\+\\s*${param}\\s*\\+\\s*'`, 'g'), '${' + param + '}');
                                    }
                                });
                                
                                if (locatorValue.startsWith('xpath=')) {
                                    tsLines.push(`    return this.page.locator(\`xpath=${dynamicLocator.substring(6)}\`);`);
                                } else {
                                    tsLines.push(`    return this.page.locator(\`${dynamicLocator}\`);`);
                                }
                            } else {
                                // Static locator
                                if (locatorValue.startsWith('xpath=')) {
                                    tsLines.push(`    return this.page.locator(\`xpath=${locatorValue.substring(6)}\`);`);
                                } else {
                                    tsLines.push(`    return this.page.locator(\`${locatorValue}\`);`);
                                }
                            }
                            foundReturn = true;
                        }
                    } else {
                        // It's a simple locator string
                        if (locatorStr.startsWith('xpath=')) {
                            tsLines.push(`    return this.page.locator(\`xpath=${locatorStr.substring(6)}\`);`);
                        } else {
                            tsLines.push(`    return this.page.locator(\`${locatorStr}\`);`);
                        }
                        foundReturn = true;
                    }
                } catch (e) {
                    // If we can't parse it, use a generic approach
                    tsLines.push(`    // TODO: Couldn't parse locator string: ${returnMatch[1]}`);
                    tsLines.push(`    return this.page.locator('xpath=//TODO');`);
                    foundReturn = true;
                }
            }
            
            if (!foundReturn) {
                // Look for other types of element returns
                const otherReturnPattern = /return\s+(\w+)/;
                const otherMatch = methodBody.match(otherReturnPattern);
                
                if (otherMatch && otherMatch[1] !== 'null' && otherMatch[1] !== 'this') {
                    const elementName = otherMatch[1];
                    tsLines.push(`    // Original returned an existing element: ${elementName}`);
                    tsLines.push(`    return await this.${elementName}();`);
                    foundReturn = true;
                }
            }
            
            if (!foundReturn) {
                // Generic fallback
                tsLines.push(`    // TODO: Couldn't determine how to convert this element method`);
                tsLines.push(`    return this.page.locator('xpath=//TODO');`);
            }
            
            i = k; // Skip to the end of the method
            tsLines.push('  }');
            braceCount--;
            tsLines.push('');
            continue;
        }

        // Try to match regular method patterns with more flexibility
        const methodPatterns = [
            /public\s+void\s+(\w+)\s*\(\s*\)\s*\{/,
            /public\s+void\s+(\w+)\s*\(\s*\)\s*throws\s+.*?\{/,
            /private\s+void\s+(\w+)\s*\(\s*\)\s*\{/,
            /protected\s+void\s+(\w+)\s*\(\s*\)\s*\{/,
            /public\s+(\w+)\s+(\w+)\s*\(\s*\)\s*\{/
        ];
        
        let methodMatch = null;
        for (const pattern of methodPatterns) {
            const match = line.match(pattern);
            if (match) {
                methodMatch = match;
                break;
            }
        }
        
        if (methodMatch) {
            const methodName = methodMatch[1];
            tsLines.push(`  async ${methodName}() {`);
            braceCount++;
            inMethod = true;
            continue;
        }

        // Handle method with parameters
        const methodWithParamsPatterns = [
            /public\s+void\s+(\w+)\s*\((.*?)\)\s*\{/,
            /public\s+void\s+(\w+)\s*\((.*?)\)\s*throws\s+.*?\{/,
            /private\s+void\s+(\w+)\s*\((.*?)\)\s*\{/,
            /protected\s+void\s+(\w+)\s*\((.*?)\)\s*\{/,
            /public\s+(\w+)\s+(\w+)\s*\((.*?)\)\s*\{/
        ];
        
        let methodWithParamsMatch = null;
        for (const pattern of methodWithParamsPatterns) {
            const match = line.match(pattern);
            if (match && !methodMatch) {
                methodWithParamsMatch = match;
                break;
            }
        }
        
        if (methodWithParamsMatch) {
            let methodName;
            let params;
            
            if (methodWithParamsMatch[2] && methodWithParamsMatch.length > 3 && typeof methodWithParamsMatch[3] === 'string') {
                // This is the fifth pattern with return type
                methodName = methodWithParamsMatch[2];
                params = methodWithParamsMatch[3]?.trim() || '';
            } else {
                // This is the first through fourth pattern
                methodName = methodWithParamsMatch[1];
                params = methodWithParamsMatch[2]?.trim() || '';
            }
            
            // Convert Java parameter types to TypeScript
            params = convertJavaParamsToTypeScript(params);
            
            tsLines.push(`  async ${methodName}(${params}) {`);
            braceCount++;
            inMethod = true;
            continue;
        }

        // Handle method end and track brace count
        if (line === '}') {
            if (inMethod) {
                tsLines.push('  }');
                inMethod = false;
                braceCount--;
                tsLines.push('');
            } else if (braceCount > 0) {
                tsLines.push('}');
                braceCount--;
            } else {
                // Skip extra closing braces
                debugLine(i, line, "Skipped extra closing brace");
            }
            continue;
        }

        // Handle element actions inside methods
        if (inMethod) {
            // Check for Reporter.log statements
            const reporterLogPattern = /Reporter\.log\(([^,)]+)(?:,\s*\w+)?\);/;
            const reporterMatch = line.match(reporterLogPattern);
            if (reporterMatch) {
                tsLines.push(`    console.log(${reporterMatch[1]});`);
                continue;
            }
            
            // Try to match common Selenium/QAF actions with page object context
            const actionMatch = matchAndConvertActionPOM(line, pageObjectRefs);
            if (actionMatch) {
                tsLines.push(actionMatch);
                continue;
            }
            
            // Try to identify and convert other common Java patterns
            const convertedLine = convertJavaPatterns(line);
            if (convertedLine) {
                tsLines.push(convertedLine);
                continue;
            }
            
            // For any line we couldn't match, add it as a comment
            tsLines.push(`    // TODO: ${line}`);
        }
    }

    // Ensure we close any remaining open braces
    while (braceCount > 0) {
        tsLines.push('}');
        braceCount--;
    }

    // Now add all unique imports at the top
    let finalContent = Array.from(foundImports).join('\n') + '\n\n';
    finalContent += tsLines.join('\n');
    
    return { tsContent: finalContent, skippedLines };
}

// Process a BDD step definition file for Cucumber
function processBDDStepContentCucumber(lines: string[]): { tsContent: string, skippedLines: string[] } {
    const tsLines: string[] = [];
    const skippedLines: string[] = [];
    let className = '';
    let foundImports = new Set<string>();
    let pageObjectRefs = new Set<string>(); // Track page object references

    // Add base TypeScript imports for Cucumber
    foundImports.add('import { Given, When, Then } from \'@cucumber/cucumber\';');
    foundImports.add('import { expect } from \'@playwright/test\';');
    foundImports.add('import { ICustomWorld } from \'../support/custom-world\';');

    // For debugging output
    const debugLine = (index: number, line: string, reason: string) => {
        if (DEBUG) {
            skippedLines.push(`Line ${index + 1}: ${line} - ${reason}`);
        }
    };

    // Add helper comment for Cucumber file
    tsLines.push('// Converted QAF BDD Step Definitions to Cucumber-Playwright');
    tsLines.push('');

    // Analyze the code to find page object references
    analyzePageObjectReferences(lines, pageObjectRefs);
    
    // Add imports for any page objects found
    pageObjectRefs.forEach(ref => {
        foundImports.add(`import { ${ref} } from '../page-objects/${ref}';`);
    });

    // Scan imports to add them properly
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.startsWith('import ')) {
            const importPath = line.substring(7, line.endsWith(';') ? line.length - 1 : line.length).trim();
            
            // Skip if already handled
            if (importMappings[importPath] !== undefined) continue;
            
            // Check if it's a page object import
            if (importPath.includes('.pages.') || importPath.includes('.pageobjects.')) {
                const className = importPath.split('.').pop();
                if (className && !pageObjectRefs.has(className)) {
                    pageObjectRefs.add(className);
                    foundImports.add(`import { ${className} } from '../page-objects/${className}';`);
                }
            }
        }
    }

    // Track if we're inside a step method
    let inStepMethod = false;
    let currentStepType = 'Given'; // Default step type
    let currentStepDescription = '';
    let currentStepParams: string[] = [];
    let currentMethodName = '';

    for (let i = 0; i < lines.length; i++) {
        const originalLine = lines[i];
        const line = originalLine.trim();

        // Skip empty lines
        if (line === '') continue;

        // Skip package declarations
        if (line.startsWith('package ')) {
            debugLine(i, line, "Skipped package declaration");
            continue;
        }

        // Handle imports - already processed earlier
        if (line.startsWith('import ')) {
            continue;
        }

        // Extract class name but don't create a class for Cucumber files
        const classMatch = line.match(/public\s+class\s+(\w+)/);
        if (classMatch) {
            className = classMatch[1];
            tsLines.push(`// Original class name: ${className}`);
            tsLines.push('');
            continue;
        }

        // Handle QAF BDD step definitions
        let stepMatch = line.match(/@QAFTestStep\s*\(\s*description\s*=\s*"([^"]+)"\s*\)/);
        if (stepMatch) {
            currentStepDescription = stepMatch[1];
            
            // Determine step type based on description's starting words
            const lcDesc = currentStepDescription.toLowerCase();
            if (lcDesc.startsWith('given ')) {
                currentStepType = 'Given';
                currentStepDescription = currentStepDescription.substring(6);
            } else if (lcDesc.startsWith('when ')) {
                currentStepType = 'When';
                currentStepDescription = currentStepDescription.substring(5);
            } else if (lcDesc.startsWith('then ')) {
                currentStepType = 'Then';
                currentStepDescription = currentStepDescription.substring(5);
            }
            
            // Look ahead to find the method signature
            let j = i + 1;
            while (j < lines.length && !lines[j].trim().match(/public.*?\(.*?\)/)) {
                j++;
            }
            
            if (j < lines.length) {
                const methodLine = lines[j].trim();
                const methodMatch = methodLine.match(/public.*?(\w+)\s*\((.*?)\)/);
                
                if (methodMatch) {
                    currentMethodName = methodMatch[1];
                    const params = methodMatch[2].trim();
                    
                    // Extract parameter names for use in the step description
                    currentStepParams = params.split(',').map(p => {
                        const parts = p.trim().split(' ');
                        return parts[parts.length - 1];
                    }).filter(p => p && p !== '');
                    
                    // Skip to the method line
                    i = j;
                    inStepMethod = true;
                    
                    // Convert step description to Cucumber format with parameters
                    let cucumberStepDesc = currentStepDescription;
                    
                    // Replace QAF parameter format with Cucumber format
                    currentStepParams.forEach(param => {
                        cucumberStepDesc = cucumberStepDesc.replace(
                            new RegExp(`\\$\\{${param}\\}`, 'g'), 
                            '{string}'
                        );
                    });
                    
                    // Start the Cucumber step function
                    tsLines.push(`// Original QAF step: "${currentStepDescription}"`);
                    tsLines.push(`${currentStepType}('${cucumberStepDesc}', async function(this: ICustomWorld${
                        currentStepParams.length > 0 ? ', ' + currentStepParams.map(() => 'paramString: string').join(', ') : ''
                    }) {`);
                    
                    // Add page initialization
                    tsLines.push('  const { page } = this;');
                    
                    // Initialize any page objects needed
                    if (pageObjectRefs.size > 0) {
                        tsLines.push('  // Initialize page objects');
                        pageObjectRefs.forEach(ref => {
                            tsLines.push(`  const ${ref.toLowerCase()} = new ${ref}(page);`);
                        });
                        tsLines.push('');
                    }
                    
                    // Handle parameter conversion
                    if (currentStepParams.length > 0) {
                        tsLines.push('  // Convert string parameters to appropriate types if needed');
                        currentStepParams.forEach((param, index) => {
                            tsLines.push(`  const ${param} = paramString;`);
                        });
                        tsLines.push('');
                    }
                    
                    continue;
                }
            }
            
            // If we couldn't find the method, skip this annotation
            debugLine(i, line, "Skipped BDD step annotation - couldn't find method");
            continue;
        }
        
        // Handle other BDD annotations (Given/When/Then)
        stepMatch = line.match(/@(Given|When|Then|And|But)\s*\(\s*"([^"]+)"\s*\)/);
        if (stepMatch) {
            currentStepType = stepMatch[1] === 'And' || stepMatch[1] === 'But' ? 'Then' : stepMatch[1];
            currentStepDescription = stepMatch[2];
            
            // Look ahead to find the method signature
            let j = i + 1;
            while (j < lines.length && !lines[j].trim().match(/public.*?\(.*?\)/)) {
                j++;
            }
            
            if (j < lines.length) {
                const methodLine = lines[j].trim();
                const methodMatch = methodLine.match(/public.*?(\w+)\s*\((.*?)\)/);
                
                if (methodMatch) {
                    currentMethodName = methodMatch[1];
                    const params = methodMatch[2].trim();
                    
                    // Extract parameter names
                    currentStepParams = params.split(',').map(p => {
                        const parts = p.trim().split(' ');
                        return parts[parts.length - 1];
                    }).filter(p => p && p !== '');
                    
                    // Skip to the method line
                    i = j;
                    inStepMethod = true;
                    
                    // Convert step description to Cucumber format with parameters
                    let cucumberStepDesc = currentStepDescription;
                    
                    // Replace parameters with Cucumber format
                    currentStepParams.forEach(param => {
                        cucumberStepDesc = cucumberStepDesc.replace(
                            new RegExp(`\\{${param}\\}`, 'g'), 
                            '{string}'
                        );
                    });
                    
                    // Start the Cucumber step function
                    tsLines.push(`// Original QAF step: "${currentStepDescription}"`);
                    tsLines.push(`${currentStepType}('${cucumberStepDesc}', async function(this: ICustomWorld${
                        currentStepParams.length > 0 ? ', ' + currentStepParams.map(() => 'paramString: string').join(', ') : ''
                    }) {`);
                    
                    // Add page initialization
                    tsLines.push('  const { page } = this;');
                    
                    // Initialize any page objects needed
                    if (pageObjectRefs.size > 0) {
                        tsLines.push('  // Initialize page objects');
                        pageObjectRefs.forEach(ref => {
                            tsLines.push(`  const ${ref.toLowerCase()} = new ${ref}(page);`);
                        });
                        tsLines.push('');
                    }
                    
                    // Handle parameter conversion
                    if (currentStepParams.length > 0) {
                        tsLines.push('  // Convert string parameters to appropriate types if needed');
                        currentStepParams.forEach((param, index) => {
                            tsLines.push(`  const ${param} = paramString;`);
                        });
                        tsLines.push('');
                    }
                    
                    continue;
                }
            }
            
            // If we couldn't find the method, skip this annotation
            debugLine(i, line, "Skipped BDD step annotation - couldn't find method");
            continue;
        }

        // Handle method end specifically for step methods
        if (line === '}' && inStepMethod) {
            tsLines.push('});');
            inStepMethod = false;
            currentMethodName = '';
            currentStepDescription = '';
            currentStepParams = [];
            tsLines.push('');
            continue;
        }

        // Handle code inside step methods
        if (inStepMethod) {
            // Skip method signature line
            if (line.includes('public') && line.includes('(') && line.includes(')')) {
                continue;
            }
            
            // Skip opening brace
            if (line === '{') {
                continue;
            }
            
            // Check for Reporter.log statements
            const reporterLogPattern = /Reporter\.log\(([^,)]+)(?:,\s*\w+)?\);/;
            const reporterMatch = line.match(reporterLogPattern);
            if (reporterMatch) {
                tsLines.push(`  console.log(${reporterMatch[1]});`);
                continue;
            }
            
            // Try to match common Selenium/QAF actions with page object context
            const actionMatch = matchAndConvertActionCucumber(line, pageObjectRefs);
            if (actionMatch) {
                tsLines.push(actionMatch);
                continue;
            }
            
            // Try to identify and convert other common Java patterns
            const convertedLine = convertJavaPatterns(line);
            if (convertedLine) {
                tsLines.push(convertedLine.replace(/^    /, '  ')); // Convert 4 spaces to 2 for Cucumber
                continue;
            }
            
            // For any line we couldn't match, add it as a comment
            tsLines.push(`  // TODO: ${line}`);
            continue;
        }

        // Skip lines outside step methods for Cucumber files
        debugLine(i, line, "Skipped line outside step method in Cucumber file");
    }

    // Now add all unique imports at the top
    let finalContent = Array.from(foundImports).join('\n') + '\n\n';
    finalContent += tsLines.join('\n');
    
    return { tsContent: finalContent, skippedLines };
}

// Analyze the file to find page object references
function analyzePageObjectReferences(lines: string[], pageObjectRefs: Set<string>): void {
    // First pass: find class declarations
    const classDeclarations = new Set<string>();
    
    for (const line of lines) {
        const classMatch = line.trim().match(/public\s+class\s+(\w+)/);
        if (classMatch) {
            classDeclarations.add(classMatch[1]);
        }
    }
    
    // Second pass: find instantiations and references
    const instantiationPattern = /new\s+(\w+)\(/;
    const fieldDeclPattern = /(private|protected|public)\s+(\w+)\s+(\w+)\s*;/;
    
    for (const line of lines) {
        const trimmedLine = line.trim();
        
        // Check instantiations
        const instantiationMatch = trimmedLine.match(instantiationPattern);
        if (instantiationMatch && !elementClasses.includes(instantiationMatch[1]) && 
            !['ArrayList', 'HashMap', 'String', 'StringBuilder', 'WebDriverWait'].includes(instantiationMatch[1])) {
            // This looks like a page object instantiation
            pageObjectRefs.add(instantiationMatch[1]);
        }
        
        // Check field declarations
        const fieldMatch = trimmedLine.match(fieldDeclPattern);
        if (fieldMatch) {
            const className = fieldMatch[2];
            if (!elementClasses.includes(className) && 
                !['String', 'int', 'boolean', 'List', 'Map', 'Object'].includes(className) &&
                !classDeclarations.has(className)) {
                // This looks like a page object field declaration
                pageObjectRefs.add(className);
            }
        }
    }
}

// Match and convert actions in page object methods
function matchAndConvertActionPOM(line: string, pageObjectRefs: Set<string>): string | null {
    // Define patterns and their replacements for page objects
    const actionPatterns = [
        // Element actions
        { 
            pattern: /(\w+)\.click\(\);/, 
            handler: (m: RegExpMatchArray) => {
                if (isPageObjectReference(m[1], pageObjectRefs)) {
                    return `    await this.${m[1].toLowerCase()}.click();`;
                } else {
                    return `    await (await this.${m[1]}()).click();`;
                }
            }
        },
        { 
            pattern: /(\w+)\.sendKeys\("([^"]*)"\);/, 
            handler: (m: RegExpMatchArray) => {
                if (isPageObjectReference(m[1], pageObjectRefs)) {
                    return `    await this.${m[1].toLowerCase()}.fill("${m[2]}");`;
                } else {
                    return `    await (await this.${m[1]}()).fill("${m[2]}");`;
                }
            }
        },
        { 
            pattern: /(\w+)\.clear\(\);/, 
            handler: (m: RegExpMatchArray) => {
                if (isPageObjectReference(m[1], pageObjectRefs)) {
                    return `    await this.${m[1].toLowerCase()}.clear();`;
                } else {
                    return `    await (await this.${m[1]}()).clear();`;
                }
            }
        },
        { 
            pattern: /(\w+)\.isDisplayed\(\)/, 
            handler: (m: RegExpMatchArray) => {
                if (isPageObjectReference(m[1], pageObjectRefs)) {
                    return line.includes('assert') || line.includes('verify') 
                        ? `    await expect(this.${m[1].toLowerCase()}).toBeVisible();`
                        : `    const isVisible = await this.${m[1].toLowerCase()}.isVisible();`;
                } else {
                    return line.includes('assert') || line.includes('verify') 
                        ? `    await expect(await this.${m[1]}()).toBeVisible();`
                        : `    const isVisible = await (await this.${m[1]}()).isVisible();`;
                }
            }
        },
        { 
            pattern: /(\w+)\.isEnabled\(\)/, 
            handler: (m: RegExpMatchArray) => {
                if (isPageObjectReference(m[1], pageObjectRefs)) {
                    return line.includes('assert') || line.includes('verify')
                        ? `    await expect(this.${m[1].toLowerCase()}).toBeEnabled();`
                        : `    const isEnabled = await this.${m[1].toLowerCase()}.isEnabled();`;
                } else {
                    return line.includes('assert') || line.includes('verify')
                        ? `    await expect(await this.${m[1]}()).toBeEnabled();`
                        : `    const isEnabled = await (await this.${m[1]}()).isEnabled();`;
                }
            }
        },
        { 
            pattern: /(\w+)\.getText\(\)/, 
            handler: (m: RegExpMatchArray) => {
                if (isPageObjectReference(m[1], pageObjectRefs)) {
                    return `    const text = await this.${m[1].toLowerCase()}.textContent();`;
                } else {
                    return `    const text = await (await this.${m[1]}()).textContent();`;
                }
            }
        },
        
        // Waits and sleeps
        { 
            pattern: /Thread\.sleep\((\d+)\)/, 
            handler: (m: RegExpMatchArray) => {
                const timeInMs = parseInt(m[1]) <= 1000 ? parseInt(m[1]) : parseInt(m[1]) / 1000;
                return `    await this.page.waitForTimeout(${timeInMs});`;
            }
        },
        { 
            pattern: /wait\.until/, 
            handler: () => `    // TODO: Convert wait condition to Playwright's built-in waits` 
        },
        
        // Assertions
        { 
            pattern: /Assert\.assertEquals\((.*?),(.*?)\)/, 
            handler: (m: RegExpMatchArray) => {
                const actual = m[1].trim();
                const expected = m[2].trim();
                return `    expect(${actual}).toEqual(${expected});`;
            } 
        },
        { 
            pattern: /Assert\.assertTrue\((.*?)\)/, 
            handler: (m: RegExpMatchArray) => `    expect(${m[1].trim()}).toBeTruthy();` 
        },
        { 
            pattern: /Assert\.assertFalse\((.*?)\)/, 
            handler: (m: RegExpMatchArray) => `    expect(${m[1].trim()}).toBeFalsy();` 
        },
        
        // Method calls on page objects
        { 
            pattern: /(\w+)\.(\w+)\((.*?)\);/, 
            handler: (m: RegExpMatchArray) => {
                if (isPageObjectReference(m[1], pageObjectRefs)) {
                    // This is a method call on a page object
                    return `    await this.${m[1].toLowerCase()}.${m[2]}(${m[3]});`;
                }
                return null; // Not a match we want to handle
            } 
        }
    ];
    
    for (const { pattern, handler } of actionPatterns) {
        const match = line.match(pattern);
        if (match) {
            const result = handler(match);
            if (result) return result;
        }
    }
    
    return null;
}

// Match and convert actions in Cucumber step methods
function matchAndConvertActionCucumber(line: string, pageObjectRefs: Set<string>): string | null {
    // Define patterns and their replacements for Cucumber
    const actionPatterns = [
        // Element actions
        { 
            pattern: /(\w+)\.click\(\);/, 
            handler: (m: RegExpMatchArray) => {
                if (isPageObjectReference(m[1], pageObjectRefs)) {
                    return `  await ${m[1].toLowerCase()}.click();`;
                } else {
                    return `  await page.locator('#${m[1]}').click();`;
                }
            }
        },
        { 
            pattern: /(\w+)\.sendKeys\("([^"]*)"\);/, 
            handler: (m: RegExpMatchArray) => {
                if (isPageObjectReference(m[1], pageObjectRefs)) {
                    return `  await ${m[1].toLowerCase()}.fill("${m[2]}");`;
                } else {
                    return `  await page.locator('#${m[1]}').fill("${m[2]}");`;
                }
            }
        },
        { 
            pattern: /(\w+)\.clear\(\);/, 
            handler: (m: RegExpMatchArray) => {
                if (isPageObjectReference(m[1], pageObjectRefs)) {
                    return `  await ${m[1].toLowerCase()}.clear();`;
                } else {
                    return `  await page.locator('#${m[1]}').clear();`;
                }
            }
        },
        { 
            pattern: /(\w+)\.isDisplayed\(\)/, 
            handler: (m: RegExpMatchArray) => {
                if (isPageObjectReference(m[1], pageObjectRefs)) {
                    return line.includes('assert') || line.includes('verify') 
                        ? `  await expect(${m[1].toLowerCase()}).toBeVisible();`
                        : `  const isVisible = await ${m[1].toLowerCase()}.isVisible();`;
                } else {
                    return line.includes('assert') || line.includes('verify') 
                        ? `  await expect(page.locator('#${m[1]}')).toBeVisible();`
                        : `  const isVisible = await page.locator('#${m[1]}').isVisible();`;
                }
            }
        },
        
        // Waits and sleeps
        { 
            pattern: /Thread\.sleep\((\d+)\)/, 
            handler: (m: RegExpMatchArray) => {
                const timeInMs = parseInt(m[1]) <= 1000 ? parseInt(m[1]) : parseInt(m[1]) / 1000;
                return `  await page.waitForTimeout(${timeInMs});`;
            }
        },
        
        // Assertions
        { 
            pattern: /Assert\.assertEquals\((.*?),(.*?)\)/, 
            handler: (m: RegExpMatchArray) => {
                const actual = m[1].trim();
                const expected = m[2].trim();
                return `  expect(${actual}).toEqual(${expected});`;
            } 
        },
        { 
            pattern: /Assert\.assertTrue\((.*?)\)/, 
            handler: (m: RegExpMatchArray) => `  expect(${m[1].trim()}).toBeTruthy();` 
        },
        { 
            pattern: /Assert\.assertFalse\((.*?)\)/, 
            handler: (m: RegExpMatchArray) => `  expect(${m[1].trim()}).toBeFalsy();` 
        },
        
        // Method calls on page objects
        { 
            pattern: /(\w+)\.(\w+)\((.*?)\);/, 
            handler: (m: RegExpMatchArray) => {
                if (isPageObjectReference(m[1], pageObjectRefs)) {
                    // This is a method call on a page object
                    return `  await ${m[1].toLowerCase()}.${m[2]}(${m[3]});`;
                }
                return null; // Not a match we want to handle
            } 
        }
    ];
    
    for (const { pattern, handler } of actionPatterns) {
        const match = line.match(pattern);
        if (match) {
            const result = handler(match);
            if (result) return result;
        }
    }
    
    return null;
}

// Convert common Java patterns to TypeScript
function convertJavaPatterns(line: string): string | null {
    // Handle common Java idioms and convert them to TypeScript
    const patterns = [
        // Loops
        {
            pattern: /for\s*\(\s*int\s+(\w+)\s*=\s*(\d+)\s*;\s*\1\s*<\s*(\w+|\d+)\s*;\s*\1\+\+\s*\)/,
            handler: (m: RegExpMatchArray) => `    for (let ${m[1]} = ${m[2]}; ${m[1]} < ${m[3]}; ${m[1]}++) `
        },
        // Variable declarations with type
        {
            pattern: /(String|int|boolean|double)\s+(\w+)\s*=\s*(.*?);/,
            handler: (m: RegExpMatchArray) => `    const ${m[2]} = ${m[3]};`
        },
        // if statements
        {
            pattern: /if\s*\((.*?)\)\s*\{/,
            handler: (m: RegExpMatchArray) => `    if (${m[1]}) {`
        },
        // else if statements
        {
            pattern: /\}\s*else\s+if\s*\((.*?)\)\s*\{/,
            handler: (m: RegExpMatchArray) => `    } else if (${m[1]}) {`
        },
        // else statements
        {
            pattern: /\}\s*else\s*\{/,
            handler: () => `    } else {`
        },
        // while loops
        {
            pattern: /while\s*\((.*?)\)\s*\{/,
            handler: (m: RegExpMatchArray) => `    while (${m[1]}) {`
        },
        // switch statements
        {
            pattern: /switch\s*\((.*?)\)\s*\{/,
            handler: (m: RegExpMatchArray) => `    switch (${m[1]}) {`
        },
        // case statements
        {
            pattern: /case\s+(.*?):/,
            handler: (m: RegExpMatchArray) => `    case ${m[1]}:`
        },
        // default case
        {
            pattern: /default:/,
            handler: () => `    default:`
        },
        // break statements
        {
            pattern: /break;/,
            handler: () => `    break;`
        },
        // try blocks
        {
            pattern: /try\s*\{/,
            handler: () => `    try {`
        },
        // catch blocks
        {
            pattern: /\}\s*catch\s*\((.*?)\)\s*\{/,
            handler: () => `    } catch (error) {`
        },
        // finally blocks
        {
            pattern: /\}\s*finally\s*\{/,
            handler: () => `    } finally {`
        },
        // String concatenation
        {
            pattern: /"([^"]*)"\s*\+\s*(\w+)(.*)"/,
            handler: (m: RegExpMatchArray) => `    \`${m[1]}\${${m[2]}}${m[3]}\``
        }
    ];

    for (const { pattern, handler } of patterns) {
        const match = line.match(pattern);
        if (match) {
            return handler(match);
        }
    }

    return null;
}

// Check if a variable name refers to a page object
function isPageObjectReference(name: string, pageObjectRefs: Set<string>): boolean {
    if (['driver', 'page', 'this', 'text', 'element', 'result'].includes(name)) {
        return false;
    }
    
    // Check for page object names (exact match or lowercase version)
    for (const ref of pageObjectRefs) {
        if (name === ref || name === ref.toLowerCase()) {
            return true;
        }
    }
    
    return false;
}

// Utility functions
function convertJavaParamsToTypeScript(params: string): string {
    if (!params) return '';
    
    return params.replace(/String/g, 'string')
                .replace(/int\b/g, 'number')
                .replace(/Integer/g, 'number')
                .replace(/boolean/g, 'boolean')
                .replace(/Map<[^>]+>/g, 'Record<string, any>')
                .replace(/List<[^>]+>/g, 'any[]')
                .replace(/Object/g, 'any');
}

function processLocator(tsLines: string[], locator: string): void {
    // Handle different locator types with proper quoting
    if (locator.startsWith('xpath=')) {
        const xpathValue = locator.substring(6);
        // Use template literals to avoid quote escaping issues
        tsLines.push(`    return this.page.locator(\`xpath=${xpathValue.replace(/`/g, '\\`')}\`);`);
    } else if (locator.startsWith('css=')) {
        const cssValue = locator.substring(4);
        tsLines.push(`    return this.page.locator(\`${cssValue.replace(/`/g, '\\`')}\`);`);
    } else if (locator.startsWith('id=')) {
        tsLines.push(`    return this.page.locator('#${locator.substring(3)}');`);
    } else if (locator.startsWith('name=')) {
        tsLines.push(`    return this.page.locator('[name="${locator.substring(5)}"]');`);
    } else if (locator.startsWith('linkText=')) {
        const linkText = locator.substring(9);
        tsLines.push(`    return this.page.getByText(\`${linkText.replace(/`/g, '\\`')}\`);`);
    } else if (locator.startsWith('partialLinkText=')) {
        const partialText = locator.substring(16);
        tsLines.push(`    return this.page.getByText(\`${partialText.replace(/`/g, '\\`')}\`, { exact: false });`);
    } else if (locator.startsWith('className=')) {
        tsLines.push(`    return this.page.locator('.${locator.substring(10)}');`);
    } else if (locator.startsWith('tagName=')) {
        tsLines.push(`    return this.page.locator('${locator.substring(8)}');`);
    } else {
        // Try to detect if it's a complex locator with a type
        const complexMatch = locator.match(/^(\w+)=(.+)$/);
        if (complexMatch) {
            const type = complexMatch[1];
            const value = complexMatch[2];
            
            switch (type.toLowerCase()) {
                case 'text':
                    tsLines.push(`    return this.page.getByText(\`${value.replace(/`/g, '\\`')}\`);`);
                    break;
                case 'role':
                    tsLines.push(`    return this.page.getByRole('${value}');`);
                    break;
                case 'label':
                    tsLines.push(`    return this.page.getByLabel(\`${value.replace(/`/g, '\\`')}\`);`);
                    break;
                case 'placeholder':
                    tsLines.push(`    return this.page.getByPlaceholder(\`${value.replace(/`/g, '\\`')}\`);`);
                    break;
                case 'alt':
                    tsLines.push(`    return this.page.getByAltText(\`${value.replace(/`/g, '\\`')}\`);`);
                    break;
                case 'title':
                    tsLines.push(`    return this.page.getByTitle(\`${value.replace(/`/g, '\\`')}\`);`);
                    break;
                default:
                    // Generic fallback
                    tsLines.push(`    return this.page.locator(\`[${type}="${value}"]\`);`);
            }
        } else {
            // Generic fallback using template literals
            tsLines.push(`    return this.page.locator(\`${locator.replace(/`/g, '\\`')}\`);`);
        }
    }
}

// Handle execution errors
process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
    process.exit(1);
});

// Generate Cucumber world definition if not exists
function generateCucumberWorld(outputDir: string): void {
    const worldFilePath = path.join(outputDir, 'support/custom-world.ts');
    
    // Check if file already exists
    if (fs.existsSync(worldFilePath)) {
        console.log('Custom world file already exists, skipping generation');
        return;
    }
    
    // Create directory if needed
    const worldDir = path.dirname(worldFilePath);
    if (!fs.existsSync(worldDir)) {
        fs.mkdirSync(worldDir, { recursive: true });
    }
    
    // Write the world file
    const worldContent = `
import { World, IWorldOptions, setWorldConstructor } from '@cucumber/cucumber';
import { BrowserContext, Page, Browser, chromium } from '@playwright/test';

export interface ICustomWorld extends World {
  context?: BrowserContext;
  page?: Page;
  browser?: Browser;
}

export class CustomWorld extends World implements ICustomWorld {
  context?: BrowserContext;
  page?: Page;
  browser?: Browser;

  constructor(options: IWorldOptions) {
    super(options);
  }

  async init() {
    this.browser = await chromium.launch({ headless: false });
    this.context = await this.browser.newContext();
    this.page = await this.context.newPage();
  }

  async teardown() {
    if (this.browser) {
      await this.browser.close();
    }
  }
}

setWorldConstructor(CustomWorld);
`;
    
    fs.writeFileSync(worldFilePath, worldContent, 'utf8');
    console.log(`Generated Cucumber world file: ${worldFilePath}`);
}

// Process a directory or a single file
function processPath(inputPath: string, outputBasePath: string = '') {
    const stats = fs.statSync(inputPath);
    
    if (stats.isDirectory()) {
        // Process all Java files in the directory
        const files = fs.readdirSync(inputPath);
        
        // Generate Cucumber world if any BDD files
        let hasBDDFiles = false;
        for (const file of files) {
            if (file.endsWith('.java')) {
                const filePath = path.join(inputPath, file);
                const fileContent = fs.readFileSync(filePath, 'utf8');
                if (isBDDStepFile(fileContent)) {
                    hasBDDFiles = true;
                    break;
                }
            }
        }
        
        if (hasBDDFiles && outputBasePath) {
            generateCucumberWorld(outputBasePath);
        }
        
        // Process each file
        files.forEach(file => {
            if (file.endsWith('.java')) {
                const filePath = path.join(inputPath, file);
                const outputPath = outputBasePath 
                    ? path.join(outputBasePath, file.replace('.java', '.ts'))
                    : filePath.replace('.java', '.ts');
                convertQafToPlaywright(filePath, outputPath);
            }
        });
    } else if (stats.isFile() && inputPath.endsWith('.java')) {
        // Process a single file
        const fileContent = fs.readFileSync(inputPath, 'utf8');
        const isBDD = isBDDStepFile(fileContent);
        
        // Generate Cucumber world for BDD file
        if (isBDD && outputBasePath) {
            const outputDir = path.dirname(outputBasePath);
            generateCucumberWorld(outputDir);
        }
        
        const outputPath = outputBasePath || inputPath.replace('.java', '.ts');
        convertQafToPlaywright(inputPath, outputPath);
    } else {
        console.error(`Error: ${inputPath} is not a directory or a Java file`);
    }
}

// Example usage
const inputPath = process.argv[2];
const outputPath = process.argv[3] || '';

if (!inputPath) {
    console.error('Please provide an input path (file or directory)');
    process.exit(1);
}

try {
    processPath(inputPath, outputPath);
} catch (error) {
    console.error('Error executing conversion:', error);
    process.exit(1);
}
