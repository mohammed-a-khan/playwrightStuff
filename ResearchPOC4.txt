package com.ctgp.service.analyzer;

import com.ctgp.model.analyzer.*;
import com.microsoft.playwright.Browser;
import com.microsoft.playwright.BrowserContext;
import com.microsoft.playwright.BrowserType;
import com.microsoft.playwright.Page;
import com.microsoft.playwright.Playwright;
import com.microsoft.playwright.options.LoadState;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class WebAnalyzerService {

    private static final List<String> FORM_ELEMENTS = Arrays.asList("input", "select", "textarea", "button");
    private static final List<String> CLICKABLE_ELEMENTS = Arrays.asList("a", "button", "div[role='button']", "[onclick]", ".btn", ".button");
    private static final List<String> NAVIGATIONAL_ELEMENTS = Arrays.asList("a", "nav a", "header a", "footer a", ".navigation a", ".menu a");
    private static final Map<String, ElementType> INPUT_TYPE_MAPPING = new HashMap<String, ElementType>() {{
        put("text", ElementType.TEXT_INPUT);
        put("email", ElementType.EMAIL_INPUT);
        put("password", ElementType.PASSWORD_INPUT);
        put("number", ElementType.NUMBER_INPUT);
        put("checkbox", ElementType.CHECKBOX);
        put("radio", ElementType.RADIO_BUTTON);
        put("date", ElementType.DATE_PICKER);
        put("file", ElementType.FILE_UPLOAD);
        put("submit", ElementType.BUTTON);
        put("button", ElementType.BUTTON);
    }};

    /**
     * Analyzes a web application starting from the given URL
     * @param url The starting URL to analyze
     * @param depth The maximum depth of pages to crawl
     * @return A WebApplication object containing the analyzed structure
     */
    public WebApplication analyzeApplication(String url, int depth) {
        log.info("Analyzing web application at: {} with depth: {}", url, depth);
        
        WebApplication application = new WebApplication();
        application.setBaseUrl(url);
        
        Set<String> visitedUrls = new HashSet<>();
        Set<String> pendingUrls = new HashSet<>();
        pendingUrls.add(url);
        
        try (Playwright playwright = Playwright.create()) {
            Browser browser = playwright.chromium().launch(new BrowserType.LaunchOptions()
                    .setHeadless(true));
            
            BrowserContext context = browser.newContext();
            Page page = context.newPage();
            
            for (int currentDepth = 0; currentDepth < depth && !pendingUrls.isEmpty(); currentDepth++) {
                Set<String> newPendingUrls = new HashSet<>();
                
                for (String pendingUrl : pendingUrls) {
                    if (visitedUrls.contains(pendingUrl)) {
                        continue;
                    }
                    
                    log.info("Analyzing page: {} (depth: {})", pendingUrl, currentDepth);
                    try {
                        page.navigate(pendingUrl);
                        page.waitForLoadState(LoadState.NETWORKIDLE, new Page.WaitForLoadStateOptions().setTimeout(10000));
                        TimeUnit.SECONDS.sleep(1); // Additional wait for any dynamic content
                        
                        String html = page.content();
                        WebPage webPage = analyzePage(pendingUrl, html);
                        application.getPages().add(webPage);
                        
                        // Collect new URLs
                        if (currentDepth < depth - 1) {
                            List<String> pageUrls = webPage.getElements().stream()
                                    .filter(e -> e.getType() == ElementType.LINK)
                                    .map(WebElement::getHref)
                                    .filter(Objects::nonNull)
                                    .filter(href -> href.startsWith(url) || (!href.startsWith("http") && !href.startsWith("//") && !href.startsWith("mailto:")))
                                    .map(href -> normalizeUrl(url, href))
                                    .collect(Collectors.toList());
                            
                            newPendingUrls.addAll(pageUrls);
                        }
                        
                        visitedUrls.add(pendingUrl);
                    } catch (Exception e) {
                        log.error("Error analyzing page: {}", pendingUrl, e);
                    }
                }
                
                pendingUrls = newPendingUrls;
            }
            
            browser.close();
        } catch (Exception e) {
            log.error("Error during web application analysis", e);
        }
        
        log.info("Analysis complete. Found {} pages.", application.getPages().size());
        return application;
    }
    
    /**
     * Analyzes a single page to extract elements, forms, and structure
     * @param url The URL of the page
     * @param html The HTML content of the page
     * @return A WebPage object containing the analyzed structure
     */
    private WebPage analyzePage(String url, String html) {
        WebPage webPage = new WebPage();
        webPage.setUrl(url);
        webPage.setTitle(extractTitle(html));
        
        Document document = Jsoup.parse(html);
        
        // Analyze forms
        Elements formElements = document.select("form");
        for (Element formElement : formElements) {
            WebForm form = analyzeForm(formElement);
            webPage.getForms().add(form);
            
            // Add form fields as individual elements
            webPage.getElements().addAll(form.getFields());
        }
        
        // Analyze clickable elements
        for (String selector : CLICKABLE_ELEMENTS) {
            Elements elements = document.select(selector);
            for (Element element : elements) {
                WebElement webElement = analyzeElement(element);
                if (webElement != null && !isDuplicate(webPage.getElements(), webElement)) {
                    webPage.getElements().add(webElement);
                }
            }
        }
        
        // Analyze navigational elements
        for (String selector : NAVIGATIONAL_ELEMENTS) {
            Elements elements = document.select(selector);
            for (Element element : elements) {
                WebElement webElement = analyzeElement(element);
                if (webElement != null && webElement.getType() == ElementType.LINK && !isDuplicate(webPage.getElements(), webElement)) {
                    webElement.setCategory("navigation");
                    webPage.getElements().add(webElement);
                }
            }
        }
        
        // Analyze text content areas
        Elements textElements = document.select("p, h1, h2, h3, h4, h5, h6, span, div");
        for (Element element : textElements) {
            if (!element.text().trim().isEmpty() && 
                element.children().isEmpty() && 
                !element.parent().tagName().equals("a") &&
                !element.parents().select("a").first().equals(element)) {
                
                WebElement webElement = new WebElement();
                webElement.setType(ElementType.TEXT);
                webElement.setSelector(generateSelector(element));
                webElement.setText(element.text().trim());
                
                if (!isDuplicate(webPage.getElements(), webElement)) {
                    webPage.getElements().add(webElement);
                }
            }
        }
        
        log.debug("Analyzed page: {} - Found {} elements and {} forms", 
                url, webPage.getElements().size(), webPage.getForms().size());
        
        return webPage;
    }
    
    /**
     * Analyzes a form element to extract its fields and structure
     * @param formElement The JSoup Element representing the form
     * @return A WebForm object containing the analyzed form structure
     */
    private WebForm analyzeForm(Element formElement) {
        WebForm form = new WebForm();
        form.setSelector(generateSelector(formElement));
        form.setAction(formElement.attr("action"));
        form.setMethod(formElement.attr("method").toUpperCase());
        
        if (form.getMethod().isEmpty()) {
            form.setMethod("GET");
        }
        
        // Extract form fields
        for (String fieldType : FORM_ELEMENTS) {
            Elements fields = formElement.select(fieldType);
            for (Element field : fields) {
                WebElement webElement = analyzeFormField(field);
                if (webElement != null) {
                    form.getFields().add(webElement);
                }
            }
        }
        
        return form;
    }
    
    /**
     * Analyzes a form field element to extract its properties
     * @param field The JSoup Element representing the form field
     * @return A WebElement object representing the form field
     */
    private WebElement analyzeFormField(Element field) {
        String tagName = field.tagName().toLowerCase();
        
        WebElement webElement = new WebElement();
        webElement.setSelector(generateSelector(field));
        webElement.setId(field.id());
        webElement.setName(field.attr("name"));
        webElement.setText(field.text().trim());
        webElement.setCategory("form-field");
        
        if (tagName.equals("input")) {
            String inputType = field.attr("type").toLowerCase();
            if (inputType.isEmpty()) {
                inputType = "text";
            }
            
            webElement.setType(INPUT_TYPE_MAPPING.getOrDefault(inputType, ElementType.OTHER_INPUT));
            webElement.setRequired(field.hasAttr("required"));
            webElement.setPlaceholder(field.attr("placeholder"));
            webElement.setValue(field.attr("value"));
            
            if (inputType.equals("radio") || inputType.equals("checkbox")) {
                webElement.setChecked(field.hasAttr("checked"));
            }
        } else if (tagName.equals("select")) {
            webElement.setType(ElementType.SELECT);
            webElement.setRequired(field.hasAttr("required"));
            
            // Extract options
            List<String> options = new ArrayList<>();
            Elements optionElements = field.select("option");
            for (Element option : optionElements) {
                options.add(option.text().trim());
            }
            webElement.setOptions(options);
            
            // Get selected value
            Element selectedOption = field.select("option[selected]").first();
            if (selectedOption != null) {
                webElement.setValue(selectedOption.attr("value"));
                webElement.setText(selectedOption.text().trim());
            }
        } else if (tagName.equals("textarea")) {
            webElement.setType(ElementType.TEXTAREA);
            webElement.setRequired(field.hasAttr("required"));
            webElement.setPlaceholder(field.attr("placeholder"));
            webElement.setValue(field.text());
        } else if (tagName.equals("button")) {
            webElement.setType(ElementType.BUTTON);
            webElement.setValue(field.attr("value"));
            
            if (field.attr("type").equals("submit") || field.text().toLowerCase().contains("submit") ||
                    field.text().toLowerCase().contains("save") || field.text().toLowerCase().contains("send")) {
                webElement.setCategory("submit-button");
            }
        }
        
        return webElement;
    }
    
    /**
     * Analyzes a general element to extract its properties
     * @param element The JSoup Element to analyze
     * @return A WebElement object representing the analyzed element
     */
    private WebElement analyzeElement(Element element) {
        if (element == null) {
            return null;
        }
        
        WebElement webElement = new WebElement();
        webElement.setSelector(generateSelector(element));
        webElement.setId(element.id());
        webElement.setText(element.text().trim());
        
        String tagName = element.tagName().toLowerCase();
        
        if (tagName.equals("a")) {
            webElement.setType(ElementType.LINK);
            webElement.setHref(element.attr("href"));
            webElement.setCategory("link");
        } else if (tagName.equals("button") || element.hasAttr("role") && element.attr("role").equals("button") || 
                   element.hasClass("btn") || element.hasClass("button")) {
            webElement.setType(ElementType.BUTTON);
            webElement.setCategory("button");
        } else if (element.hasAttr("onclick")) {
            webElement.setType(ElementType.CLICKABLE);
            webElement.setCategory("interactive");
        } else {
            return null; // Skip elements we can't categorize
        }
        
        return webElement;
    }
    
    /**
     * Extracts the title from HTML content
     * @param html The HTML content
     * @return The extracted title
     */
    private String extractTitle(String html) {
        Document document = Jsoup.parse(html);
        return document.title();
    }
    
    /**
     * Generates a CSS selector for the given element
     * @param element The JSoup Element
     * @return A CSS selector string
     */
    private String generateSelector(Element element) {
        if (!element.id().isEmpty()) {
            return "#" + element.id();
        }
        
        if (!element.attr("name").isEmpty() && (element.tagName().equals("input") || 
                                               element.tagName().equals("select") || 
                                               element.tagName().equals("textarea"))) {
            return element.tagName() + "[name='" + element.attr("name") + "']";
        }
        
        StringBuilder selector = new StringBuilder();
        Element current = element;
        
        while (current != null && !current.tagName().equals("html")) {
            String elementSelector = current.tagName();
            
            if (!current.id().isEmpty()) {
                elementSelector += "#" + current.id();
                selector.insert(0, elementSelector);
                break;
            } else if (!current.className().isEmpty()) {
                elementSelector += "." + current.className().replace(" ", ".");
            }
            
            if (current.elementSiblingIndex() > 0) {
                elementSelector += ":nth-child(" + (current.elementSiblingIndex() + 1) + ")";
            }
            
            if (selector.length() > 0) {
                selector.insert(0, elementSelector + " > ");
            } else {
                selector.append(elementSelector);
            }
            
            current = current.parent();
        }
        
        return selector.toString();
    }
    
    /**
     * Normalizes a URL relative to a base URL
     * @param baseUrl The base URL
     * @param href The href to normalize
     * @return The normalized URL
     */
    private String normalizeUrl(String baseUrl, String href) {
        if (href.startsWith("http")) {
            return href;
        }
        
        if (href.startsWith("/")) {
            String domain = baseUrl.replaceAll("(https?://[^/]+).*", "$1");
            return domain + href;
        }
        
        String basePath = baseUrl.substring(0, baseUrl.lastIndexOf('/') + 1);
        return basePath + href;
    }
    
    /**
     * Checks if an element is a duplicate of an existing element
     * @param elements The list of existing elements
     * @param newElement The new element to check
     * @return True if the element is a duplicate, false otherwise
     */
    private boolean isDuplicate(List<WebElement> elements, WebElement newElement) {
        for (WebElement element : elements) {
            if (element.getSelector().equals(newElement.getSelector())) {
                return true;
            }
        }
        return false;
    }
}


package com.ctgp.service.generator;

import com.ctgp.model.analyzer.*;
import com.ctgp.model.workspace.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class TestGeneratorService {

    private final String TEMPLATE_DIR = "templates/";
    private static final String DATE_FORMAT = "yyyy-MM-dd HH:mm:ss";
    private static final Random random = new Random();
    
    private static final Map<ElementType, String> ELEMENT_VERIFICATION_MAP = new HashMap<ElementType, String>() {{
        put(ElementType.TEXT, "await expect(page.locator('%s')).toHaveText(/%s/);");
        put(ElementType.LINK, "await expect(page.locator('%s')).toHaveAttribute('href', /%s/);");
        put(ElementType.BUTTON, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.TEXT_INPUT, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.EMAIL_INPUT, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.PASSWORD_INPUT, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.CHECKBOX, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.RADIO_BUTTON, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.SELECT, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.TEXTAREA, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.CLICKABLE, "await expect(page.locator('%s')).toBeVisible();");
    }};
    
    /**
     * Generates test suites for the given web application
     * @param project The project to generate tests for
     * @param application The analyzed web application
     * @return A list of generated test suites
     */
    public List<TestSuite> generateTestSuites(Project project, WebApplication application) {
        log.info("Generating test suites for project: {}", project.getName());
        
        List<TestSuite> testSuites = new ArrayList<>();
        
        // Generate navigation test suite
        TestSuite navigationSuite = generateNavigationTestSuite(project, application);
        testSuites.add(navigationSuite);
        
        // Generate form test suite
        TestSuite formSuite = generateFormTestSuite(project, application);
        testSuites.add(formSuite);
        
        // Generate visual verification test suite
        TestSuite visualSuite = generateVisualVerificationTestSuite(project, application);
        testSuites.add(visualSuite);
        
        // Save generated test suites
        for (TestSuite suite : testSuites) {
            saveTestSuite(project, suite);
        }
        
        log.info("Generated {} test suites with {} total test cases", 
                testSuites.size(), 
                testSuites.stream().mapToInt(s -> s.getTestCases().size()).sum());
        
        return testSuites;
    }
    
    /**
     * Generates a test suite for navigation scenarios
     * @param project The project to generate tests for
     * @param application The analyzed web application
     * @return A test suite for navigation scenarios
     */
    private TestSuite generateNavigationTestSuite(Project project, WebApplication application) {
        TestSuite suite = new TestSuite();
        suite.setName("Navigation Tests");
        suite.setDescription("Tests basic navigation functionality of the application");
        suite.setCreatedAt(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT)));
        
        // Generate page load test cases
        for (WebPage page : application.getPages()) {
            TestCase testCase = new TestCase();
            testCase.setName("Page Load Test - " + getPageName(page));
            testCase.setDescription("Verifies that the page loads correctly");
            
            List<TestStep> steps = new ArrayList<>();
            
            // Step 1: Navigate to page
            TestStep navigateStep = new TestStep();
            navigateStep.setType(TestStepType.NAVIGATE);
            navigateStep.setDescription("Navigate to " + page.getUrl());
            navigateStep.setTarget(page.getUrl());
            steps.add(navigateStep);
            
            // Step 2: Verify page title
            if (page.getTitle() != null && !page.getTitle().isEmpty()) {
                TestStep titleStep = new TestStep();
                titleStep.setType(TestStepType.ASSERT_TITLE);
                titleStep.setDescription("Verify page title is correct");
                titleStep.setTarget(page.getTitle());
                steps.add(titleStep);
            }
            
            // Add verification steps for key elements
            List<WebElement> keyElements = page.getElements().stream()
                    .filter(e -> e.getType() == ElementType.TEXT || e.getType() == ElementType.BUTTON)
                    .limit(3)
                    .collect(Collectors.toList());
            
            for (WebElement element : keyElements) {
                TestStep verifyStep = new TestStep();
                verifyStep.setType(TestStepType.ASSERT_ELEMENT);
                verifyStep.setDescription("Verify element: " + element.getText());
                verifyStep.setTarget(element.getSelector());
                steps.add(verifyStep);
            }
            
            testCase.setSteps(steps);
            suite.getTestCases().add(testCase);
        }
        
        // Generate navigation flow test cases
        if (application.getPages().size() > 1) {
            TestCase navigationFlowTest = new TestCase();
            navigationFlowTest.setName("Navigation Flow Test");
            navigationFlowTest.setDescription("Verifies navigation between pages");
            
            List<TestStep> steps = new ArrayList<>();
            
            // Start at the first page
            WebPage startPage = application.getPages().get(0);
            TestStep startStep = new TestStep();
            startStep.setType(TestStepType.NAVIGATE);
            startStep.setDescription("Navigate to starting page");
            startStep.setTarget(startPage.getUrl());
            steps.add(startStep);
            
            // Navigate through links to other pages
            Set<String> visitedUrls = new HashSet<>();
            visitedUrls.add(startPage.getUrl());
            
            // Add navigation steps for up to 5 pages
            int navigationCount = 0;
            for (WebPage page : application.getPages()) {
                if (navigationCount >= 5) {
                    break;
                }
                
                List<WebElement> links = page.getElements().stream()
                        .filter(e -> e.getType() == ElementType.LINK)
                        .filter(e -> e.getHref() != null && !e.getHref().isEmpty())
                        .filter(e -> !visitedUrls.contains(e.getHref()))
                        .collect(Collectors.toList());
                
                if (!links.isEmpty()) {
                    WebElement link = links.get(0);
                    
                    // Click step
                    TestStep clickStep = new TestStep();
                    clickStep.setType(TestStepType.CLICK);
                    clickStep.setDescription("Click on link: " + link.getText());
                    clickStep.setTarget(link.getSelector());
                    steps.add(clickStep);
                    
                    // Verify navigation
                    TestStep verifyStep = new TestStep();
                    verifyStep.setType(TestStepType.ASSERT_URL);
                    verifyStep.setDescription("Verify navigation to: " + link.getHref());
                    verifyStep.setTarget(link.getHref());
                    steps.add(verifyStep);
                    
                    visitedUrls.add(link.getHref());
                    navigationCount++;
                }
            }
            
            navigationFlowTest.setSteps(steps);
            suite.getTestCases().add(navigationFlowTest);
        }
        
        return suite;
    }
    
    /**
     * Generates a test suite for form interaction scenarios
     * @param project The project to generate tests for
     * @param application The analyzed web application
     * @return A test suite for form scenarios
     */
    private TestSuite generateFormTestSuite(Project project, WebApplication application) {
        TestSuite suite = new TestSuite();
        suite.setName("Form Tests");
        suite.setDescription("Tests form interaction functionality");
        suite.setCreatedAt(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT)));
        
        // Find pages with forms
        List<WebPage> pagesWithForms = application.getPages().stream()
                .filter(p -> !p.getForms().isEmpty())
                .collect(Collectors.toList());
        
        for (WebPage page : pagesWithForms) {
            for (WebForm form : page.getForms()) {
                // Generate happy path test case
                TestCase happyPathTest = generateFormHappyPathTest(page, form);
                suite.getTestCases().add(happyPathTest);
                
                // Generate validation test case if form has required fields
                boolean hasRequiredFields = form.getFields().stream()
                        .anyMatch(WebElement::isRequired);
                
                if (hasRequiredFields) {
                    TestCase validationTest = generateFormValidationTest(page, form);
                    suite.getTestCases().add(validationTest);
                }
            }
        }
        
        return suite;
    }
    
    /**
     * Generates a happy path test case for a form
     * @param page The page containing the form
     * @param form The form to generate a test for
     * @return A test case for the happy path scenario
     */
    private TestCase generateFormHappyPathTest(WebPage page, WebForm form) {
        TestCase testCase = new TestCase();
        testCase.setName("Form Submission Test - " + getFormName(form));
        testCase.setDescription("Tests successful submission of the form");
        
        List<TestStep> steps = new ArrayList<>();
        
        // Step 1: Navigate to page
        TestStep navigateStep = new TestStep();
        navigateStep.setType(TestStepType.NAVIGATE);
        navigateStep.setDescription("Navigate to " + page.getUrl());
        navigateStep.setTarget(page.getUrl());
        steps.add(navigateStep);
        
        // Fill out form fields
        for (WebElement field : form.getFields()) {
            if (field.getType() != ElementType.BUTTON) {
                TestStep fillStep = generateFillFormFieldStep(field, true);
                steps.add(fillStep);
            }
        }
        
        // Find and click submit button
        WebElement submitButton = findSubmitButton(form);
        if (submitButton != null) {
            TestStep submitStep = new TestStep();
            submitStep.setType(TestStepType.CLICK);
            submitStep.setDescription("Click submit button");
            submitStep.setTarget(submitButton.getSelector());
            steps.add(submitStep);
            
            // Add verification step (generic)
            TestStep verifyStep = new TestStep();
            verifyStep.setType(TestStepType.WAIT);
            verifyStep.setDescription("Wait for form submission to complete");
            verifyStep.setTarget("2000");  // 2 seconds
            steps.add(verifyStep);
        }
        
        testCase.setSteps(steps);
        return testCase;
    }
    
    /**
     * Generates a validation test case for a form
     * @param page The page containing the form
     * @param form The form to generate a test for
     * @return A test case for the validation scenario
     */
    private TestCase generateFormValidationTest(WebPage page, WebForm form) {
        TestCase testCase = new TestCase();
        testCase.setName("Form Validation Test - " + getFormName(form));
        testCase.setDescription("Tests form validation for required fields");
        
        List<TestStep> steps = new ArrayList<>();
        
        // Step 1: Navigate to page
        TestStep navigateStep = new TestStep();
        navigateStep.setType(TestStepType.NAVIGATE);
        navigateStep.setDescription("Navigate to " + page.getUrl());
        navigateStep.setTarget(page.getUrl());
        steps.add(navigateStep);
        
        // Fill out only optional fields
        for (WebElement field : form.getFields()) {
            if (field.getType() != ElementType.BUTTON && !field.isRequired()) {
                TestStep fillStep = generateFillFormFieldStep(field, true);
                steps.add(fillStep);
            }
        }
        
        // Find and click submit button
        WebElement submitButton = findSubmitButton(form);
        if (submitButton != null) {
            TestStep submitStep = new TestStep();
            submitStep.setType(TestStepType.CLICK);
            submitStep.setDescription("Click submit button");
            submitStep.setTarget(submitButton.getSelector());
            steps.add(submitStep);
            
            // Verify that form was not submitted (still on same page)
            TestStep verifyStep = new TestStep();
            verifyStep.setType(TestStepType.ASSERT_URL);
            verifyStep.setDescription("Verify still on same page (form not submitted)");
            verifyStep.setTarget(page.getUrl());
            steps.add(verifyStep);
        }
        
        testCase.setSteps(steps);
        return testCase;
    }
    
    /**
     * Generates a test suite for visual verification
     * @param project The project to generate tests for
     * @param application The analyzed web application
     * @return A test suite for visual verification
     */
    private TestSuite generateVisualVerificationTestSuite(Project project, WebApplication application) {
        TestSuite suite = new TestSuite();
        suite.setName("Visual Verification Tests");
        suite.setDescription("Tests for visual regression and UI consistency");
        suite.setCreatedAt(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT)));
        
        // Generate visual verification test for each page
        for (WebPage page : application.getPages()) {
            TestCase testCase = new TestCase();
            testCase.setName("Visual Verification - " + getPageName(page));
            testCase.setDescription("Verifies visual appearance of the page");
            
            List<TestStep> steps = new ArrayList<>();
            
            // Step 1: Navigate to page
            TestStep navigateStep = new TestStep();
            navigateStep.setType(TestStepType.NAVIGATE);
            navigateStep.setDescription("Navigate to " + page.getUrl());
            navigateStep.setTarget(page.getUrl());
            steps.add(navigateStep);
            
            // Step 2: Capture screenshot
            TestStep screenshotStep = new TestStep();
            screenshotStep.setType(TestStepType.SCREENSHOT);
            screenshotStep.setDescription("Capture page screenshot");
            screenshotStep.setTarget("page");
            steps.add(screenshotStep);
            
            // Steps 3-5: Verify specific visual elements
            List<WebElement> visualElements = page.getElements().stream()
                    .filter(e -> e.getType() == ElementType.BUTTON || 
                                e.getType() == ElementType.LINK || 
                                e.getType() == ElementType.TEXT)
                    .limit(3)
                    .collect(Collectors.toList());
            
            for (WebElement element : visualElements) {
                TestStep elementScreenshotStep = new TestStep();
                elementScreenshotStep.setType(TestStepType.SCREENSHOT);
                elementScreenshotStep.setDescription("Capture element screenshot: " + element.getText());
                elementScreenshotStep.setTarget(element.getSelector());
                steps.add(elementScreenshotStep);
            }
            
            testCase.setSteps(steps);
            suite.getTestCases().add(testCase);
        }
        
        return suite;
    }
    
    /**
     * Generates a test step to fill a form field
     * @param field The form field to fill
     * @param validData Whether to use valid data
     * @return A test step for filling the form field
     */
    private TestStep generateFillFormFieldStep(WebElement field, boolean validData) {
        TestStep step = new TestStep();
        
        switch (field.getType()) {
            case TEXT_INPUT:
            case EMAIL_INPUT:
            case PASSWORD_INPUT:
            case NUMBER_INPUT:
            case TEXTAREA:
                step.setType(TestStepType.FILL);
                step.setDescription("Fill " + getFieldName(field));
                step.setTarget(field.getSelector());
                step.setValue(generateValueForField(field, validData));
                break;
                
            case CHECKBOX:
            case RADIO_BUTTON:
                step.setType(TestStepType.CLICK);
                step.setDescription("Click " + getFieldName(field));
                step.setTarget(field.getSelector());
                break;
                
            case SELECT:
                step.setType(TestStepType.SELECT);
                step.setDescription("Select option in " + getFieldName(field));
                step.setTarget(field.getSelector());
                
                if (field.getOptions() != null && !field.getOptions().isEmpty()) {
                    int optionIndex = random.nextInt(field.getOptions().size());
                    step.setValue(field.getOptions().get(optionIndex));
                } else {
                    step.setValue("Option 1");
                }
                break;
                
            case FILE_UPLOAD:
                step.setType(TestStepType.UPLOAD);
                step.setDescription("Upload file to " + getFieldName(field));
                step.setTarget(field.getSelector());
                step.setValue("test-file.txt");
                break;
                
            default:
                // Skip other field types
                return null;
        }
        
        return step;
    }
    
    /**
     * Finds the submit button for a form
     * @param form The form to find the submit button for
     * @return The submit button element
     */
    private WebElement findSubmitButton(WebForm form) {
        // First look for submit type buttons
        Optional<WebElement> submitButton = form.getFields().stream()
                .filter(e -> e.getType() == ElementType.BUTTON && 
                           (e.getCategory() != null && e.getCategory().equals("submit-button")))
                .findFirst();
        
        if (submitButton.isPresent()) {
            return submitButton.get();
        }
        
        // Then look for any button
        Optional<WebElement> anyButton = form.getFields().stream()
                .filter(e -> e.getType() == ElementType.BUTTON)
                .findFirst();
        
        return anyButton.orElse(null);
    }
    
    /**
     * Generates a value for a form field based on its type
     * @param field The form field
     * @param validData Whether to generate valid data
     * @return A generated value for the field
     */
    private String generateValueForField(WebElement field, boolean validData) {
        if (!validData) {
            return "";  // For invalid data, return empty string
        }
        
        switch (field.getType()) {
            case TEXT_INPUT:
                if (field.getName() != null) {
                    String name = field.getName().toLowerCase();
                    if (name.contains("name")) {
                        return "Test User";
                    } else if (name.contains("first")) {
                        return "Test";
                    } else if (name.contains("last")) {
                        return "User";
                    } else if (name.contains("address")) {
                        return "123 Test Street";
                    } else if (name.contains("city")) {
                        return "Test City";
                    } else if (name.contains("state")) {
                        return "Test State";
                    } else if (name.contains("zip") || name.contains("postal")) {
                        return "12345";
                    } else if (name.contains("phone")) {
                        return "555-123-4567";
                    }
                }
                return "Test Input";
                
            case EMAIL_INPUT:
                return "test@example.com";
                
            case PASSWORD_INPUT:
                return "Password123!";
                
            case NUMBER_INPUT:
                if (field.getName() != null) {
                    String name = field.getName().toLowerCase();
                    if (name.contains("age")) {
                        return "30";
                    } else if (name.contains("quantity")) {
                        return "1";
                    } else if (name.contains("price") || name.contains("amount")) {
                        return "99.99";
                    }
                }
                return "42";
                
            case TEXTAREA:
                return "This is a test comment or message that is being entered into this text area field for testing purposes.";
                
            default:
                return "Test Value";
        }
    }
    
    /**
     * Gets a readable name for a page
     * @param page The page
     * @return A readable name
     */
    private String getPageName(WebPage page) {
        if (page.getTitle() != null && !page.getTitle().isEmpty()) {
            return page.getTitle();
        }
        
        String url = page.getUrl();
        if (url.endsWith("/")) {
            url = url.substring(0, url.length() - 1);
        }
        
        int lastSlash = url.lastIndexOf('/');
        if (lastSlash >= 0 && lastSlash < url.length() - 1) {
            return url.substring(lastSlash + 1);
        }
        
        return url;
    }
    
    /**
     * Gets a readable name for a form
     * @param form The form
     * @return A readable name
     */
    private String getFormName(WebForm form) {
        if (form.getAction() != null && !form.getAction().isEmpty()) {
            String action = form.getAction();
            int lastSlash = action.lastIndexOf('/');
            if (lastSlash >= 0 && lastSlash < action.length() - 1) {
                return action.substring(lastSlash + 1);
            }
            return action;
        }
        
        return "Form " + form.getSelector();
    }
    
    /**
     * Gets a readable name for a field
     * @param field The field
     * @return A readable name
     */
    private String getFieldName(WebElement field) {
        if (field.getName() != null && !field.getName().isEmpty()) {
            return "field '" + field.getName() + "'";
        }
        
        if (field.getId() != null && !field.getId().isEmpty()) {
            return "field with id '" + field.getId() + "'";
        }
        
        if (field.getText() != null && !field.getText().isEmpty()) {
            return "field with text '" + field.getText() + "'";
        }
        
        return "field " + field.getSelector();
    }
    
    /**
     * Saves a test suite to the file system
     * @param project The project
     * @param suite The test suite to save
     */
    private void saveTestSuite(Project project, TestSuite suite) {
        try {
            // Create directory structure
            String projectDir = project.getPath();
            String suitesDir = projectDir + "/test-suites";
            
            Path path = Paths.get(suitesDir);
            if (!Files.exists(path)) {
                Files.createDirectories(path);
            }
            
            // Generate suite ID if not present
            if (suite.getId() == null || suite.getId().isEmpty()) {
                suite.setId(UUID.randomUUID().toString());
            }
            
            // Save suite JSON
            String suiteJson = convertToJson(suite);
            String suiteFile = suitesDir + "/" + suite.getId() + ".json";
            
            FileUtils.writeStringToFile(new File(suiteFile), suiteJson, StandardCharsets.UTF_8);
            
            // Generate script files for each test case
            String scriptsDir = projectDir + "/test-scripts";
            path = Paths.get(scriptsDir);
            if (!Files.exists(path)) {
                Files.createDirectories(path);
            }
            
            for (TestCase testCase : suite.getTestCases()) {
                if (testCase.getId() == null || testCase.getId().isEmpty()) {
                    testCase.setId(UUID.randomUUID().toString());
                }
                
                String scriptContent = generateTestScript(testCase);
                String scriptFile = scriptsDir + "/" + testCase.getId() + ".js";
                
                FileUtils.writeStringToFile(new File(scriptFile), scriptContent, StandardCharsets.UTF_8);
            }
            
        } catch (IOException e) {
            log.error("Error saving test suite: {}", suite.getName(), e);
        }
    }
    
    /**
     * Generates a test script for a test case
     * @param testCase The test case
     * @return The generated script content
     */
    private String generateTestScript(TestCase testCase) {
        StringBuilder script = new StringBuilder();
        
        // Add header
        script.append("// Test Case: ").append(testCase.getName()).append("\n");
        script.append("// Generated: ").append(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT))).append("\n\n");
        
        // Add imports
        script.append("const { test, expect } = require('@playwright/test');\n\n");
        
        // Add test function
        script.append("test('").append(testCase.getName()).append("', async ({ page }) => {\n");
        
        // Add test steps
        for (TestStep step : testCase.getSteps()) {
            script.append("  // ").append(step.getDescription()).append("\n");
            
            switch (step.getType()) {
                case NAVIGATE:
                    script.append("  await page.goto('").append(step.getTarget()).append("');\n");
                    break;
                    
                case CLICK:
                    script.append("  await page.click('").append(step.getTarget()).append("');\n");
                    break;
                    
                case FILL:
                    script.append("  await page.fill('").append(step.getTarget()).append("', '")
                          .append(step.getValue()).append("');\n");
                    break;
                    
                case SELECT:
                    script.append("  await page.selectOption('").append(step.getTarget()).append("', '")
                          .append(step.getValue()).append("');\n");
                    break;
                    
                case UPLOAD:
                    script.append("  await page.setInputFiles('").append(step.getTarget()).append("', '")
                          .append(step.getValue()).append("');\n");
                    break;
                    
                case WAIT:
                    script.append("  await page.waitForTimeout(").append(step.getTarget()).append(");\n");
                    break;
                    
                case ASSERT_TITLE:
                    script.append("  await expect(page).toHaveTitle(/").append(step.getTarget()).append("/);\n");
                    break;
                    
                case ASSERT_URL:
                    script.append("  await expect(page).toHaveURL(/").append(step.getTarget()).append("/);\n");
                    break;
                    
                case ASSERT_ELEMENT:
                    script.append("  await expect(page.locator('").append(step.getTarget()).append("')).toBeVisible();\n");
                    break;
                    
                case SCREENSHOT:
                    if (step.getTarget().equals("page")) {
                        script.append("  await page.screenshot({ path: 'screenshots/")
                              .append(testCase.getId()).append("_page.png' });\n");
                    } else {
                        script.append("  await page.locator('").append(step.getTarget())
                              .append("').screenshot({ path: 'screenshots/")
                              .append(testCase.getId()).append("_element_")
                              .append(System.currentTimeMillis()).append(".png' });\n");
                    }
                    break;
                    
                default:
                    script.append("  // Unsupported step type: ").append(step.getType()).append("\n");
            }
            
            script.append("\n");
        }
        
        script.append("});\n");
        
        return script.toString();
    }
    
    /**
     * Converts an object to JSON
     * @param object The object to convert
     * @return The JSON representation
     */
    private String convertToJson(Object object) {
        // Note: In a real implementation, this would use Jackson or Gson
        // This is a simplified placeholder
        return "{ \"id\": \"" + UUID.randomUUID().toString() + "\", \"name\": \"" + object.toString() + "\" }";
    }
}


package com.ctgp.service.generator;

import com.ctgp.model.analyzer.*;
import com.ctgp.model.workspace.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class AdvancedTestGeneratorService {

    private final TestGeneratorService basicTestGenerator;
    private static final String DATE_FORMAT = "yyyy-MM-dd HH:mm:ss";
    private static final Pattern EMAIL_PATTERN = Pattern.compile("^[A-Za-z0-9+_.-]+@(.+)$");
    private static final Pattern NUMERIC_PATTERN = Pattern.compile("^\\d+$");
    private static final Random random = new Random();

    /**
     * Generates advanced test suites with workflow detection and data-driven tests
     * @param project The project to generate tests for
     * @param application The analyzed web application
     * @return A list of generated test suites
     */
    public List<TestSuite> generateAdvancedTestSuites(Project project, WebApplication application) {
        log.info("Generating advanced test suites for project: {}", project.getName());
        
        List<TestSuite> testSuites = new ArrayList<>();
        
        // Generate workflow test suite
        TestSuite workflowSuite = generateWorkflowTestSuite(project, application);
        testSuites.add(workflowSuite);
        
        // Generate data-driven test suite
        TestSuite dataDrivenSuite = generateDataDrivenTestSuite(project, application);
        testSuites.add(dataDrivenSuite);
        
        // Generate visual regression test suite
        TestSuite visualRegressionSuite = generateVisualRegressionTestSuite(project, application);
        testSuites.add(visualRegressionSuite);
        
        log.info("Generated {} advanced test suites with {} total test cases", 
                testSuites.size(), 
                testSuites.stream().mapToInt(s -> s.getTestCases().size()).sum());
        
        return testSuites;
    }
    
    /**
     * Generates a test suite for detected workflows
     * @param project The project
     * @param application The web application
     * @return A test suite with workflow test cases
     */
    private TestSuite generateWorkflowTestSuite(Project project, WebApplication application) {
        TestSuite suite = new TestSuite();
        suite.setName("Workflow Tests");
        suite.setDescription("Tests that verify end-to-end user workflows");
        suite.setCreatedAt(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT)));
        
        // Detect potential workflows
        List<Workflow> workflows = detectWorkflows(application);
        
        // Generate test cases for each workflow
        for (Workflow workflow : workflows) {
            TestCase testCase = new TestCase();
            testCase.setId(UUID.randomUUID().toString());
            testCase.setName("Workflow Test - " + workflow.getName());
            testCase.setDescription("Tests the " + workflow.getName() + " workflow");
            
            List<TestStep> steps = new ArrayList<>();
            
            // First step: Navigate to starting page
            TestStep navigateStep = new TestStep();
            navigateStep.setType(TestStepType.NAVIGATE);
            navigateStep.setDescription("Navigate to starting page");
            navigateStep.setTarget(workflow.getStartPage().getUrl());
            steps.add(navigateStep);
            
            // Add steps for each workflow step
            for (WorkflowStep workflowStep : workflow.getSteps()) {
                steps.addAll(generateTestStepsForWorkflowStep(workflowStep));
            }
            
            testCase.setSteps(steps);
            suite.getTestCases().add(testCase);
        }
        
        return suite;
    }
    
    /**
     * Generates test steps for a workflow step
     * @param workflowStep The workflow step
     * @return List of test steps
     */
    private List<TestStep> generateTestStepsForWorkflowStep(WorkflowStep workflowStep) {
        List<TestStep> steps = new ArrayList<>();
        
        switch (workflowStep.getType()) {
            case NAVIGATION:
                // Add a click step for the navigation
                TestStep clickNavStep = new TestStep();
                clickNavStep.setType(TestStepType.CLICK);
                clickNavStep.setDescription("Click on navigation element: " + workflowStep.getElement().getText());
                clickNavStep.setTarget(workflowStep.getElement().getSelector());
                steps.add(clickNavStep);
                
                // Verify navigation
                TestStep verifyNavStep = new TestStep();
                verifyNavStep.setType(TestStepType.ASSERT_URL);
                verifyNavStep.setDescription("Verify navigation to: " + workflowStep.getTargetUrl());
                verifyNavStep.setTarget(workflowStep.getTargetUrl());
                steps.add(verifyNavStep);
                break;
                
            case FORM_SUBMISSION:
                // Get form
                WebForm form = workflowStep.getForm();
                
                // Fill out form fields
                for (WebElement field : form.getFields()) {
                    if (field.getType() != ElementType.BUTTON) {
                        // Generate appropriate test step for the field
                        TestStep fillStep = generateFormFieldStep(field);
                        if (fillStep != null) {
                            steps.add(fillStep);
                        }
                    }
                }
                
                // Find and click submit button
                WebElement submitButton = findSubmitButton(form);
                if (submitButton != null) {
                    TestStep submitStep = new TestStep();
                    submitStep.setType(TestStepType.CLICK);
                    submitStep.setDescription("Click submit button");
                    submitStep.setTarget(submitButton.getSelector());
                    steps.add(submitStep);
                    
                    // Add verification step if target URL is known
                    if (workflowStep.getTargetUrl() != null && !workflowStep.getTargetUrl().isEmpty()) {
                        TestStep verifyFormStep = new TestStep();
                        verifyFormStep.setType(TestStepType.ASSERT_URL);
                        verifyFormStep.setDescription("Verify navigation after form submission");
                        verifyFormStep.setTarget(workflowStep.getTargetUrl());
                        steps.add(verifyFormStep);
                    } else {
                        // Generic wait for form submission
                        TestStep waitStep = new TestStep();
                        waitStep.setType(TestStepType.WAIT);
                        waitStep.setDescription("Wait for form submission to complete");
                        waitStep.setTarget("2000");  // 2 seconds
                        steps.add(waitStep);
                    }
                }
                break;
                
            case INTERACTION:
                // Add click step for the interaction
                TestStep clickStep = new TestStep();
                clickStep.setType(TestStepType.CLICK);
                clickStep.setDescription("Click on interactive element: " + workflowStep.getElement().getText());
                clickStep.setTarget(workflowStep.getElement().getSelector());
                steps.add(clickStep);
                
                // Add verification step if applicable
                if (workflowStep.getVerificationElement() != null) {
                    TestStep verifyInteractionStep = new TestStep();
                    verifyInteractionStep.setType(TestStepType.ASSERT_ELEMENT);
                    verifyInteractionStep.setDescription("Verify element appears after interaction");
                    verifyInteractionStep.setTarget(workflowStep.getVerificationElement().getSelector());
                    steps.add(verifyInteractionStep);
                }
                break;
        }
        
        return steps;
    }
    
    /**
     * Generates a test suite with data-driven tests for forms
     * @param project The project
     * @param application The web application
     * @return A test suite with data-driven test cases
     */
    private TestSuite generateDataDrivenTestSuite(Project project, WebApplication application) {
        TestSuite suite = new TestSuite();
        suite.setName("Data-Driven Tests");
        suite.setDescription("Tests forms with various data inputs including valid, invalid, and boundary values");
        suite.setCreatedAt(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT)));
        
        // Find pages with forms
        List<WebPage> pagesWithForms = application.getPages().stream()
                .filter(p -> !p.getForms().isEmpty())
                .collect(Collectors.toList());
        
        for (WebPage page : pagesWithForms) {
            for (WebForm form : page.getForms()) {
                // Generate valid data test
                TestCase validDataTest = generateDataDrivenTest(
                    page, form, "Valid Data", "Tests form submission with valid data", 
                    DataTestType.VALID_DATA
                );
                suite.getTestCases().add(validDataTest);
                
                // Generate invalid data test
                TestCase invalidDataTest = generateDataDrivenTest(
                    page, form, "Invalid Data", "Tests form validation with invalid data", 
                    DataTestType.INVALID_DATA
                );
                suite.getTestCases().add(invalidDataTest);
                
                // Generate boundary value test
                TestCase boundaryValueTest = generateDataDrivenTest(
                    page, form, "Boundary Values", "Tests form with boundary value data", 
                    DataTestType.BOUNDARY_VALUES
                );
                suite.getTestCases().add(boundaryValueTest);
            }
        }
        
        return suite;
    }
    
    /**
     * Generates a data-driven test case for a form
     * @param page The page containing the form
     * @param form The form to test
     * @param nameSuffix The suffix for the test name
     * @param description The test description
     * @param dataType The type of data to use
     * @return A test case
     */
    private TestCase generateDataDrivenTest(WebPage page, WebForm form, String nameSuffix, 
                                          String description, DataTestType dataType) {
        TestCase testCase = new TestCase();
        testCase.setId(UUID.randomUUID().toString());
        testCase.setName("Form " + nameSuffix + " Test - " + getFormName(form));
        testCase.setDescription(description);
        
        List<TestStep> steps = new ArrayList<>();
        
        // Navigate to page
        TestStep navigateStep = new TestStep();
        navigateStep.setType(TestStepType.NAVIGATE);
        navigateStep.setDescription("Navigate to " + page.getUrl());
        navigateStep.setTarget(page.getUrl());
        steps.add(navigateStep);
        
        // Fill form fields with appropriate data
        for (WebElement field : form.getFields()) {
            if (field.getType() != ElementType.BUTTON) {
                TestStep fillStep = generateDataDrivenFieldStep(field, dataType);
                if (fillStep != null) {
                    steps.add(fillStep);
                }
            }
        }
        
        // Find and click submit button
        WebElement submitButton = findSubmitButton(form);
        if (submitButton != null) {
            TestStep submitStep = new TestStep();
            submitStep.setType(TestStepType.CLICK);
            submitStep.setDescription("Click submit button");
            submitStep.setTarget(submitButton.getSelector());
            steps.add(submitStep);
            
            // Add appropriate verification
            if (dataType == DataTestType.VALID_DATA) {
                // For valid data, expect successful submission
                TestStep waitStep = new TestStep();
                waitStep.setType(TestStepType.WAIT);
                waitStep.setDescription("Wait for form submission to complete");
                waitStep.setTarget("2000");  // 2 seconds
                steps.add(waitStep);
            } else {
                // For invalid or boundary data, verify form validation
                TestStep verifyStep = new TestStep();
                verifyStep.setType(TestStepType.ASSERT_URL);
                verifyStep.setDescription("Verify still on same page (form validation triggered)");
                verifyStep.setTarget(page.getUrl());
                steps.add(verifyStep);
            }
        }
        
        testCase.setSteps(steps);
        return testCase;
    }
    
    /**
     * Generates a visual regression test suite
     * @param project The project
     * @param application The web application
     * @return A test suite with visual regression tests
     */
    private TestSuite generateVisualRegressionTestSuite(Project project, WebApplication application) {
        TestSuite suite = new TestSuite();
        suite.setName("Visual Regression Tests");
        suite.setDescription("Advanced tests for visual appearance and layout consistency");
        suite.setCreatedAt(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT)));
        
        // Generate responsive design test cases
        for (WebPage page : application.getPages()) {
            TestCase responsiveTest = generateResponsiveDesignTest(page);
            suite.getTestCases().add(responsiveTest);
        }
        
        // Generate layout consistency test
        TestCase layoutConsistencyTest = generateLayoutConsistencyTest(application);
        suite.getTestCases().add(layoutConsistencyTest);
        
        return suite;
    }
    
    /**
     * Generates a responsive design test case
     * @param page The page to test
     * @return A test case
     */
    private TestCase generateResponsiveDesignTest(WebPage page) {
        TestCase testCase = new TestCase();
        testCase.setId(UUID.randomUUID().toString());
        testCase.setName("Responsive Design Test - " + getPageName(page));
        testCase.setDescription("Tests page appearance at different screen sizes");
        
        List<TestStep> steps = new ArrayList<>();
        
        // Navigate to page
        TestStep navigateStep = new TestStep();
        navigateStep.setType(TestStepType.NAVIGATE);
        navigateStep.setDescription("Navigate to " + page.getUrl());
        navigateStep.setTarget(page.getUrl());
        steps.add(navigateStep);
        
        // Test different viewport sizes
        int[][] viewportSizes = {
            {1920, 1080}, // Desktop
            {1024, 768},  // Tablet landscape
            {768, 1024},  // Tablet portrait
            {375, 812}    // Mobile
        };
        
        for (int[] size : viewportSizes) {
            // Set viewport size
            TestStep viewportStep = new TestStep();
            viewportStep.setType(TestStepType.VIEWPORT);
            viewportStep.setDescription("Set viewport to " + size[0] + "x" + size[1]);
            viewportStep.setTarget(size[0] + "," + size[1]);
            steps.add(viewportStep);
            
            // Take screenshot
            TestStep screenshotStep = new TestStep();
            screenshotStep.setType(TestStepType.SCREENSHOT);
            screenshotStep.setDescription("Capture screenshot at " + size[0] + "x" + size[1]);
            screenshotStep.setTarget("page");
            steps.add(screenshotStep);
        }
        
        testCase.setSteps(steps);
        return testCase;
    }
    
    /**
     * Generates a layout consistency test case
     * @param application The web application
     * @return A test case
     */
    private TestCase generateLayoutConsistencyTest(WebApplication application) {
        TestCase testCase = new TestCase();
        testCase.setId(UUID.randomUUID().toString());
        testCase.setName("Layout Consistency Test");
        testCase.setDescription("Tests consistency of layout elements across pages");
        
        List<TestStep> steps = new ArrayList<>();
        
        // Select key pages to test (limit to 5)
        List<WebPage> pagesToTest = application.getPages().stream()
                .limit(5)
                .collect(Collectors.toList());
        
        for (WebPage page : pagesToTest) {
            // Navigate to page
            TestStep navigateStep = new TestStep();
            navigateStep.setType(TestStepType.NAVIGATE);
            navigateStep.setDescription("Navigate to " + page.getUrl());
            navigateStep.setTarget(page.getUrl());
            steps.add(navigateStep);
            
            // Check common elements (header, footer, navigation)
            String[] commonSelectors = {
                "header", "nav", "footer", ".logo", ".main-menu"
            };
            
            for (String selector : commonSelectors) {
                TestStep assertStep = new TestStep();
                assertStep.setType(TestStepType.ASSERT_ELEMENT);
                assertStep.setDescription("Verify common element exists: " + selector);
                assertStep.setTarget(selector);
                steps.add(assertStep);
            }
            
            // Take screenshot for comparison
            TestStep screenshotStep = new TestStep();
            screenshotStep.setType(TestStepType.SCREENSHOT);
            screenshotStep.setDescription("Capture screenshot for layout comparison");
            screenshotStep.setTarget("page");
            steps.add(screenshotStep);
        }
        
        testCase.setSteps(steps);
        return testCase;
    }
    
    /**
     * Detects potential workflows in the application
     * @param application The web application
     * @return List of detected workflows
     */
    private List<Workflow> detectWorkflows(WebApplication application) {
        List<Workflow> workflows = new ArrayList<>();
        
        // Try to find login/signup workflow
        Workflow authWorkflow = detectAuthenticationWorkflow(application);
        if (authWorkflow != null) {
            workflows.add(authWorkflow);
        }
        
        // Try to find form submission workflows
        List<Workflow> formWorkflows = detectFormSubmissionWorkflows(application);
        workflows.addAll(formWorkflows);
        
        // Try to find multi-step workflows
        List<Workflow> multiStepWorkflows = detectMultiStepWorkflows(application);
        workflows.addAll(multiStepWorkflows);
        
        return workflows;
    }
    
    /**
     * Detects authentication workflows (login/signup)
     * @param application The web application
     * @return Detected workflow or null
     */
    private Workflow detectAuthenticationWorkflow(WebApplication application) {
        // Look for login/signup pages
        Optional<WebPage> loginPage = findPageWithAuthForm(application, "login");
        Optional<WebPage> signupPage = findPageWithAuthForm(application, "signup");
        
        if (loginPage.isPresent()) {
            // Create login workflow
            Workflow workflow = new Workflow();
            workflow.setName("Login");
            workflow.setStartPage(loginPage.get());
            
            List<WorkflowStep> steps = new ArrayList<>();
            
            // Add form submission step
            WebForm loginForm = findAuthForm(loginPage.get(), "login");
            if (loginForm != null) {
                WorkflowStep formStep = new WorkflowStep();
                formStep.setType(WorkflowStepType.FORM_SUBMISSION);
                formStep.setForm(loginForm);
                
                // Try to determine target URL after login
                if (application.getPages().size() > 1) {
                    // Assume first non-login page might be the dashboard/home
                    Optional<WebPage> targetPage = application.getPages().stream()
                            .filter(p -> !p.equals(loginPage.get()))
                            .findFirst();
                    
                    if (targetPage.isPresent()) {
                        formStep.setTargetUrl(targetPage.get().getUrl());
                    }
                }
                
                steps.add(formStep);
            }
            
            workflow.setSteps(steps);
            return workflow;
        } else if (signupPage.isPresent()) {
            // Create signup workflow
            Workflow workflow = new Workflow();
            workflow.setName("Signup");
            workflow.setStartPage(signupPage.get());
            
            List<WorkflowStep> steps = new ArrayList<>();
            
            // Add form submission step
            WebForm signupForm = findAuthForm(signupPage.get(), "signup");
            if (signupForm != null) {
                WorkflowStep formStep = new WorkflowStep();
                formStep.setType(WorkflowStepType.FORM_SUBMISSION);
                formStep.setForm(signupForm);
                
                // Try to determine target URL after signup
                if (application.getPages().size() > 1) {
                    // Assume first non-signup page might be the confirmation/login page
                    Optional<WebPage> targetPage = application.getPages().stream()
                            .filter(p -> !p.equals(signupPage.get()))
                            .findFirst();
                    
                    if (targetPage.isPresent()) {
                        formStep.setTargetUrl(targetPage.get().getUrl());
                    }
                }
                
                steps.add(formStep);
            }
            
            workflow.setSteps(steps);
            return workflow;
        }
        
        return null;
    }
    
    /**
     * Finds a page with authentication form
     * @param application The web application
     * @param authType "login" or "signup"
     * @return Optional containing the page, or empty
     */
    private Optional<WebPage> findPageWithAuthForm(WebApplication application, String authType) {
        return application.getPages().stream()
                .filter(page -> {
                    // Check URL first
                    boolean urlMatch = page.getUrl().toLowerCase().contains(authType) ||
                                     (authType.equals("signup") && page.getUrl().toLowerCase().contains("register"));
                    
                    if (urlMatch) {
                        return true;
                    }
                    
                    // Check title
                    if (page.getTitle() != null) {
                        boolean titleMatch = page.getTitle().toLowerCase().contains(authType) ||
                                          (authType.equals("signup") && page.getTitle().toLowerCase().contains("register"));
                        
                        if (titleMatch) {
                            return true;
                        }
                    }
                    
                    // Check for authentication form
                    return findAuthForm(page, authType) != null;
                })
                .findFirst();
    }
    
    /**
     * Finds an authentication form on a page
     * @param page The page
     * @param authType "login" or "signup"
     * @return The form or null
     */
    private WebForm findAuthForm(WebPage page, String authType) {
        for (WebForm form : page.getForms()) {
            boolean hasPasswordField = form.getFields().stream()
                    .anyMatch(f -> f.getType() == ElementType.PASSWORD_INPUT);
            
            if (!hasPasswordField) {
                continue;
            }
            
            boolean hasEmailField = form.getFields().stream()
                    .anyMatch(f -> f.getType() == ElementType.EMAIL_INPUT ||
                                 (f.getType() == ElementType.TEXT_INPUT && 
                                  (f.getName() != null && f.getName().toLowerCase().contains("email") || 
                                   f.getId() != null && f.getId().toLowerCase().contains("email"))));
            
            if (authType.equals("login")) {
                // Login form typically has password + email/username fields
                boolean hasUsernameField = form.getFields().stream()
                        .anyMatch(f -> f.getType() == ElementType.TEXT_INPUT && 
                                     (f.getName() != null && f.getName().toLowerCase().contains("username") || 
                                      f.getId() != null && f.getId().toLowerCase().contains("username")));
                
                if (hasEmailField || hasUsernameField) {
                    return form;
                }
            } else if (authType.equals("signup")) {
                // Signup form typically has more fields, like name, confirmation fields, etc.
                boolean hasNameField = form.getFields().stream()
                        .anyMatch(f -> f.getType() == ElementType.TEXT_INPUT && 
                                     (f.getName() != null && (f.getName().toLowerCase().contains("name") || 
                                                           f.getName().toLowerCase().contains("first") || 
                                                           f.getName().toLowerCase().contains("last")) || 
                                      f.getId() != null && (f.getId().toLowerCase().contains("name") || 
                                                          f.getId().toLowerCase().contains("first") || 
                                                          f.getId().toLowerCase().contains("last"))));
                
                boolean hasConfirmPasswordField = form.getFields().stream()
                        .filter(f -> f.getType() == ElementType.PASSWORD_INPUT)
                        .count() > 1;
                
                if (hasEmailField && (hasNameField || hasConfirmPasswordField)) {
                    return form;
                }
            }
        }
        
        return null;
    }
    
    /**
     * Detects form submission workflows
     * @param application The web application
     * @return List of form workflows
     */
    private List<Workflow> detectFormSubmissionWorkflows(WebApplication application) {
        List<Workflow> workflows = new ArrayList<>();
        
        for (WebPage page : application.getPages()) {
            for (WebForm form : page.getForms()) {
                // Skip simple forms with less than 3 fields (likely already covered by auth workflows)
                if (form.getFields().size() < 3) {
                    continue;
                }
                
                // Determine form type based on fields
                String formType = determineFormType(form);
                
                Workflow workflow = new Workflow();
                workflow.setName(formType + " Submission");
                workflow.setStartPage(page);
                
                List<WorkflowStep> steps = new ArrayList<>();
                
                // Add form submission step
                WorkflowStep formStep = new WorkflowStep();
                formStep.setType(WorkflowStepType.FORM_SUBMISSION);
                formStep.setForm(form);
                
                // Try to guess target URL
                if (form.getAction() != null && !form.getAction().isEmpty()) {
                    String action = form.getAction();
                    if (action.startsWith("/") || !action.startsWith("http")) {
                        // Relative URL, try to find matching page
                        String targetPath = action.startsWith("/") ? action : "/" + action;
                        Optional<WebPage> targetPage = application.getPages().stream()
                                .filter(p -> p.getUrl().endsWith(targetPath))
                                .findFirst();
                        
                        if (targetPage.isPresent()) {
                            formStep.setTargetUrl(targetPage.get().getUrl());
                        }
                    } else {
                        // Absolute URL
                        formStep.setTargetUrl(action);
                    }
                }
                
                steps.add(formStep);
                workflow.setSteps(steps);
                
                workflows.add(workflow);
            }
        }
        
        return workflows;
    }
    
    /**
     * Detects multi-step workflows
     * @param application The web application
     * @return List of multi-step workflows
     */
    private List<Workflow> detectMultiStepWorkflows(WebApplication application) {
        List<Workflow> workflows = new ArrayList<>();
        
        // Check for sequential pages with navigation links
        Map<String, List<String>> pageConnections = buildPageNavigationGraph(application);
        
        // Find potential workflows (sequences of connected pages)
        for (WebPage startPage : application.getPages()) {
            String startUrl = startPage.getUrl();
            
            if (!pageConnections.containsKey(startUrl)) {
                continue;
            }
            
            // Try to find a path of 3+ connected pages
            List<String> path = findLongestPath(startUrl, pageConnections, new HashSet<>(), 3);
            
            if (path.size() >= 3) {
                Workflow workflow = new Workflow();
                workflow.setName("Multi-Page Workflow");
                workflow.setStartPage(startPage);
                
                List<WorkflowStep> steps = new ArrayList<>();
                
                // Convert path to workflow steps
                String currentUrl = startUrl;
                for (int i = 1; i < path.size(); i++) {
                    String nextUrl = path.get(i);
                    
                    // Find the current page and next page
                    WebPage currentPage = findPageByUrl(application, currentUrl);
                    WebPage nextPage = findPageByUrl(application, nextUrl);
                    
                    if (currentPage != null && nextPage != null) {
                        // Find the link connecting them
                        Optional<WebElement> linkElement = currentPage.getElements().stream()
                                .filter(e -> e.getType() == ElementType.LINK && 
                                           e.getHref() != null &&
                                           nextUrl.endsWith(e.getHref()))
                                .findFirst();
                        
                        if (linkElement.isPresent()) {
                            WorkflowStep navigationStep = new WorkflowStep();
                            navigationStep.setType(WorkflowStepType.NAVIGATION);
                            navigationStep.setElement(linkElement.get());
                            navigationStep.setTargetUrl(nextUrl);
                            steps.add(navigationStep);
                        }
                    }
                    
                    currentUrl = nextUrl;
                }
                
                workflow.setSteps(steps);
                
                if (!steps.isEmpty()) {
                    workflows.add(workflow);
                }
            }
        }
        
        return workflows;
    }
    
    /**
     * Builds a navigation graph of page connections
     * @param application The web application
     * @return Map of page URLs to connected page URLs
     */
    private Map<String, List<String>> buildPageNavigationGraph(WebApplication application) {
        Map<String, List<String>> connections = new HashMap<>();
        
        for (WebPage page : application.getPages()) {
            String pageUrl = page.getUrl();
            List<String> linkedUrls = new ArrayList<>();
            
            // Find all links on the page
            for (WebElement element : page.getElements()) {
                if (element.getType() == ElementType.LINK && element.getHref() != null) {
                    String href = element.getHref();
                    
                    // Find target page
                    Optional<WebPage> targetPage = application.getPages().stream()
                            .filter(p -> p.getUrl().endsWith(href) || p.getUrl().equals(href))
                            .findFirst();
                    
                    if (targetPage.isPresent()) {
                        linkedUrls.add(targetPage.get().getUrl());
                    }
                }
            }
            
            if (!linkedUrls.isEmpty()) {
                connections.put(pageUrl, linkedUrls);
            }
        }
        
        return connections;
    }
    
    /**
     * Recursively finds the longest path from a starting URL
     * @param currentUrl The current URL
     * @param connections The page connections map
     * @param visited Set of visited URLs
     * @param minPathLength The minimum path length to return
     * @return List of URLs in the path
     */
    private List<String> findLongestPath(String currentUrl, Map<String, List<String>> connections,
                                        Set<String> visited, int minPathLength) {
        visited.add(currentUrl);
        
        List<String> longestPath = new ArrayList<>();
        longestPath.add(currentUrl);
        
        if (!connections.containsKey(currentUrl)) {
            return longestPath;
        }
        
        for (String nextUrl : connections.get(currentUrl)) {
            if (!visited.contains(nextUrl)) {
                List<String> path = findLongestPath(nextUrl, connections, new HashSet<>(visited), minPathLength);
                path.add(0, currentUrl);
                
                if (path.size() > longestPath.size()) {
                    longestPath = path;
                }
            }
        }
        
        // Only return the path if it's long enough
        if (longestPath.size() >= minPathLength) {
            return longestPath;
        } else {
            List<String> singlePath = new ArrayList<>();
            singlePath.add(currentUrl);
            return singlePath;
        }
    }
    
    /**
     * Finds a page by URL
     * @param application The web application
     * @param url The URL to find
     * @return The page or null
     */
    private WebPage findPageByUrl(WebApplication application, String url) {
        return application.getPages().stream()
                .filter(p -> p.getUrl().equals(url))
                .findFirst()
                .orElse(null);
    }
    
    /**
     * Determines the type of a form
     * @param form The form
     * @return A descriptive form type
     */
    private String determineFormType(WebForm form) {
        // Check for common field patterns
        boolean hasContactFields = form.getFields().stream()
                .anyMatch(f -> f.getName() != null && 
                             (f.getName().toLowerCase().contains("email") ||
                              f.getName().toLowerCase().contains("name") ||
                              f.getName().toLowerCase().contains("message") ||
                              f.getName().toLowerCase().contains("subject")));
        
        boolean hasAddressFields = form.getFields().stream()
                .anyMatch(f -> f.getName() != null && 
                             (f.getName().toLowerCase().contains("address") ||
                              f.getName().toLowerCase().contains("city") ||
                              f.getName().toLowerCase().contains("state") ||
                              f.getName().toLowerCase().contains("zip") ||
                              f.getName().toLowerCase().contains("postal")));
        
        boolean hasPaymentFields = form.getFields().stream()
                .anyMatch(f -> f.getName() != null && 
                             (f.getName().toLowerCase().contains("card") ||
                              f.getName().toLowerCase().contains("payment") ||
                              f.getName().toLowerCase().contains("credit") ||
                              f.getName().toLowerCase().contains("expir") ||
                              f.getName().toLowerCase().contains("cvv")));
        
        boolean hasSearchFields = form.getFields().stream()
                .anyMatch(f -> f.getName() != null && 
                             (f.getName().toLowerCase().contains("search") ||
                              f.getName().toLowerCase().contains("query") ||
                              f.getName().toLowerCase().contains("keyword")));
        
        // Determine form type based on fields
        if (hasContactFields && !hasAddressFields && !hasPaymentFields) {
            return "Contact";
        } else if (hasAddressFields && !hasPaymentFields) {
            return "Address";
        } else if (hasPaymentFields) {
            return "Payment";
        } else if (hasSearchFields) {
            return "Search";
        } else {
            return "Form";
        }
    }
    
    /**
     * Generates a form field step
     * @param field The form field
     * @return A test step
     */
    private TestStep generateFormFieldStep(WebElement field) {
        TestStep step = new TestStep();
        
        switch (field.getType()) {
            case TEXT_INPUT:
            case EMAIL_INPUT:
            case PASSWORD_INPUT:
            case NUMBER_INPUT:
            case TEXTAREA:
                step.setType(TestStepType.FILL);
                step.setDescription("Fill " + getFieldName(field));
                step.setTarget(field.getSelector());
                step.setValue(generateValueForField(field));
                break;
                
            case CHECKBOX:
            case RADIO_BUTTON:
                step.setType(TestStepType.CLICK);
                step.setDescription("Click " + getFieldName(field));
                step.setTarget(field.getSelector());
                break;
                
            case SELECT:
                step.setType(TestStepType.SELECT);
                step.setDescription("Select option in " + getFieldName(field));
                step.setTarget(field.getSelector());
                
                if (field.getOptions() != null && !field.getOptions().isEmpty()) {
                    int optionIndex = random.nextInt(field.getOptions().size());
                    step.setValue(field.getOptions().get(optionIndex));
                } else {
                    step.setValue("Option 1");
                }
                break;
                
            case FILE_UPLOAD:
                step.setType(TestStepType.UPLOAD);
                step.setDescription("Upload file to " + getFieldName(field));
                step.setTarget(field.getSelector());
                step.setValue("test-file.txt");
                break;
                
            default:
                // Skip other field types
                return null;
        }
        
        return step;
    }
    
    /**
     * Generates a data-driven field step
     * @param field The form field
     * @param dataType The type of data to use
     * @return A test step
     */
    private TestStep generateDataDrivenFieldStep(WebElement field, DataTestType dataType) {
        TestStep step = new TestStep();
        
        switch (field.getType()) {
            case TEXT_INPUT:
            case EMAIL_INPUT:
            case PASSWORD_INPUT:
            case NUMBER_INPUT:
            case TEXTAREA:
                step.setType(TestStepType.FILL);
                step.setDescription("Fill " + getFieldName(field));
                step.setTarget(field.getSelector());
                step.setValue(generateDataDrivenValue(field, dataType));
                break;
                
            case CHECKBOX:
            case RADIO_BUTTON:
                if (dataType == DataTestType.INVALID_DATA && field.isRequired()) {
                    // For invalid data, skip required checkboxes/radios
                    return null;
                }
                
                step.setType(TestStepType.CLICK);
                step.setDescription("Click " + getFieldName(field));
                step.setTarget(field.getSelector());
                break;
                
            case SELECT:
                step.setType(TestStepType.SELECT);
                step.setDescription("Select option in " + getFieldName(field));
                step.setTarget(field.getSelector());
                
                if (dataType == DataTestType.INVALID_DATA && field.isRequired()) {
                    // For invalid data on required select, choose empty option if available
                    if (field.getOptions() != null && field.getOptions().contains("")) {
                        step.setValue("");
                    } else {
                        // Skip if no empty option
                        return null;
                    }
                } else if (field.getOptions() != null && !field.getOptions().isEmpty()) {
                    if (dataType == DataTestType.BOUNDARY_VALUES) {
                        // For boundary values, choose first or last option
                        boolean useFirst = random.nextBoolean();
                        step.setValue(useFirst ? field.getOptions().get(0) : 
                                     field.getOptions().get(field.getOptions().size() - 1));
                    } else {
                        // Otherwise choose random
                        int optionIndex = random.nextInt(field.getOptions().size());
                        step.setValue(field.getOptions().get(optionIndex));
                    }
                } else {
                    step.setValue("Option 1");
                }
                break;
                
            case FILE_UPLOAD:
                step.setType(TestStepType.UPLOAD);
                step.setDescription("Upload file to " + getFieldName(field));
                step.setTarget(field.getSelector());
                
                if (dataType == DataTestType.INVALID_DATA) {
                    step.setValue("invalid-file.xyz");
                } else {
                    step.setValue("test-file.txt");
                }
                break;
                
            default:
                // Skip other field types
                return null;
        }
        
        return step;
    }
    
    /**
     * Generates a value for a field
     * @param field The field
     * @return A generated value
     */
    private String generateValueForField(WebElement field) {
        switch (field.getType()) {
            case TEXT_INPUT:
                if (field.getName() != null) {
                    String name = field.getName().toLowerCase();
                    if (name.contains("name")) {
                        return "Test User";
                    } else if (name.contains("first")) {
                        return "Test";
                    } else if (name.contains("last")) {
                        return "User";
                    } else if (name.contains("address")) {
                        return "123 Test Street";
                    } else if (name.contains("city")) {
                        return "Test City";
                    } else if (name.contains("state")) {
                        return "Test State";
                    } else if (name.contains("zip") || name.contains("postal")) {
                        return "12345";
                    } else if (name.contains("phone")) {
                        return "555-123-4567";
                    }
                }
                return "Test Input";
                
            case EMAIL_INPUT:
                return "test@example.com";
                
            case PASSWORD_INPUT:
                return "Password123!";
                
            case NUMBER_INPUT:
                if (field.getName() != null) {
                    String name = field.getName().toLowerCase();
                    if (name.contains("age")) {
                        return "30";
                    } else if (name.contains("quantity")) {
                        return "1";
                    } else if (name.contains("price") || name.contains("amount")) {
                        return "99.99";
                    }
                }
                return "42";
                
            case TEXTAREA:
                return "This is a test comment or message that is being entered into this text area field for testing purposes.";
                
            default:
                return "Test Value";
        }
    }
    
    /**
     * Generates a data-driven value for a field
     * @param field The field
     * @param dataType The type of data to use
     * @return A generated value
     */
    private String generateDataDrivenValue(WebElement field, DataTestType dataType) {
        switch (dataType) {
            case VALID_DATA:
                return generateValueForField(field);
                
            case INVALID_DATA:
                if (field.isRequired()) {
                    return ""; // Empty value for required fields
                }
                
                switch (field.getType()) {
                    case EMAIL_INPUT:
                        return "invalid-email";
                        
                    case NUMBER_INPUT:
                        return "not-a-number";
                        
                    case PASSWORD_INPUT:
                        return "short"; // Too short password
                        
                    default:
                        return "";
                }
                
            case BOUNDARY_VALUES:
                switch (field.getType()) {
                    case TEXT_INPUT:
                    case TEXTAREA:
                        // Generate a very long string
                        StringBuilder sb = new StringBuilder();
                        for (int i = 0; i < 255; i++) {
                            sb.append("X");
                        }
                        return sb.toString();
                        
                    case EMAIL_INPUT:
                        // Very long local part
                        sb = new StringBuilder();
                        for (int i = 0; i < 64; i++) {
                            sb.append("a");
                        }
                        return sb.toString() + "@example.com";
                        
                    case NUMBER_INPUT:
                        // Large number or boundary value
                        return "999999999";
                        
                    case PASSWORD_INPUT:
                        // Exactly 8 characters (common minimum)
                        return "Pass1234";
                        
                    default:
                        return generateValueForField(field);
                }
                
            default:
                return generateValueForField(field);
        }
    }
    
    /**
     * Finds the submit button for a form
     * @param form The form
     * @return The submit button
     */
    private WebElement findSubmitButton(WebForm form) {
        // First look for submit type buttons
        Optional<WebElement> submitButton = form.getFields().stream()
                .filter(e -> e.getType() == ElementType.BUTTON && 
                           (e.getCategory() != null && e.getCategory().equals("submit-button")))
                .findFirst();
        
        if (submitButton.isPresent()) {
            return submitButton.get();
        }
        
        // Then look for any button
        Optional<WebElement> anyButton = form.getFields().stream()
                .filter(e -> e.getType() == ElementType.BUTTON)
                .findFirst();
        
        return anyButton.orElse(null);
    }
    
    /**
     * Gets a readable name for a form
     * @param form The form
     * @return A readable name
     */
    private String getFormName(WebForm form) {
        if (form.getAction() != null && !form.getAction().isEmpty()) {
            String action = form.getAction();
            int lastSlash = action.lastIndexOf('/');
            if (lastSlash >= 0 && lastSlash < action.length() - 1) {
                return action.substring(lastSlash + 1);
            }
            return action;
        }
        
        return "Form " + form.getSelector();
    }
    
    /**
     * Gets a readable name for a field
     * @param field The field
     * @return A readable name
     */
    private String getFieldName(WebElement field) {
        if (field.getName() != null && !field.getName().isEmpty()) {
            return "field '" + field.getName() + "'";
        }
        
        if (field.getId() != null && !field.getId().isEmpty()) {
            return "field with id '" + field.getId() + "'";
        }
        
        if (field.getText() != null && !field.getText().isEmpty()) {
            return "field with text '" + field.getText() + "'";
        }
        
        return "field " + field.getSelector();
    }
    
    /**
     * Gets a readable name for a page
     * @param page The page
     * @return A readable name
     */
    private String getPageName(WebPage page) {
        if (page.getTitle() != null && !page.getTitle().isEmpty()) {
            return page.getTitle();
        }
        
        String url = page.getUrl();
        if (url.endsWith("/")) {
            url = url.substring(0, url.length() - 1);
        }
        
        int lastSlash = url.lastIndexOf('/');
        if (lastSlash >= 0 && lastSlash < url.length() - 1) {
            return url.substring(lastSlash + 1);
        }
        
        return url;
    }
    
    /**
     * Enum for data-driven test types
     */
    private enum DataTestType {
        VALID_DATA,
        INVALID_DATA,
        BOUNDARY_VALUES
    }
    
    /**
     * Class representing a detected workflow
     */
    private static class Workflow {
        private String name;
        private WebPage startPage;
        private List<WorkflowStep> steps = new ArrayList<>();
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
        
        public WebPage getStartPage() {
            return startPage;
        }
        
        public void setStartPage(WebPage startPage) {
            this.startPage = startPage;
        }
        
        public List<WorkflowStep> getSteps() {
            return steps;
        }
        
        public void setSteps(List<WorkflowStep> steps) {
            this.steps = steps;
        }
    }
    
    /**
     * Class representing a step in a workflow
     */
    private static class WorkflowStep {
        private WorkflowStepType type;
        private WebElement element;
        private WebForm form;
        private String targetUrl;
        private WebElement verificationElement;
        
        public WorkflowStepType getType() {
            return type;
        }
        
        public void setType(WorkflowStepType type) {
            this.type = type;
        }
        
        public WebElement getElement() {
            return element;
        }
        
        public void setElement(WebElement element) {
            this.element = element;
        }
        
        public WebForm getForm() {
            return form;
        }
        
        public void setForm(WebForm form) {
            this.form = form;
        }
        
        public String getTargetUrl() {
            return targetUrl;
        }
        
        public void setTargetUrl(String targetUrl) {
            this.targetUrl = targetUrl;
        }
        
        public WebElement getVerificationElement() {
            return verificationElement;
        }
        
        public void setVerificationElement(WebElement verificationElement) {
            this.verificationElement = verificationElement;
        }
    }
    
    /**
     * Enum for workflow step types
     */
    private enum WorkflowStepType {
        NAVIGATION,
        FORM_SUBMISSION,
        INTERACTION
    }
}



package com.ctgp.service.integration;

import com.ctgp.model.workspace.*;
import com.ctgp.model.integration.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.util.Base64Utils;

import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

@Service
@RequiredArgsConstructor
@Slf4j
public class AzureDevOpsIntegrationService {

    private final RestTemplate restTemplate;
    
    @Value("${azure.devops.organization:#{null}}")
    private String organization;
    
    @Value("${azure.devops.project:#{null}}")
    private String project;
    
    @Value("${azure.devops.pat:#{null}}")
    private String personalAccessToken;
    
    private static final String AZURE_DEVOPS_API_URL = "https://dev.azure.com";
    private static final String API_VERSION = "6.0";
    private static final String DATE_FORMAT = "yyyy-MM-dd HH:mm:ss";
    
    /**
     * Uploads test results to Azure DevOps
     * @param testExecutionSession The test execution session
     * @return The integration result
     */
    public IntegrationResult uploadTestResults(TestExecutionSession testExecutionSession) {
        log.info("Uploading test results to Azure DevOps for execution session: {}", testExecutionSession.getId());
        
        // Validate configuration
        if (!isConfigurationValid()) {
            log.error("Azure DevOps integration is not properly configured");
            return createErrorResult("Azure DevOps integration is not properly configured");
        }
        
        try {
            // Create test run
            AzureTestRun testRun = createTestRun(testExecutionSession);
            
            // Upload test results
            AzureTestRun updatedTestRun = uploadTestResults(testRun, testExecutionSession);
            
            // Create work items for failed tests if needed
            if (updatedTestRun != null && updatedTestRun.getId() != null) {
                createWorkItemsForFailedTests(updatedTestRun, testExecutionSession);
            }
            
            // Return success result
            IntegrationResult result = new IntegrationResult();
            result.setSuccess(true);
            result.setTimestamp(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT)));
            
            if (updatedTestRun != null) {
                result.setMessage("Test results uploaded successfully. Test run ID: " + updatedTestRun.getId());
                result.setExternalId(updatedTestRun.getId().toString());
                
                // Build URL to test run
                String testRunUrl = AZURE_DEVOPS_API_URL + "/" + organization + "/" + project + 
                                   "/_testManagement/runs?runId=" + updatedTestRun.getId();
                result.setExternalUrl(testRunUrl);
            } else {
                result.setMessage("Test results uploaded but no test run was created");
            }
            
            return result;
        } catch (Exception e) {
            log.error("Error uploading test results to Azure DevOps", e);
            return createErrorResult("Error uploading test results: " + e.getMessage());
        }
    }
    
    /**
     * Checks if Azure DevOps configuration is valid
     * @return True if valid, false otherwise
     */
    public boolean isConfigurationValid() {
        return organization != null && !organization.isEmpty() &&
               project != null && !project.isEmpty() &&
               personalAccessToken != null && !personalAccessToken.isEmpty();
    }
    
    /**
     * Creates a new test run in Azure DevOps
     * @param session The test execution session
     * @return The created test run
     */
    private AzureTestRun createTestRun(TestExecutionSession session) {
        String url = AZURE_DEVOPS_API_URL + "/" + organization + "/" + project + 
                    "/_apis/test/runs?api-version=" + API_VERSION;
        
        // Create test run request
        AzureTestRun testRun = new AzureTestRun();
        testRun.setName("Automated Test Run - " + session.getTestSuiteName());
        testRun.setAutomated(true);
        testRun.setState("InProgress");
        testRun.setBuild(new AzureBuildReference());
        testRun.setStartDate(session.getStartTime());
        testRun.setEndDate(session.getEndTime());
        
        // Add test suite info
        testRun.setComment("Test suite: " + session.getTestSuiteName() + 
                         ", Execution session: " + session.getId());
        
        // Send request
        HttpHeaders headers = createAuthHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        HttpEntity<AzureTestRun> requestEntity = new HttpEntity<>(testRun, headers);
        ResponseEntity<AzureTestRun> response = restTemplate.exchange(
                url, HttpMethod.POST, requestEntity, AzureTestRun.class);
        
        if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
            log.info("Created test run in Azure DevOps. Test run ID: {}", response.getBody().getId());
            return response.getBody();
        } else {
            log.error("Failed to create test run in Azure DevOps. Status code: {}", response.getStatusCode());
            return null;
        }
    }
    
    /**
     * Uploads test results to an existing test run
     * @param testRun The test run
     * @param session The test execution session
     * @return The updated test run
     */
    private AzureTestRun uploadTestResults(AzureTestRun testRun, TestExecutionSession session) {
        if (testRun == null || testRun.getId() == null) {
            log.error("Cannot upload test results: invalid test run");
            return null;
        }
        
        String url = AZURE_DEVOPS_API_URL + "/" + organization + "/" + project + 
                    "/_apis/test/runs/" + testRun.getId() + "/results?api-version=" + API_VERSION;
        
        // Convert test results to Azure format
        List<AzureTestResult> testResults = convertTestResults(session.getResults(), testRun.getId());
        
        // Send request
        HttpHeaders headers = createAuthHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        HttpEntity<List<AzureTestResult>> requestEntity = new HttpEntity<>(testResults, headers);
        ResponseEntity<AzureTestResultsResponse> response = restTemplate.exchange(
                url, HttpMethod.POST, requestEntity, AzureTestResultsResponse.class);
        
        if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
            log.info("Uploaded {} test results to Azure DevOps", testResults.size());
            
            // Update test run to Completed state
            return updateTestRunState(testRun.getId(), "Completed");
        } else {
            log.error("Failed to upload test results to Azure DevOps. Status code: {}", response.getStatusCode());
            return null;
        }
    }
    
    /**
     * Updates a test run's state
     * @param testRunId The test run ID
     * @param state The new state
     * @return The updated test run
     */
    private AzureTestRun updateTestRunState(Integer testRunId, String state) {
        String url = AZURE_DEVOPS_API_URL + "/" + organization + "/" + project + 
                    "/_apis/test/runs/" + testRunId + "?api-version=" + API_VERSION;
        
        // Create update request
        Map<String, String> updateRequest = new HashMap<>();
        updateRequest.put("state", state);
        
        // Send request
        HttpHeaders headers = createAuthHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        HttpEntity<Map<String, String>> requestEntity = new HttpEntity<>(updateRequest, headers);
        ResponseEntity<AzureTestRun> response = restTemplate.exchange(
                url, HttpMethod.PATCH, requestEntity, AzureTestRun.class);
        
        if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
            log.info("Updated test run state to: {}", state);
            return response.getBody();
        } else {
            log.error("Failed to update test run state. Status code: {}", response.getStatusCode());
            return null;
        }
    }
    
    /**
     * Creates work items for failed tests
     * @param testRun The test run
     * @param session The test execution session
     */
    private void createWorkItemsForFailedTests(AzureTestRun testRun, TestExecutionSession session) {
        // Get failed test results
        List<TestExecutionResult> failedTests = new ArrayList<>();
        for (TestExecutionResult result : session.getResults()) {
            if (result.getStatus() == ExecutionStatus.FAILED) {
                failedTests.add(result);
            }
        }
        
        if (failedTests.isEmpty()) {
            log.info("No failed tests, skipping work item creation");
            return;
        }
        
        log.info("Creating work items for {} failed tests", failedTests.size());
        
        String url = AZURE_DEVOPS_API_URL + "/" + organization + "/" + project + 
                    "/_apis/wit/workitems/$Bug?api-version=" + API_VERSION;
        
        // Create work items for each failed test
        for (TestExecutionResult failedTest : failedTests) {
            try {
                // Create work item
                AzureWorkItem workItem = createWorkItem(url, failedTest, testRun);
                
                if (workItem != null && workItem.getId() != null) {
                    log.info("Created work item for failed test: {}. Work item ID: {}", 
                            failedTest.getName(), workItem.getId());
                    
                    // Link work item to test result
                    linkWorkItemToTestResult(testRun.getId(), failedTest.getTestCaseId(), workItem.getId());
                }
            } catch (Exception e) {
                log.error("Error creating work item for failed test: {}", failedTest.getName(), e);
            }
        }
    }
    
    /**
     * Creates a work item for a failed test
     * @param url The work item creation URL
     * @param failedTest The failed test
     * @param testRun The test run
     * @return The created work item
     */
    private AzureWorkItem createWorkItem(String url, TestExecutionResult failedTest, AzureTestRun testRun) {
        // Build error description
        StringBuilder errorDescription = new StringBuilder();
        errorDescription.append("<h2>Test Failure Details</h2>")
                      .append("<p><strong>Test:</strong> ").append(failedTest.getName()).append("</p>")
                      .append("<p><strong>Test Suite:</strong> ").append(testRun.getName()).append("</p>")
                      .append("<p><strong>Status:</strong> Failed</p>")
                      .append("<p><strong>Duration:</strong> ").append(failedTest.getDuration()).append(" ms</p>")
                      .append("<h3>Steps</h3><ul>");
        
        // Add step execution details
        if (failedTest.getStepExecutions() != null) {
            for (TestStepExecution step : failedTest.getStepExecutions()) {
                String status = step.getStatus() == ExecutionStatus.PASSED ? "✅ Passed" : "❌ Failed";
                errorDescription.append("<li>")
                              .append("<strong>").append(status).append(":</strong> ")
                              .append(step.getDescription());
                
                if (step.getStatus() == ExecutionStatus.FAILED && step.getError() != null) {
                    errorDescription.append(" - <em>Error: ").append(step.getError()).append("</em>");
                }
                
                errorDescription.append("</li>");
            }
        }
        
        errorDescription.append("</ul>");
        
        // Add links to screenshots if available
        if (failedTest.getStepExecutions() != null) {
            boolean hasScreenshots = failedTest.getStepExecutions().stream()
                    .anyMatch(step -> step.getScreenshotUrl() != null);
            
            if (hasScreenshots) {
                errorDescription.append("<h3>Screenshots</h3><ul>");
                
                for (TestStepExecution step : failedTest.getStepExecutions()) {
                    if (step.getScreenshotUrl() != null) {
                        errorDescription.append("<li>")
                                      .append(step.getDescription())
                                      .append(" - Screenshot available in test artifacts")
                                      .append("</li>");
                    }
                }
                
                errorDescription.append("</ul>");
            }
        }
        
        // Create work item fields
        List<Map<String, Object>> fields = new ArrayList<>();
        
        // Title
        Map<String, Object> titleField = new HashMap<>();
        titleField.put("op", "add");
        titleField.put("path", "/fields/System.Title");
        titleField.put("value", "Test Failure: " + failedTest.getName());
        fields.add(titleField);
        
        // Description
        Map<String, Object> descriptionField = new HashMap<>();
        descriptionField.put("op", "add");
        descriptionField.put("path", "/fields/System.Description");
        descriptionField.put("value", errorDescription.toString());
        fields.add(descriptionField);
        
        // Priority
        Map<String, Object> priorityField = new HashMap<>();
        priorityField.put("op", "add");
        priorityField.put("path", "/fields/Microsoft.VSTS.Common.Priority");
        priorityField.put("value", 2);  // Medium priority
        fields.add(priorityField);
        
        // Severity
        Map<String, Object> severityField = new HashMap<>();
        severityField.put("op", "add");
        severityField.put("path", "/fields/Microsoft.VSTS.Common.Severity");
        severityField.put("value", "3 - Medium");
        fields.add(severityField);
        
        // Send request
        HttpHeaders headers = createAuthHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON_PATCH_JSON);
        
        HttpEntity<List<Map<String, Object>>> requestEntity = new HttpEntity<>(fields, headers);
        ResponseEntity<AzureWorkItem> response = restTemplate.exchange(
                url, HttpMethod.POST, requestEntity, AzureWorkItem.class);
        
        if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
            return response.getBody();
        } else {
            log.error("Failed to create work item. Status code: {}", response.getStatusCode());
            return null;
        }
    }
    
    /**
     * Links a work item to a test result
     * @param testRunId The test run ID
     * @param testCaseId The test case ID
     * @param workItemId The work item ID
     * @return True if successful, false otherwise
     */
    private boolean linkWorkItemToTestResult(Integer testRunId, String testCaseId, Integer workItemId) {
        // In a real implementation, we would link the work item to the test result
        // This would require additional API calls to Azure DevOps
        // Simplified implementation for this example
        log.info("Linking work item {} to test result for test case {} in test run {}", 
                workItemId, testCaseId, testRunId);
        return true;
    }
    
    /**
     * Converts test results to Azure DevOps format
     * @param results The test execution results
     * @param testRunId The test run ID
     * @return List of Azure test results
     */
    private List<AzureTestResult> convertTestResults(List<TestExecutionResult> results, Integer testRunId) {
        List<AzureTestResult> azureResults = new ArrayList<>();
        
        for (TestExecutionResult result : results) {
            AzureTestResult azureResult = new AzureTestResult();
            azureResult.setTestCaseTitle(result.getName());
            azureResult.setTestCase(new AzureTestCaseReference(result.getTestCaseId()));
            azureResult.setTestRun(new AzureTestRunReference(testRunId));
            azureResult.setOutcome(mapStatusToOutcome(result.getStatus()));
            azureResult.setState("Completed");
            azureResult.setStartedDate(result.getStartTime());
            azureResult.setCompletedDate(result.getEndTime());
            azureResult.setDurationInMs(result.getDuration());
            
            // Add error message if test failed
            if (result.getStatus() == ExecutionStatus.FAILED) {
                // Find first failed step with error
                Optional<TestStepExecution> failedStep = result.getStepExecutions().stream()
                        .filter(step -> step.getStatus() == ExecutionStatus.FAILED && step.getError() != null)
                        .findFirst();
                
                if (failedStep.isPresent()) {
                    azureResult.setErrorMessage(failedStep.get().getError());
                } else {
                    azureResult.setErrorMessage("Test failed with no specific error message");
                }
            }
            
            azureResults.add(azureResult);
        }
        
        return azureResults;
    }
    
    /**
     * Maps test execution status to Azure DevOps outcome
     * @param status The execution status
     * @return The Azure DevOps outcome
     */
    private String mapStatusToOutcome(ExecutionStatus status) {
        switch (status) {
            case PASSED:
                return "Passed";
            case FAILED:
                return "Failed";
            case ABORTED:
                return "Aborted";
            default:
                return "NotExecuted";
        }
    }
    
    /**
     * Creates HTTP headers with authentication
     * @return The HTTP headers
     */
    private HttpHeaders createAuthHeaders() {
        HttpHeaders headers = new HttpHeaders();
        String auth = ":" + personalAccessToken;
        byte[] encodedAuth = Base64Utils.encode(auth.getBytes(StandardCharsets.UTF_8));
        headers.set("Authorization", "Basic " + new String(encodedAuth));
        return headers;
    }
    
    /**
     * Creates an error integration result
     * @param errorMessage The error message
     * @return The integration result
     */
    private IntegrationResult createErrorResult(String errorMessage) {
        IntegrationResult result = new IntegrationResult();
        result.setSuccess(false);
        result.setMessage(errorMessage);
        result.setTimestamp(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT)));
        return result;
    }
    
    // Inner classes for Azure DevOps API models
    
    /**
     * Azure DevOps test run
     */
    private static class AzureTestRun {
        private Integer id;
        private String name;
        private String state;
        private boolean automated;
        private AzureBuildReference build;
        private String startDate;
        private String endDate;
        private String comment;
        
        public Integer getId() {
            return id;
        }
        
        public void setId(Integer id) {
            this.id = id;
        }
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
        
        public String getState() {
            return state;
        }
        
        public void setState(String state) {
            this.state = state;
        }
        
        public boolean isAutomated() {
            return automated;
        }
        
        public void setAutomated(boolean automated) {
            this.automated = automated;
        }
        
        public AzureBuildReference getBuild() {
            return build;
        }
        
        public void setBuild(AzureBuildReference build) {
            this.build = build;
        }
        
        public String getStartDate() {
            return startDate;
        }
        
        public void setStartDate(String startDate) {
            this.startDate = startDate;
        }
        
        public String getEndDate() {
            return endDate;
        }
        
        public void setEndDate(String endDate) {
            this.endDate = endDate;
        }
        
        public String getComment() {
            return comment;
        }
        
        public void setComment(String comment) {
            this.comment = comment;
        }
    }
    
    /**
     * Azure DevOps build reference
     */
    private static class AzureBuildReference {
        private Integer id;
        
        public Integer getId() {
            return id;
        }
        
        public void setId(Integer id) {
            this.id = id;
        }
    }
    
    /**
     * Azure DevOps test result
     */
    private static class AzureTestResult {
        private Integer id;
        private String testCaseTitle;
        private AzureTestCaseReference testCase;
        private AzureTestRunReference testRun;
        private String outcome;
        private String state;
        private String errorMessage;
        private String startedDate;
        private String completedDate;
        private Long durationInMs;
        
        public Integer getId() {
            return id;
        }
        
        public void setId(Integer id) {
            this.id = id;
        }
        
        public String getTestCaseTitle() {
            return testCaseTitle;
        }
        
        public void setTestCaseTitle(String testCaseTitle) {
            this.testCaseTitle = testCaseTitle;
        }
        
        public AzureTestCaseReference getTestCase() {
            return testCase;
        }
        
        public void setTestCase(AzureTestCaseReference testCase) {
            this.testCase = testCase;
        }
        
        public AzureTestRunReference getTestRun() {
            return testRun;
        }
        
        public void setTestRun(AzureTestRunReference testRun) {
            this.testRun = testRun;
        }
        
        public String getOutcome() {
            return outcome;
        }
        
        public void setOutcome(String outcome) {
            this.outcome = outcome;
        }
        
        public String getState() {
            return state;
        }
        
        public void setState(String state) {
            this.state = state;
        }
        
        public String getErrorMessage() {
            return errorMessage;
        }
        
        public void setErrorMessage(String errorMessage) {
            this.errorMessage = errorMessage;
        }
        
        public String getStartedDate() {
            return startedDate;
        }
        
        public void setStartedDate(String startedDate) {
            this.startedDate = startedDate;
        }
        
        public String getCompletedDate() {
            return completedDate;
        }
        
        public void setCompletedDate(String completedDate) {
            this.completedDate = completedDate;
        }
        
        public Long getDurationInMs() {
            return durationInMs;
        }
        
        public void setDurationInMs(Long durationInMs) {
            this.durationInMs = durationInMs;
        }
    }
    
    /**
     * Azure DevOps test case reference
     */
    private static class AzureTestCaseReference {
        private String id;
        
        public AzureTestCaseReference() {
        }
        
        public AzureTestCaseReference(String id) {
            this.id = id;
        }
        
        public String getId() {
            return id;
        }
        
        public void setId(String id) {
            this.id = id;
        }
    }
    
    /**
     * Azure DevOps test run reference
     */
    private static class AzureTestRunReference {
        private Integer id;
        
        public AzureTestRunReference() {
        }
        
        public AzureTestRunReference(Integer id) {
            this.id = id;
        }
        
        public Integer getId() {
            return id;
        }
        
        public void setId(Integer id) {
            this.id = id;
        }
    }
    
    /**
     * Azure DevOps test results response
     */
    private static class AzureTestResultsResponse {
        private Integer count;
        private List<AzureTestResult> value;
        
        public Integer getCount() {
            return count;
        }
        
        public void setCount(Integer count) {
            this.count = count;
        }
        
        public List<AzureTestResult> getValue() {
            return value;
        }
        
        public void setValue(List<AzureTestResult> value) {
            this.value = value;
        }
    }
    
    /**
     * Azure DevOps work item
     */
    private static class AzureWorkItem {
        private Integer id;
        private String url;
        
        public Integer getId() {
            return id;
        }
        
        public void setId(Integer id) {
            this.id = id;
        }
        
        public String getUrl() {
            return url;
        }
        
        public void setUrl(String url) {
            this.url = url;
        }
    }
}


// src/pages/execution/TestExecution.tsx
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate, Link } from 'react-router-dom';
import { toast } from 'react-toastify';
import { FaSpinner, FaPlay, FaCheck, FaTimes, FaPause, FaStop, FaEye, FaVideo, FaCamera } from 'react-icons/fa';
import { Breadcrumb, Card, Button, Table, Badge, Spinner, Tabs, Tab, Modal, Accordion } from 'react-bootstrap';
import { api } from '../../services/api';
import { formatDuration, formatDateTime } from '../../utils/formatters';
import { TestStep, TestCase, TestSuite, TestExecutionSession, TestExecutionResult, TestStepExecution } from '../../types/test';
import './TestExecution.css';

// TestExecution component
const TestExecution: React.FC = () => {
  const { projectId, suiteId } = useParams<{ projectId: string; suiteId: string }>();
  const navigate = useNavigate();
  
  // State
  const [testSuite, setTestSuite] = useState<TestSuite | null>(null);
  const [executionSession, setExecutionSession] = useState<TestExecutionSession | null>(null);
  const [executionResults, setExecutionResults] = useState<{ [key: string]: TestExecutionResult }>({});
  const [selectedTestCase, setSelectedTestCase] = useState<string | null>(null);
  const [isExecuting, setIsExecuting] = useState<boolean>(false);
  const [currentStepIndex, setCurrentStepIndex] = useState<number | null>(null);
  const [selectedTestCaseDetails, setSelectedTestCaseDetails] = useState<TestCase | null>(null);
  const [showScreenshotModal, setShowScreenshotModal] = useState<boolean>(false);
  const [selectedScreenshot, setSelectedScreenshot] = useState<string | null>(null);
  const [executionSpeed, setExecutionSpeed] = useState<'normal' | 'slow' | 'fast'>('normal');
  const [filterStatus, setFilterStatus] = useState<'all' | 'passed' | 'failed' | 'pending'>('all');
  
  // Load test suite
  useEffect(() => {
    if (projectId && suiteId) {
      loadTestSuite();
    }
  }, [projectId, suiteId]);
  
  // Load test suite function
  const loadTestSuite = async () => {
    try {
      const response = await api.get(`/api/projects/${projectId}/test-suites/${suiteId}`);
      setTestSuite(response.data);
      
      // Load last execution session if exists
      const sessionsResponse = await api.get(`/api/projects/${projectId}/test-suites/${suiteId}/execution-sessions`);
      if (sessionsResponse.data && sessionsResponse.data.length > 0) {
        const lastSession = sessionsResponse.data[0];
        setExecutionSession(lastSession);
        
        // Load results for the last session
        const resultsResponse = await api.get(`/api/projects/${projectId}/execution-sessions/${lastSession.id}/results`);
        const resultsMap = resultsResponse.data.reduce((map: any, result: TestExecutionResult) => {
          map[result.testCaseId] = result;
          return map;
        }, {});
        setExecutionResults(resultsMap);
      }
    } catch (error) {
      console.error('Error loading test suite:', error);
      toast.error('Failed to load test suite');
    }
  };
  
  // Execute all test cases
  const executeAllTests = async () => {
    if (!testSuite || isExecuting) return;
    
    try {
      setIsExecuting(true);
      
      // Create a new execution session
      const sessionResponse = await api.post(`/api/projects/${projectId}/test-suites/${suiteId}/execute`, {
        executionSpeed,
        takeScreenshots: true,
        recordVideo: true
      });
      
      setExecutionSession(sessionResponse.data);
      
      // Reset current execution results
      setExecutionResults({});
      
      // Poll for execution updates
      const intervalId = setInterval(async () => {
        try {
          const sessionStatusResponse = await api.get(`/api/projects/${projectId}/execution-sessions/${sessionResponse.data.id}`);
          const session = sessionStatusResponse.data;
          setExecutionSession(session);
          
          // Load results
          const resultsResponse = await api.get(`/api/projects/${projectId}/execution-sessions/${session.id}/results`);
          const resultsMap = resultsResponse.data.reduce((map: any, result: TestExecutionResult) => {
            map[result.testCaseId] = result;
            return map;
          }, {});
          setExecutionResults(resultsMap);
          
          // If execution is complete, stop polling
          if (session.status === 'COMPLETED' || session.status === 'ABORTED') {
            setIsExecuting(false);
            clearInterval(intervalId);
            toast.info(`Test execution ${session.status.toLowerCase()}`);
          }
        } catch (error) {
          console.error('Error polling execution status:', error);
          clearInterval(intervalId);
          setIsExecuting(false);
        }
      }, 2000);
      
      return () => clearInterval(intervalId);
    } catch (error) {
      console.error('Error executing tests:', error);
      toast.error('Failed to execute tests');
      setIsExecuting(false);
    }
  };
  
  // Execute a single test case
  const executeTestCase = async (testCaseId: string) => {
    if (isExecuting) return;
    
    try {
      setIsExecuting(true);
      setSelectedTestCase(testCaseId);
      
      // Create a new execution session for a single test case
      const sessionResponse = await api.post(`/api/projects/${projectId}/test-cases/${testCaseId}/execute`, {
        executionSpeed,
        takeScreenshots: true,
        recordVideo: true
      });
      
      setExecutionSession(sessionResponse.data);
      
      // Poll for execution updates
      const intervalId = setInterval(async () => {
        try {
          const sessionStatusResponse = await api.get(`/api/projects/${projectId}/execution-sessions/${sessionResponse.data.id}`);
          const session = sessionStatusResponse.data;
          setExecutionSession(session);
          
          // Load results
          const resultsResponse = await api.get(`/api/projects/${projectId}/execution-sessions/${session.id}/results`);
          if (resultsResponse.data.length > 0) {
            const result = resultsResponse.data[0];
            setExecutionResults(prev => ({ ...prev, [testCaseId]: result }));
            
            // Update current step index
            if (result.stepExecutions) {
              const runningStepIndex = result.stepExecutions.findIndex(step => step.status === 'RUNNING');
              setCurrentStepIndex(runningStepIndex >= 0 ? runningStepIndex : null);
            }
          }
          
          // If execution is complete, stop polling
          if (session.status === 'COMPLETED' || session.status === 'ABORTED') {
            setIsExecuting(false);
            setCurrentStepIndex(null);
            setSelectedTestCase(null);
            clearInterval(intervalId);
            toast.info(`Test execution ${session.status.toLowerCase()}`);
          }
        } catch (error) {
          console.error('Error polling execution status:', error);
          clearInterval(intervalId);
          setIsExecuting(false);
          setCurrentStepIndex(null);
          setSelectedTestCase(null);
        }
      }, 1000);
      
      return () => clearInterval(intervalId);
    } catch (error) {
      console.error('Error executing test case:', error);
      toast.error('Failed to execute test case');
      setIsExecuting(false);
      setSelectedTestCase(null);
    }
  };
  
  // Stop test execution
  const stopExecution = async () => {
    if (!executionSession) return;
    
    try {
      await api.post(`/api/projects/${projectId}/execution-sessions/${executionSession.id}/stop`);
      toast.info('Stopping test execution...');
    } catch (error) {
      console.error('Error stopping test execution:', error);
      toast.error('Failed to stop test execution');
    }
  };
  
  // View test case details
  const viewTestCaseDetails = async (testCaseId: string) => {
    try {
      const response = await api.get(`/api/projects/${projectId}/test-cases/${testCaseId}`);
      setSelectedTestCaseDetails(response.data);
    } catch (error) {
      console.error('Error loading test case details:', error);
      toast.error('Failed to load test case details');
    }
  };
  
  // View screenshot
  const viewScreenshot = (screenshotUrl: string) => {
    setSelectedScreenshot(screenshotUrl);
    setShowScreenshotModal(true);
  };
  
  // Export test results
  const exportResults = async () => {
    if (!executionSession) return;
    
    try {
      const response = await api.get(`/api/projects/${projectId}/execution-sessions/${executionSession.id}/export`, {
        responseType: 'blob'
      });
      
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `test-results-${executionSession.id}.html`);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } catch (error) {
      console.error('Error exporting results:', error);
      toast.error('Failed to export results');
    }
  };
  
  // Send results to Azure DevOps
  const sendToAzureDevOps = async () => {
    if (!executionSession) return;
    
    try {
      await api.post(`/api/projects/${projectId}/execution-sessions/${executionSession.id}/send-to-azure-devops`);
      toast.success('Results sent to Azure DevOps');
    } catch (error) {
      console.error('Error sending results to Azure DevOps:', error);
      toast.error('Failed to send results to Azure DevOps');
    }
  };
  
  // Filter test cases based on status
  const getFilteredTestCases = () => {
    if (!testSuite || !testSuite.testCases) return [];
    
    if (filterStatus === 'all') {
      return testSuite.testCases;
    }
    
    return testSuite.testCases.filter(testCase => {
      const result = executionResults[testCase.id];
      if (!result) return filterStatus === 'pending';
      return result.status.toLowerCase() === filterStatus;
    });
  };
  
  // Render status badge
  const renderStatusBadge = (status: string) => {
    switch (status.toLowerCase()) {
      case 'passed':
        return <Badge bg="success">Passed</Badge>;
      case 'failed':
        return <Badge bg="danger">Failed</Badge>;
      case 'running':
        return <Badge bg="primary">Running</Badge>;
      case 'aborted':
        return <Badge bg="warning">Aborted</Badge>;
      default:
        return <Badge bg="secondary">Pending</Badge>;
    }
  };
  
  // If loading
  if (!testSuite) {
    return (
      <div className="d-flex justify-content-center align-items-center" style={{ height: '80vh' }}>
        <Spinner animation="border" />
        <span className="ms-2">Loading test suite...</span>
      </div>
    );
  }
  
  return (
    <div className="test-execution-container">
      {/* Breadcrumb */}
      <Breadcrumb>
        <Breadcrumb.Item linkAs={Link} linkProps={{ to: '/projects' }}>Projects</Breadcrumb.Item>
        <Breadcrumb.Item linkAs={Link} linkProps={{ to: `/projects/${projectId}` }}>
          {projectId}
        </Breadcrumb.Item>
        <Breadcrumb.Item linkAs={Link} linkProps={{ to: `/projects/${projectId}/test-suites` }}>
          Test Suites
        </Breadcrumb.Item>
        <Breadcrumb.Item active>{testSuite.name}</Breadcrumb.Item>
      </Breadcrumb>
      
      {/* Header */}
      <div className="d-flex justify-content-between align-items-center mb-4">
        <div>
          <h2>{testSuite.name}</h2>
          <p className="text-muted">{testSuite.description}</p>
        </div>
        <div className="d-flex gap-2">
          {/* Execution speed selector */}
          <select 
            className="form-select" 
            value={executionSpeed} 
            onChange={(e) => setExecutionSpeed(e.target.value as any)}
            disabled={isExecuting}
          >
            <option value="slow">Slow Execution</option>
            <option value="normal">Normal Execution</option>
            <option value="fast">Fast Execution</option>
          </select>
          
          {/* Execute all button */}
          <Button 
            variant="primary" 
            onClick={executeAllTests} 
            disabled={isExecuting}
          >
            {isExecuting ? (
              <>
                <FaSpinner className="spinner me-2" />
                Executing...
              </>
            ) : (
              <>
                <FaPlay className="me-2" />
                Execute All
              </>
            )}
          </Button>
          
          {/* Stop button */}
          {isExecuting && (
            <Button variant="danger" onClick={stopExecution}>
              <FaStop className="me-2" />
              Stop
            </Button>
          )}
          
          {/* Results actions */}
          {executionSession && executionSession.status === 'COMPLETED' && (
            <>
              <Button variant="outline-primary" onClick={exportResults}>
                Export Results
              </Button>
              <Button variant="outline-secondary" onClick={sendToAzureDevOps}>
                Send to Azure DevOps
              </Button>
            </>
          )}
        </div>
      </div>
      
      {/* Execution Status */}
      {executionSession && (
        <Card className="mb-4">
          <Card.Header>Execution Status</Card.Header>
          <Card.Body>
            <div className="d-flex justify-content-between">
              <div>
                <p><strong>Session ID:</strong> {executionSession.id}</p>
                <p><strong>Status:</strong> {renderStatusBadge(executionSession.status)}</p>
              </div>
              <div>
                <p><strong>Started:</strong> {formatDateTime(executionSession.startTime)}</p>
                <p><strong>Duration:</strong> {formatDuration(executionSession.duration)}</p>
              </div>
              <div>
                <p>
                  <strong>Tests:</strong> {testSuite.testCases.length} | 
                  <span className="text-success"> Passed: {Object.values(executionResults).filter(r => r.status === 'PASSED').length}</span> | 
                  <span className="text-danger"> Failed: {Object.values(executionResults).filter(r => r.status === 'FAILED').length}</span>
                </p>
                <div className="progress">
                  <div 
                    className="progress-bar bg-success" 
                    style={{ 
                      width: `${(Object.values(executionResults).filter(r => r.status === 'PASSED').length / testSuite.testCases.length) * 100}%` 
                    }}
                  />
                  <div 
                    className="progress-bar bg-danger" 
                    style={{ 
                      width: `${(Object.values(executionResults).filter(r => r.status === 'FAILED').length / testSuite.testCases.length) * 100}%` 
                    }}
                  />
                </div>
              </div>
            </div>
          </Card.Body>
        </Card>
      )}
      
      {/* Test Cases */}
      <Card>
        <Card.Header className="d-flex justify-content-between align-items-center">
          <span>Test Cases</span>
          <div>
            <select 
              className="form-select form-select-sm" 
              value={filterStatus} 
              onChange={(e) => setFilterStatus(e.target.value as any)}
            >
              <option value="all">All Tests</option>
              <option value="passed">Passed</option>
              <option value="failed">Failed</option>
              <option value="pending">Pending</option>
            </select>
          </div>
        </Card.Header>
        <Card.Body>
          <Table striped hover>
            <thead>
              <tr>
                <th>Name</th>
                <th>Description</th>
                <th>Status</th>
                <th>Duration</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              {getFilteredTestCases().map(testCase => {
                const result = executionResults[testCase.id];
                const isRunning = isExecuting && selectedTestCase === testCase.id;
                
                return (
                  <tr key={testCase.id} className={isRunning ? 'table-primary' : ''}>
                    <td>{testCase.name}</td>
                    <td>{testCase.description}</td>
                    <td>
                      {result ? renderStatusBadge(result.status) : renderStatusBadge('pending')}
                    </td>
                    <td>{result ? formatDuration(result.duration) : '-'}</td>
                    <td>
                      <div className="d-flex gap-2">
                        <Button 
                          variant="primary" 
                          size="sm" 
                          onClick={() => executeTestCase(testCase.id)} 
                          disabled={isExecuting}
                        >
                          <FaPlay />
                        </Button>
                        <Button 
                          variant="info" 
                          size="sm" 
                          onClick={() => viewTestCaseDetails(testCase.id)}
                        >
                          <FaEye />
                        </Button>
                        {result && result.videoUrl && (
                          <Button 
                            variant="secondary" 
                            size="sm" 
                            as="a" 
                            href={result.videoUrl} 
                            target="_blank"
                          >
                            <FaVideo />
                          </Button>
                        )}
                      </div>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </Table>
        </Card.Body>
      </Card>
      
      {/* Test Case Details Modal */}
      {selectedTestCaseDetails && (
        <Modal
          show={!!selectedTestCaseDetails}
          onHide={() => setSelectedTestCaseDetails(null)}
          size="lg"
        >
          <Modal.Header closeButton>
            <Modal.Title>{selectedTestCaseDetails.name}</Modal.Title>
          </Modal.Header>
          <Modal.Body>
            <p>{selectedTestCaseDetails.description}</p>
            
            <h5>Test Steps</h5>
            <Accordion defaultActiveKey="0">
              {selectedTestCaseDetails.steps.map((step, index) => {
                const result = executionResults[selectedTestCaseDetails.id];
                const stepExecution = result?.stepExecutions?.[index];
                
                return (
                  <Accordion.Item eventKey={index.toString()} key={index}>
                    <Accordion.Header>
                      <div className="d-flex justify-content-between w-100 align-items-center pe-4">
                        <span>Step {index + 1}: {step.description}</span>
                        {stepExecution && (
                          <Badge bg={stepExecution.status === 'PASSED' ? 'success' : stepExecution.status === 'FAILED' ? 'danger' : 'secondary'}>
                            {stepExecution.status}
                          </Badge>
                        )}
                      </div>
                    </Accordion.Header>
                    <Accordion.Body>
                      <div className="mb-3">
                        <strong>Type:</strong> {step.type}
                      </div>
                      <div className="mb-3">
                        <strong>Target:</strong> {step.target}
                      </div>
                      {step.value && (
                        <div className="mb-3">
                          <strong>Value:</strong> {step.value}
                        </div>
                      )}
                      
                      {stepExecution && (
                        <>
                          <div className="mb-3">
                            <strong>Execution Time:</strong> {formatDuration(stepExecution.duration)}
                          </div>
                          {stepExecution.error && (
                            <div className="mb-3 text-danger">
                              <strong>Error:</strong> {stepExecution.error}
                            </div>
                          )}
                          {stepExecution.screenshotUrl && (
                            <div className="mb-3">
                              <Button variant="outline-primary" size="sm" onClick={() => viewScreenshot(stepExecution.screenshotUrl)}>
                                <FaCamera className="me-2" />
                                View Screenshot
                              </Button>
                            </div>
                          )}
                        </>
                      )}
                    </Accordion.Body>
                  </Accordion.Item>
                );
              })}
            </Accordion>
          </Modal.Body>
          <Modal.Footer>
            <Button variant="secondary" onClick={() => setSelectedTestCaseDetails(null)}>
              Close
            </Button>
          </Modal.Footer>
        </Modal>
      )}
      
      {/* Screenshot Modal */}
      <Modal
        show={showScreenshotModal}
        onHide={() => setShowScreenshotModal(false)}
        size="lg"
      >
        <Modal.Header closeButton>
          <Modal.Title>Screenshot</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          {selectedScreenshot && (
            <img src={selectedScreenshot} alt="Test Execution Screenshot" className="img-fluid" />
          )}
        </Modal.Body>
        <Modal.Footer>
          <Button variant="secondary" onClick={() => setShowScreenshotModal(false)}>
            Close
          </Button>
        </Modal.Footer>
      </Modal>
    </div>
  );
};

export default TestExecution;



  package com.ctgp.controller;

import com.ctgp.model.analyzer.WebApplication;
import com.ctgp.model.dto.TestGenerationRequest;
import com.ctgp.model.dto.TestGenerationResponse;
import com.ctgp.model.workspace.Project;
import com.ctgp.model.workspace.TestSuite;
import com.ctgp.service.analyzer.WebAnalyzerService;
import com.ctgp.service.generator.AdvancedTestGeneratorService;
import com.ctgp.service.workspace.ProjectService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/projects/{projectId}/advanced-test-generator")
@RequiredArgsConstructor
@Slf4j
public class AdvancedTestGeneratorController {

    private final ProjectService projectService;
    private final WebAnalyzerService webAnalyzerService;
    private final AdvancedTestGeneratorService advancedTestGeneratorService;

    /**
     * Generates advanced test suites for a project based on a web application URL
     * @param projectId The project ID
     * @param request The test generation request
     * @return The generated test suites
     */
    @PostMapping("/generate")
    public ResponseEntity<TestGenerationResponse> generateTests(
            @PathVariable String projectId, 
            @RequestBody TestGenerationRequest request) {
        
        log.info("Generating advanced tests for project: {}, URL: {}", projectId, request.getUrl());
        
        // Get project
        Project project = projectService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Analyze web application
        WebApplication application = webAnalyzerService.analyzeApplication(
                request.getUrl(), 
                request.getDepth() != null ? request.getDepth() : 3);
        
        // Generate advanced test suites
        List<TestSuite> testSuites = advancedTestGeneratorService.generateAdvancedTestSuites(project, application);
        
        // Create response
        TestGenerationResponse response = new TestGenerationResponse();
        response.setTestSuites(testSuites);
        response.setMessage("Successfully generated " + testSuites.size() + " advanced test suites");
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Generates workflow tests for a project based on a web application URL
     * @param projectId The project ID
     * @param request The test generation request
     * @return The generated workflow test suite
     */
    @PostMapping("/generate-workflow-tests")
    public ResponseEntity<TestGenerationResponse> generateWorkflowTests(
            @PathVariable String projectId, 
            @RequestBody TestGenerationRequest request) {
        
        log.info("Generating workflow tests for project: {}, URL: {}", projectId, request.getUrl());
        
        // Get project
        Project project = projectService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Analyze web application
        WebApplication application = webAnalyzerService.analyzeApplication(
                request.getUrl(), 
                request.getDepth() != null ? request.getDepth() : 3);
        
        // Generate workflow test suite
        TestSuite workflowSuite = advancedTestGeneratorService.generateWorkflowTestSuite(project, application);
        
        // Create response
        TestGenerationResponse response = new TestGenerationResponse();
        response.setTestSuites(List.of(workflowSuite));
        response.setMessage("Successfully generated workflow test suite with " + 
                         workflowSuite.getTestCases().size() + " test cases");
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Generates data-driven tests for a project based on a web application URL
     * @param projectId The project ID
     * @param request The test generation request
     * @return The generated data-driven test suite
     */
    @PostMapping("/generate-data-driven-tests")
    public ResponseEntity<TestGenerationResponse> generateDataDrivenTests(
            @PathVariable String projectId, 
            @RequestBody TestGenerationRequest request) {
        
        log.info("Generating data-driven tests for project: {}, URL: {}", projectId, request.getUrl());
        
        // Get project
        Project project = projectService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Analyze web application
        WebApplication application = webAnalyzerService.analyzeApplication(
                request.getUrl(), 
                request.getDepth() != null ? request.getDepth() : 3);
        
        // Generate data-driven test suite
        TestSuite dataDrivenSuite = advancedTestGeneratorService.generateDataDrivenTestSuite(project, application);
        
        // Create response
        TestGenerationResponse response = new TestGenerationResponse();
        response.setTestSuites(List.of(dataDrivenSuite));
        response.setMessage("Successfully generated data-driven test suite with " + 
                         dataDrivenSuite.getTestCases().size() + " test cases");
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Generates visual regression tests for a project based on a web application URL
     * @param projectId The project ID
     * @param request The test generation request
     * @return The generated visual regression test suite
     */
    @PostMapping("/generate-visual-regression-tests")
    public ResponseEntity<TestGenerationResponse> generateVisualRegressionTests(
            @PathVariable String projectId, 
            @RequestBody TestGenerationRequest request) {
        
        log.info("Generating visual regression tests for project: {}, URL: {}", projectId, request.getUrl());
        
        // Get project
        Project project = projectService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Analyze web application
        WebApplication application = webAnalyzerService.analyzeApplication(
                request.getUrl(), 
                request.getDepth() != null ? request.getDepth() : 3);
        
        // Generate visual regression test suite
        TestSuite visualRegressionSuite = advancedTestGeneratorService.generateVisualRegressionTestSuite(project, application);
        
        // Create response
        TestGenerationResponse response = new TestGenerationResponse();
        response.setTestSuites(List.of(visualRegressionSuite));
        response.setMessage("Successfully generated visual regression test suite with " + 
                         visualRegressionSuite.getTestCases().size() + " test cases");
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Gets information about possible test types and strategies
     * @param projectId The project ID
     * @return Information about available test generation options
     */
    @GetMapping("/options")
    public ResponseEntity<TestGenerationOptions> getTestGenerationOptions(@PathVariable String projectId) {
        // Get project
        Project project = projectService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Create options info
        TestGenerationOptions options = new TestGenerationOptions();
        
        // Add available test types
        options.addTestType("workflow", "Workflow Tests", "Detects user journeys and generates end-to-end workflow tests");
        options.addTestType("data-driven", "Data-Driven Tests", "Generates tests with valid, invalid, and boundary data");
        options.addTestType("visual-regression", "Visual Regression Tests", "Tests for visual appearance and layout consistency");
        
        // Add available strategies
        options.addStrategy("full", "Full Coverage", "Generates all possible test types for comprehensive coverage");
        options.addStrategy("critical-path", "Critical Path", "Focuses on the most important user workflows");
        options.addStrategy("regression", "Regression", "Optimized for regression testing with visual verification");
        
        return ResponseEntity.ok(options);
    }
    
    /**
     * Inner class for test generation options
     */
    private static class TestGenerationOptions {
        private List<TestTypeInfo> testTypes = new java.util.ArrayList<>();
        private List<StrategyInfo> strategies = new java.util.ArrayList<>();
        
        public void addTestType(String id, String name, String description) {
            testTypes.add(new TestTypeInfo(id, name, description));
        }
        
        public void addStrategy(String id, String name, String description) {
            strategies.add(new StrategyInfo(id, name, description));
        }
        
        public List<TestTypeInfo> getTestTypes() {
            return testTypes;
        }
        
        public List<StrategyInfo> getStrategies() {
            return strategies;
        }
        
        /**
         * Test type information
         */
        private static class TestTypeInfo {
            private final String id;
            private final String name;
            private final String description;
            
            public TestTypeInfo(String id, String name, String description) {
                this.id = id;
                this.name = name;
                this.description = description;
            }
            
            public String getId() {
                return id;
            }
            
            public String getName() {
                return name;
            }
            
            public String getDescription() {
                return description;
            }
        }
        
        /**
         * Strategy information
         */
        private static class StrategyInfo {
            private final String id;
            private final String name;
            private final String description;
            
            public StrategyInfo(String id, String name, String description) {
                this.id = id;
                this.name = name;
                this.description = description;
            }
            
            public String getId() {
                return id;
            }
            
            public String getName() {
                return name;
            }
            
            public String getDescription() {
                return description;
            }
        }
    }
}




package com.ctgp.controller;

import com.ctgp.model.analyzer.WebApplication;
import com.ctgp.model.dto.TestGenerationRequest;
import com.ctgp.model.dto.TestGenerationResponse;
import com.ctgp.model.workspace.Project;
import com.ctgp.model.workspace.TestSuite;
import com.ctgp.service.analyzer.WebAnalyzerService;
import com.ctgp.service.generator.TestGeneratorService;
import com.ctgp.service.workspace.ProjectService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/projects/{projectId}/test-generator")
@RequiredArgsConstructor
@Slf4j
public class TestGeneratorController {

    private final ProjectService projectService;
    private final WebAnalyzerService webAnalyzerService;
    private final TestGeneratorService testGeneratorService;

    /**
     * Generates test suites for a project based on a web application URL
     * @param projectId The project ID
     * @param request The test generation request
     * @return The generated test suites
     */
    @PostMapping("/generate")
    public ResponseEntity<TestGenerationResponse> generateTests(
            @PathVariable String projectId, 
            @RequestBody TestGenerationRequest request) {
        
        log.info("Generating tests for project: {}, URL: {}", projectId, request.getUrl());
        
        // Get project
        Project project = projectService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Analyze web application
        WebApplication application = webAnalyzerService.analyzeApplication(
                request.getUrl(), 
                request.getDepth() != null ? request.getDepth() : 3);
        
        // Generate test suites
        List<TestSuite> testSuites = testGeneratorService.generateTestSuites(project, application);
        
        // Create response
        TestGenerationResponse response = new TestGenerationResponse();
        response.setTestSuites(testSuites);
        response.setMessage("Successfully generated " + testSuites.size() + " test suites");
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Analyzes a web application and returns its structure
     * @param projectId The project ID
     * @param request The analysis request
     * @return The analyzed web application structure
     */
    @PostMapping("/analyze")
    public ResponseEntity<WebApplication> analyzeWebApplication(
            @PathVariable String projectId, 
            @RequestBody TestGenerationRequest request) {
        
        log.info("Analyzing web application for project: {}, URL: {}", projectId, request.getUrl());
        
        // Get project
        Project project = projectService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Analyze web application
        WebApplication application = webAnalyzerService.analyzeApplication(
                request.getUrl(), 
                request.getDepth() != null ? request.getDepth() : 3);
        
        return ResponseEntity.ok(application);
    }
    
    /**
     * Gets a test suite by ID
     * @param projectId The project ID
     * @param suiteId The test suite ID
     * @return The test suite
     */
    @GetMapping("/test-suites/{suiteId}")
    public ResponseEntity<TestSuite> getTestSuite(
            @PathVariable String projectId, 
            @PathVariable String suiteId) {
        
        log.info("Getting test suite: {} for project: {}", suiteId, projectId);
        
        // Get project
        Project project = projectService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Get test suite
        TestSuite testSuite = testGeneratorService.getTestSuite(project, suiteId);
        if (testSuite == null) {
            return ResponseEntity.notFound().build();
        }
        
        return ResponseEntity.ok(testSuite);
    }
    
    /**
     * Gets all test suites for a project
     * @param projectId The project ID
     * @return The list of test suites
     */
    @GetMapping("/test-suites")
    public ResponseEntity<List<TestSuite>> getTestSuites(@PathVariable String projectId) {
        log.info("Getting all test suites for project: {}", projectId);
        
        // Get project
        Project project = projectService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Get test suites
        List<TestSuite> testSuites = testGeneratorService.getTestSuites(project);
        
        return ResponseEntity.ok(testSuites);
    }
    
    /**
     * Deletes a test suite
     * @param projectId The project ID
     * @param suiteId The test suite ID
     * @return No content response
     */
    @DeleteMapping("/test-suites/{suiteId}")
    public ResponseEntity<Void> deleteTestSuite(
            @PathVariable String projectId, 
            @PathVariable String suiteId) {
        
        log.info("Deleting test suite: {} for project: {}", suiteId, projectId);
        
        // Get project
        Project project = projectService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Delete test suite
        boolean deleted = testGeneratorService.deleteTestSuite(project, suiteId);
        if (!deleted) {
            return ResponseEntity.notFound().build();
        }
        
        return ResponseEntity.noContent().build();
    }
}


package com.ctgp.service.generator;

import com.ctgp.model.analyzer.*;
import com.ctgp.model.workspace.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.FileUtils;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class TestGeneratorService {

    private final String TEMPLATE_DIR = "templates/";
    private static final String DATE_FORMAT = "yyyy-MM-dd HH:mm:ss";
    private static final Random random = new Random();
    
    private static final Map<ElementType, String> ELEMENT_VERIFICATION_MAP = new HashMap<ElementType, String>() {{
        put(ElementType.TEXT, "await expect(page.locator('%s')).toHaveText(/%s/);");
        put(ElementType.LINK, "await expect(page.locator('%s')).toHaveAttribute('href', /%s/);");
        put(ElementType.BUTTON, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.TEXT_INPUT, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.EMAIL_INPUT, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.PASSWORD_INPUT, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.CHECKBOX, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.RADIO_BUTTON, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.SELECT, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.TEXTAREA, "await expect(page.locator('%s')).toBeVisible();");
        put(ElementType.CLICKABLE, "await expect(page.locator('%s')).toBeVisible();");
    }};
    
    /**
     * Generates test suites for the given web application
     * @param project The project to generate tests for
     * @param application The analyzed web application
     * @return A list of generated test suites
     */
    public List<TestSuite> generateTestSuites(Project project, WebApplication application) {
        log.info("Generating test suites for project: {}", project.getName());
        
        List<TestSuite> testSuites = new ArrayList<>();
        
        // Generate navigation test suite
        TestSuite navigationSuite = generateNavigationTestSuite(project, application);
        testSuites.add(navigationSuite);
        
        // Generate form test suite
        TestSuite formSuite = generateFormTestSuite(project, application);
        testSuites.add(formSuite);
        
        // Generate visual verification test suite
        TestSuite visualSuite = generateVisualVerificationTestSuite(project, application);
        testSuites.add(visualSuite);
        
        // Save generated test suites
        for (TestSuite suite : testSuites) {
            saveTestSuite(project, suite);
        }
        
        log.info("Generated {} test suites with {} total test cases", 
                testSuites.size(), 
                testSuites.stream().mapToInt(s -> s.getTestCases().size()).sum());
        
        return testSuites;
    }
    
    /**
     * Generates a test suite for navigation scenarios
     * @param project The project to generate tests for
     * @param application The analyzed web application
     * @return A test suite for navigation scenarios
     */
    private TestSuite generateNavigationTestSuite(Project project, WebApplication application) {
        TestSuite suite = new TestSuite();
        suite.setName("Navigation Tests");
        suite.setDescription("Tests basic navigation functionality of the application");
        suite.setCreatedAt(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT)));
        
        // Generate page load test cases
        for (WebPage page : application.getPages()) {
            TestCase testCase = new TestCase();
            testCase.setName("Page Load Test - " + getPageName(page));
            testCase.setDescription("Verifies that the page loads correctly");
            
            List<TestStep> steps = new ArrayList<>();
            
            // Step 1: Navigate to page
            TestStep navigateStep = new TestStep();
            navigateStep.setType(TestStepType.NAVIGATE);
            navigateStep.setDescription("Navigate to " + page.getUrl());
            navigateStep.setTarget(page.getUrl());
            steps.add(navigateStep);
            
            // Step 2: Verify page title
            if (page.getTitle() != null && !page.getTitle().isEmpty()) {
                TestStep titleStep = new TestStep();
                titleStep.setType(TestStepType.ASSERT_TITLE);
                titleStep.setDescription("Verify page title is correct");
                titleStep.setTarget(page.getTitle());
                steps.add(titleStep);
            }
            
            // Add verification steps for key elements
            List<WebElement> keyElements = page.getElements().stream()
                    .filter(e -> e.getType() == ElementType.TEXT || e.getType() == ElementType.BUTTON)
                    .limit(3)
                    .collect(Collectors.toList());
            
            for (WebElement element : keyElements) {
                TestStep verifyStep = new TestStep();
                verifyStep.setType(TestStepType.ASSERT_ELEMENT);
                verifyStep.setDescription("Verify element: " + element.getText());
                verifyStep.setTarget(element.getSelector());
                steps.add(verifyStep);
            }
            
            testCase.setSteps(steps);
            suite.getTestCases().add(testCase);
        }
        
        // Generate navigation flow test cases
        if (application.getPages().size() > 1) {
            TestCase navigationFlowTest = new TestCase();
            navigationFlowTest.setName("Navigation Flow Test");
            navigationFlowTest.setDescription("Verifies navigation between pages");
            
            List<TestStep> steps = new ArrayList<>();
            
            // Start at the first page
            WebPage startPage = application.getPages().get(0);
            TestStep startStep = new TestStep();
            startStep.setType(TestStepType.NAVIGATE);
            startStep.setDescription("Navigate to starting page");
            startStep.setTarget(startPage.getUrl());
            steps.add(startStep);
            
            // Navigate through links to other pages
            Set<String> visitedUrls = new HashSet<>();
            visitedUrls.add(startPage.getUrl());
            
            // Add navigation steps for up to 5 pages
            int navigationCount = 0;
            for (WebPage page : application.getPages()) {
                if (navigationCount >= 5) {
                    break;
                }
                
                List<WebElement> links = page.getElements().stream()
                        .filter(e -> e.getType() == ElementType.LINK)
                        .filter(e -> e.getHref() != null && !e.getHref().isEmpty())
                        .filter(e -> !visitedUrls.contains(e.getHref()))
                        .collect(Collectors.toList());
                
                if (!links.isEmpty()) {
                    WebElement link = links.get(0);
                    
                    // Click step
                    TestStep clickStep = new TestStep();
                    clickStep.setType(TestStepType.CLICK);
                    clickStep.setDescription("Click on link: " + link.getText());
                    clickStep.setTarget(link.getSelector());
                    steps.add(clickStep);
                    
                    // Verify navigation
                    TestStep verifyStep = new TestStep();
                    verifyStep.setType(TestStepType.ASSERT_URL);
                    verifyStep.setDescription("Verify navigation to: " + link.getHref());
                    verifyStep.setTarget(link.getHref());
                    steps.add(verifyStep);
                    
                    visitedUrls.add(link.getHref());
                    navigationCount++;
                }
            }
            
            navigationFlowTest.setSteps(steps);
            suite.getTestCases().add(navigationFlowTest);
        }
        
        return suite;
    }
    
    /**
     * Generates a test suite for form interaction scenarios
     * @param project The project to generate tests for
     * @param application The analyzed web application
     * @return A test suite for form scenarios
     */
    private TestSuite generateFormTestSuite(Project project, WebApplication application) {
        TestSuite suite = new TestSuite();
        suite.setName("Form Tests");
        suite.setDescription("Tests form interaction functionality");
        suite.setCreatedAt(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT)));
        
        // Find pages with forms
        List<WebPage> pagesWithForms = application.getPages().stream()
                .filter(p -> !p.getForms().isEmpty())
                .collect(Collectors.toList());
        
        for (WebPage page : pagesWithForms) {
            for (WebForm form : page.getForms()) {
                // Generate happy path test case
                TestCase happyPathTest = generateFormHappyPathTest(page, form);
                suite.getTestCases().add(happyPathTest);
                
                // Generate validation test case if form has required fields
                boolean hasRequiredFields = form.getFields().stream()
                        .anyMatch(WebElement::isRequired);
                
                if (hasRequiredFields) {
                    TestCase validationTest = generateFormValidationTest(page, form);
                    suite.getTestCases().add(validationTest);
                }
            }
        }
        
        return suite;
    }
    
    /**
     * Generates a happy path test case for a form
     * @param page The page containing the form
     * @param form The form to generate a test for
     * @return A test case for the happy path scenario
     */
    private TestCase generateFormHappyPathTest(WebPage page, WebForm form) {
        TestCase testCase = new TestCase();
        testCase.setName("Form Submission Test - " + getFormName(form));
        testCase.setDescription("Tests successful submission of the form");
        
        List<TestStep> steps = new ArrayList<>();
        
        // Step 1: Navigate to page
        TestStep navigateStep = new TestStep();
        navigateStep.setType(TestStepType.NAVIGATE);
        navigateStep.setDescription("Navigate to " + page.getUrl());
        navigateStep.setTarget(page.getUrl());
        steps.add(navigateStep);
        
        // Fill out form fields
        for (WebElement field : form.getFields()) {
            if (field.getType() != ElementType.BUTTON) {
                TestStep fillStep = generateFillFormFieldStep(field, true);
                steps.add(fillStep);
            }
        }
        
        // Find and click submit button
        WebElement submitButton = findSubmitButton(form);
        if (submitButton != null) {
            TestStep submitStep = new TestStep();
            submitStep.setType(TestStepType.CLICK);
            submitStep.setDescription("Click submit button");
            submitStep.setTarget(submitButton.getSelector());
            steps.add(submitStep);
            
            // Add verification step (generic)
            TestStep verifyStep = new TestStep();
            verifyStep.setType(TestStepType.WAIT);
            verifyStep.setDescription("Wait for form submission to complete");
            verifyStep.setTarget("2000");  // 2 seconds
            steps.add(verifyStep);
        }
        
        testCase.setSteps(steps);
        return testCase;
    }
    
    /**
     * Generates a validation test case for a form
     * @param page The page containing the form
     * @param form The form to generate a test for
     * @return A test case for the validation scenario
     */
    private TestCase generateFormValidationTest(WebPage page, WebForm form) {
        TestCase testCase = new TestCase();
        testCase.setName("Form Validation Test - " + getFormName(form));
        testCase.setDescription("Tests form validation for required fields");
        
        List<TestStep> steps = new ArrayList<>();
        
        // Step 1: Navigate to page
        TestStep navigateStep = new TestStep();
        navigateStep.setType(TestStepType.NAVIGATE);
        navigateStep.setDescription("Navigate to " + page.getUrl());
        navigateStep.setTarget(page.getUrl());
        steps.add(navigateStep);
        
        // Fill out only optional fields
        for (WebElement field : form.getFields()) {
            if (field.getType() != ElementType.BUTTON && !field.isRequired()) {
                TestStep fillStep = generateFillFormFieldStep(field, true);
                steps.add(fillStep);
            }
        }
        
        // Find and click submit button
        WebElement submitButton = findSubmitButton(form);
        if (submitButton != null) {
            TestStep submitStep = new TestStep();
            submitStep.setType(TestStepType.CLICK);
            submitStep.setDescription("Click submit button");
            submitStep.setTarget(submitButton.getSelector());
            steps.add(submitStep);
            
            // Verify that form was not submitted (still on same page)
            TestStep verifyStep = new TestStep();
            verifyStep.setType(TestStepType.ASSERT_URL);
            verifyStep.setDescription("Verify still on same page (form not submitted)");
            verifyStep.setTarget(page.getUrl());
            steps.add(verifyStep);
        }
        
        testCase.setSteps(steps);
        return testCase;
    }
    
    /**
     * Generates a test suite for visual verification
     * @param project The project to generate tests for
     * @param application The analyzed web application
     * @return A test suite for visual verification
     */
    private TestSuite generateVisualVerificationTestSuite(Project project, WebApplication application) {
        TestSuite suite = new TestSuite();
        suite.setName("Visual Verification Tests");
        suite.setDescription("Tests for visual regression and UI consistency");
        suite.setCreatedAt(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT)));
        
        // Generate visual verification test for each page
        for (WebPage page : application.getPages()) {
            TestCase testCase = new TestCase();
            testCase.setName("Visual Verification - " + getPageName(page));
            testCase.setDescription("Verifies visual appearance of the page");
            
            List<TestStep> steps = new ArrayList<>();
            
            // Step 1: Navigate to page
            TestStep navigateStep = new TestStep();
            navigateStep.setType(TestStepType.NAVIGATE);
            navigateStep.setDescription("Navigate to " + page.getUrl());
            navigateStep.setTarget(page.getUrl());
            steps.add(navigateStep);
            
            // Step 2: Capture screenshot
            TestStep screenshotStep = new TestStep();
            screenshotStep.setType(TestStepType.SCREENSHOT);
            screenshotStep.setDescription("Capture page screenshot");
            screenshotStep.setTarget("page");
            steps.add(screenshotStep);
            
            // Steps 3-5: Verify specific visual elements
            List<WebElement> visualElements = page.getElements().stream()
                    .filter(e -> e.getType() == ElementType.BUTTON || 
                                e.getType() == ElementType.LINK || 
                                e.getType() == ElementType.TEXT)
                    .limit(3)
                    .collect(Collectors.toList());
            
            for (WebElement element : visualElements) {
                TestStep elementScreenshotStep = new TestStep();
                elementScreenshotStep.setType(TestStepType.SCREENSHOT);
                elementScreenshotStep.setDescription("Capture element screenshot: " + element.getText());
                elementScreenshotStep.setTarget(element.getSelector());
                steps.add(elementScreenshotStep);
            }
            
            testCase.setSteps(steps);
            suite.getTestCases().add(testCase);
        }
        
        return suite;
    }
    
    /**
     * Generates a test step to fill a form field
     * @param field The form field to fill
     * @param validData Whether to use valid data
     * @return A test step for filling the form field
     */
    private TestStep generateFillFormFieldStep(WebElement field, boolean validData) {
        TestStep step = new TestStep();
        
        switch (field.getType()) {
            case TEXT_INPUT:
            case EMAIL_INPUT:
            case PASSWORD_INPUT:
            case NUMBER_INPUT:
            case TEXTAREA:
                step.setType(TestStepType.FILL);
                step.setDescription("Fill " + getFieldName(field));
                step.setTarget(field.getSelector());
                step.setValue(generateValueForField(field, validData));
                break;
                
            case CHECKBOX:
            case RADIO_BUTTON:
                step.setType(TestStepType.CLICK);
                step.setDescription("Click " + getFieldName(field));
                step.setTarget(field.getSelector());
                break;
                
            case SELECT:
                step.setType(TestStepType.SELECT);
                step.setDescription("Select option in " + getFieldName(field));
                step.setTarget(field.getSelector());
                
                if (field.getOptions() != null && !field.getOptions().isEmpty()) {
                    int optionIndex = random.nextInt(field.getOptions().size());
                    step.setValue(field.getOptions().get(optionIndex));
                } else {
                    step.setValue("Option 1");
                }
                break;
                
            case FILE_UPLOAD:
                step.setType(TestStepType.UPLOAD);
                step.setDescription("Upload file to " + getFieldName(field));
                step.setTarget(field.getSelector());
                step.setValue("test-file.txt");
                break;
                
            default:
                // Skip other field types
                return null;
        }
        
        return step;
    }
    
    /**
     * Finds the submit button for a form
     * @param form The form to find the submit button for
     * @return The submit button element
     */
    private WebElement findSubmitButton(WebForm form) {
        // First look for submit type buttons
        Optional<WebElement> submitButton = form.getFields().stream()
                .filter(e -> e.getType() == ElementType.BUTTON && 
                           (e.getCategory() != null && e.getCategory().equals("submit-button")))
                .findFirst();
        
        if (submitButton.isPresent()) {
            return submitButton.get();
        }
        
        // Then look for any button
        Optional<WebElement> anyButton = form.getFields().stream()
                .filter(e -> e.getType() == ElementType.BUTTON)
                .findFirst();
        
        return anyButton.orElse(null);
    }
    
    /**
     * Generates a value for a form field based on its type
     * @param field The form field
     * @param validData Whether to generate valid data
     * @return A generated value for the field
     */
    private String generateValueForField(WebElement field, boolean validData) {
        if (!validData) {
            return "";  // For invalid data, return empty string
        }
        
        switch (field.getType()) {
            case TEXT_INPUT:
                if (field.getName() != null) {
                    String name = field.getName().toLowerCase();
                    if (name.contains("name")) {
                        return "Test User";
                    } else if (name.contains("first")) {
                        return "Test";
                    } else if (name.contains("last")) {
                        return "User";
                    } else if (name.contains("address")) {
                        return "123 Test Street";
                    } else if (name.contains("city")) {
                        return "Test City";
                    } else if (name.contains("state")) {
                        return "Test State";
                    } else if (name.contains("zip") || name.contains("postal")) {
                        return "12345";
                    } else if (name.contains("phone")) {
                        return "555-123-4567";
                    }
                }
                return "Test Input";
                
            case EMAIL_INPUT:
                return "test@example.com";
                
            case PASSWORD_INPUT:
                return "Password123!";
                
            case NUMBER_INPUT:
                if (field.getName() != null) {
                    String name = field.getName().toLowerCase();
                    if (name.contains("age")) {
                        return "30";
                    } else if (name.contains("quantity")) {
                        return "1";
                    } else if (name.contains("price") || name.contains("amount")) {
                        return "99.99";
                    }
                }
                return "42";
                
            case TEXTAREA:
                return "This is a test comment or message that is being entered into this text area field for testing purposes.";
                
            default:
                return "Test Value";
        }
    }
    
    /**
     * Gets a readable name for a page
     * @param page The page
     * @return A readable name
     */
    private String getPageName(WebPage page) {
        if (page.getTitle() != null && !page.getTitle().isEmpty()) {
            return page.getTitle();
        }
        
        String url = page.getUrl();
        if (url.endsWith("/")) {
            url = url.substring(0, url.length() - 1);
        }
        
        int lastSlash = url.lastIndexOf('/');
        if (lastSlash >= 0 && lastSlash < url.length() - 1) {
            return url.substring(lastSlash + 1);
        }
        
        return url;
    }
    
    /**
     * Gets a readable name for a form
     * @param form The form
     * @return A readable name
     */
    private String getFormName(WebForm form) {
        if (form.getAction() != null && !form.getAction().isEmpty()) {
            String action = form.getAction();
            int lastSlash = action.lastIndexOf('/');
            if (lastSlash >= 0 && lastSlash < action.length() - 1) {
                return action.substring(lastSlash + 1);
            }
            return action;
        }
        
        return "Form " + form.getSelector();
    }
    
    /**
     * Gets a readable name for a field
     * @param field The field
     * @return A readable name
     */
    private String getFieldName(WebElement field) {
        if (field.getName() != null && !field.getName().isEmpty()) {
            return "field '" + field.getName() + "'";
        }
        
        if (field.getId() != null && !field.getId().isEmpty()) {
            return "field with id '" + field.getId() + "'";
        }
        
        if (field.getText() != null && !field.getText().isEmpty()) {
            return "field with text '" + field.getText() + "'";
        }
        
        return "field " + field.getSelector();
    }
    
    /**
     * Saves a test suite to the file system
     * @param project The project
     * @param suite The test suite to save
     */
    private void saveTestSuite(Project project, TestSuite suite) {
        try {
            // Create directory structure
            String projectDir = project.getPath();
            String suitesDir = projectDir + "/test-suites";
            
            Path path = Paths.get(suitesDir);
            if (!Files.exists(path)) {
                Files.createDirectories(path);
            }
            
            // Generate suite ID if not present
            if (suite.getId() == null || suite.getId().isEmpty()) {
                suite.setId(UUID.randomUUID().toString());
            }
            
            // Save suite JSON
            String suiteJson = convertToJson(suite);
            String suiteFile = suitesDir + "/" + suite.getId() + ".json";
            
            FileUtils.writeStringToFile(new File(suiteFile), suiteJson, StandardCharsets.UTF_8);
            
            // Generate script files for each test case
            String scriptsDir = projectDir + "/test-scripts";
            path = Paths.get(scriptsDir);
            if (!Files.exists(path)) {
                Files.createDirectories(path);
            }
            
            for (TestCase testCase : suite.getTestCases()) {
                if (testCase.getId() == null || testCase.getId().isEmpty()) {
                    testCase.setId(UUID.randomUUID().toString());
                }
                
                String scriptContent = generateTestScript(testCase);
                String scriptFile = scriptsDir + "/" + testCase.getId() + ".js";
                
                FileUtils.writeStringToFile(new File(scriptFile), scriptContent, StandardCharsets.UTF_8);
            }
            
        } catch (IOException e) {
            log.error("Error saving test suite: {}", suite.getName(), e);
        }
    }
    
    /**
     * Generates a test script for a test case
     * @param testCase The test case
     * @return The generated script content
     */
    private String generateTestScript(TestCase testCase) {
        StringBuilder script = new StringBuilder();
        
        // Add header
        script.append("// Test Case: ").append(testCase.getName()).append("\n");
        script.append("// Generated: ").append(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT))).append("\n\n");
        
        // Add imports
        script.append("const { test, expect } = require('@playwright/test');\n\n");
        
        // Add test function
        script.append("test('").append(testCase.getName()).append("', async ({ page }) => {\n");
        
        // Add test steps
        for (TestStep step : testCase.getSteps()) {
            script.append("  // ").append(step.getDescription()).append("\n");
            
            switch (step.getType()) {
                case NAVIGATE:
                    script.append("  await page.goto('").append(step.getTarget()).append("');\n");
                    break;
                    
                case CLICK:
                    script.append("  await page.click('").append(step.getTarget()).append("');\n");
                    break;
                    
                case FILL:
                    script.append("  await page.fill('").append(step.getTarget()).append("', '")
                          .append(step.getValue()).append("');\n");
                    break;
                    
                case SELECT:
                    script.append("  await page.selectOption('").append(step.getTarget()).append("', '")
                          .append(step.getValue()).append("');\n");
                    break;
                    
                case UPLOAD:
                    script.append("  await page.setInputFiles('").append(step.getTarget()).append("', '")
                          .append(step.getValue()).append("');\n");
                    break;
                    
                case WAIT:
                    script.append("  await page.waitForTimeout(").append(step.getTarget()).append(");\n");
                    break;
                    
                case ASSERT_TITLE:
                    script.append("  await expect(page).toHaveTitle(/").append(step.getTarget()).append("/);\n");
                    break;
                    
                case ASSERT_URL:
                    script.append("  await expect(page).toHaveURL(/").append(step.getTarget()).append("/);\n");
                    break;
                    
                case ASSERT_ELEMENT:
                    script.append("  await expect(page.locator('").append(step.getTarget()).append("')).toBeVisible();\n");
                    break;
                    
                case SCREENSHOT:
                    if (step.getTarget().equals("page")) {
                        script.append("  await page.screenshot({ path: 'screenshots/")
                              .append(testCase.getId()).append("_page.png' });\n");
                    } else {
                        script.append("  await page.locator('").append(step.getTarget())
                              .append("').screenshot({ path: 'screenshots/")
                              .append(testCase.getId()).append("_element_")
                              .append(System.currentTimeMillis()).append(".png' });\n");
                    }
                    break;
                    
                default:
                    script.append("  // Unsupported step type: ").append(step.getType()).append("\n");
            }
            
            script.append("\n");
        }
        
        script.append("});\n");
        
        return script.toString();
    }
    
    /**
     * Converts an object to JSON
     * @param object The object to convert
     * @return The JSON representation
     */
    private String convertToJson(Object object) {
        // Note: In a real implementation, this would use Jackson or Gson
        // This is a simplified placeholder
        return "{ \"id\": \"" + UUID.randomUUID().toString() + "\", \"name\": \"" + object.toString() + "\" }";
    }
    
    /**
     * Gets a test suite by ID
     * @param project The project
     * @param suiteId The test suite ID
     * @return The test suite or null if not found
     */
    public TestSuite getTestSuite(Project project, String suiteId) {
        log.info("Getting test suite: {} for project: {}", suiteId, project.getName());
        
        try {
            // Build the path to the test suite file
            String suitesDir = project.getPath() + "/test-suites";
            String suiteFile = suitesDir + "/" + suiteId + ".json";
            
            File file = new File(suiteFile);
            if (!file.exists()) {
                log.warn("Test suite file not found: {}", suiteFile);
                return null;
            }
            
            // Read the test suite file
            String suiteJson = FileUtils.readFileToString(file, StandardCharsets.UTF_8);
            
            // Parse the JSON to a TestSuite object
            // Note: In a real implementation, this would use Jackson or Gson
            // This is a simplified placeholder implementation
            TestSuite suite = new TestSuite();
            suite.setId(suiteId);
            // Parse other properties from JSON...
            
            // Load test cases
            List<TestCase> testCases = loadTestCases(project, suite);
            suite.setTestCases(testCases);
            
            return suite;
        } catch (IOException e) {
            log.error("Error loading test suite: {}", suiteId, e);
            return null;
        }
    }
    
    /**
     * Gets all test suites for a project
     * @param project The project
     * @return The list of test suites
     */
    public List<TestSuite> getTestSuites(Project project) {
        log.info("Getting all test suites for project: {}", project.getName());
        
        List<TestSuite> testSuites = new ArrayList<>();
        
        try {
            // Get the test suites directory
            String suitesDir = project.getPath() + "/test-suites";
            File dir = new File(suitesDir);
            
            if (!dir.exists() || !dir.isDirectory()) {
                log.warn("Test suites directory not found: {}", suitesDir);
                return testSuites;
            }
            
            // List all JSON files in the directory
            File[] files = dir.listFiles((d, name) -> name.endsWith(".json"));
            
            if (files == null) {
                return testSuites;
            }
            
            // Load each test suite
            for (File file : files) {
                try {
                    String suiteId = file.getName().replace(".json", "");
                    TestSuite suite = getTestSuite(project, suiteId);
                    
                    if (suite != null) {
                        testSuites.add(suite);
                    }
                } catch (Exception e) {
                    log.error("Error loading test suite from file: {}", file.getName(), e);
                }
            }
        } catch (Exception e) {
            log.error("Error loading test suites", e);
        }
        
        return testSuites;
    }
    
    /**
     * Deletes a test suite
     * @param project The project
     * @param suiteId The test suite ID
     * @return True if deleted, false otherwise
     */
    public boolean deleteTestSuite(Project project, String suiteId) {
        log.info("Deleting test suite: {} for project: {}", suiteId, project.getName());
        
        try {
            // Build the path to the test suite file
            String suitesDir = project.getPath() + "/test-suites";
            String suiteFile = suitesDir + "/" + suiteId + ".json";
            
            File file = new File(suiteFile);
            if (!file.exists()) {
                log.warn("Test suite file not found: {}", suiteFile);
                return false;
            }
            
            // Delete the test suite file
            boolean deleted = file.delete();
            
            if (deleted) {
                log.info("Test suite file deleted: {}", suiteFile);
                
                // Also delete associated test script files
                String scriptsDir = project.getPath() + "/test-scripts";
                File scriptsDirectory = new File(scriptsDir);
                
                if (scriptsDirectory.exists() && scriptsDirectory.isDirectory()) {
                    // Get the test suite to find its test case IDs
                    TestSuite suite = getTestSuite(project, suiteId);
                    
                    if (suite != null && suite.getTestCases() != null) {
                        for (TestCase testCase : suite.getTestCases()) {
                            String scriptFile = scriptsDir + "/" + testCase.getId() + ".js";
                            File script = new File(scriptFile);
                            
                            if (script.exists()) {
                                script.delete();
                                log.info("Test script file deleted: {}", scriptFile);
                            }
                        }
                    }
                }
            }
            
            return deleted;
        } catch (Exception e) {
            log.error("Error deleting test suite: {}", suiteId, e);
            return false;
        }
    }
    
    /**
     * Loads test cases for a test suite
     * @param project The project
     * @param suite The test suite
     * @return The list of test cases
     */
    private List<TestCase> loadTestCases(Project project, TestSuite suite) {
        List<TestCase> testCases = new ArrayList<>();
        
        try {
            // In a real implementation, this would load test cases from individual files or from the suite file
            // This is a simplified placeholder implementation
            
            // For demonstration, create some sample test cases
            TestCase testCase = new TestCase();
            testCase.setId(UUID.randomUUID().toString());
            testCase.setName("Sample Test Case");
            testCase.setDescription("A sample test case for demonstration");
            
            List<TestStep> steps = new ArrayList<>();
            
            TestStep step1 = new TestStep();
            step1.setType(TestStepType.NAVIGATE);
            step1.setDescription("Navigate to page");
            step1.setTarget("https://example.com");
            steps.add(step1);
            
            TestStep step2 = new TestStep();
            step2.setType(TestStepType.CLICK);
            step2.setDescription("Click button");
            step2.setTarget("#submit-button");
            steps.add(step2);
            
            testCase.setSteps(steps);
            testCases.add(testCase);
        } catch (Exception e) {
            log.error("Error loading test cases for suite: {}", suite.getId(), e);
        }
        
        return testCases;
    }
}


package com.ctgp.service.generator;

import com.ctgp.model.analyzer.*;
import com.ctgp.model.workspace.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class AdvancedTestGeneratorService {

    private final TestGeneratorService basicTestGenerator;
    private static final String DATE_FORMAT = "yyyy-MM-dd HH:mm:ss";
    private static final Pattern EMAIL_PATTERN = Pattern.compile("^[A-Za-z0-9+_.-]+@(.+)$");
    private static final Pattern NUMERIC_PATTERN = Pattern.compile("^\\d+$");
    private static final Random random = new Random();

    /**
     * Generates advanced test suites with workflow detection and data-driven tests
     * @param project The project to generate tests for
     * @param application The analyzed web application
     * @return A list of generated test suites
     */
    public List<TestSuite> generateAdvancedTestSuites(Project project, WebApplication application) {
        log.info("Generating advanced test suites for project: {}", project.getName());
        
        List<TestSuite> testSuites = new ArrayList<>();
        
        // Generate workflow test suite
        TestSuite workflowSuite = generateWorkflowTestSuite(project, application);
        testSuites.add(workflowSuite);
        
        // Generate data-driven test suite
        TestSuite dataDrivenSuite = generateDataDrivenTestSuite(project, application);
        testSuites.add(dataDrivenSuite);
        
        // Generate visual regression test suite
        TestSuite visualRegressionSuite = generateVisualRegressionTestSuite(project, application);
        testSuites.add(visualRegressionSuite);
        
        log.info("Generated {} advanced test suites with {} total test cases", 
                testSuites.size(), 
                testSuites.stream().mapToInt(s -> s.getTestCases().size()).sum());
        
        return testSuites;
    }
    
    /**
     * Generates a test suite for detected workflows
     * @param project The project
     * @param application The web application
     * @return A test suite with workflow test cases
     */
    public TestSuite generateWorkflowTestSuite(Project project, WebApplication application) {
        TestSuite suite = new TestSuite();
        suite.setName("Workflow Tests");
        suite.setDescription("Tests that verify end-to-end user workflows");
        suite.setCreatedAt(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT)));
        
        // Detect potential workflows
        List<Workflow> workflows = detectWorkflows(application);
        
        // Generate test cases for each workflow
        for (Workflow workflow : workflows) {
            TestCase testCase = new TestCase();
            testCase.setId(UUID.randomUUID().toString());
            testCase.setName("Workflow Test - " + workflow.getName());
            testCase.setDescription("Tests the " + workflow.getName() + " workflow");
            
            List<TestStep> steps = new ArrayList<>();
            
            // First step: Navigate to starting page
            TestStep navigateStep = new TestStep();
            navigateStep.setType(TestStepType.NAVIGATE);
            navigateStep.setDescription("Navigate to starting page");
            navigateStep.setTarget(workflow.getStartPage().getUrl());
            steps.add(navigateStep);
            
            // Add steps for each workflow step
            for (WorkflowStep workflowStep : workflow.getSteps()) {
                steps.addAll(generateTestStepsForWorkflowStep(workflowStep));
            }
            
            testCase.setSteps(steps);
            suite.getTestCases().add(testCase);
        }
        
        return suite;
    }
    
    /**
     * Generates test steps for a workflow step
     * @param workflowStep The workflow step
     * @return List of test steps
     */
    private List<TestStep> generateTestStepsForWorkflowStep(WorkflowStep workflowStep) {
        List<TestStep> steps = new ArrayList<>();
        
        switch (workflowStep.getType()) {
            case NAVIGATION:
                // Add a click step for the navigation
                TestStep clickNavStep = new TestStep();
                clickNavStep.setType(TestStepType.CLICK);
                clickNavStep.setDescription("Click on navigation element: " + workflowStep.getElement().getText());
                clickNavStep.setTarget(workflowStep.getElement().getSelector());
                steps.add(clickNavStep);
                
                // Verify navigation
                TestStep verifyNavStep = new TestStep();
                verifyNavStep.setType(TestStepType.ASSERT_URL);
                verifyNavStep.setDescription("Verify navigation to: " + workflowStep.getTargetUrl());
                verifyNavStep.setTarget(workflowStep.getTargetUrl());
                steps.add(verifyNavStep);
                break;
                
            case FORM_SUBMISSION:
                // Get form
                WebForm form = workflowStep.getForm();
                
                // Fill out form fields
                for (WebElement field : form.getFields()) {
                    if (field.getType() != ElementType.BUTTON) {
                        // Generate appropriate test step for the field
                        TestStep fillStep = generateFormFieldStep(field);
                        if (fillStep != null) {
                            steps.add(fillStep);
                        }
                    }
                }
                
                // Find and click submit button
                WebElement submitButton = findSubmitButton(form);
                if (submitButton != null) {
                    TestStep submitStep = new TestStep();
                    submitStep.setType(TestStepType.CLICK);
                    submitStep.setDescription("Click submit button");
                    submitStep.setTarget(submitButton.getSelector());
                    steps.add(submitStep);
                    
                    // Add verification step if target URL is known
                    if (workflowStep.getTargetUrl() != null && !workflowStep.getTargetUrl().isEmpty()) {
                        TestStep verifyFormStep = new TestStep();
                        verifyFormStep.setType(TestStepType.ASSERT_URL);
                        verifyFormStep.setDescription("Verify navigation after form submission");
                        verifyFormStep.setTarget(workflowStep.getTargetUrl());
                        steps.add(verifyFormStep);
                    } else {
                        // Generic wait for form submission
                        TestStep waitStep = new TestStep();
                        waitStep.setType(TestStepType.WAIT);
                        waitStep.setDescription("Wait for form submission to complete");
                        waitStep.setTarget("2000");  // 2 seconds
                        steps.add(waitStep);
                    }
                }
                break;
                
            case INTERACTION:
                // Add click step for the interaction
                TestStep clickStep = new TestStep();
                clickStep.setType(TestStepType.CLICK);
                clickStep.setDescription("Click on interactive element: " + workflowStep.getElement().getText());
                clickStep.setTarget(workflowStep.getElement().getSelector());
                steps.add(clickStep);
                
                // Add verification step if applicable
                if (workflowStep.getVerificationElement() != null) {
                    TestStep verifyInteractionStep = new TestStep();
                    verifyInteractionStep.setType(TestStepType.ASSERT_ELEMENT);
                    verifyInteractionStep.setDescription("Verify element appears after interaction");
                    verifyInteractionStep.setTarget(workflowStep.getVerificationElement().getSelector());
                    steps.add(verifyInteractionStep);
                }
                break;
        }
        
        return steps;
    }
    
    /**
     * Generates a test suite with data-driven tests for forms
     * @param project The project
     * @param application The web application
     * @return A test suite with data-driven test cases
     */
    public TestSuite generateDataDrivenTestSuite(Project project, WebApplication application) {
        TestSuite suite = new TestSuite();
        suite.setName("Data-Driven Tests");
        suite.setDescription("Tests forms with various data inputs including valid, invalid, and boundary values");
        suite.setCreatedAt(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT)));
        
        // Find pages with forms
        List<WebPage> pagesWithForms = application.getPages().stream()
                .filter(p -> !p.getForms().isEmpty())
                .collect(Collectors.toList());
        
        for (WebPage page : pagesWithForms) {
            for (WebForm form : page.getForms()) {
                // Generate valid data test
                TestCase validDataTest = generateDataDrivenTest(
                    page, form, "Valid Data", "Tests form submission with valid data", 
                    DataTestType.VALID_DATA
                );
                suite.getTestCases().add(validDataTest);
                
                // Generate invalid data test
                TestCase invalidDataTest = generateDataDrivenTest(
                    page, form, "Invalid Data", "Tests form validation with invalid data", 
                    DataTestType.INVALID_DATA
                );
                suite.getTestCases().add(invalidDataTest);
                
                // Generate boundary value test
                TestCase boundaryValueTest = generateDataDrivenTest(
                    page, form, "Boundary Values", "Tests form with boundary value data", 
                    DataTestType.BOUNDARY_VALUES
                );
                suite.getTestCases().add(boundaryValueTest);
            }
        }
        
        return suite;
    }
    
    /**
     * Generates a data-driven test case for a form
     * @param page The page containing the form
     * @param form The form to test
     * @param nameSuffix The suffix for the test name
     * @param description The test description
     * @param dataType The type of data to use
     * @return A test case
     */
    private TestCase generateDataDrivenTest(WebPage page, WebForm form, String nameSuffix, 
                                          String description, DataTestType dataType) {
        TestCase testCase = new TestCase();
        testCase.setId(UUID.randomUUID().toString());
        testCase.setName("Form " + nameSuffix + " Test - " + getFormName(form));
        testCase.setDescription(description);
        
        List<TestStep> steps = new ArrayList<>();
        
        // Navigate to page
        TestStep navigateStep = new TestStep();
        navigateStep.setType(TestStepType.NAVIGATE);
        navigateStep.setDescription("Navigate to " + page.getUrl());
        navigateStep.setTarget(page.getUrl());
        steps.add(navigateStep);
        
        // Fill form fields with appropriate data
        for (WebElement field : form.getFields()) {
            if (field.getType() != ElementType.BUTTON) {
                TestStep fillStep = generateDataDrivenFieldStep(field, dataType);
                if (fillStep != null) {
                    steps.add(fillStep);
                }
            }
        }
        
        // Find and click submit button
        WebElement submitButton = findSubmitButton(form);
        if (submitButton != null) {
            TestStep submitStep = new TestStep();
            submitStep.setType(TestStepType.CLICK);
            submitStep.setDescription("Click submit button");
            submitStep.setTarget(submitButton.getSelector());
            steps.add(submitStep);
            
            // Add appropriate verification
            if (dataType == DataTestType.VALID_DATA) {
                // For valid data, expect successful submission
                TestStep waitStep = new TestStep();
                waitStep.setType(TestStepType.WAIT);
                waitStep.setDescription("Wait for form submission to complete");
                waitStep.setTarget("2000");  // 2 seconds
                steps.add(waitStep);
            } else {
                // For invalid or boundary data, verify form validation
                TestStep verifyStep = new TestStep();
                verifyStep.setType(TestStepType.ASSERT_URL);
                verifyStep.setDescription("Verify still on same page (form validation triggered)");
                verifyStep.setTarget(page.getUrl());
                steps.add(verifyStep);
            }
        }
        
        testCase.setSteps(steps);
        return testCase;
    }
    
    /**
     * Generates a visual regression test suite
     * @param project The project
     * @param application The web application
     * @return A test suite with visual regression tests
     */
    public TestSuite generateVisualRegressionTestSuite(Project project, WebApplication application) {
        TestSuite suite = new TestSuite();
        suite.setName("Visual Regression Tests");
        suite.setDescription("Advanced tests for visual appearance and layout consistency");
        suite.setCreatedAt(LocalDateTime.now().format(DateTimeFormatter.ofPattern(DATE_FORMAT)));
        
        // Generate responsive design test cases
        for (WebPage page : application.getPages()) {
            TestCase responsiveTest = generateResponsiveDesignTest(page);
            suite.getTestCases().add(responsiveTest);
        }
        
        // Generate layout consistency test
        TestCase layoutConsistencyTest = generateLayoutConsistencyTest(application);
        suite.getTestCases().add(layoutConsistencyTest);
        
        return suite;
    }
    
    /**
     * Generates a responsive design test case
     * @param page The page to test
     * @return A test case
     */
    private TestCase generateResponsiveDesignTest(WebPage page) {
        TestCase testCase = new TestCase();
        testCase.setId(UUID.randomUUID().toString());
        testCase.setName("Responsive Design Test - " + getPageName(page));
        testCase.setDescription("Tests page appearance at different screen sizes");
        
        List<TestStep> steps = new ArrayList<>();
        
        // Navigate to page
        TestStep navigateStep = new TestStep();
        navigateStep.setType(TestStepType.NAVIGATE);
        navigateStep.setDescription("Navigate to " + page.getUrl());
        navigateStep.setTarget(page.getUrl());
        steps.add(navigateStep);
        
        // Test different viewport sizes
        int[][] viewportSizes = {
            {1920, 1080}, // Desktop
            {1024, 768},  // Tablet landscape
            {768, 1024},  // Tablet portrait
            {375, 812}    // Mobile
        };
        
        for (int[] size : viewportSizes) {
            // Set viewport size
            TestStep viewportStep = new TestStep();
            viewportStep.setType(TestStepType.VIEWPORT);
            viewportStep.setDescription("Set viewport to " + size[0] + "x" + size[1]);
            viewportStep.setTarget(size[0] + "," + size[1]);
            steps.add(viewportStep);
            
            // Take screenshot
            TestStep screenshotStep = new TestStep();
            screenshotStep.setType(TestStepType.SCREENSHOT);
            screenshotStep.setDescription("Capture screenshot at " + size[0] + "x" + size[1]);
            screenshotStep.setTarget("page");
            steps.add(screenshotStep);
        }
        
        testCase.setSteps(steps);
        return testCase;
    }
    
    /**
     * Generates a layout consistency test case
     * @param application The web application
     * @return A test case
     */
    private TestCase generateLayoutConsistencyTest(WebApplication application) {
        TestCase testCase = new TestCase();
        testCase.setId(UUID.randomUUID().toString());
        testCase.setName("Layout Consistency Test");
        testCase.setDescription("Tests consistency of layout elements across pages");
        
        List<TestStep> steps = new ArrayList<>();
        
        // Select key pages to test (limit to 5)
        List<WebPage> pagesToTest = application.getPages().stream()
                .limit(5)
                .collect(Collectors.toList());
        
        for (WebPage page : pagesToTest) {
            // Navigate to page
            TestStep navigateStep = new TestStep();
            navigateStep.setType(TestStepType.NAVIGATE);
            navigateStep.setDescription("Navigate to " + page.getUrl());
            navigateStep.setTarget(page.getUrl());
            steps.add(navigateStep);
            
            // Check common elements (header, footer, navigation)
            String[] commonSelectors = {
                "header", "nav", "footer", ".logo", ".main-menu"
            };
            
            for (String selector : commonSelectors) {
                TestStep assertStep = new TestStep();
                assertStep.setType(TestStepType.ASSERT_ELEMENT);
                assertStep.setDescription("Verify common element exists: " + selector);
                assertStep.setTarget(selector);
                steps.add(assertStep);
            }
            
            // Take screenshot for comparison
            TestStep screenshotStep = new TestStep();
            screenshotStep.setType(TestStepType.SCREENSHOT);
            screenshotStep.setDescription("Capture screenshot for layout comparison");
            screenshotStep.setTarget("page");
            steps.add(screenshotStep);
        }
        
        testCase.setSteps(steps);
        return testCase;
    }
    
    /**
     * Detects potential workflows in the application
     * @param application The web application
     * @return List of detected workflows
     */
    private List<Workflow> detectWorkflows(WebApplication application) {
        List<Workflow> workflows = new ArrayList<>();
        
        // Try to find login/signup workflow
        Workflow authWorkflow = detectAuthenticationWorkflow(application);
        if (authWorkflow != null) {
            workflows.add(authWorkflow);
        }
        
        // Try to find form submission workflows
        List<Workflow> formWorkflows = detectFormSubmissionWorkflows(application);
        workflows.addAll(formWorkflows);
        
        // Try to find multi-step workflows
        List<Workflow> multiStepWorkflows = detectMultiStepWorkflows(application);
        workflows.addAll(multiStepWorkflows);
        
        return workflows;
    }
    
    /**
     * Detects authentication workflows (login/signup)
     * @param application The web application
     * @return Detected workflow or null
     */
    private Workflow detectAuthenticationWorkflow(WebApplication application) {
        // Look for login/signup pages
        Optional<WebPage> loginPage = findPageWithAuthForm(application, "login");
        Optional<WebPage> signupPage = findPageWithAuthForm(application, "signup");
        
        if (loginPage.isPresent()) {
            // Create login workflow
            Workflow workflow = new Workflow();
            workflow.setName("Login");
            workflow.setStartPage(loginPage.get());
            
            List<WorkflowStep> steps = new ArrayList<>();
            
            // Add form submission step
            WebForm loginForm = findAuthForm(loginPage.get(), "login");
            if (loginForm != null) {
                WorkflowStep formStep = new WorkflowStep();
                formStep.setType(WorkflowStepType.FORM_SUBMISSION);
                formStep.setForm(loginForm);
                
                // Try to determine target URL after login
                if (application.getPages().size() > 1) {
                    // Assume first non-login page might be the dashboard/home
                    Optional<WebPage> targetPage = application.getPages().stream()
                            .filter(p -> !p.equals(loginPage.get()))
                            .findFirst();
                    
                    if (targetPage.isPresent()) {
                        formStep.setTargetUrl(targetPage.get().getUrl());
                    }
                }
                
                steps.add(formStep);
            }
            
            workflow.setSteps(steps);
            return workflow;
        } else if (signupPage.isPresent()) {
            // Create signup workflow
            Workflow workflow = new Workflow();
            workflow.setName("Signup");
            workflow.setStartPage(signupPage.get());
            
            List<WorkflowStep> steps = new ArrayList<>();
            
            // Add form submission step
            WebForm signupForm = findAuthForm(signupPage.get(), "signup");
            if (signupForm != null) {
                WorkflowStep formStep = new WorkflowStep();
                formStep.setType(WorkflowStepType.FORM_SUBMISSION);
                formStep.setForm(signupForm);
                
                // Try to determine target URL after signup
                if (application.getPages().size() > 1) {
                    // Assume first non-signup page might be the confirmation/login page
                    Optional<WebPage> targetPage = application.getPages().stream()
                            .filter(p -> !p.equals(signupPage.get()))
                            .findFirst();
                    
                    if (targetPage.isPresent()) {
                        formStep.setTargetUrl(targetPage.get().getUrl());
                    }
                }
                
                steps.add(formStep);
            }
            
            workflow.setSteps(steps);
            return workflow;
        }
        
        return null;
    }
    
    /**
     * Finds a page with authentication form
     * @param application The web application
     * @param authType "login" or "signup"
     * @return Optional containing the page, or empty
     */
    private Optional<WebPage> findPageWithAuthForm(WebApplication application, String authType) {
        return application.getPages().stream()
                .filter(page -> {
                    // Check URL first
                    boolean urlMatch = page.getUrl().toLowerCase().contains(authType) ||
                                     (authType.equals("signup") && page.getUrl().toLowerCase().contains("register"));
                    
                    if (urlMatch) {
                        return true;
                    }
                    
                    // Check title
                    if (page.getTitle() != null) {
                        boolean titleMatch = page.getTitle().toLowerCase().contains(authType) ||
                                          (authType.equals("signup") && page.getTitle().toLowerCase().contains("register"));
                        
                        if (titleMatch) {
                            return true;
                        }
                    }
                    
                    // Check for authentication form
                    return findAuthForm(page, authType) != null;
                })
                .findFirst();
    }
    
    /**
     * Finds an authentication form on a page
     * @param page The page
     * @param authType "login" or "signup"
     * @return The form or null
     */
    private WebForm findAuthForm(WebPage page, String authType) {
        for (WebForm form : page.getForms()) {
            boolean hasPasswordField = form.getFields().stream()
                    .anyMatch(f -> f.getType() == ElementType.PASSWORD_INPUT);
            
            if (!hasPasswordField) {
                continue;
            }
            
            boolean hasEmailField = form.getFields().stream()
                    .anyMatch(f -> f.getType() == ElementType.EMAIL_INPUT ||
                                 (f.getType() == ElementType.TEXT_INPUT && 
                                  (f.getName() != null && f.getName().toLowerCase().contains("email") || 
                                   f.getId() != null && f.getId().toLowerCase().contains("email"))));
            
            if (authType.equals("login")) {
                // Login form typically has password + email/username fields
                boolean hasUsernameField = form.getFields().stream()
                        .anyMatch(f -> f.getType() == ElementType.TEXT_INPUT && 
                                     (f.getName() != null && f.getName().toLowerCase().contains("username") || 
                                      f.getId() != null && f.getId().toLowerCase().contains("username")));
                
                if (hasEmailField || hasUsernameField) {
                    return form;
                }
            } else if (authType.equals("signup")) {
                // Signup form typically has more fields, like name, confirmation fields, etc.
                boolean hasNameField = form.getFields().stream()
                        .anyMatch(f -> f.getType() == ElementType.TEXT_INPUT && 
                                     (f.getName() != null && (f.getName().toLowerCase().contains("name") || 
                                                           f.getName().toLowerCase().contains("first") || 
                                                           f.getName().toLowerCase().contains("last")) || 
                                      f.getId() != null && (f.getId().toLowerCase().contains("name") || 
                                                          f.getId().toLowerCase().contains("first") || 
                                                          f.getId().toLowerCase().contains("last"))));
                
                boolean hasConfirmPasswordField = form.getFields().stream()
                        .filter(f -> f.getType() == ElementType.PASSWORD_INPUT)
                        .count() > 1;
                
                if (hasEmailField && (hasNameField || hasConfirmPasswordField)) {
                    return form;
                }
            }
        }
        
        return null;
    }
    
    /**
     * Detects form submission workflows
     * @param application The web application
     * @return List of form workflows
     */
    private List<Workflow> detectFormSubmissionWorkflows(WebApplication application) {
        List<Workflow> workflows = new ArrayList<>();
        
        for (WebPage page : application.getPages()) {
            for (WebForm form : page.getForms()) {
                // Skip simple forms with less than 3 fields (likely already covered by auth workflows)
                if (form.getFields().size() < 3) {
                    continue;
                }
                
                // Determine form type based on fields
                String formType = determineFormType(form);
                
                Workflow workflow = new Workflow();
                workflow.setName(formType + " Submission");
                workflow.setStartPage(page);
                
                List<WorkflowStep> steps = new ArrayList<>();
                
                // Add form submission step
                WorkflowStep formStep = new WorkflowStep();
                formStep.setType(WorkflowStepType.FORM_SUBMISSION);
                formStep.setForm(form);
                
                // Try to guess target URL
                if (form.getAction() != null && !form.getAction().isEmpty()) {
                    String action = form.getAction();
                    if (action.startsWith("/") || !action.startsWith("http")) {
                        // Relative URL, try to find matching page
                        String targetPath = action.startsWith("/") ? action : "/" + action;
                        Optional<WebPage> targetPage = application.getPages().stream()
                                .filter(p -> p.getUrl().endsWith(targetPath))
                                .findFirst();
                        
                        if (targetPage.isPresent()) {
                            formStep.setTargetUrl(targetPage.get().getUrl());
                        }
                    } else {
                        // Absolute URL
                        formStep.setTargetUrl(action);
                    }
                }
                
                steps.add(formStep);
                workflow.setSteps(steps);
                
                workflows.add(workflow);
            }
        }
        
        return workflows;
    }
    
    /**
     * Detects multi-step workflows
     * @param application The web application
     * @return List of multi-step workflows
     */
    private List<Workflow> detectMultiStepWorkflows(WebApplication application) {
        List<Workflow> workflows = new ArrayList<>();
        
        // Check for sequential pages with navigation links
        Map<String, List<String>> pageConnections = buildPageNavigationGraph(application);
        
        // Find potential workflows (sequences of connected pages)
        for (WebPage startPage : application.getPages()) {
            String startUrl = startPage.getUrl();
            
            if (!pageConnections.containsKey(startUrl)) {
                continue;
            }
            
            // Try to find a path of 3+ connected pages
            List<String> path = findLongestPath(startUrl, pageConnections, new HashSet<>(), 3);
            
            if (path.size() >= 3) {
                Workflow workflow = new Workflow();
                workflow.setName("Multi-Page Workflow");
                workflow.setStartPage(startPage);
                
                List<WorkflowStep> steps = new ArrayList<>();
                
                // Convert path to workflow steps
                String currentUrl = startUrl;
                for (int i = 1; i < path.size(); i++) {
                    String nextUrl = path.get(i);
                    
                    // Find the current page and next page
                    WebPage currentPage = findPageByUrl(application, currentUrl);
                    WebPage nextPage = findPageByUrl(application, nextUrl);
                    
                    if (currentPage != null && nextPage != null) {
                        // Find the link connecting them
                        Optional<WebElement> linkElement = currentPage.getElements().stream()
                                .filter(e -> e.getType() == ElementType.LINK && 
                                           e.getHref() != null &&
                                           nextUrl.endsWith(e.getHref()))
                                .findFirst();
                        
                        if (linkElement.isPresent()) {
                            WorkflowStep navigationStep = new WorkflowStep();
                            navigationStep.setType(WorkflowStepType.NAVIGATION);
                            navigationStep.setElement(linkElement.get());
                            navigationStep.setTargetUrl(nextUrl);
                            steps.add(navigationStep);
                        }
                    }
                    
                    currentUrl = nextUrl;
                }
                
                workflow.setSteps(steps);
                
                if (!steps.isEmpty()) {
                    workflows.add(workflow);
                }
            }
        }
        
        return workflows;
    }
    
    /**
     * Builds a navigation graph of page connections
     * @param application The web application
     * @return Map of page URLs to connected page URLs
     */
    private Map<String, List<String>> buildPageNavigationGraph(WebApplication application) {
        Map<String, List<String>> connections = new HashMap<>();
        
        for (WebPage page : application.getPages()) {
            String pageUrl = page.getUrl();
            List<String> linkedUrls = new ArrayList<>();
            
            // Find all links on the page
            for (WebElement element : page.getElements()) {
                if (element.getType() == ElementType.LINK && element.getHref() != null) {
                    String href = element.getHref();
                    
                    // Find target page
                    Optional<WebPage> targetPage = application.getPages().stream()
                            .filter(p -> p.getUrl().endsWith(href) || p.getUrl().equals(href))
                            .findFirst();
                    
                    if (targetPage.isPresent()) {
                        linkedUrls.add(targetPage.get().getUrl());
                    }
                }
            }
            
            if (!linkedUrls.isEmpty()) {
                connections.put(pageUrl, linkedUrls);
            }
        }
        
        return connections;
    }
    
    /**
     * Recursively finds the longest path from a starting URL
     * @param currentUrl The current URL
     * @param connections The page connections map
     * @param visited Set of visited URLs
     * @param minPathLength The minimum path length to return
     * @return List of URLs in the path
     */
    private List<String> findLongestPath(String currentUrl, Map<String, List<String>> connections,
                                        Set<String> visited, int minPathLength) {
        visited.add(currentUrl);
        
        List<String> longestPath = new ArrayList<>();
        longestPath.add(currentUrl);
        
        if (!connections.containsKey(currentUrl)) {
            return longestPath;
        }
        
        for (String nextUrl : connections.get(currentUrl)) {
            if (!visited.contains(nextUrl)) {
                List<String> path = findLongestPath(nextUrl, connections, new HashSet<>(visited), minPathLength);
                path.add(0, currentUrl);
                
                if (path.size() > longestPath.size()) {
                    longestPath = path;
                }
            }
        }
        
        // Only return the path if it's long enough
        if (longestPath.size() >= minPathLength) {
            return longestPath;
        } else {
            List<String> singlePath = new ArrayList<>();
            singlePath.add(currentUrl);
            return singlePath;
        }
    }
    
    /**
     * Finds a page by URL
     * @param application The web application
     * @param url The URL to find
     * @return The page or null
     */
    private WebPage findPageByUrl(WebApplication application, String url) {
        return application.getPages().stream()
                .filter(p -> p.getUrl().equals(url))
                .findFirst()
                .orElse(null);
    }
    
    /**
     * Determines the type of a form
     * @param form The form
     * @return A descriptive form type
     */
    private String determineFormType(WebForm form) {
        // Check for common field patterns
        boolean hasContactFields = form.getFields().stream()
                .anyMatch(f -> f.getName() != null && 
                             (f.getName().toLowerCase().contains("email") ||
                              f.getName().toLowerCase().contains("name") ||
                              f.getName().toLowerCase().contains("message") ||
                              f.getName().toLowerCase().contains("subject")));
        
        boolean hasAddressFields = form.getFields().stream()
                .anyMatch(f -> f.getName() != null && 
                             (f.getName().toLowerCase().contains("address") ||
                              f.getName().toLowerCase().contains("city") ||
                              f.getName().toLowerCase().contains("state") ||
                              f.getName().toLowerCase().contains("zip") ||
                              f.getName().toLowerCase().contains("postal")));
        
        boolean hasPaymentFields = form.getFields().stream()
                .anyMatch(f -> f.getName() != null && 
                             (f.getName().toLowerCase().contains("card") ||
                              f.getName().toLowerCase().contains("payment") ||
                              f.getName().toLowerCase().contains("credit") ||
                              f.getName().toLowerCase().contains("expir") ||
                              f.getName().toLowerCase().contains("cvv")));
        
        boolean hasSearchFields = form.getFields().stream()
                .anyMatch(f -> f.getName() != null && 
                             (f.getName().toLowerCase().contains("search") ||
                              f.getName().toLowerCase().contains("query") ||
                              f.getName().toLowerCase().contains("keyword")));
        
        // Determine form type based on fields
        if (hasContactFields && !hasAddressFields && !hasPaymentFields) {
            return "Contact";
        } else if (hasAddressFields && !hasPaymentFields) {
            return "Address";
        } else if (hasPaymentFields) {
            return "Payment";
        } else if (hasSearchFields) {
            return "Search";
        } else {
            return "Form";
        }
    }
    
    /**
     * Generates a form field step
     * @param field The form field
     * @return A test step
     */
    private TestStep generateFormFieldStep(WebElement field) {
        TestStep step = new TestStep();
        
        switch (field.getType()) {
            case TEXT_INPUT:
            case EMAIL_INPUT:
            case PASSWORD_INPUT:
            case NUMBER_INPUT:
            case TEXTAREA:
                step.setType(TestStepType.FILL);
                step.setDescription("Fill " + getFieldName(field));
                step.setTarget(field.getSelector());
                step.setValue(generateValueForField(field));
                break;
                
            case CHECKBOX:
            case RADIO_BUTTON:
                step.setType(TestStepType.CLICK);
                step.setDescription("Click " + getFieldName(field));
                step.setTarget(field.getSelector());
                break;
                
            case SELECT:
                step.setType(TestStepType.SELECT);
                step.setDescription("Select option in " + getFieldName(field));
                step.setTarget(field.getSelector());
                
                if (field.getOptions() != null && !field.getOptions().isEmpty()) {
                    int optionIndex = random.nextInt(field.getOptions().size());
                    step.setValue(field.getOptions().get(optionIndex));
                } else {
                    step.setValue("Option 1");
                }
                break;
                
            case FILE_UPLOAD:
                step.setType(TestStepType.UPLOAD);
                step.setDescription("Upload file to " + getFieldName(field));
                step.setTarget(field.getSelector());
                step.setValue("test-file.txt");
                break;
                
            default:
                // Skip other field types
                return null;
        }
        
        return step;
    }
    
    /**
     * Generates a data-driven field step
     * @param field The form field
     * @param dataType The type of data to use
     * @return A test step
     */
    private TestStep generateDataDrivenFieldStep(WebElement field, DataTestType dataType) {
        TestStep step = new TestStep();
        
        switch (field.getType()) {
            case TEXT_INPUT:
            case EMAIL_INPUT:
            case PASSWORD_INPUT:
            case NUMBER_INPUT:
            case TEXTAREA:
                step.setType(TestStepType.FILL);
                step.setDescription("Fill " + getFieldName(field));
                step.setTarget(field.getSelector());
                step.setValue(generateDataDrivenValue(field, dataType));
                break;
                
            case CHECKBOX:
            case RADIO_BUTTON:
                if (dataType == DataTestType.INVALID_DATA && field.isRequired()) {
                    // For invalid data, skip required checkboxes/radios
                    return null;
                }
                
                step.setType(TestStepType.CLICK);
                step.setDescription("Click " + getFieldName(field));
                step.setTarget(field.getSelector());
                break;
                
            case SELECT:
                step.setType(TestStepType.SELECT);
                step.setDescription("Select option in " + getFieldName(field));
                step.setTarget(field.getSelector());
                
                if (dataType == DataTestType.INVALID_DATA && field.isRequired()) {
                    // For invalid data on required select, choose empty option if available
                    if (field.getOptions() != null && field.getOptions().contains("")) {
                        step.setValue("");
                    } else {
                        // Skip if no empty option
                        return null;
                    }
                } else if (field.getOptions() != null && !field.getOptions().isEmpty()) {
                    if (dataType == DataTestType.BOUNDARY_VALUES) {
                        // For boundary values, choose first or last option
                        boolean useFirst = random.nextBoolean();
                        step.setValue(useFirst ? field.getOptions().get(0) : 
                                     field.getOptions().get(field.getOptions().size() - 1));
                    } else {
                        // Otherwise choose random
                        int optionIndex = random.nextInt(field.getOptions().size());
                        step.setValue(field.getOptions().get(optionIndex));
                    }
                } else {
                    step.setValue("Option 1");
                }
                break;
                
            case FILE_UPLOAD:
                step.setType(TestStepType.UPLOAD);
                step.setDescription("Upload file to " + getFieldName(field));
                step.setTarget(field.getSelector());
                
                if (dataType == DataTestType.INVALID_DATA) {
                    step.setValue("invalid-file.xyz");
                } else {
                    step.setValue("test-file.txt");
                }
                break;
                
            default:
                // Skip other field types
                return null;
        }
        
        return step;
    }
    
    /**
     * Generates a value for a field
     * @param field The field
     * @return A generated value
     */
    private String generateValueForField(WebElement field) {
        switch (field.getType()) {
            case TEXT_INPUT:
                if (field.getName() != null) {
                    String name = field.getName().toLowerCase();
                    if (name.contains("name")) {
                        return "Test User";
                    } else if (name.contains("first")) {
                        return "Test";
                    } else if (name.contains("last")) {
                        return "User";
                    } else if (name.contains("address")) {
                        return "123 Test Street";
                    } else if (name.contains("city")) {
                        return "Test City";
                    } else if (name.contains("state")) {
                        return "Test State";
                    } else if (name.contains("zip") || name.contains("postal")) {
                        return "12345";
                    } else if (name.contains("phone")) {
                        return "555-123-4567";
                    }
                }
                return "Test Input";
                
            case EMAIL_INPUT:
                return "test@example.com";
                
            case PASSWORD_INPUT:
                return "Password123!";
                
            case NUMBER_INPUT:
                if (field.getName() != null) {
                    String name = field.getName().toLowerCase();
                    if (name.contains("age")) {
                        return "30";
                    } else if (name.contains("quantity")) {
                        return "1";
                    } else if (name.contains("price") || name.contains("amount")) {
                        return "99.99";
                    }
                }
                return "42";
                
            case TEXTAREA:
                return "This is a test comment or message that is being entered into this text area field for testing purposes.";
                
            default:
                return "Test Value";
        }
    }
    
    /**
     * Generates a data-driven value for a field
     * @param field The field
     * @param dataType The type of data to use
     * @return A generated value
     */
    private String generateDataDrivenValue(WebElement field, DataTestType dataType) {
        switch (dataType) {
            case VALID_DATA:
                return generateValueForField(field);
                
            case INVALID_DATA:
                if (field.isRequired()) {
                    return ""; // Empty value for required fields
                }
                
                switch (field.getType()) {
                    case EMAIL_INPUT:
                        return "invalid-email";
                        
                    case NUMBER_INPUT:
                        return "not-a-number";
                        
                    case PASSWORD_INPUT:
                        return "short"; // Too short password
                        
                    default:
                        return "";
                }
                
            case BOUNDARY_VALUES:
                switch (field.getType()) {
                    case TEXT_INPUT:
                    case TEXTAREA:
                        // Generate a very long string
                        StringBuilder sb = new StringBuilder();
                        for (int i = 0; i < 255; i++) {
                            sb.append("X");
                        }
                        return sb.toString();
                        
                    case EMAIL_INPUT:
                        // Very long local part
                        sb = new StringBuilder();
                        for (int i = 0; i < 64; i++) {
                            sb.append("a");
                        }
                        return sb.toString() + "@example.com";
                        
                    case NUMBER_INPUT:
                        // Large number or boundary value
                        return "999999999";
                        
                    case PASSWORD_INPUT:
                        // Exactly 8 characters (common minimum)
                        return "Pass1234";
                        
                    default:
                        return generateValueForField(field);
                }
                
            default:
                return generateValueForField(field);
        }
    }
    
    /**
     * Finds the submit button for a form
     * @param form The form
     * @return The submit button
     */
    private WebElement findSubmitButton(WebForm form) {
        // First look for submit type buttons
        Optional<WebElement> submitButton = form.getFields().stream()
                .filter(e -> e.getType() == ElementType.BUTTON && 
                           (e.getCategory() != null && e.getCategory().equals("submit-button")))
                .findFirst();
        
        if (submitButton.isPresent()) {
            return submitButton.get();
        }
        
        // Then look for any button
        Optional<WebElement> anyButton = form.getFields().stream()
                .filter(e -> e.getType() == ElementType.BUTTON)
                .findFirst();
        
        return anyButton.orElse(null);
    }
    
    /**
     * Gets a readable name for a form
     * @param form The form
     * @return A readable name
     */
    private String getFormName(WebForm form) {
        if (form.getAction() != null && !form.getAction().isEmpty()) {
            String action = form.getAction();
            int lastSlash = action.lastIndexOf('/');
            if (lastSlash >= 0 && lastSlash < action.length() - 1) {
                return action.substring(lastSlash + 1);
            }
            return action;
        }
        
        return "Form " + form.getSelector();
    }
    
    /**
     * Gets a readable name for a field
     * @param field The field
     * @return A readable name
     */
    private String getFieldName(WebElement field) {
        if (field.getName() != null && !field.getName().isEmpty()) {
            return "field '" + field.getName() + "'";
        }
        
        if (field.getId() != null && !field.getId().isEmpty()) {
            return "field with id '" + field.getId() + "'";
        }
        
        if (field.getText() != null && !field.getText().isEmpty()) {
            return "field with text '" + field.getText() + "'";
        }
        
        return "field " + field.getSelector();
    }
    
    /**
     * Gets a readable name for a page
     * @param page The page
     * @return A readable name
     */
    private String getPageName(WebPage page) {
        if (page.getTitle() != null && !page.getTitle().isEmpty()) {
            return page.getTitle();
        }
        
        String url = page.getUrl();
        if (url.endsWith("/")) {
            url = url.substring(0, url.length() - 1);
        }
        
        int lastSlash = url.lastIndexOf('/');
        if (lastSlash >= 0 && lastSlash < url.length() - 1) {
            return url.substring(lastSlash + 1);
        }
        
        return url;
    }
    
    /**
     * Enum for data-driven test types
     */
    private enum DataTestType {
        VALID_DATA,
        INVALID_DATA,
        BOUNDARY_VALUES
    }
    
    /**
     * Class representing a detected workflow
     */
    private static class Workflow {
        private String name;
        private WebPage startPage;
        private List<WorkflowStep> steps = new ArrayList<>();
        
        public String getName() {
            return name;
        }
        
        public void setName(String name) {
            this.name = name;
        }
        
        public WebPage getStartPage() {
            return startPage;
        }
        
        public void setStartPage(WebPage startPage) {
            this.startPage = startPage;
        }
        
        public List<WorkflowStep> getSteps() {
            return steps;
        }
        
        public void setSteps(List<WorkflowStep> steps) {
            this.steps = steps;
        }
    }
    
    /**
     * Class representing a step in a workflow
     */
    private static class WorkflowStep {
        private WorkflowStepType type;
        private WebElement element;
        private WebForm form;
        private String targetUrl;
        private WebElement verificationElement;
        
        public WorkflowStepType getType() {
            return type;
        }
        
        public void setType(WorkflowStepType type) {
            this.type = type;
        }
        
        public WebElement getElement() {
            return element;
        }
        
        public void setElement(WebElement element) {
            this.element = element;
        }
        
        public WebForm getForm() {
            return form;
        }
        
        public void setForm(WebForm form) {
            this.form = form;
        }
        
        public String getTargetUrl() {
            return targetUrl;
        }
        
        public void setTargetUrl(String targetUrl) {
            this.targetUrl = targetUrl;
        }
        
        public WebElement getVerificationElement() {
            return verificationElement;
        }
        
        public void setVerificationElement(WebElement verificationElement) {
            this.verificationElement = verificationElement;
        }
    }
    
    /**
     * Enum for workflow step types
     */
    private enum WorkflowStepType {
        NAVIGATION,
        FORM_SUBMISSION,
        INTERACTION
    }
}

package com.ctgp.controller;

import com.ctgp.model.analyzer.WebApplicationAnalysis;
import com.ctgp.model.workspace.Project;
import com.ctgp.model.workspace.TestSuite;
import com.ctgp.service.analyzer.WebAnalyzerService;
import com.ctgp.service.generator.AdvancedTestGeneratorService;
import com.ctgp.service.workspace.WorkspaceService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/projects/{projectId}/advanced-test-generator")
@RequiredArgsConstructor
@Slf4j
public class AdvancedTestGeneratorController {

    private final WorkspaceService workspaceService;
    private final WebAnalyzerService webAnalyzerService;
    private final AdvancedTestGeneratorService advancedTestGeneratorService;

    /**
     * Generates advanced test suites for a project based on a web application URL
     * @param projectId The project ID
     * @param request The test generation request
     * @return The generated test suites
     */
    @PostMapping("/generate")
    public ResponseEntity<Map<String, Object>> generateTests(
            @PathVariable String projectId, 
            @RequestBody Map<String, Object> request) {
        
        String url = (String) request.get("url");
        Integer depth = request.get("depth") != null ? (Integer) request.get("depth") : 3;
        
        log.info("Generating advanced tests for project: {}, URL: {}", projectId, url);
        
        // Get project
        Project project = workspaceService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Analyze web application
        WebApplicationAnalysis analysis = webAnalyzerService.analyzeApplication(url, depth);
        
        // Generate advanced test suites
        List<TestSuite> testSuites = advancedTestGeneratorService.generateAdvancedTestSuites(project, analysis);
        
        // Create response
        Map<String, Object> response = Map.of(
            "testSuites", testSuites,
            "message", "Successfully generated " + testSuites.size() + " advanced test suites"
        );
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Generates workflow tests for a project based on a web application URL
     * @param projectId The project ID
     * @param request The test generation request
     * @return The generated workflow test suite
     */
    @PostMapping("/generate-workflow-tests")
    public ResponseEntity<Map<String, Object>> generateWorkflowTests(
            @PathVariable String projectId, 
            @RequestBody Map<String, Object> request) {
        
        String url = (String) request.get("url");
        Integer depth = request.get("depth") != null ? (Integer) request.get("depth") : 3;
        
        log.info("Generating workflow tests for project: {}, URL: {}", projectId, url);
        
        // Get project
        Project project = workspaceService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Analyze web application
        WebApplicationAnalysis analysis = webAnalyzerService.analyzeApplication(url, depth);
        
        // Generate workflow test suite
        TestSuite workflowSuite = advancedTestGeneratorService.generateWorkflowTestSuite(project, analysis);
        
        // Create response
        Map<String, Object> response = Map.of(
            "testSuites", List.of(workflowSuite),
            "message", "Successfully generated workflow test suite with " + 
                     workflowSuite.getTestCases().size() + " test cases"
        );
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Generates data-driven tests for a project based on a web application URL
     * @param projectId The project ID
     * @param request The test generation request
     * @return The generated data-driven test suite
     */
    @PostMapping("/generate-data-driven-tests")
    public ResponseEntity<Map<String, Object>> generateDataDrivenTests(
            @PathVariable String projectId, 
            @RequestBody Map<String, Object> request) {
        
        String url = (String) request.get("url");
        Integer depth = request.get("depth") != null ? (Integer) request.get("depth") : 3;
        
        log.info("Generating data-driven tests for project: {}, URL: {}", projectId, url);
        
        // Get project
        Project project = workspaceService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Analyze web application
        WebApplicationAnalysis analysis = webAnalyzerService.analyzeApplication(url, depth);
        
        // Generate data-driven test suite
        TestSuite dataDrivenSuite = advancedTestGeneratorService.generateDataDrivenTestSuite(project, analysis);
        
        // Create response
        Map<String, Object> response = Map.of(
            "testSuites", List.of(dataDrivenSuite),
            "message", "Successfully generated data-driven test suite with " + 
                     dataDrivenSuite.getTestCases().size() + " test cases"
        );
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Generates visual regression tests for a project based on a web application URL
     * @param projectId The project ID
     * @param request The test generation request
     * @return The generated visual regression test suite
     */
    @PostMapping("/generate-visual-regression-tests")
    public ResponseEntity<Map<String, Object>> generateVisualRegressionTests(
            @PathVariable String projectId, 
            @RequestBody Map<String, Object> request) {
        
        String url = (String) request.get("url");
        Integer depth = request.get("depth") != null ? (Integer) request.get("depth") : 3;
        
        log.info("Generating visual regression tests for project: {}, URL: {}", projectId, url);
        
        // Get project
        Project project = workspaceService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Analyze web application
        WebApplicationAnalysis analysis = webAnalyzerService.analyzeApplication(url, depth);
        
        // Generate visual regression test suite
        TestSuite visualRegressionSuite = advancedTestGeneratorService.generateVisualRegressionTestSuite(project, analysis);
        
        // Create response
        Map<String, Object> response = Map.of(
            "testSuites", List.of(visualRegressionSuite),
            "message", "Successfully generated visual regression test suite with " + 
                     visualRegressionSuite.getTestCases().size() + " test cases"
        );
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * Gets information about possible test types and strategies
     * @param projectId The project ID
     * @return Information about available test generation options
     */
    @GetMapping("/options")
    public ResponseEntity<Map<String, Object>> getTestGenerationOptions(@PathVariable String projectId) {
        // Get project
        Project project = workspaceService.getProject(projectId);
        if (project == null) {
            return ResponseEntity.notFound().build();
        }
        
        // Create options info
        List<Map<String, String>> testTypes = List.of(
            Map.of(
                "id", "workflow",
                "name", "Workflow Tests",
                "description", "Detects user journeys and generates end-to-end workflow tests"
            ),
            Map.of(
                "id", "data-driven",
                "name", "Data-Driven Tests",
                "description", "Generates tests with valid, invalid, and boundary data"
            ),
            Map.of(
                "id", "visual-regression",
                "name", "Visual Regression Tests",
                "description", "Tests for visual appearance and layout consistency"
            )
        );
        
        List<Map<String, String>> strategies = List.of(
            Map.of(
                "id", "full",
                "name", "Full Coverage",
                "description", "Generates all possible test types for comprehensive coverage"
            ),
            Map.of(
                "id", "critical-path",
                "name", "Critical Path",
                "description", "Focuses on the most important user workflows"
            ),
            Map.of(
                "id", "regression",
                "name", "Regression",
                "description", "Optimized for regression testing with visual verification"
            )
        );
        
        Map<String, Object> options = Map.of(
            "testTypes", testTypes,
            "strategies", strategies
        );
        
        return ResponseEntity.ok(options);
    }
}

