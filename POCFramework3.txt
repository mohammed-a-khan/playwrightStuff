package com.cssmart.api.validation;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import com.cssmart.api.response.CSSmartAPIResponse;
import com.cssmart.api.utils.CSSmartJSONUtils;
import com.cssmart.database.CSSmartDatabaseManager;
import com.cssmart.utils.CSSmartDataLoader;
import com.cssmart.utils.CSSmartLogger;

/**
 * A versatile API response validator that can validate API responses against
 * different sources including JSON files, database outputs, or predefined expectations
 */
public class CSSmartAPIResponseValidator {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartAPIResponseValidator.class);
    
    /**
     * Validates API response against an expected JSON file
     * 
     * @param response The API response to validate
     * @param jsonFilePath Path to the expected JSON file
     * @param ignoreFields Fields to ignore during comparison (optional)
     * @return Validation result with details about any differences
     */
    public static ValidationResult validateAgainstJsonFile(CSSmartAPIResponse response, String jsonFilePath, String... ignoreFields) {
        try {
            String expectedJson = new String(Files.readAllBytes(Paths.get(jsonFilePath)));
            return validateJsonContent(response.getResponseBody(), expectedJson, ignoreFields);
        } catch (IOException e) {
            logger.error("Failed to read expected JSON file: " + jsonFilePath, e);
            return new ValidationResult(false, "Failed to read expected JSON file: " + e.getMessage());
        }
    }
    
    /**
     * Validates API response against database query results
     * 
     * @param response The API response to validate
     * @param dbQuery SQL query to execute for expected data
     * @param mappingRules Rules to map database columns to JSON fields
     * @param ignoreFields Fields to ignore during comparison (optional)
     * @return Validation result with details about any differences
     */
    public static ValidationResult validateAgainstDatabase(CSSmartAPIResponse response, 
                                                           String dbQuery, 
                                                           Map<String, String> mappingRules,
                                                           String... ignoreFields) {
        try {
            Connection conn = CSSmartDatabaseManager.getConnection();
            ResultSet rs = conn.createStatement().executeQuery(dbQuery);
            
            JSONArray expectedArray = new JSONArray();
            while (rs.next()) {
                JSONObject row = new JSONObject();
                for (Map.Entry<String, String> mapping : mappingRules.entrySet()) {
                    String dbColumn = mapping.getKey();
                    String jsonField = mapping.getValue();
                    row.put(jsonField, rs.getObject(dbColumn));
                }
                expectedArray.put(row);
            }
            
            return validateJsonContent(response.getResponseBody(), 
                                      expectedArray.length() == 1 ? expectedArray.get(0).toString() : expectedArray.toString(), 
                                      ignoreFields);
        } catch (SQLException e) {
            logger.error("Database validation failed", e);
            return new ValidationResult(false, "Database validation failed: " + e.getMessage());
        }
    }
    
    /**
     * Validates API response against expected values from a data source (CSV, Excel, etc.)
     * 
     * @param response The API response to validate
     * @param dataSourcePath Path to the data source file
     * @param dataSourceType Type of data source (CSV, EXCEL, etc.)
     * @param sheetName Sheet name for Excel files (optional)
     * @param rowIndex Row index for the expected data (default is 0)
     * @param ignoreFields Fields to ignore during comparison (optional)
     * @return Validation result with details about any differences
     */
    public static ValidationResult validateAgainstDataSource(CSSmartAPIResponse response,
                                                            String dataSourcePath,
                                                            CSSmartDataLoader.DataSourceType dataSourceType,
                                                            String sheetName,
                                                            int rowIndex,
                                                            String... ignoreFields) {
        try {
            Map<String, Object> expectedData = CSSmartDataLoader.loadData(dataSourcePath, dataSourceType, sheetName, rowIndex);
            JSONObject expectedJson = new JSONObject(expectedData);
            
            return validateJsonContent(response.getResponseBody(), expectedJson.toString(), ignoreFields);
        } catch (Exception e) {
            logger.error("Data source validation failed", e);
            return new ValidationResult(false, "Data source validation failed: " + e.getMessage());
        }
    }
    
    /**
     * Validates JSON schema of API response
     * 
     * @param response The API response to validate
     * @param schemaPath Path to the JSON schema file
     * @return Validation result with details about any schema violations
     */
    public static ValidationResult validateJsonSchema(CSSmartAPIResponse response, String schemaPath) {
        try {
            // Using the CSSmartJSONUtils to validate the schema
            boolean isValid = CSSmartJSONUtils.validateSchema(response.getResponseBody(), schemaPath);
            
            if (isValid) {
                return new ValidationResult(true, "Schema validation passed");
            } else {
                return new ValidationResult(false, "Schema validation failed");
            }
        } catch (Exception e) {
            logger.error("Schema validation failed", e);
            return new ValidationResult(false, "Schema validation failed: " + e.getMessage());
        }
    }
    
    /**
     * Validates specific fields in the API response
     * 
     * @param response The API response to validate
     * @param fieldValidations Map of field paths to expected values
     * @return Validation result with details about any field validation failures
     */
    public static ValidationResult validateFields(CSSmartAPIResponse response, Map<String, Object> fieldValidations) {
        try {
            JSONObject responseJson = new JSONObject(response.getResponseBody());
            ValidationResult result = new ValidationResult(true, "Field validations passed");
            
            for (Map.Entry<String, Object> validation : fieldValidations.entrySet()) {
                String fieldPath = validation.getKey();
                Object expectedValue = validation.getValue();
                
                try {
                    Object actualValue = extractValueByPath(responseJson, fieldPath);
                    
                    if (actualValue == null && expectedValue == null) {
                        continue;
                    }
                    
                    if ((actualValue == null && expectedValue != null) || 
                        (actualValue != null && !actualValue.toString().equals(expectedValue.toString()))) {
                        result.setValid(false);
                        result.addDetail("Field '" + fieldPath + "' validation failed. Expected: " + 
                                        expectedValue + ", Actual: " + actualValue);
                    }
                } catch (Exception e) {
                    result.setValid(false);
                    result.addDetail("Field '" + fieldPath + "' validation failed: " + e.getMessage());
                }
            }
            
            return result;
        } catch (JSONException e) {
            logger.error("Field validation failed", e);
            return new ValidationResult(false, "Field validation failed: " + e.getMessage());
        }
    }
    
    /**
     * Core method to validate JSON content against expected JSON
     */
    private static ValidationResult validateJsonContent(String actualJson, String expectedJson, String... ignoreFields) {
        try {
            Map<String, Object> differences = CSSmartJSONUtils.compareJson(actualJson, expectedJson, ignoreFields);
            
            ValidationResult result = new ValidationResult(differences.isEmpty(), 
                                                          differences.isEmpty() ? "Validation passed" : "Validation failed");
            
            for (Map.Entry<String, Object> diff : differences.entrySet()) {
                result.addDetail(diff.getKey() + ": " + diff.getValue());
            }
            
            return result;
        } catch (Exception e) {
            logger.error("JSON content validation failed", e);
            return new ValidationResult(false, "JSON content validation failed: " + e.getMessage());
        }
    }
    
    /**
     * Extracts a value from a JSON object using a dot-notation path
     */
    private static Object extractValueByPath(JSONObject json, String path) {
        String[] parts = path.split("\\.");
        Object current = json;
        
        for (String part : parts) {
            if (current instanceof JSONObject) {
                JSONObject jsonObj = (JSONObject) current;
                if (jsonObj.has(part)) {
                    current = jsonObj.get(part);
                } else {
                    return null;
                }
            } else if (current instanceof JSONArray) {
                try {
                    int index = Integer.parseInt(part);
                    JSONArray array = (JSONArray) current;
                    if (index >= 0 && index < array.length()) {
                        current = array.get(index);
                    } else {
                        return null;
                    }
                } catch (NumberFormatException e) {
                    return null;
                }
            } else {
                return null;
            }
        }
        
        return current;
    }
    
    /**
     * Class to hold validation results with details
     */
    public static class ValidationResult {
        private boolean isValid;
        private String message;
        private final List<String> details = new java.util.ArrayList<>();
        
        public ValidationResult(boolean isValid, String message) {
            this.isValid = isValid;
            this.message = message;
        }
        
        public boolean isValid() {
            return isValid;
        }
        
        public void setValid(boolean valid) {
            isValid = valid;
        }
        
        public String getMessage() {
            return message;
        }
        
        public void setMessage(String message) {
            this.message = message;
        }
        
        public List<String> getDetails() {
            return details;
        }
        
        public void addDetail(String detail) {
            details.add(detail);
        }
        
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append("Validation ").append(isValid ? "PASSED" : "FAILED").append(": ").append(message).append("\n");
            
            if (!details.isEmpty()) {
                sb.append("Details:\n");
                for (String detail : details) {
                    sb.append("- ").append(detail).append("\n");
                }
            }
            
            return sb.toString();
        }
    }
}


package com.cssmart.api.utils;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.everit.json.schema.Schema;
import org.everit.json.schema.ValidationException;
import org.everit.json.schema.loader.SchemaLoader;

import com.cssmart.utils.CSSmartLogger;

/**
 * Utility class for JSON operations including parsing, comparison, and schema validation
 */
public class CSSmartJSONUtils {

    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartJSONUtils.class);

    /**
     * Compares two JSON strings and returns differences
     * 
     * @param actualJson   The actual JSON string
     * @param expectedJson The expected JSON string
     * @param ignoreFields Fields to ignore during comparison
     * @return Map of differences with path as key and difference details as value
     */
    public static Map<String, Object> compareJson(String actualJson, String expectedJson, String... ignoreFields) {
        Map<String, Object> differences = new HashMap<>();
        Set<String> ignoreFieldsSet = new HashSet<>(Arrays.asList(ignoreFields));

        try {
            // Check if both are objects or both are arrays
            if (actualJson.trim().startsWith("{") && expectedJson.trim().startsWith("{")) {
                JSONObject actual = new JSONObject(actualJson);
                JSONObject expected = new JSONObject(expectedJson);
                compareJsonObjects(actual, expected, "", differences, ignoreFieldsSet);
            } else if (actualJson.trim().startsWith("[") && expectedJson.trim().startsWith("[")) {
                JSONArray actual = new JSONArray(actualJson);
                JSONArray expected = new JSONArray(expectedJson);
                compareJsonArrays(actual, expected, "", differences, ignoreFieldsSet);
            } else {
                // One is an object and one is an array - obviously different
                differences.put("root", "Different JSON types: " + 
                    (actualJson.trim().startsWith("{") ? "Object" : "Array") + " vs " + 
                    (expectedJson.trim().startsWith("{") ? "Object" : "Array"));
            }
        } catch (JSONException e) {
            logger.error("JSON comparison failed", e);
            differences.put("error", "JSON parsing error: " + e.getMessage());
        }

        return differences;
    }

    /**
     * Recursively compares two JSON objects
     */
    private static void compareJsonObjects(JSONObject actual, JSONObject expected, 
                                          String path, Map<String, Object> differences, 
                                          Set<String> ignoreFields) {
        // Check keys in expected that are missing in actual
        for (String key : JSONObject.getNames(expected)) {
            String currentPath = path.isEmpty() ? key : path + "." + key;
            
            // Skip fields that should be ignored
            if (ignoreFields.contains(key) || ignoreFields.contains(currentPath)) {
                continue;
            }
            
            if (!actual.has(key)) {
                differences.put(currentPath, "Missing key in actual JSON");
                continue;
            }
            
            // Compare values
            Object actualValue = actual.get(key);
            Object expectedValue = expected.get(key);
            
            compareValues(actualValue, expectedValue, currentPath, differences, ignoreFields);
        }
        
        // Check keys in actual that are not in expected
        for (String key : JSONObject.getNames(actual)) {
            String currentPath = path.isEmpty() ? key : path + "." + key;
            
            // Skip fields that should be ignored
            if (ignoreFields.contains(key) || ignoreFields.contains(currentPath)) {
                continue;
            }
            
            if (!expected.has(key)) {
                differences.put(currentPath, "Unexpected key in actual JSON");
            }
        }
    }
    
    /**
     * Recursively compares two JSON arrays
     */
    private static void compareJsonArrays(JSONArray actual, JSONArray expected, 
                                         String path, Map<String, Object> differences, 
                                         Set<String> ignoreFields) {
        // Check array lengths
        if (actual.length() != expected.length()) {
            differences.put(path + ".length", 
                          "Array length mismatch: actual=" + actual.length() + 
                          ", expected=" + expected.length());
        }
        
        // Compare array elements up to the length of the shorter array
        int minLength = Math.min(actual.length(), expected.length());
        for (int i = 0; i < minLength; i++) {
            String currentPath = path + "[" + i + "]";
            Object actualValue = actual.get(i);
            Object expectedValue = expected.get(i);
            
            compareValues(actualValue, expectedValue, currentPath, differences, ignoreFields);
        }
    }
    
    /**
     * Compares two JSON values (recursively if objects or arrays)
     */
    private static void compareValues(Object actualValue, Object expectedValue, 
                                     String path, Map<String, Object> differences, 
                                     Set<String> ignoreFields) {
        // Same type comparison
        if (actualValue instanceof JSONObject && expectedValue instanceof JSONObject) {
            compareJsonObjects((JSONObject) actualValue, (JSONObject) expectedValue, 
                              path, differences, ignoreFields);
        } else if (actualValue instanceof JSONArray && expectedValue instanceof JSONArray) {
            compareJsonArrays((JSONArray) actualValue, (JSONArray) expectedValue, 
                             path, differences, ignoreFields);
        } else if (actualValue.getClass() != expectedValue.getClass()) {
            // Different types
            differences.put(path, "Type mismatch: actual=" + actualValue.getClass().getSimpleName() + 
                          ", expected=" + expectedValue.getClass().getSimpleName());
        } else if (!actualValue.toString().equals(expectedValue.toString())) {
            // Values don't match
            differences.put(path, "Value mismatch: actual=" + actualValue + 
                          ", expected=" + expectedValue);
        }
    }
    
    /**
     * Validates a JSON string against a JSON schema
     * 
     * @param json       JSON string to validate
     * @param schemaPath Path to the JSON schema file
     * @return true if validation passes, false otherwise
     */
    public static boolean validateSchema(String json, String schemaPath) {
        try {
            String schemaString = new String(Files.readAllBytes(Paths.get(schemaPath)));
            org.json.JSONObject jsonSchema = new org.json.JSONObject(schemaString);
            
            Schema schema = SchemaLoader.load(jsonSchema);
            org.json.JSONObject jsonSubject = new org.json.JSONObject(json);
            
            schema.validate(jsonSubject);
            return true;
        } catch (ValidationException e) {
            logger.error("Schema validation failed", e);
            e.getAllMessages().forEach(logger::error);
            return false;
        } catch (IOException e) {
            logger.error("Failed to read schema file: " + schemaPath, e);
            return false;
        } catch (Exception e) {
            logger.error("Schema validation error", e);
            return false;
        }
    }
    
    /**
     * Extracts value from a JSON object using JSONPath-like syntax
     * 
     * @param json     JSON string
     * @param jsonPath JSONPath expression
     * @return The extracted value or null if not found
     */
    public static Object extractByPath(String json, String jsonPath) {
        try {
            Object jsonObject;
            if (json.trim().startsWith("{")) {
                jsonObject = new JSONObject(json);
            } else if (json.trim().startsWith("[")) {
                jsonObject = new JSONArray(json);
            } else {
                return null;
            }
            
            String[] pathParts = jsonPath.split("\\.");
            Object current = jsonObject;
            
            for (String part : pathParts) {
                // Handle array indices
                if (part.contains("[") && part.endsWith("]")) {
                    String fieldName = part.substring(0, part.indexOf("["));
                    String indexStr = part.substring(part.indexOf("[") + 1, part.length() - 1);
                    int index = Integer.parseInt(indexStr);
                    
                    if (current instanceof JSONObject) {
                        JSONObject obj = (JSONObject) current;
                        if (obj.has(fieldName)) {
                            current = obj.getJSONArray(fieldName).get(index);
                        } else {
                            return null;
                        }
                    } else {
                        return null;
                    }
                }
                // Handle simple field names
                else if (current instanceof JSONObject) {
                    JSONObject obj = (JSONObject) current;
                    if (obj.has(part)) {
                        current = obj.get(part);
                    } else {
                        return null;
                    }
                } else {
                    return null;
                }
            }
            
            return current;
        } catch (Exception e) {
            logger.error("Error extracting JSON value by path", e);
            return null;
        }
    }
    
    /**
     * Merges two JSON objects
     * 
     * @param json1 First JSON object string
     * @param json2 Second JSON object string
     * @return Merged JSON object string
     */
    public static String mergeJson(String json1, String json2) {
        try {
            JSONObject obj1 = new JSONObject(json1);
            JSONObject obj2 = new JSONObject(json2);
            
            return mergeJSONObjects(obj1, obj2).toString();
        } catch (JSONException e) {
            logger.error("JSON merge failed", e);
            return json1;
        }
    }
    
    /**
     * Recursively merges two JSON objects
     */
    private static JSONObject mergeJSONObjects(JSONObject json1, JSONObject json2) {
        JSONObject merged = new JSONObject(json1, JSONObject.getNames(json1));
        
        for (String key : JSONObject.getNames(json2)) {
            Object value = json2.get(key);
            if (!merged.has(key)) {
                merged.put(key, value);
            } else {
                if (merged.get(key) instanceof JSONObject && value instanceof JSONObject) {
                    merged.put(key, mergeJSONObjects((JSONObject) merged.get(key), (JSONObject) value));
                } else {
                    merged.put(key, value);
                }
            }
        }
        
        return merged;
    }
}


package com.cssmart.api.response;

import java.util.HashMap;
import java.util.Map;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

/**
 * Represents an API response with status code, headers, and response body
 */
public class CSSmartAPIResponse {
    
    private int statusCode;
    private Map<String, String> headers;
    private String responseBody;
    private long responseTimeMs;
    
    /**
     * Constructor for API response
     * 
     * @param statusCode HTTP status code
     * @param headers Response headers
     * @param responseBody Response body as string
     * @param responseTimeMs Response time in milliseconds
     */
    public CSSmartAPIResponse(int statusCode, Map<String, String> headers, String responseBody, long responseTimeMs) {
        this.statusCode = statusCode;
        this.headers = headers != null ? headers : new HashMap<>();
        this.responseBody = responseBody;
        this.responseTimeMs = responseTimeMs;
    }
    
    /**
     * Get HTTP status code
     * 
     * @return Status code
     */
    public int getStatusCode() {
        return statusCode;
    }
    
    /**
     * Get response headers
     * 
     * @return Map of headers
     */
    public Map<String, String> getHeaders() {
        return new HashMap<>(headers);
    }
    
    /**
     * Get response body as string
     * 
     * @return Response body
     */
    public String getResponseBody() {
        return responseBody;
    }
    
    /**
     * Get response time in milliseconds
     * 
     * @return Response time
     */
    public long getResponseTimeMs() {
        return responseTimeMs;
    }
    
    /**
     * Check if status code indicates success (2xx)
     * 
     * @return true if successful, false otherwise
     */
    public boolean isSuccessful() {
        return statusCode >= 200 && statusCode < 300;
    }
    
    /**
     * Get response body as JSONObject
     * 
     * @return JSONObject representation of response body
     * @throws JSONException if response is not valid JSON object
     */
    public JSONObject getBodyAsJsonObject() throws JSONException {
        return new JSONObject(responseBody);
    }
    
    /**
     * Get response body as JSONArray
     * 
     * @return JSONArray representation of response body
     * @throws JSONException if response is not valid JSON array
     */
    public JSONArray getBodyAsJsonArray() throws JSONException {
        return new JSONArray(responseBody);
    }
    
    /**
     * Extract value from JSON response using path
     * 
     * @param jsonPath Path to the value (dot notation)
     * @return Extracted value or null if not found
     */
    public Object extractValue(String jsonPath) {
        try {
            JSONObject json = new JSONObject(responseBody);
            
            String[] pathParts = jsonPath.split("\\.");
            Object current = json;
            
            for (String part : pathParts) {
                if (current instanceof JSONObject) {
                    JSONObject jsonObj = (JSONObject) current;
                    if (jsonObj.has(part)) {
                        current = jsonObj.get(part);
                    } else {
                        return null;
                    }
                } else if (current instanceof JSONArray) {
                    try {
                        int index = Integer.parseInt(part);
                        JSONArray array = (JSONArray) current;
                        if (index >= 0 && index < array.length()) {
                            current = array.get(index);
                        } else {
                            return null;
                        }
                    } catch (NumberFormatException e) {
                        return null;
                    }
                } else {
                    return null;
                }
            }
            
            return current;
        } catch (JSONException e) {
            return null;
        }
    }
    
    /**
     * Get header value by name
     * 
     * @param name Header name
     * @return Header value or null if not found
     */
    public String getHeader(String name) {
        return headers.get(name);
    }
    
    /**
     * Check if response contains a specific header
     * 
     * @param name Header name
     * @return true if header exists, false otherwise
     */
    public boolean hasHeader(String name) {
        return headers.containsKey(name);
    }
    
    /**
     * Generate string representation of the response
     */
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("Status Code: ").append(statusCode).append("\n");
        builder.append("Response Time: ").append(responseTimeMs).append("ms\n");
        
        builder.append("Headers:\n");
        for (Map.Entry<String, String> header : headers.entrySet()) {
            builder.append("  ").append(header.getKey()).append(": ").append(header.getValue()).append("\n");
        }
        
        builder.append("Body:\n").append(responseBody);
        
        return builder.toString();
    }
}


package com.cssmart.api.client;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpHeaders;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;

import com.cssmart.api.response.CSSmartAPIResponse;
import com.cssmart.utils.CSSmartLogger;

/**
 * Native Java HTTP client for API testing with support for various authentication methods
 */
public class CSSmartHTTPClient {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartHTTPClient.class);
    
    private HttpClient httpClient;
    private Map<String, String> defaultHeaders;
    private int defaultTimeoutSeconds;
    
    /**
     * Creates a default HTTP client with standard configuration
     */
    public CSSmartHTTPClient() {
        this.httpClient = HttpClient.newBuilder()
                           .version(HttpClient.Version.HTTP_2)
                           .followRedirects(HttpClient.Redirect.NORMAL)
                           .connectTimeout(Duration.ofSeconds(30))
                           .build();
        this.defaultHeaders = new HashMap<>();
        this.defaultTimeoutSeconds = 30;
        
        // Set common headers
        defaultHeaders.put("Accept", "application/json");
        defaultHeaders.put("Content-Type", "application/json");
        defaultHeaders.put("User-Agent", "CSSmartHTTPClient/1.0");
    }
    
    /**
     * Creates an HTTP client with certificate-based authentication
     * 
     * @param pfxFilePath Path to PFX certificate file
     * @param passphrase Passphrase for the certificate
     * @throws Exception If certificate loading fails
     */
    public CSSmartHTTPClient(String pfxFilePath, String passphrase) throws Exception {
        this();
        configureCertificateAuthentication(pfxFilePath, passphrase);
    }
    
    /**
     * Configures certificate-based authentication with PFX certificate
     * 
     * @param pfxFilePath Path to PFX certificate file
     * @param passphrase Passphrase for the certificate
     * @throws Exception If certificate loading fails
     */
    public void configureCertificateAuthentication(String pfxFilePath, String passphrase) throws Exception {
        // Load the keystore
        KeyStore keyStore = KeyStore.getInstance("PKCS12");
        try (FileInputStream fis = new FileInputStream(pfxFilePath)) {
            keyStore.load(fis, passphrase.toCharArray());
        }
        
        // Set up key manager factory
        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        kmf.init(keyStore, passphrase.toCharArray());
        
        // Set up trust manager factory
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init(keyStore);
        
        // Create and configure SSL context
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new SecureRandom());
        
        // Build HTTP client with SSLContext
        this.httpClient = HttpClient.newBuilder()
                           .version(HttpClient.Version.HTTP_2)
                           .followRedirects(HttpClient.Redirect.NORMAL)
                           .connectTimeout(Duration.ofSeconds(defaultTimeoutSeconds))
                           .sslContext(sslContext)
                           .build();
    }
    
    /**
     * Sets a default header for all requests
     * 
     * @param name Header name
     * @param value Header value
     * @return This client instance for chaining
     */
    public CSSmartHTTPClient setDefaultHeader(String name, String value) {
        defaultHeaders.put(name, value);
        return this;
    }
    
    /**
     * Sets the default timeout for all requests
     * 
     * @param timeoutSeconds Timeout in seconds
     * @return This client instance for chaining
     */
    public CSSmartHTTPClient setDefaultTimeout(int timeoutSeconds) {
        this.defaultTimeoutSeconds = timeoutSeconds;
        return this;
    }
    
    /**
     * Configures OAuth token authentication
     * 
     * @param token OAuth token
     * @param tokenType Token type (Bearer, Basic, etc.)
     * @return This client instance for chaining
     */
    public CSSmartHTTPClient configureTokenAuthentication(String token, String tokenType) {
        defaultHeaders.put("Authorization", tokenType + " " + token);
        return this;
    }
    
    /**
     * Configures basic authentication
     * 
     * @param username Username
     * @param password Password
     * @return This client instance for chaining
     */
    public CSSmartHTTPClient configureBasicAuthentication(String username, String password) {
        String auth = username + ":" + password;
        String encodedAuth = java.util.Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));
        defaultHeaders.put("Authorization", "Basic " + encodedAuth);
        return this;
    }
    
    /**
     * Sends a GET request
     * 
     * @param url Target URL
     * @return API response
     */
    public CSSmartAPIResponse get(String url) {
        return get(url, null);
    }
    
    /**
     * Sends a GET request with headers
     * 
     * @param url Target URL
     * @param headers Additional headers
     * @return API response
     */
    public CSSmartAPIResponse get(String url, Map<String, String> headers) {
        try {
            long startTime = System.currentTimeMillis();
            
            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                                                .uri(URI.create(url))
                                                .timeout(Duration.ofSeconds(defaultTimeoutSeconds))
                                                .GET();
            
            // Add headers
            addHeaders(requestBuilder, headers);
            
            HttpRequest request = requestBuilder.build();
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            long responseTime = System.currentTimeMillis() - startTime;
            return createApiResponse(response, responseTime);
            
        } catch (Exception e) {
            logger.error("GET request failed: " + url, e);
            return new CSSmartAPIResponse(0, new HashMap<>(), e.getMessage(), 0);
        }
    }
    
    /**
     * Sends a POST request with JSON body
     * 
     * @param url Target URL
     * @param jsonBody JSON request body
     * @return API response
     */
    public CSSmartAPIResponse post(String url, String jsonBody) {
        return post(url, jsonBody, null);
    }
    
    /**
     * Sends a POST request with JSON body and headers
     * 
     * @param url Target URL
     * @param jsonBody JSON request body
     * @param headers Additional headers
     * @return API response
     */
    public CSSmartAPIResponse post(String url, String jsonBody, Map<String, String> headers) {
        try {
            long startTime = System.currentTimeMillis();
            
            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                                                .uri(URI.create(url))
                                                .timeout(Duration.ofSeconds(defaultTimeoutSeconds))
                                                .POST(HttpRequest.BodyPublishers.ofString(jsonBody));
            
            // Add headers
            addHeaders(requestBuilder, headers);
            
            HttpRequest request = requestBuilder.build();
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            long responseTime = System.currentTimeMillis() - startTime;
            return createApiResponse(response, responseTime);
            
        } catch (Exception e) {
            logger.error("POST request failed: " + url, e);
            return new CSSmartAPIResponse(0, new HashMap<>(), e.getMessage(), 0);
        }
    }
    
    /**
     * Sends a PUT request with JSON body
     * 
     * @param url Target URL
     * @param jsonBody JSON request body
     * @return API response
     */
    public CSSmartAPIResponse put(String url, String jsonBody) {
        return put(url, jsonBody, null);
    }
    
    /**
     * Sends a PUT request with JSON body and headers
     * 
     * @param url Target URL
     * @param jsonBody JSON request body
     * @param headers Additional headers
     * @return API response
     */
    public CSSmartAPIResponse put(String url, String jsonBody, Map<String, String> headers) {
        try {
            long startTime = System.currentTimeMillis();
            
            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                                                .uri(URI.create(url))
                                                .timeout(Duration.ofSeconds(defaultTimeoutSeconds))
                                                .PUT(HttpRequest.BodyPublishers.ofString(jsonBody));
            
            // Add headers
            addHeaders(requestBuilder, headers);
            
            HttpRequest request = requestBuilder.build();
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            long responseTime = System.currentTimeMillis() - startTime;
            return createApiResponse(response, responseTime);
            
        } catch (Exception e) {
            logger.error("PUT request failed: " + url, e);
            return new CSSmartAPIResponse(0, new HashMap<>(), e.getMessage(), 0);
        }
    }
    
    /**
     * Sends a DELETE request
     * 
     * @param url Target URL
     * @return API response
     */
    public CSSmartAPIResponse delete(String url) {
        return delete(url, null);
    }
    
    /**
     * Sends a DELETE request with headers
     * 
     * @param url Target URL
     * @param headers Additional headers
     * @return API response
     */
    public CSSmartAPIResponse delete(String url, Map<String, String> headers) {
        try {
            long startTime = System.currentTimeMillis();
            
            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                                                .uri(URI.create(url))
                                                .timeout(Duration.ofSeconds(defaultTimeoutSeconds))
                                                .DELETE();
            
            // Add headers
            addHeaders(requestBuilder, headers);
            
            HttpRequest request = requestBuilder.build();
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            long responseTime = System.currentTimeMillis() - startTime;
            return createApiResponse(response, responseTime);
            
        } catch (Exception e) {
            logger.error("DELETE request failed: " + url, e);
            return new CSSmartAPIResponse(0, new HashMap<>(), e.getMessage(), 0);
        }
    }
    
    /**
     * Sends a PATCH request with JSON body
     * 
     * @param url Target URL
     * @param jsonBody JSON request body
     * @return API response
     */
    public CSSmartAPIResponse patch(String url, String jsonBody) {
        return patch(url, jsonBody, null);
    }
    
    /**
     * Sends a PATCH request with JSON body and headers
     * 
     * @param url Target URL
     * @param jsonBody JSON request body
     * @param headers Additional headers
     * @return API response
     */
    public CSSmartAPIResponse patch(String url, String jsonBody, Map<String, String> headers) {
        try {
            long startTime = System.currentTimeMillis();
            
            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                                                .uri(URI.create(url))
                                                .timeout(Duration.ofSeconds(defaultTimeoutSeconds))
                                                .method("PATCH", HttpRequest.BodyPublishers.ofString(jsonBody));
            
            // Add headers
            addHeaders(requestBuilder, headers);
            
            HttpRequest request = requestBuilder.build();
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            long responseTime = System.currentTimeMillis() - startTime;
            return createApiResponse(response, responseTime);
            
        } catch (Exception e) {
            logger.error("PATCH request failed: " + url, e);
            return new CSSmartAPIResponse(0, new HashMap<>(), e.getMessage(), 0);
        }
    }
    
    /**
     * Sends a multipart form data request
     * 
     * @param url Target URL
     * @param method HTTP method
     * @param formData Form data parts
     * @param files Files to upload
     * @return API response
     */
    public CSSmartAPIResponse sendMultipartFormData(String url, String method, 
                                                  Map<String, String> formData, 
                                                  Map<String, File> files) {
        try {
            long startTime = System.currentTimeMillis();
            
            String boundary = "----WebKitFormBoundary" + System.currentTimeMillis();
            StringBuilder requestBody = new StringBuilder();
            
            // Add form fields
            if (formData != null) {
                for (Map.Entry<String, String> entry : formData.entrySet()) {
                    requestBody.append("--").append(boundary).append("\r\n");
                    requestBody.append("Content-Disposition: form-data; name=\"").append(entry.getKey()).append("\"\r\n\r\n");
                    requestBody.append(entry.getValue()).append("\r\n");
                }
            }
            
            // Add files
            if (files != null) {
                for (Map.Entry<String, File> entry : files.entrySet()) {
                    File file = entry.getValue();
                    String filename = file.getName();
                    String contentType = Files.probeContentType(file.toPath());
                    if (contentType == null) {
                        contentType = "application/octet-stream";
                    }
                    
                    requestBody.append("--").append(boundary).append("\r\n");
                    requestBody.append("Content-Disposition: form-data; name=\"")
                              .append(entry.getKey()).append("\"; filename=\"")
                              .append(filename).append("\"\r\n");
                    requestBody.append("Content-Type: ").append(contentType).append("\r\n\r\n");
                    
                    // Add file content
                    try (InputStream inputStream = new FileInputStream(file)) {
                        byte[] bytes = inputStream.readAllBytes();
                        requestBody.append(new String(bytes, StandardCharsets.UTF_8)).append("\r\n");
                    }
                }
            }
            
            // Add final boundary
            requestBody.append("--").append(boundary).append("--\r\n");
            
            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                                                .uri(URI.create(url))
                                                .timeout(Duration.ofSeconds(defaultTimeoutSeconds))
                                                .header("Content-Type", "multipart/form-data; boundary=" + boundary)
                                                .method(method, HttpRequest.BodyPublishers.ofString(requestBody.toString()));
            
            // Add default headers (except Content-Type which is already set)
            for (Map.Entry<String, String> entry : defaultHeaders.entrySet()) {
                if (!entry.getKey().equalsIgnoreCase("Content-Type")) {
                    requestBuilder.header(entry.getKey(), entry.getValue());
                }
            }
            
            HttpRequest request = requestBuilder.build();
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            long responseTime = System.currentTimeMillis() - startTime;
            return createApiResponse(response, responseTime);
            
        } catch (Exception e) {
            logger.error("Multipart form data request failed: " + url, e);
            return new CSSmartAPIResponse(0, new HashMap<>(), e.getMessage(), 0);
        }
    }
    
    /**
     * Sends an asynchronous GET request
     * 
     * @param url Target URL
     * @return CompletableFuture of API response
     */
    public CompletableFuture<CSSmartAPIResponse> getAsync(String url) {
        return getAsync(url, null);
    }
    
    /**
     * Sends an asynchronous GET request with headers
     * 
     * @param url Target URL
     * @param headers Additional headers
     * @return CompletableFuture of API response
     */
    public CompletableFuture<CSSmartAPIResponse> getAsync(String url, Map<String, String> headers) {
        try {
            long startTime = System.currentTimeMillis();
            
            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                                                .uri(URI.create(url))
                                                .timeout(Duration.ofSeconds(defaultTimeoutSeconds))
                                                .GET();
            
            // Add headers
            addHeaders(requestBuilder, headers);
            
            HttpRequest request = requestBuilder.build();
            
            return httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())
                    .thenApply(response -> {
                        long responseTime = System.currentTimeMillis() - startTime;
                        return createApiResponse(response, responseTime);
                    })
                    .exceptionally(e -> {
                        logger.error("Async GET request failed: " + url, e);
                        return new CSSmartAPIResponse(0, new HashMap<>(), e.getMessage(), 0);
                    });
            
        } catch (Exception e) {
            logger.error("Async GET request setup failed: " + url, e);
            CompletableFuture<CSSmartAPIResponse> future = new CompletableFuture<>();
            future.complete(new CSSmartAPIResponse(0, new HashMap<>(), e.getMessage(), 0));
            return future;
        }
    }
    
    /**
     * Adds headers to the request builder
     * 
     * @param requestBuilder HTTP request builder
     * @param additionalHeaders Additional headers
     */
    private void addHeaders(HttpRequest.Builder requestBuilder, Map<String, String> additionalHeaders) {
        // Add default headers
        for (Map.Entry<String, String> entry : defaultHeaders.entrySet()) {
            requestBuilder.header(entry.getKey(), entry.getValue());
        }
        
        // Add additional headers
        if (additionalHeaders != null) {
            for (Map.Entry<String, String> entry : additionalHeaders.entrySet()) {
                requestBuilder.header(entry.getKey(), entry.getValue());
            }
        }
    }
    
    /**
     * Creates an API response from HTTP response
     * 
     * @param response HTTP response
     * @param responseTime Response time in milliseconds
     * @return API response
     */
    private CSSmartAPIResponse createApiResponse(HttpResponse<String> response, long responseTime) {
        // Convert HTTP headers to Map
        Map<String, String> headerMap = new HashMap<>();
        HttpHeaders headers = response.headers();
        headers.map().forEach((name, values) -> {
            if (!values.isEmpty()) {
                headerMap.put(name, String.join(", ", values));
            }
        });
        
        return new CSSmartAPIResponse(response.statusCode(), headerMap, response.body(), responseTime);
    }
}



package com.cssmart.api.cucumber;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

import org.json.JSONArray;
import org.json.JSONObject;
import org.testng.Assert;

import com.cssmart.api.client.CSSmartHTTPClient;
import com.cssmart.api.response.CSSmartAPIResponse;
import com.cssmart.api.utils.CSSmartJSONUtils;
import com.cssmart.api.validation.CSSmartAPIResponseValidator;
import com.cssmart.api.validation.CSSmartAPIResponseValidator.ValidationResult;
import com.cssmart.utils.CSSmartDataLoader;
import com.cssmart.utils.CSSmartLogger;

import io.cucumber.java.Before;
import io.cucumber.java.en.And;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;

/**
 * BDD-style step definitions for API testing that non-technical users can use for zero-code API testing
 */
public class CSSmartAPITestSteps {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartAPITestSteps.class);
    
    private CSSmartHTTPClient httpClient;
    private CSSmartAPIResponse apiResponse;
    private String baseUrl;
    private String endpoint;
    private String requestBody;
    private Map<String, String> headers;
    private Map<String, Object> fieldValidations;
    
    @Before
    public void setup() {
        httpClient = new CSSmartHTTPClient();
        headers = new HashMap<>();
        fieldValidations = new HashMap<>();
    }
    
    @Given("I set base URL to {string}")
    public void setBaseUrl(String url) {
        this.baseUrl = url;
        logger.info("Base URL set to: " + url);
    }
    
    @Given("I set endpoint to {string}")
    public void setEndpoint(String endpoint) {
        this.endpoint = endpoint;
        logger.info("Endpoint set to: " + endpoint);
    }
    
    @Given("I set header {string} to {string}")
    public void setHeader(String headerName, String headerValue) {
        headers.put(headerName, headerValue);
        logger.info("Added header: " + headerName + " = " + headerValue);
    }
    
    @Given("I set bearer token to {string}")
    public void setBearerToken(String token) {
        headers.put("Authorization", "Bearer " + token);
        logger.info("Bearer token set");
    }
    
    @Given("I set basic authentication with username {string} and password {string}")
    public void setBasicAuth(String username, String password) {
        httpClient.configureBasicAuthentication(username, password);
        logger.info("Basic authentication set for username: " + username);
    }
    
    @Given("I set certificate authentication with PFX file {string} and passphrase {string}")
    public void setCertificateAuth(String pfxFilePath, String passphrase) {
        try {
            httpClient = new CSSmartHTTPClient(pfxFilePath, passphrase);
            logger.info("Certificate authentication set with file: " + pfxFilePath);
        } catch (Exception e) {
            logger.error("Failed to set certificate authentication", e);
            Assert.fail("Failed to set certificate authentication: " + e.getMessage());
        }
    }
    
    @Given("I set request timeout to {int} seconds")
    public void setRequestTimeout(int seconds) {
        httpClient.setDefaultTimeout(seconds);
        logger.info("Request timeout set to " + seconds + " seconds");
    }
    
    @Given("I set request body as JSON")
    public void setJsonRequestBody(String jsonBody) {
        this.requestBody = jsonBody;
        logger.info("Request body set as JSON");
    }
    
    @Given("I set request body from file {string}")
    public void setRequestBodyFromFile(String filePath) {
        try {
            this.requestBody = new String(java.nio.file.Files.readAllBytes(java.nio.file.Paths.get(filePath)));
            logger.info("Request body loaded from file: " + filePath);
        } catch (Exception e) {
            logger.error("Failed to load request body from file", e);
            Assert.fail("Failed to load request body from file: " + e.getMessage());
        }
    }
    
    @Given("I set request body from data source {string} of type {string} with sheet {string} and row {int}")
    public void setRequestBodyFromDataSource(String filePath, String dataSourceType, String sheetName, int rowIndex) {
        try {
            CSSmartDataLoader.DataSourceType type = CSSmartDataLoader.DataSourceType.valueOf(dataSourceType.toUpperCase());
            Map<String, Object> data = CSSmartDataLoader.loadData(filePath, type, sheetName, rowIndex);
            this.requestBody = new JSONObject(data).toString();
            logger.info("Request body loaded from data source: " + filePath);
        } catch (Exception e) {
            logger.error("Failed to load request body from data source", e);
            Assert.fail("Failed to load request body from data source: " + e.getMessage());
        }
    }
    
    @Given("I replace path parameter {string} with {string} in the endpoint")
    public void replacePathParameter(String paramName, String paramValue) {
        this.endpoint = this.endpoint.replace("{" + paramName + "}", paramValue);
        logger.info("Replaced path parameter " + paramName + " with " + paramValue);
    }
    
    @Given("I replace placeholder {string} with {string} in the request body")
    public void replacePlaceholderInRequestBody(String placeholder, String value) {
        if (this.requestBody != null) {
            this.requestBody = this.requestBody.replace("{{" + placeholder + "}}", value);
            logger.info("Replaced placeholder " + placeholder + " with " + value + " in request body");
        }
    }
    
    @When("I send GET request")
    public void sendGetRequest() {
        String url = buildUrl();
        logger.info("Sending GET request to: " + url);
        this.apiResponse = httpClient.get(url, headers);
        logResponse();
    }
    
    @When("I send POST request")
    public void sendPostRequest() {
        String url = buildUrl();
        logger.info("Sending POST request to: " + url);
        logger.debug("With body: " + requestBody);
        this.apiResponse = httpClient.post(url, requestBody, headers);
        logResponse();
    }
    
    @When("I send PUT request")
    public void sendPutRequest() {
        String url = buildUrl();
        logger.info("Sending PUT request to: " + url);
        logger.debug("With body: " + requestBody);
        this.apiResponse = httpClient.put(url, requestBody, headers);
        logResponse();
    }
    
    @When("I send DELETE request")
    public void sendDeleteRequest() {
        String url = buildUrl();
        logger.info("Sending DELETE request to: " + url);
        this.apiResponse = httpClient.delete(url, headers);
        logResponse();
    }
    
    @When("I send PATCH request")
    public void sendPatchRequest() {
        String url = buildUrl();
        logger.info("Sending PATCH request to: " + url);
        logger.debug("With body: " + requestBody);
        this.apiResponse = httpClient.patch(url, requestBody, headers);
        logResponse();
    }
    
    @Then("the response status code should be {int}")
    public void verifyStatusCode(int expectedStatusCode) {
        Assert.assertEquals(apiResponse.getStatusCode(), expectedStatusCode, 
                           "Expected status code: " + expectedStatusCode + 
                           ", but got: " + apiResponse.getStatusCode());
        logger.info("Status code verified: " + expectedStatusCode);
    }
    
    @Then("the response body should contain {string}")
    public void verifyResponseBodyContains(String text) {
        Assert.assertTrue(apiResponse.getResponseBody().contains(text), 
                         "Expected response body to contain: " + text);
        logger.info("Response body contains: " + text);
    }
    
    @Then("the response header {string} should be {string}")
    public void verifyResponseHeader(String headerName, String expectedValue) {
        String actualValue = apiResponse.getHeader(headerName);
        Assert.assertEquals(actualValue, expectedValue, 
                           "Expected header '" + headerName + "' to be: " + expectedValue + 
                           ", but got: " + actualValue);
        logger.info("Response header verified: " + headerName + " = " + expectedValue);
    }
    
    @Then("the response should match JSON schema from file {string}")
    public void verifyJsonSchema(String schemaFilePath) {
        ValidationResult result = CSSmartAPIResponseValidator.validateJsonSchema(apiResponse, schemaFilePath);
        Assert.assertTrue(result.isValid(), "JSON Schema validation failed: " + result.getMessage());
        logger.info("JSON schema validation passed");
    }
    
    @Then("the response should match expected JSON from file {string}")
    public void verifyResponseAgainstJsonFile(String jsonFilePath) {
        ValidationResult result = CSSmartAPIResponseValidator.validateAgainstJsonFile(apiResponse, jsonFilePath);
        Assert.assertTrue(result.isValid(), "JSON validation failed: " + result);
        logger.info("Response matches expected JSON from file");
    }
    
    @Then("the response field {string} should be equal to {string}")
    public void verifyResponseField(String jsonPath, String expectedValue) {
        fieldValidations.put(jsonPath, expectedValue);
    }
    
    @Then("the response field {string} should be a number equal to {double}")
    public void verifyResponseFieldAsNumber(String jsonPath, double expectedValue) {
        fieldValidations.put(jsonPath, expectedValue);
    }
    
    @Then("the response field {string} should be a boolean equal to {boolean}")
    public void verifyResponseFieldAsBoolean(String jsonPath, boolean expectedValue) {
        fieldValidations.put(jsonPath, expectedValue);
    }
    
    @Then("the response field {string} should exist")
    public void verifyResponseFieldExists(String jsonPath) {
        Object value = apiResponse.extractValue(jsonPath);
        Assert.assertNotNull(value, "Field '" + jsonPath + "' does not exist in response");
        logger.info("Field exists: " + jsonPath);
    }
    
    @Then("the response field {string} should not exist")
    public void verifyResponseFieldDoesNotExist(String jsonPath) {
        Object value = apiResponse.extractValue(jsonPath);
        Assert.assertNull(value, "Field '" + jsonPath + "' exists in response but should not");
        logger.info("Field does not exist: " + jsonPath);
    }
    
    @Then("the response field {string} should be null")
    public void verifyResponseFieldIsNull(String jsonPath) {
        Object value = apiResponse.extractValue(jsonPath);
        Assert.assertNull(value, "Field '" + jsonPath + "' is not null");
        logger.info("Field is null: " + jsonPath);
    }
    
    @Then("the response field {string} should not be null")
    public void verifyResponseFieldIsNotNull(String jsonPath) {
        Object value = apiResponse.extractValue(jsonPath);
        Assert.assertNotNull(value, "Field '" + jsonPath + "' is null");
        logger.info("Field is not null: " + jsonPath);
    }
    
    @Then("the response field {string} should contain {string}")
    public void verifyResponseFieldContains(String jsonPath, String substring) {
        Object value = apiResponse.extractValue(jsonPath);
        Assert.assertNotNull(value, "Field '" + jsonPath + "' does not exist in response");
        Assert.assertTrue(value.toString().contains(substring), 
                         "Field '" + jsonPath + "' does not contain '" + substring + "'");
        logger.info("Field contains substring: " + jsonPath + " contains " + substring);
    }
    
    @Then("the response field {string} should match regex {string}")
    public void verifyResponseFieldMatchesRegex(String jsonPath, String regex) {
        Object value = apiResponse.extractValue(jsonPath);
        Assert.assertNotNull(value, "Field '" + jsonPath + "' does not exist in response");
        Assert.assertTrue(value.toString().matches(regex), 
                         "Field '" + jsonPath + "' does not match regex '" + regex + "'");
        logger.info("Field matches regex: " + jsonPath + " matches " + regex);
    }
    
    @Then("the response should match database query {string} with mapping")
    public void verifyResponseAgainstDatabaseQuery(String query, Map<String, String> columnToFieldMapping) {
        ValidationResult result = CSSmartAPIResponseValidator.validateAgainstDatabase(
            apiResponse, query, columnToFieldMapping
        );
        Assert.assertTrue(result.isValid(), "Database validation failed: " + result);
        logger.info("Response matches database query results");
    }
    
    @Then("the response should match data from {string} of type {string} with sheet {string} and row {int}")
    public void verifyResponseAgainstDataSource(String filePath, String dataSourceType, String sheetName, int rowIndex) {
        try {
            CSSmartDataLoader.DataSourceType type = CSSmartDataLoader.DataSourceType.valueOf(dataSourceType.toUpperCase());
            ValidationResult result = CSSmartAPIResponseValidator.validateAgainstDataSource(
                apiResponse, filePath, type, sheetName, rowIndex
            );
            Assert.assertTrue(result.isValid(), "Data source validation failed: " + result);
            logger.info("Response matches data source");
        } catch (Exception e) {
            logger.error("Failed to validate against data source", e);
            Assert.fail("Failed to validate against data source: " + e.getMessage());
        }
    }
    
    @And("I verify all field validations")
    public void verifyAllFieldValidations() {
        if (!fieldValidations.isEmpty()) {
            ValidationResult result = CSSmartAPIResponseValidator.validateFields(apiResponse, fieldValidations);
            Assert.assertTrue(result.isValid(), "Field validations failed: " + result);
            logger.info("All field validations passed");
        }
    }
    
    @Then("the response time should be less than {int} milliseconds")
    public void verifyResponseTime(int maxResponseTime) {
        Assert.assertTrue(apiResponse.getResponseTimeMs() < maxResponseTime, 
                         "Response time (" + apiResponse.getResponseTimeMs() + " ms) exceeds maximum (" + maxResponseTime + " ms)");
        logger.info("Response time verified: " + apiResponse.getResponseTimeMs() + " ms");
    }
    
    @Then("the response array should have length {int}")
    public void verifyResponseArrayLength(int expectedLength) {
        try {
            JSONArray array = apiResponse.getBodyAsJsonArray();
            Assert.assertEquals(array.length(), expectedLength, 
                               "Expected array length: " + expectedLength + ", but got: " + array.length());
            logger.info("Array length verified: " + expectedLength);
        } catch (Exception e) {
            logger.error("Failed to verify array length", e);
            Assert.fail("Response body is not a valid JSON array: " + e.getMessage());
        }
    }
    
    @Then("the response array should not be empty")
    public void verifyResponseArrayNotEmpty() {
        try {
            JSONArray array = apiResponse.getBodyAsJsonArray();
            Assert.assertTrue(array.length() > 0, "Response array is empty");
            logger.info("Array is not empty, length: " + array.length());
        } catch (Exception e) {
            logger.error("Failed to verify array is not empty", e);
            Assert.fail("Response body is not a valid JSON array: " + e.getMessage());
        }
    }
    
    @And("I store response field {string} as variable {string}")
    public void storeResponseFieldAsVariable(String jsonPath, String variableName) {
        Object value = apiResponse.extractValue(jsonPath);
        Assert.assertNotNull(value, "Field '" + jsonPath + "' does not exist in response");
        
        // Store in the Cucumber context for later use
        CSSmartAPIContext.getInstance().setVariable(variableName, value.toString());
        logger.info("Stored field '" + jsonPath + "' as variable '" + variableName + "' with value: " + value);
    }
    
    @And("I use variable {string} as path parameter {string}")
    public void useVariableAsPathParameter(String variableName, String paramName) {
        String value = CSSmartAPIContext.getInstance().getVariable(variableName);
        Assert.assertNotNull(value, "Variable '" + variableName + "' does not exist");
        
        this.endpoint = this.endpoint.replace("{" + paramName + "}", value);
        logger.info("Replaced path parameter '" + paramName + "' with variable '" + variableName + "' value: " + value);
    }
    
    @And("I use variable {string} as request body placeholder {string}")
    public void useVariableAsRequestBodyPlaceholder(String variableName, String placeholder) {
        String value = CSSmartAPIContext.getInstance().getVariable(variableName);
        Assert.assertNotNull(value, "Variable '" + variableName + "' does not exist");
        
        if (this.requestBody != null) {
            this.requestBody = this.requestBody.replace("{{" + placeholder + "}}", value);
            logger.info("Replaced placeholder '" + placeholder + "' with variable '" + variableName + "' value: " + value);
        }
    }
    
    @And("I use variable {string} as header {string}")
    public void useVariableAsHeader(String variableName, String headerName) {
        String value = CSSmartAPIContext.getInstance().getVariable(variableName);
        Assert.assertNotNull(value, "Variable '" + variableName + "' does not exist");
        
        headers.put(headerName, value);
        logger.info("Set header '" + headerName + "' with variable '" + variableName + "' value: " + value);
    }
    
    @Given("I upload file {string} as form field {string}")
    public void uploadFileAsFormField(String filePath, String fieldName) {
        try {
            Map<String, File> files = new HashMap<>();
            files.put(fieldName, new File(filePath));
            
            Map<String, String> formData = new HashMap<>();
            
            String url = buildUrl();
            logger.info("Uploading file " + filePath + " to " + url);
            
            this.apiResponse = httpClient.sendMultipartFormData(url, "POST", formData, files);
            logResponse();
        } catch (Exception e) {
            logger.error("Failed to upload file", e);
            Assert.fail("Failed to upload file: " + e.getMessage());
        }
    }
    
    @Given("I set form field {string} to {string}")
    public void setFormField(String fieldName, String fieldValue) {
        try {
            Map<String, String> formData = new HashMap<>();
            formData.put(fieldName, fieldValue);
            
            Map<String, File> files = new HashMap<>();
            
            String url = buildUrl();
            logger.info("Sending form data to " + url);
            
            this.apiResponse = httpClient.sendMultipartFormData(url, "POST", formData, files);
            logResponse();
        } catch (Exception e) {
            logger.error("Failed to send form data", e);
            Assert.fail("Failed to send form data: " + e.getMessage());
        }
    }
    
    @When("I wait for {int} milliseconds")
    public void waitForMilliseconds(int milliseconds) {
        try {
            Thread.sleep(milliseconds);
            logger.info("Waited for " + milliseconds + " milliseconds");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("Wait interrupted", e);
        }
    }
    
    /**
     * Build the full URL from base URL and endpoint
     */
    private String buildUrl() {
        return baseUrl + (baseUrl.endsWith("/") || endpoint.startsWith("/") ? "" : "/") + endpoint;
    }
    
    /**
     * Log the API response details
     */
    private void logResponse() {
        logger.info("Response received with status code: " + apiResponse.getStatusCode());
        logger.info("Response time: " + apiResponse.getResponseTimeMs() + " ms");
        logger.debug("Response headers: " + apiResponse.getHeaders());
        logger.debug("Response body: " + apiResponse.getResponseBody());
    }



package com.cssmart.api.cucumber;

import java.util.HashMap;
import java.util.Map;

/**
 * Singleton class to store and retrieve variables across API test steps
 */
public class CSSmartAPIContext {
    
    private static CSSmartAPIContext instance;
    private final Map<String, String> variables;
    
    /**
     * Private constructor to prevent direct instantiation
     */
    private CSSmartAPIContext() {
        variables = new HashMap<>();
    }
    
    /**
     * Get singleton instance
     * 
     * @return The singleton instance
     */
    public static synchronized CSSmartAPIContext getInstance() {
        if (instance == null) {
            instance = new CSSmartAPIContext();
        }
        return instance;
    }
    
    /**
     * Set a variable in the context
     * 
     * @param name Variable name
     * @param value Variable value
     */
    public void setVariable(String name, String value) {
        variables.put(name, value);
    }
    
    /**
     * Get a variable from the context
     * 
     * @param name Variable name
     * @return Variable value or null if not found
     */
    public String getVariable(String name) {
        return variables.get(name);
    }
    
    /**
     * Check if a variable exists in the context
     * 
     * @param name Variable name
     * @return true if variable exists, false otherwise
     */
    public boolean hasVariable(String name) {
        return variables.containsKey(name);
    }
    
    /**
     * Remove a variable from the context
     * 
     * @param name Variable name
     */
    public void removeVariable(String name) {
        variables.remove(name);
    }
    
    /**
     * Clear all variables in the context
     */
    public void clearVariables() {
        variables.clear();
    }
    
    /**
     * Get all variables in the context
     * 
     * @return Map of all variables
     */
    public Map<String, String> getAllVariables() {
        return new HashMap<>(variables);
    }
}



Feature: Sample API Testing with CSSmartAPITestSteps
  As a user
  I want to test RESTful APIs
  So that I can verify they work correctly without writing code

  Background:
    Given I set base URL to "https://api.example.com"
    And I set request timeout to 30 seconds

  Scenario: GET request to retrieve user data
    Given I set endpoint to "/api/users/1"
    And I set header "Accept" to "application/json"
    When I send GET request
    Then the response status code should be 200
    And the response field "data.id" should be equal to "1"
    And the response field "data.email" should exist
    And the response field "data.email" should match regex "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
    And I verify all field validations
    And the response time should be less than 1000 milliseconds

  Scenario: POST request to create a new user
    Given I set endpoint to "/api/users"
    And I set header "Content-Type" to "application/json"
    And I set request body as JSON
    """
    {
      "name": "John Doe",
      "job": "Software Engineer",
      "email": "john.doe@example.com"
    }
    """
    When I send POST request
    Then the response status code should be 201
    And the response field "id" should exist
    And the response field "createdAt" should exist
    And I store response field "id" as variable "userId"

  Scenario: PUT request to update user
    Given I set endpoint to "/api/users/{userId}"
    And I use variable "userId" as path parameter "userId"
    And I set header "Content-Type" to "application/json"
    And I set request body as JSON
    """
    {
      "name": "John Updated",
      "job": "Senior Software Engineer"
    }
    """
    When I send PUT request
    Then the response status code should be 200
    And the response field "name" should be equal to "John Updated"
    And the response field "updatedAt" should exist
    And I verify all field validations

  Scenario: DELETE request to remove user
    Given I set endpoint to "/api/users/{userId}"
    And I use variable "userId" as path parameter "userId"
    When I send DELETE request
    Then the response status code should be 204

  Scenario: Validate response against JSON schema
    Given I set endpoint to "/api/users?page=1"
    When I send GET request
    Then the response status code should be 200
    And the response should match JSON schema from file "src/test/resources/schemas/users-schema.json"
    And the response array should not be empty

  Scenario: Authenticate with bearer token
    Given I set endpoint to "/api/secure-resource"
    And I set bearer token to "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ"
    When I send GET request
    Then the response status code should be 200
    And the response field "message" should be equal to "Access granted"
    And I verify all field validations

  Scenario: Authenticate with client certificate
    Given I set certificate authentication with PFX file "src/test/resources/certs/client.pfx" and passphrase "password"
    And I set endpoint to "/api/secure-resource/certificate"
    When I send GET request
    Then the response status code should be 200
    And the response field "message" should be equal to "Certificate authentication successful"
    And I verify all field validations

  Scenario: Validate response against database
    Given I set endpoint to "/api/products/1"
    When I send GET request
    Then the response status code should be 200
    And the response should match database query "SELECT id, name, price, description FROM products WHERE id = 1" with mapping
      | id          | id          |
      | name        | name        |
      | price       | price       |
      | description | description |

  Scenario: Load test data from Excel and validate response
    Given I set endpoint to "/api/products"
    And I set request body from data source "src/test/resources/testdata/products.xlsx" of type "EXCEL" with sheet "Products" and row 0
    When I send POST request
    Then the response status code should be 201
    And the response should match data from "src/test/resources/expected/product_response.xlsx" of type "EXCEL" with sheet "ExpectedResponse" and row 0

  Scenario: File upload test
    Given I set endpoint to "/api/upload"
    And I upload file "src/test/resources/files/sample.pdf" as form field "document"
    And I set form field "description" to "Sample document"
    Then the response status code should be 200
    And the response field "success" should be a boolean equal to true
    And the response field "fileName" should exist
    And I verify all field validations



package com.cssmart.ci;

import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.json.JSONArray;
import org.json.JSONObject;

import com.cssmart.reporting.CSSmartTestResult;
import com.cssmart.utils.CSSmartLogger;

/**
 * Integration with Azure DevOps using native Java HTTP client for updating test results
 * and triggering pipelines without using Microsoft ADO packages
 */
public class CSSmartAzureDevOpsIntegration {

    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartAzureDevOpsIntegration.class);
    
    private final String organization;
    private final String project;
    private final String personalAccessToken;
    private final HttpClient httpClient;
    private final String baseUrl;
    
    /**
     * Constructor for Azure DevOps integration
     * 
     * @param organization Azure DevOps organization name
     * @param project Azure DevOps project name
     * @param personalAccessToken Personal Access Token (PAT) for authentication
     */
    public CSSmartAzureDevOpsIntegration(String organization, String project, String personalAccessToken) {
        this.organization = organization;
        this.project = project;
        this.personalAccessToken = personalAccessToken;
        this.baseUrl = "https://dev.azure.com/" + organization + "/" + project;
        
        this.httpClient = HttpClient.newBuilder()
                           .version(HttpClient.Version.HTTP_2)
                           .connectTimeout(Duration.ofSeconds(30))
                           .build();
    }
    
    /**
     * Updates test results in Azure DevOps Test Plans
     * 
     * @param testPlanId Test Plan ID
     * @param testSuiteId Test Suite ID
     * @param testResults List of test results
     * @return true if update successful, false otherwise
     */
    public boolean updateTestResults(int testPlanId, int testSuiteId, List<CSSmartTestResult> testResults) {
        try {
            // Get test points for the test suite
            Map<String, Integer> testNameToPointIdMap = getTestPointIds(testPlanId, testSuiteId);
            
            // Prepare test results payload
            JSONArray resultsArray = new JSONArray();
            
            for (CSSmartTestResult result : testResults) {
                Integer testPointId = testNameToPointIdMap.get(result.getTestName());
                if (testPointId == null) {
                    logger.warn("Test point not found for test: " + result.getTestName());
                    continue;
                }
                
                JSONObject testResult = new JSONObject();
                testResult.put("testPoint", new JSONObject().put("id", testPointId));
                testResult.put("outcome", mapOutcome(result.getStatus()));
                testResult.put("state", "Completed");
                
                // Add error message if failed
                if ("Failed".equals(result.getStatus())) {
                    testResult.put("comment", result.getErrorMessage());
                }
                
                resultsArray.put(testResult);
            }
            
            JSONObject payload = new JSONObject();
            payload.put("results", resultsArray);
            
            // Send test results update request
            String updateUrl = baseUrl + "/_apis/test/runs?api-version=6.0";
            
            // First create test run
            JSONObject runPayload = new JSONObject();
            runPayload.put("name", "CSSmart Automated Test Run - " + System.currentTimeMillis());
            runPayload.put("plan", new JSONObject().put("id", testPlanId));
            
            HttpRequest createRunRequest = HttpRequest.newBuilder()
                                          .uri(URI.create(updateUrl))
                                          .timeout(Duration.ofMinutes(2))
                                          .header("Content-Type", "application/json")
                                          .header("Authorization", getAuthorizationHeader())
                                          .POST(HttpRequest.BodyPublishers.ofString(runPayload.toString()))
                                          .build();
            
            HttpResponse<String> createRunResponse = httpClient.send(createRunRequest, HttpResponse.BodyHandlers.ofString());
            
            if (createRunResponse.statusCode() != 200) {
                logger.error("Failed to create test run: " + createRunResponse.body());
                return false;
            }
            
            JSONObject runResponse = new JSONObject(createRunResponse.body());
            int runId = runResponse.getInt("id");
            
            // Update test results
            String resultsUrl = baseUrl + "/_apis/test/runs/" + runId + "/results?api-version=6.0";
            
            HttpRequest updateRequest = HttpRequest.newBuilder()
                                       .uri(URI.create(resultsUrl))
                                       .timeout(Duration.ofMinutes(2))
                                       .header("Content-Type", "application/json")
                                       .header("Authorization", getAuthorizationHeader())
                                       .PATCH(HttpRequest.BodyPublishers.ofString(payload.toString()))
                                       .build();
            
            HttpResponse<String> response = httpClient.send(updateRequest, HttpResponse.BodyHandlers.ofString());
            
            boolean isSuccess = response.statusCode() == 200;
            
            if (!isSuccess) {
                logger.error("Failed to update test results: " + response.body());
            } else {
                logger.info("Test results updated successfully");
                
                // Update test run state to completed
                String updateRunUrl = baseUrl + "/_apis/test/runs/" + runId + "?api-version=6.0";
                JSONObject completeRunPayload = new JSONObject();
                completeRunPayload.put("state", "Completed");
                
                HttpRequest completeRunRequest = HttpRequest.newBuilder()
                                               .uri(URI.create(updateRunUrl))
                                               .timeout(Duration.ofMinutes(1))
                                               .header("Content-Type", "application/json")
                                               .header("Authorization", getAuthorizationHeader())
                                               .method("PATCH", HttpRequest.BodyPublishers.ofString(completeRunPayload.toString()))
                                               .build();
                
                httpClient.send(completeRunRequest, HttpResponse.BodyHandlers.ofString());
            }
            
            return isSuccess;
        } catch (Exception e) {
            logger.error("Error updating test results in Azure DevOps", e);
            return false;
        }
    }
    
    /**
     * Triggers an Azure DevOps pipeline
     * 
     * @param pipelineId Pipeline ID
     * @param branch Branch name (e.g. 'refs/heads/master')
     * @param parameters Pipeline parameters
     * @return Build ID if successful, -1 otherwise
     */
    public int triggerPipeline(int pipelineId, String branch, Map<String, String> parameters) {
        try {
            String triggerUrl = baseUrl + "/_apis/pipelines/" + pipelineId + "/runs?api-version=6.0-preview.1";
            
            JSONObject payload = new JSONObject();
            payload.put("resources", new JSONObject()
                .put("repositories", new JSONObject()
                    .put("self", new JSONObject()
                        .put("refName", branch))));
            
            if (parameters != null && !parameters.isEmpty()) {
                JSONObject parametersJson = new JSONObject();
                for (Map.Entry<String, String> param : parameters.entrySet()) {
                    parametersJson.put(param.getKey(), param.getValue());
                }
                payload.put("templateParameters", parametersJson);
            }
            
            HttpRequest request = HttpRequest.newBuilder()
                                .uri(URI.create(triggerUrl))
                                .timeout(Duration.ofMinutes(2))
                                .header("Content-Type", "application/json")
                                .header("Authorization", getAuthorizationHeader())
                                .POST(HttpRequest.BodyPublishers.ofString(payload.toString()))
                                .build();
            
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() != 200) {
                logger.error("Failed to trigger pipeline: " + response.body());
                return -1;
            }
            
            JSONObject jsonResponse = new JSONObject(response.body());
            int buildId = jsonResponse.getInt("id");
            logger.info("Pipeline triggered successfully with build ID: " + buildId);
            
            return buildId;
        } catch (Exception e) {
            logger.error("Error triggering pipeline in Azure DevOps", e);
            return -1;
        }
    }
    
    /**
     * Gets the status of a pipeline run
     * 
     * @param pipelineId Pipeline ID
     * @param runId Run ID
     * @return Status of the pipeline run
     */
    public String getPipelineRunStatus(int pipelineId, int runId) {
        try {
            String statusUrl = baseUrl + "/_apis/pipelines/" + pipelineId + "/runs/" + runId + "?api-version=6.0-preview.1";
            
            HttpRequest request = HttpRequest.newBuilder()
                                .uri(URI.create(statusUrl))
                                .timeout(Duration.ofMinutes(1))
                                .header("Authorization", getAuthorizationHeader())
                                .GET()
                                .build();
            
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() != 200) {
                logger.error("Failed to get pipeline run status: " + response.body());
                return "Unknown";
            }
            
            JSONObject jsonResponse = new JSONObject(response.body());
            String status = jsonResponse.getString("state");
            logger.info("Pipeline run status: " + status);
            
            return status;
        } catch (Exception e) {
            logger.error("Error getting pipeline run status from Azure DevOps", e);
            return "Unknown";
        }
    }
    
    /**
     * Creates a work item in Azure DevOps
     * 
     * @param type Work item type (e.g. "Bug", "Task", "User Story")
     * @param title Title of the work item
     * @param description Description of the work item
     * @return Work item ID if successful, -1 otherwise
     */
    public int createWorkItem(String type, String title, String description) {
        try {
            String createUrl = baseUrl + "/_apis/wit/workitems/$" + type + "?api-version=6.0";
            
            JSONArray payload = new JSONArray();
            
            // Add title
            payload.put(new JSONObject()
                .put("op", "add")
                .put("path", "/fields/System.Title")
                .put("value", title));
            
            // Add description
            payload.put(new JSONObject()
                .put("op", "add")
                .put("path", "/fields/System.Description")
                .put("value", description));
            
            HttpRequest request = HttpRequest.newBuilder()
                                .uri(URI.create(createUrl))
                                .timeout(Duration.ofMinutes(2))
                                .header("Content-Type", "application/json-patch+json")
                                .header("Authorization", getAuthorizationHeader())
                                .POST(HttpRequest.BodyPublishers.ofString(payload.toString()))
                                .build();
            
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() != 200) {
                logger.error("Failed to create work item: " + response.body());
                return -1;
            }
            
            JSONObject jsonResponse = new JSONObject(response.body());
            int workItemId = jsonResponse.getInt("id");
            logger.info("Work item created successfully with ID: " + workItemId);
            
            return workItemId;
        } catch (Exception e) {
            logger.error("Error creating work item in Azure DevOps", e);
            return -1;
        }
    }
    
    /**
     * Gets test point IDs for a test plan and suite
     * 
     * @param testPlanId Test Plan ID
     * @param testSuiteId Test Suite ID
     * @return Map of test names to test point IDs
     * @throws IOException If HTTP request fails
     * @throws InterruptedException If HTTP request is interrupted
     */
    private Map<String, Integer> getTestPointIds(int testPlanId, int testSuiteId) throws IOException, InterruptedException {
        String pointsUrl = baseUrl + "/_apis/test/Plans/" + testPlanId + "/Suites/" + testSuiteId + "/Points?api-version=6.0";
        
        HttpRequest request = HttpRequest.newBuilder()
                            .uri(URI.create(pointsUrl))
                            .timeout(Duration.ofMinutes(1))
                            .header("Authorization", getAuthorizationHeader())
                            .GET()
                            .build();
        
        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
        
        if (response.statusCode() != 200) {
            logger.error("Failed to get test points: " + response.body());
            return new HashMap<>();
        }
        
        JSONObject jsonResponse = new JSONObject(response.body());
        JSONArray points = jsonResponse.getJSONArray("value");
        
        Map<String, Integer> testNameToPointIdMap = new HashMap<>();
        
        for (int i = 0; i < points.length(); i++) {
            JSONObject point = points.getJSONObject(i);
            int pointId = point.getInt("id");
            
            // Get the test case details
            int testCaseId = point.getJSONObject("testCase").getInt("id");
            String testName = getTestCaseName(testCaseId);
            
            if (testName != null) {
                testNameToPointIdMap.put(testName, pointId);
            }
        }
        
        return testNameToPointIdMap;
    }
    
    /**
     * Gets test case name by ID
     * 
     * @param testCaseId Test Case ID
     * @return Test case name
     * @throws IOException If HTTP request fails
     * @throws InterruptedException If HTTP request is interrupted
     */
    private String getTestCaseName(int testCaseId) throws IOException, InterruptedException {
        String testCaseUrl = baseUrl + "/_apis/wit/workitems/" + testCaseId + "?api-version=6.0";
        
        HttpRequest request = HttpRequest.newBuilder()
                            .uri(URI.create(testCaseUrl))
                            .timeout(Duration.ofMinutes(1))
                            .header("Authorization", getAuthorizationHeader())
                            .GET()
                            .build();
        
        HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
        
        if (response.statusCode() != 200) {
            logger.error("Failed to get test case details: " + response.body());
            return null;
        }
        
        JSONObject jsonResponse = new JSONObject(response.body());
        JSONObject fields = jsonResponse.getJSONObject("fields");
        
        return fields.getString("System.Title");
    }
    
    /**
     * Maps CSSmart test status to Azure DevOps outcome
     * 
     * @param status CSSmart test status
     * @return Azure DevOps outcome
     */
    private String mapOutcome(String status) {
        switch (status) {
            case "Passed":
                return "Passed";
            case "Failed":
                return "Failed";
            case "Skipped":
                return "NotExecuted";
            default:
                return "InProgress";
        }
    }
    
    /**
     * Gets authorization header for Azure DevOps API
     * 
     * @return Authorization header value
     */
    private String getAuthorizationHeader() {
        String auth = ":" + personalAccessToken;
        String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes(StandardCharsets.UTF_8));
        return "Basic " + encodedAuth;
    }
}



package com.cssmart.reporting;

import java.time.Duration;
import java.time.LocalDateTime;

/**
 * Represents a test result for reporting
 */
public class CSSmartTestResult {
    
    private String testName;
    private String testClass;
    private String status;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String errorMessage;
    private String stackTrace;
    
    /**
     * Constructor for test result
     * 
     * @param testName Test name
     * @param testClass Test class name
     * @param status Test status (Passed, Failed, Skipped)
     */
    public CSSmartTestResult(String testName, String testClass, String status) {
        this.testName = testName;
        this.testClass = testClass;
        this.status = status;
        this.startTime = LocalDateTime.now();
    }
    
    /**
     * Set error details for failed test
     * 
     * @param errorMessage Error message
     * @param stackTrace Stack trace
     * @return This test result instance for chaining
     */
    public CSSmartTestResult withError(String errorMessage, String stackTrace) {
        this.errorMessage = errorMessage;
        this.stackTrace = stackTrace;
        return this;
    }
    
    /**
     * Mark test as complete
     */
    public void markComplete() {
        this.endTime = LocalDateTime.now();
    }
    
    /**
     * Get test name
     * 
     * @return Test name
     */
    public String getTestName() {
        return testName;
    }
    
    /**
     * Get test class name
     * 
     * @return Test class name
     */
    public String getTestClass() {
        return testClass;
    }
    
    /**
     * Get test status
     * 
     * @return Test status
     */
    public String getStatus() {
        return status;
    }
    
    /**
     * Get test start time
     * 
     * @return Start time
     */
    public LocalDateTime getStartTime() {
        return startTime;
    }
    
    /**
     * Get test end time
     * 
     * @return End time
     */
    public LocalDateTime getEndTime() {
        return endTime;
    }
    
    /**
     * Get test duration in milliseconds
     * 
     * @return Test duration
     */
    public long getDurationMs() {
        if (endTime == null) {
            return 0;
        }
        return Duration.between(startTime, endTime).toMillis();
    }
    
    /**
     * Get error message
     * 
     * @return Error message for failed test
     */
    public String getErrorMessage() {
        return errorMessage;
    }
    
    /**
     * Get stack trace
     * 
     * @return Stack trace for failed test
     */
    public String getStackTrace() {
        return stackTrace;
    }
    
    /**
     * Check if test passed
     * 
     * @return true if passed, false otherwise
     */
    public boolean isPassed() {
        return "Passed".equals(status);
    }
    
    /**
     * Check if test failed
     * 
     * @return true if failed, false otherwise
     */
    public boolean isFailed() {
        return "Failed".equals(status);
    }
    
    /**
     * Check if test was skipped
     * 
     * @return true if skipped, false otherwise
     */
    public boolean isSkipped() {
        return "Skipped".equals(status);
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(testClass).append("#").append(testName).append(" - ").append(status);
        
        if (endTime != null) {
            sb.append(" (").append(getDurationMs()).append("ms)");
        }
        
        if (errorMessage != null && !errorMessage.isEmpty()) {
            sb.append("\nError: ").append(errorMessage);
        }
        
        return sb.toString();
    }
}


package com.cssmart.examples;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.cssmart.ci.CSSmartAzureDevOpsIntegration;
import com.cssmart.reporting.CSSmartTestResult;
import com.cssmart.runner.CSSmartTestRunner;
import com.cssmart.utils.CSSmartLogger;

/**
 * Example showing how to integrate CSSmart framework with Azure DevOps pipelines
 */
public class CSSmartPipelineExample {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartPipelineExample.class);
    
    public static void main(String[] args) {
        // Parse command line arguments
        String organization = getArgValue(args, "organization");
        String project = getArgValue(args, "project");
        String pat = getArgValue(args, "pat");
        int testPlanId = Integer.parseInt(getArgValue(args, "testPlanId", "0"));
        int testSuiteId = Integer.parseInt(getArgValue(args, "testSuiteId", "0"));
        int pipelineId = Integer.parseInt(getArgValue(args, "pipelineId", "0"));
        String testTagsToRun = getArgValue(args, "tags", "");
        
        // Validate required parameters
        if (organization == null || project == null || pat == null) {
            logger.error("Required parameters missing. Usage: java CSSmartPipelineExample --organization=myorg --project=myproject --pat=mypat [--testPlanId=123] [--testSuiteId=456] [--pipelineId=789] [--tags=tag1,tag2]");
            System.exit(1);
        }
        
        // Initialize Azure DevOps integration
        CSSmartAzureDevOpsIntegration adoIntegration = new CSSmartAzureDevOpsIntegration(organization, project, pat);
        
        // Run tests using CSSmart framework
        CSSmartTestRunner testRunner = new CSSmartTestRunner();
        List<CSSmartTestResult> testResults;
        
        if (!testTagsToRun.isEmpty()) {
            String[] tags = testTagsToRun.split(",");
            testResults = testRunner.runTestsWithTags(tags);
        } else {
            testResults = testRunner.runAllTests();
        }
        
        // Log test results summary
        int passed = 0, failed = 0, skipped = 0;
        for (CSSmartTestResult result : testResults) {
            if (result.isPassed()) passed++;
            else if (result.isFailed()) failed++;
            else if (result.isSkipped()) skipped++;
        }
        
        logger.info("Test Results Summary:");
        logger.info("Total: " + testResults.size());
        logger.info("Passed: " + passed);
        logger.info("Failed: " + failed);
        logger.info("Skipped: " + skipped);
        
        // Update test results in Azure DevOps if test plan and suite IDs are provided
        if (testPlanId > 0 && testSuiteId > 0) {
            boolean updateSuccess = adoIntegration.updateTestResults(testPlanId, testSuiteId, testResults);
            logger.info("Test results update " + (updateSuccess ? "successful" : "failed"));
        }
        
        // Create work items for failed tests
        for (CSSmartTestResult result : testResults) {
            if (result.isFailed()) {
                String title = "Test failure: " + result.getTestName();
                String description = "Test class: " + result.getTestClass() +
                                    "<br>Error: " + result.getErrorMessage() +
                                    "<br>Stack trace: <pre>" + result.getStackTrace() + "</pre>";
                
                int workItemId = adoIntegration.createWorkItem("Bug", title, description);
                if (workItemId > 0) {
                    logger.info("Created bug work item: " + workItemId);
                }
            }
        }
        
        // Trigger another pipeline if pipelineId is provided and all tests passed
        if (pipelineId > 0 && failed == 0) {
            Map<String, String> parameters = new HashMap<>();
            parameters.put("TestsPassed", "true");
            parameters.put("TestsCount", String.valueOf(testResults.size()));
            
            int runId = adoIntegration.triggerPipeline(pipelineId, "refs/heads/master", parameters);
            if (runId > 0) {
                logger.info("Triggered pipeline: " + pipelineId + ", run ID: " + runId);
                
                // Wait for pipeline to complete
                boolean isCompleted = false;
                int waitCount = 0;
                
                while (!isCompleted && waitCount < 60) {  // Wait up to 5 minutes
                    try {
                        Thread.sleep(5000);  // Check every 5 seconds
                        waitCount++;
                        
                        String status = adoIntegration.getPipelineRunStatus(pipelineId, runId);
                        logger.info("Pipeline status: " + status);
                        
                        if ("completed".equalsIgnoreCase(status) || 
                            "failed".equalsIgnoreCase(status) ||
                            "canceled".equalsIgnoreCase(status)) {
                            isCompleted = true;
                        }
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
                
                if (!isCompleted) {
                    logger.warn("Pipeline still running after timeout period");
                }
            }
        }
    }
    
    /**
     * Get command line argument value
     * 
     * @param args Command line arguments
     * @param name Argument name
     * @return Argument value or null if not found
     */
    private static String getArgValue(String[] args, String name) {
        return getArgValue(args, name, null);
    }
    
    /**
     * Get command line argument value with default
     * 
     * @param args Command line arguments
     * @param name Argument name
     * @param defaultValue Default value if argument not found
     * @return Argument value or default if not found
     */
    private static String getArgValue(String[] args, String name, String defaultValue) {
        String prefix = "--" + name + "=";
        
        for (String arg : args) {
            if (arg.startsWith(prefix)) {
                return arg.substring(prefix.length());
            }
        }
        
        return defaultValue;
    }
}



package com.cssmart.reporting;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

import org.testng.ITestResult;

import com.cssmart.utils.CSSmartLogger;

/**
 * Advanced reporting system for CSSmart framework that generates detailed HTML reports
 * without using external libraries.
 */
public class CSSmartReporter {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartReporter.class);
    private static final String DEFAULT_REPORT_DIR = "cssmart-reports";
    private static CSSmartReporter instance;
    
    private final Map<String, TestSuiteReport> suiteReports = new ConcurrentHashMap<>();
    private final Map<Long, TestCaseReport> testReports = new ConcurrentHashMap<>();
    private final AtomicInteger screenshotCounter = new AtomicInteger(0);
    private final LocalDateTime reportStartTime = LocalDateTime.now();
    private String reportDirectory;
    private String executionEnvironment;
    private String buildNumber;
    private int passedTests = 0;
    private int failedTests = 0;
    private int skippedTests = 0;
    
    /**
     * Private constructor for singleton pattern
     */
    private CSSmartReporter() {
        this.reportDirectory = DEFAULT_REPORT_DIR;
        initializeReportDirectory();
    }
    
    /**
     * Get singleton instance
     * 
     * @return Reporter instance
     */
    public static synchronized CSSmartReporter getInstance() {
        if (instance == null) {
            instance = new CSSmartReporter();
        }
        return instance;
    }
    
    /**
     * Configure the reporter with custom settings
     * 
     * @param reportDir Report directory
     * @param environment Execution environment
     * @param buildNum Build number
     */
    public void configure(String reportDir, String environment, String buildNum) {
        if (reportDir != null && !reportDir.isEmpty()) {
            this.reportDirectory = reportDir;
            initializeReportDirectory();
        }
        
        this.executionEnvironment = environment;
        this.buildNumber = buildNum;
        logger.info("Configured reporter with directory: " + reportDirectory + 
                  ", environment: " + environment + 
                  ", build: " + buildNum);
    }
    
    /**
     * Initialize the report directory
     */
    private void initializeReportDirectory() {
        try {
            Path reportPath = Paths.get(reportDirectory);
            if (!Files.exists(reportPath)) {
                Files.createDirectories(reportPath);
                logger.info("Created report directory: " + reportDirectory);
            }
            
            // Create screenshots directory
            Path screenshotsPath = Paths.get(reportDirectory, "screenshots");
            if (!Files.exists(screenshotsPath)) {
                Files.createDirectories(screenshotsPath);
            }
            
            // Copy CSS and JS resources
            copyResources();
            
        } catch (IOException e) {
            logger.error("Failed to initialize report directory", e);
        }
    }
    
    /**
     * Copy CSS and JS resources to report directory
     */
    private void copyResources() {
        try {
            // Create CSS file
            Path cssPath = Paths.get(reportDirectory, "cssmart-report.css");
            try (PrintWriter writer = new PrintWriter(new FileWriter(cssPath.toFile()))) {
                writer.println("body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }");
                writer.println(".report-header { background-color: #2c3e50; color: white; padding: 20px; margin-bottom: 20px; border-radius: 5px; }");
                writer.println(".summary-container { display: flex; justify-content: space-between; margin-bottom: 20px; }");
                writer.println(".summary-box { background-color: white; padding: 15px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); flex: 1; margin: 0 10px; }");
                writer.println(".summary-box h3 { margin-top: 0; color: #2c3e50; }");
                writer.println(".passed { color: #27ae60; }");
                writer.println(".failed { color: #e74c3c; }");
                writer.println(".skipped { color: #f39c12; }");
                writer.println(".test-suite { background-color: white; margin-bottom: 20px; border-radius: 5px; overflow: hidden; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }");
                writer.println(".suite-header { background-color: #34495e; color: white; padding: 10px 20px; cursor: pointer; }");
                writer.println(".suite-content { padding: 0 20px; display: none; }");
                writer.println(".test-case { border-bottom: 1px solid #eee; padding: 15px 0; }");
                writer.println(".test-case:last-child { border-bottom: none; }");
                writer.println(".test-name { font-weight: bold; margin-bottom: 5px; }");
                writer.println(".test-details { margin-left: 20px; }");
                writer.println(".expand-btn { float: right; }");
                writer.println(".screenshot { max-width: 800px; border: 1px solid #ddd; margin: 10px 0; }");
                writer.println(".error-details { background-color: #ffeeee; padding: 10px; border-radius: 5px; margin-top: 10px; font-family: monospace; white-space: pre-wrap; }");
                writer.println(".progress-bar-container { width: 100%; background-color: #e0e0e0; border-radius: 4px; margin: 5px 0; }");
                writer.println(".progress-bar { height: 20px; border-radius: 4px; text-align: center; color: white; font-weight: bold; }");
                writer.println(".progress-bar-passed { background-color: #27ae60; }");
                writer.println(".progress-bar-failed { background-color: #e74c3c; }");
                writer.println(".progress-bar-skipped { background-color: #f39c12; }");
                writer.println(".chart-container { display: flex; justify-content: center; margin: 20px 0; }");
                writer.println(".pie-chart { width: 150px; height: 150px; position: relative; }");
                writer.println(".pie-slice { position: absolute; width: 100%; height: 100%; clip: rect(0px, 150px, 150px, 75px); }");
                writer.println(".pie-slice-inner { position: absolute; width: 100%; height: 100%; clip: rect(0px, 75px, 150px, 0px); }");
                writer.println(".legend { display: flex; justify-content: center; margin-top: 10px; }");
                writer.println(".legend-item { margin: 0 10px; display: flex; align-items: center; }");
                writer.println(".legend-color { width: 12px; height: 12px; margin-right: 5px; }");
                writer.println(".steps-container { margin-left: 20px; margin-top: 10px; }");
                writer.println(".step { padding: 5px 0; border-left: 2px solid #ddd; padding-left: 20px; position: relative; }");
                writer.println(".step:before { content: ''; width: 10px; height: 10px; background-color: #ddd; border-radius: 50%; position: absolute; left: -6px; top: 10px; }");
                writer.println(".step-passed:before { background-color: #27ae60; }");
                writer.println(".step-failed:before { background-color: #e74c3c; }");
                writer.println(".step-info:before { background-color: #3498db; }");
                writer.println(".step-warning:before { background-color: #f39c12; }");
                writer.println(".step-time { color: #7f8c8d; font-size: 0.8em; margin-left: 10px; }");
            }
            
            // Create JS file
            Path jsPath = Paths.get(reportDirectory, "cssmart-report.js");
            try (PrintWriter writer = new PrintWriter(new FileWriter(jsPath.toFile()))) {
                writer.println("document.addEventListener('DOMContentLoaded', function() {");
                writer.println("  // Toggle test suite details");
                writer.println("  document.querySelectorAll('.suite-header').forEach(function(header) {");
                writer.println("    header.addEventListener('click', function() {");
                writer.println("      var content = this.nextElementSibling;");
                writer.println("      if (content.style.display === 'block') {");
                writer.println("        content.style.display = 'none';");
                writer.println("        this.querySelector('.expand-btn').textContent = '+';");
                writer.println("      } else {");
                writer.println("        content.style.display = 'block';");
                writer.println("        this.querySelector('.expand-btn').textContent = '-';");
                writer.println("      }");
                writer.println("    });");
                writer.println("  });");
                writer.println("  // Filter tests");
                writer.println("  document.getElementById('filter-tests').addEventListener('input', function() {");
                writer.println("    var filterText = this.value.toLowerCase();");
                writer.println("    document.querySelectorAll('.test-case').forEach(function(testCase) {");
                writer.println("      var testName = testCase.querySelector('.test-name').textContent.toLowerCase();");
                writer.println("      if (testName.includes(filterText)) {");
                writer.println("        testCase.style.display = '';");
                writer.println("      } else {");
                writer.println("        testCase.style.display = 'none';");
                writer.println("      }");
                writer.println("    });");
                writer.println("  });");
                writer.println("  // Expand all suites");
                writer.println("  document.getElementById('expand-all').addEventListener('click', function() {");
                writer.println("    document.querySelectorAll('.suite-content').forEach(function(content) {");
                writer.println("      content.style.display = 'block';");
                writer.println("    });");
                writer.println("    document.querySelectorAll('.expand-btn').forEach(function(btn) {");
                writer.println("      btn.textContent = '-';");
                writer.println("    });");
                writer.println("  });");
                writer.println("  // Collapse all suites");
                writer.println("  document.getElementById('collapse-all').addEventListener('click', function() {");
                writer.println("    document.querySelectorAll('.suite-content').forEach(function(content) {");
                writer.println("      content.style.display = 'none';");
                writer.println("    });");
                writer.println("    document.querySelectorAll('.expand-btn').forEach(function(btn) {");
                writer.println("      btn.textContent = '+';");
                writer.println("    });");
                writer.println("  });");
                writer.println("});");
            }
        } catch (IOException e) {
            logger.error("Failed to create resource files", e);
        }
    }
    
    /**
     * Start a test suite
     * 
     * @param suiteName Suite name
     * @return The TestSuiteReport
     */
    public TestSuiteReport startSuite(String suiteName) {
        TestSuiteReport suiteReport = new TestSuiteReport(suiteName);
        suiteReports.put(suiteName, suiteReport);
        logger.info("Started test suite: " + suiteName);
        return suiteReport;
    }
    
    /**
     * Start a test case
     * 
     * @param testName Test name
     * @param suiteName Suite name
     * @param description Test description
     * @return Test case ID
     */
    public long startTest(String testName, String suiteName, String description) {
        long testId = Thread.currentThread().getId();
        TestCaseReport testReport = new TestCaseReport(testName, description);
        
        TestSuiteReport suiteReport = suiteReports.get(suiteName);
        if (suiteReport == null) {
            suiteReport = startSuite(suiteName);
        }
        
        suiteReport.addTest(testReport);
        testReports.put(testId, testReport);
        logger.info("Started test: " + testName);
        
        return testId;
    }
    
    /**
     * Add a step to the current test
     * 
     * @param message Step message
     * @param status Step status
     */
    public void addStep(String message, StepStatus status) {
        long testId = Thread.currentThread().getId();
        TestCaseReport testReport = testReports.get(testId);
        
        if (testReport != null) {
            testReport.addStep(message, status);
        }
    }
    
    /**
     * Add a screenshot to the current test
     * 
     * @param screenshotBytes Screenshot image bytes
     * @param description Screenshot description
     * @return Path to the screenshot file
     */
    public String addScreenshot(byte[] screenshotBytes, String description) {
        long testId = Thread.currentThread().getId();
        TestCaseReport testReport = testReports.get(testId);
        
        if (testReport != null && screenshotBytes != null) {
            try {
                int screenshotId = screenshotCounter.incrementAndGet();
                String fileName = "screenshot_" + screenshotId + "_" + System.currentTimeMillis() + ".png";
                Path screenshotPath = Paths.get(reportDirectory, "screenshots", fileName);
                
                Files.write(screenshotPath, screenshotBytes);
                
                String relativePath = "screenshots/" + fileName;
                testReport.addScreenshot(relativePath, description);
                
                return relativePath;
            } catch (IOException e) {
                logger.error("Failed to save screenshot", e);
            }
        }
        
        return null;
    }
    
    /**
     * End a test case with result
     * 
     * @param result Test result
     */
    public void endTest(ITestResult result) {
        long testId = Thread.currentThread().getId();
        TestCaseReport testReport = testReports.get(testId);
        
        if (testReport != null) {
            switch (result.getStatus()) {
                case ITestResult.SUCCESS:
                    testReport.setStatus(TestStatus.PASSED);
                    passedTests++;
                    break;
                case ITestResult.FAILURE:
                    testReport.setStatus(TestStatus.FAILED);
                    if (result.getThrowable() != null) {
                        testReport.setErrorMessage(result.getThrowable().getMessage());
                        testReport.setStackTrace(getStackTraceAsString(result.getThrowable()));
                    }
                    failedTests++;
                    break;
                case ITestResult.SKIP:
                    testReport.setStatus(TestStatus.SKIPPED);
                    skippedTests++;
                    break;
                default:
                    testReport.setStatus(TestStatus.UNKNOWN);
                    break;
            }
            
            testReport.setEndTime(LocalDateTime.now());
            logger.info("Ended test: " + testReport.getName() + " with status: " + testReport.getStatus());
        }
    }
    
    /**
     * End a test case with custom result
     * 
     * @param testId Test ID
     * @param status Test status
     * @param errorMessage Error message (for failed tests)
     * @param stackTrace Stack trace (for failed tests)
     */
    public void endTest(long testId, TestStatus status, String errorMessage, String stackTrace) {
        TestCaseReport testReport = testReports.get(testId);
        
        if (testReport != null) {
            testReport.setStatus(status);
            testReport.setEndTime(LocalDateTime.now());
            
            if (status == TestStatus.FAILED) {
                testReport.setErrorMessage(errorMessage);
                testReport.setStackTrace(stackTrace);
                failedTests++;
            } else if (status == TestStatus.PASSED) {
                passedTests++;
            } else if (status == TestStatus.SKIPPED) {
                skippedTests++;
            }
            
            logger.info("Ended test: " + testReport.getName() + " with status: " + status);
        }
    }
    
    /**
     * End a test suite
     * 
     * @param suiteName Suite name
     */
    public void endSuite(String suiteName) {
        TestSuiteReport suiteReport = suiteReports.get(suiteName);
        
        if (suiteReport != null) {
            suiteReport.setEndTime(LocalDateTime.now());
            logger.info("Ended test suite: " + suiteName);
        }
    }
    
    /**
     * Generate HTML report
     * 
     * @return Path to the generated report
     */
    public String generateReport() {
        try {
            String fileName = "cssmart-report-" + new SimpleDateFormat("yyyyMMdd-HHmmss").format(new Date()) + ".html";
            Path reportPath = Paths.get(reportDirectory, fileName);
            
            try (PrintWriter writer = new PrintWriter(new FileWriter(reportPath.toFile()))) {
                writeReportHeader(writer);
                writeSummary(writer);
                writeTestDetails(writer);
                writeReportFooter(writer);
            }
            
            logger.info("Generated report at: " + reportPath.toAbsolutePath());
            return reportPath.toAbsolutePath().toString();
        } catch (IOException e) {
            logger.error("Failed to generate report", e);
            return null;
        }
    }
    
    /**
     * Write report header
     * 
     * @param writer Writer
     */
    private void writeReportHeader(PrintWriter writer) {
        writer.println("<!DOCTYPE html>");
        writer.println("<html lang=\"en\">");
        writer.println("<head>");
        writer.println("  <meta charset=\"UTF-8\">");
        writer.println("  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">");
        writer.println("  <title>CSSmart Test Report</title>");
        writer.println("  <link rel=\"stylesheet\" href=\"cssmart-report.css\">");
        writer.println("</head>");
        writer.println("<body>");
        
        writer.println("  <div class=\"report-header\">");
        writer.println("    <h1>CSSmart Test Report</h1>");
        writer.println("    <p>Generated on: " + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) + "</p>");
        
        if (executionEnvironment != null) {
            writer.println("    <p>Environment: " + executionEnvironment + "</p>");
        }
        
        if (buildNumber != null) {
            writer.println("    <p>Build: " + buildNumber + "</p>");
        }
        
        LocalDateTime endTime = LocalDateTime.now();
        Duration duration = Duration.between(reportStartTime, endTime);
        writer.println("    <p>Execution Duration: " + formatDuration(duration) + "</p>");
        
        writer.println("    <div>");
        writer.println("      <input type=\"text\" id=\"filter-tests\" placeholder=\"Filter tests...\" style=\"padding: 5px; margin-right: 10px;\">");
        writer.println("      <button id=\"expand-all\" style=\"padding: 5px; margin-right: 5px;\">Expand All</button>");
        writer.println("      <button id=\"collapse-all\" style=\"padding: 5px;\">Collapse All</button>");
        writer.println("    </div>");
        writer.println("  </div>");
    }
    
    /**
     * Write test summary
     * 
     * @param writer Writer
     */
    private void writeSummary(PrintWriter writer) {
        int totalTests = passedTests + failedTests + skippedTests;
        double passPercentage = totalTests > 0 ? (double) passedTests / totalTests * 100 : 0;
        
        writer.println("  <div class=\"summary-container\">");
        
        // Test Summary
        writer.println("    <div class=\"summary-box\">");
        writer.println("      <h3>Test Summary</h3>");
        writer.println("      <p>Total Tests: " + totalTests + "</p>");
        writer.println("      <p class=\"passed\">Passed: " + passedTests + "</p>");
        writer.println("      <p class=\"failed\">Failed: " + failedTests + "</p>");
        writer.println("      <p class=\"skipped\">Skipped: " + skippedTests + "</p>");
        writer.println("      <p>Pass Rate: " + String.format("%.2f", passPercentage) + "%</p>");
        
        // Progress bar
        writer.println("      <div class=\"progress-bar-container\">");
        if (passedTests > 0) {
            double passWidth = (double) passedTests / totalTests * 100;
            writer.println("        <div class=\"progress-bar progress-bar-passed\" style=\"width: " + passWidth + "%; float: left;\">" + 
                          (passWidth > 10 ? passedTests : "") + "</div>");
        }
        if (failedTests > 0) {
            double failWidth = (double) failedTests / totalTests * 100;
            writer.println("        <div class=\"progress-bar progress-bar-failed\" style=\"width: " + failWidth + "%; float: left;\">" + 
                          (failWidth > 10 ? failedTests : "") + "</div>");
        }
        if (skippedTests > 0) {
            double skipWidth = (double) skippedTests / totalTests * 100;
            writer.println("        <div class=\"progress-bar progress-bar-skipped\" style=\"width: " + skipWidth + "%; float: left;\">" + 
                          (skipWidth > 10 ? skippedTests : "") + "</div>");
        }
        writer.println("      </div>");
        writer.println("    </div>");
        
        // Execution Times
        writer.println("    <div class=\"summary-box\">");
        writer.println("      <h3>Execution Times</h3>");
        writer.println("      <p>Start Time: " + reportStartTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) + "</p>");
        LocalDateTime endTime = LocalDateTime.now();
        writer.println("      <p>End Time: " + endTime.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) + "</p>");
        Duration duration = Duration.between(reportStartTime, endTime);
        writer.println("      <p>Total Duration: " + formatDuration(duration) + "</p>");
        writer.println("    </div>");
        
        // Chart
        writer.println("    <div class=\"summary-box\">");
        writer.println("      <h3>Test Results Chart</h3>");
        writer.println("      <div class=\"chart-container\">");
        writer.println("        <svg width=\"150\" height=\"150\" viewBox=\"0 0 42 42\">");
        writer.println("          <circle cx=\"21\" cy=\"21\" r=\"15.91549430918954\" fill=\"transparent\" stroke=\"#27ae60\" stroke-width=\"3\" stroke-dasharray=\"" + 
                      (passPercentage * 0.01 * 100) + " " + (100 - passPercentage * 0.01 * 100) + "\" stroke-dashoffset=\"25\"></circle>");
        writer.println("          <circle cx=\"21\" cy=\"21\" r=\"15.91549430918954\" fill=\"transparent\" stroke=\"#e74c3c\" stroke-width=\"3\" stroke-dasharray=\"" + 
                      (failedTests * 100.0 / totalTests) + " " + (100 - failedTests * 100.0 / totalTests) + "\" stroke-dashoffset=\"" + 
                      (25 - passPercentage * 0.01 * 100) + "\"></circle>");
        writer.println("          <circle cx=\"21\" cy=\"21\" r=\"15.91549430918954\" fill=\"transparent\" stroke=\"#f39c12\" stroke-width=\"3\" stroke-dasharray=\"" + 
                      (skippedTests * 100.0 / totalTests) + " " + (100 - skippedTests * 100.0 / totalTests) + "\" stroke-dashoffset=\"" + 
                      (25 - passPercentage * 0.01 * 100 - failedTests * 100.0 / totalTests) + "\"></circle>");
        writer.println("          <g>");
        writer.println("            <text x=\"50%\" y=\"50%\" text-anchor=\"middle\" stroke=\"none\" fill=\"#333\" font-size=\"7px\" font-weight=\"bold\">" + 
                      String.format("%.0f%%", passPercentage) + "</text>");
        writer.println("            <text x=\"50%\" y=\"60%\" text-anchor=\"middle\" stroke=\"none\" fill=\"#333\" font-size=\"3px\">Pass Rate</text>");
        writer.println("          </g>");
        writer.println("        </svg>");
        writer.println("      </div>");
        writer.println("      <div class=\"legend\">");
        writer.println("        <div class=\"legend-item\"><div class=\"legend-color\" style=\"background-color: #27ae60;\"></div>Passed</div>");
        writer.println("        <div class=\"legend-item\"><div class=\"legend-color\" style=\"background-color: #e74c3c;\"></div>Failed</div>");
        writer.println("        <div class=\"legend-item\"><div class=\"legend-color\" style=\"background-color: #f39c12;\"></div>Skipped</div>");
        writer.println("      </div>");
        writer.println("    </div>");
        
        writer.println("  </div>");
    }
    
    /**
     * Write test details
     * 
     * @param writer Writer
     */
    private void writeTestDetails(PrintWriter writer) {
        for (TestSuiteReport suiteReport : suiteReports.values()) {
            writer.println("  <div class=\"test-suite\">");
            
            // Suite header
            writer.println("    <div class=\"suite-header\">");
            writer.println("      <span class=\"expand-btn\">+</span>");
            writer.println("      <h2>" + suiteReport.getName() + "</h2>");
            writer.println("      <p>Duration: " + formatDuration(suiteReport.getDuration()) + "</p>");
            
            // Suite summary
            int suitePassed = 0, suiteFailed = 0, suiteSkipped = 0;
            for (TestCaseReport testReport : suiteReport.getTests()) {
                switch (testReport.getStatus()) {
                    case PASSED: suitePassed++; break;
                    case FAILED: suiteFailed++; break;
                    case SKIPPED: suiteSkipped++; break;
                    default: break;
                }
            }
            
            writer.println("      <p>Tests: " + suiteReport.getTests().size() + " | " +
                          "<span class=\"passed\">Passed: " + suitePassed + "</span> | " +
                          "<span class=\"failed\">Failed: " + suiteFailed + "</span> | " +
                          "<span class=\"skipped\">Skipped: " + suiteSkipped + "</span></p>");
            writer.println("    </div>");
            
            // Test cases
            writer.println("    <div class=\"suite-content\">");
            for (TestCaseReport testReport : suiteReport.getTests()) {
                writer.println("      <div class=\"test-case\">");
                writer.println("        <div class=\"test-name\">" + testReport.getName() + 
                             " <span class=\"" + testReport.getStatus().toString().toLowerCase() + "\">" + 
                             testReport.getStatus() + "</span></div>");
                
                if (testReport.getDescription() != null && !testReport.getDescription().isEmpty()) {
                    writer.println("        <div class=\"test-details\">Description: " + testReport.getDescription() + "</div>");
                }
                
                writer.println("        <div class=\"test-details\">Duration: " + formatDuration(testReport.getDuration()) + "</div>");
                
                // Test steps
                if (!testReport.getSteps().isEmpty()) {
                    writer.println("        <div class=\"steps-container\">");
                    for (TestStep step : testReport.getSteps()) {
                        String stepClass = "step";
                        switch (step.getStatus()) {
                            case PASSED: stepClass += " step-passed"; break;
                            case FAILED: stepClass += " step-failed"; break;
                            case INFO: stepClass += " step-info"; break;
                            case WARNING: stepClass += " step-warning"; break;
                            default: break;
                        }
                        
                        writer.println("          <div class=\"" + stepClass + "\">");
                        writer.println("            " + step.getMessage());
                        writer.println("            <span class=\"step-time\">" + 
                                     step.getTime().format(DateTimeFormatter.ofPattern("HH:mm:ss.SSS")) + "</span>");
                        writer.println("          </div>");
                    }
                    writer.println("        </div>");
                }
                
                // Screenshots
                if (!testReport.getScreenshots().isEmpty()) {
                    writer.println("        <div class=\"test-details\">");
                    writer.println("          <h4>Screenshots:</h4>");
                    for (Screenshot screenshot : testReport.getScreenshots()) {
                        writer.println("          <div>");
                        writer.println("            <p>" + screenshot.getDescription() + "</p>");
                        writer.println("            <img src=\"" + screenshot.getPath() + "\" class=\"screenshot\" alt=\"" + 
                                     screenshot.getDescription() + "\">");
                        writer.println("          </div>");
                    }
                    writer.println("        </div>");
                }
                
                // Error details
                if (testReport.getStatus() == TestStatus.FAILED && testReport.getErrorMessage() != null) {
                    writer.println("        <div class=\"test-details\">");
                    writer.println("          <h4>Error:</h4>");
                    writer.println("          <div class=\"error-details\">");
                    writer.println("            <p>" + testReport.getErrorMessage() + "</p>");
                    if (testReport.getStackTrace() != null) {
                        writer.println("            <pre>" + testReport.getStackTrace() + "</pre>");
                    }
                    writer.println("          </div>");
                    writer.println("        </div>");
                }
                
                writer.println("      </div>");
            }
            writer.println("    </div>");
            writer.println("  </div>");
        }
    }
    
    /**
     * Write report footer
     * 
     * @param writer Writer
     */
    private void writeReportFooter(PrintWriter writer) {
        writer.println("  <script src=\"cssmart-report.js\"></script>");
        writer.println("</body>");
        writer.println("</html>");
    }
    
    /**
     * Convert stack trace to string
     * 
     * @param throwable Throwable
     * @return Stack trace as string
     */
    private String getStackTraceAsString(Throwable throwable) {
        if (throwable == null) {
            return null;
        }
        
        java.io.StringWriter sw = new java.io.StringWriter();
        throwable.printStackTrace(new java.io.PrintWriter(sw));
        return sw.toString();
    }
    
    /**
     * Format duration to readable string
     * 
     * @param duration Duration
     * @return Formatted duration
     */
    private String formatDuration(Duration duration) {
        long hours = duration.toHours();
        long minutes = duration.toMinutesPart();
        long seconds = duration.toSecondsPart();
        long millis = duration.toMillisPart();
        
        return String.format("%02d:%02d:%02d.%03d", hours, minutes, seconds, millis);
    }
    
    /**
     * Enum for test status
     */
    public enum TestStatus {
        PASSED, FAILED, SKIPPED, UNKNOWN
    }
    
    /**
     * Enum for step status
     */
    public enum StepStatus {
        PASSED, FAILED, INFO, WARNING
    }
    
    /**
     * Class to represent a test suite report
     */
    public class TestSuiteReport {
        private final String name;
        private final List<TestCaseReport> tests = new ArrayList<>();
        private final LocalDateTime startTime;
        private LocalDateTime endTime;
        
        public TestSuiteReport(String name) {
            this.name = name;
            this.startTime = LocalDateTime.now();
        }
        
        public String getName() {
            return name;
        }
        
        public void addTest(TestCaseReport test) {
            tests.add(test);
        }
        
        public List<TestCaseReport> getTests() {
            return tests;
        }
        
        public LocalDateTime getStartTime() {
            return startTime;
        }
        
        public LocalDateTime getEndTime() {
            return endTime;
        }
        
        public void setEndTime(LocalDateTime endTime) {
            this.endTime = endTime;
        }
        
        public Duration getDuration() {
            LocalDateTime end = endTime != null ? endTime : LocalDateTime.now();
            return Duration.between(startTime, end);
        }
    }
    
    /**
     * Class to represent a test case report
     */
    public class TestCaseReport {
        private final String name;
        private final String description;
        private final LocalDateTime startTime;
        private LocalDateTime endTime;
        private TestStatus status = TestStatus.UNKNOWN;
        private String errorMessage;
        private String stackTrace;
        private final List<TestStep> steps = new ArrayList<>();
        private final List<Screenshot> screenshots = new ArrayList<>();
        
        public TestCaseReport(String name, String description) {
            this.name = name;
            this.description = description;
            this.startTime = LocalDateTime.now();
        }
        
        public String getName() {
            return name;
        }
        
        public String getDescription() {
            return description;
        }
        
        public TestStatus getStatus() {
            return status;
        }
        
        public void setStatus(TestStatus status) {
            this.status = status;
        }
        
        public LocalDateTime getStartTime() {
            return startTime;
        }
        
        public LocalDateTime getEndTime() {
            return endTime;
        }
        
        public void setEndTime(LocalDateTime endTime) {
            this.endTime = endTime;
        }
        
        public String getErrorMessage() {
            return errorMessage;
        }
        
        public void setErrorMessage(String errorMessage) {
            this.errorMessage = errorMessage;
        }
        
        public String getStackTrace() {
            return stackTrace;
        }
        
        public void setStackTrace(String stackTrace) {
            this.stackTrace = stackTrace;
        }
        
        public void addStep(String message, StepStatus status) {
            steps.add(new TestStep(message, status));
        }
        
        public List<TestStep> getSteps() {
            return steps;
        }
        
        public void addScreenshot(String path, String description) {
            screenshots.add(new Screenshot(path, description));
        }
        
        public List<Screenshot> getScreenshots() {
            return screenshots;
        }
        
        public Duration getDuration() {
            LocalDateTime end = endTime != null ? endTime : LocalDateTime.now();
            return Duration.between(startTime, end);
        }
    }
    
    /**
     * Class to represent a test step
     */
    public class TestStep {
        private final String message;
        private final StepStatus status;
        private final LocalDateTime time;
        
        public TestStep(String message, StepStatus status) {
            this.message = message;
            this.status = status;
            this.time = LocalDateTime.now();
        }
        
        public String getMessage() {
            return message;
        }
        
        public StepStatus getStatus() {
            return status;
        }
        
        public LocalDateTime getTime() {
            return time;
        }
    }
    
    /**
     * Class to represent a screenshot
     */
    public class Screenshot {
        private final String path;
        private final String description;
        
        public Screenshot(String path, String description) {
            this.path = path;
            this.description = description;
        }
        
        public String getPath() {
            return path;
        }
        
        public String getDescription() {
            return description;
        }
    }
}


package com.cssmart.browser;

import java.io.File;
import java.nio.file.Paths;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;

import org.openqa.selenium.Capabilities;
import org.openqa.selenium.PageLoadStrategy;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.edge.EdgeOptions;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.firefox.FirefoxOptions;
import org.openqa.selenium.firefox.FirefoxProfile;
import org.openqa.selenium.ie.InternetExplorerDriver;
import org.openqa.selenium.ie.InternetExplorerOptions;
import org.openqa.selenium.opera.OperaDriver;
import org.openqa.selenium.opera.OperaOptions;
import org.openqa.selenium.remote.DesiredCapabilities;
import org.openqa.selenium.remote.RemoteWebDriver;
import org.openqa.selenium.safari.SafariDriver;
import org.openqa.selenium.safari.SafariOptions;

import com.cssmart.config.CSSmartConfig;
import com.cssmart.utils.CSSmartLogger;

/**
 * Advanced browser manager for CSSmart framework with dynamic browser switching capabilities
 */
public class CSSmartBrowserManager {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartBrowserManager.class);
    
    // Store drivers for each thread
    private static final Map<Long, WebDriver> drivers = new ConcurrentHashMap<>();
    
    // Store browser type for each thread
    private static final Map<Long, BrowserType> browserTypes = new ConcurrentHashMap<>();
    
    // Default browser type
    private static BrowserType defaultBrowserType = BrowserType.CHROME;
    
    // Default timeout
    private static int defaultTimeoutSeconds = 30;
    
    /**
     * Supported browser types
     */
    public enum BrowserType {
        CHROME,
        FIREFOX,
        EDGE,
        IE,
        SAFARI,
        OPERA,
        REMOTE
    }
    
    /**
     * Configure browser manager with default settings
     * 
     * @param browserType Default browser type
     * @param timeoutSeconds Default timeout in seconds
     */
    public static void configure(BrowserType browserType, int timeoutSeconds) {
        defaultBrowserType = browserType;
        defaultTimeoutSeconds = timeoutSeconds;
        logger.info("Configured browser manager with default browser: " + browserType + 
                  ", timeout: " + timeoutSeconds + " seconds");
    }
    
    /**
     * Configure browser manager from properties
     * 
     * @param properties Properties
     */
    public static void configureFromProperties(Properties properties) {
        String browser = properties.getProperty("browser", "chrome");
        int timeout = Integer.parseInt(properties.getProperty("timeout", "30"));
        
        configure(getBrowserTypeFromString(browser), timeout);
    }
    
    /**
     * Get browser type from string
     * 
     * @param browser Browser name
     * @return Browser type
     */
    public static BrowserType getBrowserTypeFromString(String browser) {
        if (browser == null) {
            return defaultBrowserType;
        }
        
        switch (browser.toLowerCase()) {
            case "chrome": return BrowserType.CHROME;
            case "firefox": return BrowserType.FIREFOX;
            case "edge": return BrowserType.EDGE;
            case "ie": return BrowserType.IE;
            case "safari": return BrowserType.SAFARI;
            case "opera": return BrowserType.OPERA;
            case "remote": return BrowserType.REMOTE;
            default: return defaultBrowserType;
        }
    }
    
    /**
     * Get the current WebDriver for this thread or create a new one
     * 
     * @return WebDriver instance
     */
    public static WebDriver getDriver() {
        long threadId = Thread.currentThread().getId();
        
        if (!drivers.containsKey(threadId)) {
            BrowserType browserType = CSSmartConfig.getInstance().getBrowserType();
            if (browserType == null) {
                browserType = defaultBrowserType;
            }
            
            createDriver(browserType);
        }
        
        return drivers.get(threadId);
    }
    
    /**
     * Get the current WebDriver for this thread with specific browser type
     * 
     * @param browserType Browser type
     * @return WebDriver instance
     */
    public static WebDriver getDriver(BrowserType browserType) {
        long threadId = Thread.currentThread().getId();
        
        if (!drivers.containsKey(threadId) || browserTypes.get(threadId) != browserType) {
            createDriver(browserType);
        }
        
        return drivers.get(threadId);
    }
    
    /**
     * Get the current WebDriver for this thread with specific browser name
     * 
     * @param browserName Browser name
     * @return WebDriver instance
     */
    public static WebDriver getDriver(String browserName) {
        return getDriver(getBrowserTypeFromString(browserName));
    }
    
    /**
     * Switch to a different browser during execution
     * 
     * @param browserType New browser type
     * @return WebDriver instance for the new browser
     */
    public static WebDriver switchBrowser(BrowserType browserType) {
        long threadId = Thread.currentThread().getId();
        
        // Quit current driver if exists
        if (drivers.containsKey(threadId)) {
            try {
                WebDriver driver = drivers.get(threadId);
                if (driver != null) {
                    driver.quit();
                }
            } catch (Exception e) {
                logger.warn("Exception while quitting previous driver", e);
            } finally {
                drivers.remove(threadId);
                browserTypes.remove(threadId);
            }
        }
        
        // Create new driver
        return createDriver(browserType);
    }
    
    /**
     * Switch to a different browser during execution
     * 
     * @param browserName New browser name
     * @return WebDriver instance for the new browser
     */
    public static WebDriver switchBrowser(String browserName) {
        return switchBrowser(getBrowserTypeFromString(browserName));
    }
    
    /**
     * Create a WebDriver based on browser type
     * 
     * @param browserType Browser type
     * @return WebDriver instance
     */
    private static WebDriver createDriver(BrowserType browserType) {
        long threadId = Thread.currentThread().getId();
        WebDriver driver;
        
        try {
            switch (browserType) {
                case CHROME:
                    driver = createChromeDriver();
                    break;
                case FIREFOX:
                    driver = createFirefoxDriver();
                    break;
                case EDGE:
                    driver = createEdgeDriver();
                    break;
                case IE:
                    driver = createIEDriver();
                    break;
                case SAFARI:
                    driver = createSafariDriver();
                    break;
                case OPERA:
                    driver = createOperaDriver();
                    break;
                case REMOTE:
                    driver = createRemoteDriver();
                    break;
                default:
                    logger.info("Unknown browser type, defaulting to Chrome");
                    driver = createChromeDriver();
                    browserType = BrowserType.CHROME;
                    break;
            }
            
            if (driver != null) {
                driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(defaultTimeoutSeconds));
                driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(defaultTimeoutSeconds));
                driver.manage().timeouts().scriptTimeout(Duration.ofSeconds(defaultTimeoutSeconds));
                driver.manage().window().maximize();
            }
        } catch (Exception e) {
            logger.error("Error creating WebDriver for browser type: " + browserType, e);
            
            // Fallback to Chrome if the requested browser failed
            if (browserType != BrowserType.CHROME) {
                logger.info("Falling back to Chrome browser");
                browserType = BrowserType.CHROME;
                driver = createChromeDriver();
                
                if (driver != null) {
                    driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(defaultTimeoutSeconds));
                    driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(defaultTimeoutSeconds));
                    driver.manage().timeouts().scriptTimeout(Duration.ofSeconds(defaultTimeoutSeconds));
                    driver.manage().window().maximize();
                }
            } else {
                throw new RuntimeException("Failed to create WebDriver", e);
            }
        }
        
        drivers.put(threadId, driver);
        browserTypes.put(threadId, browserType);
        
        logger.info("Created new WebDriver for thread " + threadId + " with browser type: " + browserType);
        return driver;
    }
    
    /**
     * Create Chrome WebDriver
     * 
     * @return ChromeDriver instance
     */
    private static WebDriver createChromeDriver() {
        ChromeOptions options = new ChromeOptions();
        
        // Add common options
        options.addArguments("--disable-gpu");
        options.addArguments("--disable-extensions");
        options.addArguments("--no-sandbox");
        options.addArguments("--disable-dev-shm-usage");
        options.setPageLoadStrategy(PageLoadStrategy.NORMAL);
        
        // Add proxy if configured
        addProxySettings(options);
        
        // Add custom Chrome options from config
        Map<String, Object> chromePrefs = new HashMap<>();
        chromePrefs.put("profile.default_content_settings.popups", 0);
        chromePrefs.put("download.default_directory", getDownloadDir());
        options.setExperimentalOption("prefs", chromePrefs);
        
        // Headless mode if configured
        if (CSSmartConfig.getInstance().isHeadless()) {
            options.addArguments("--headless=new");
            logger.info("Running Chrome in headless mode");
        }
        
        // Set binary location if configured
        String chromeBinary = CSSmartConfig.getInstance().getProperty("chrome.binary");
        if (chromeBinary != null && !chromeBinary.isEmpty()) {
            options.setBinary(chromeBinary);
        }
        
        // Set driver path if configured
        String driverPath = CSSmartConfig.getInstance().getProperty("webdriver.chrome.driver");
        if (driverPath != null && !driverPath.isEmpty()) {
            System.setProperty("webdriver.chrome.driver", driverPath);
        }
        
        logger.info("Creating Chrome WebDriver with options: " + options.toString());
        return new ChromeDriver(options);
    }
    
    /**
     * Create Firefox WebDriver
     * 
     * @return FirefoxDriver instance
     */
    private static WebDriver createFirefoxDriver() {
        FirefoxOptions options = new FirefoxOptions();
        
        // Create and configure Firefox profile
        FirefoxProfile profile = new FirefoxProfile();
        profile.setPreference("browser.download.folderList", 2);
        profile.setPreference("browser.download.dir", getDownloadDir());
        profile.setPreference("browser.helperApps.neverAsk.saveToDisk", 
                            "application/pdf,application/x-pdf,application/octet-stream");
        profile.setPreference("pdfjs.disabled", true);
        
        options.setProfile(profile);
        options.setPageLoadStrategy(PageLoadStrategy.NORMAL);
        
        // Add proxy if configured
        addProxySettings(options);
        
        // Headless mode if configured
        if (CSSmartConfig.getInstance().isHeadless()) {
            options.addArguments("-headless");
            logger.info("Running Firefox in headless mode");
        }
        
        // Set binary location if configured
        String firefoxBinary = CSSmartConfig.getInstance().getProperty("firefox.binary");
        if (firefoxBinary != null && !firefoxBinary.isEmpty()) {
            options.setBinary(firefoxBinary);
        }
        
        // Set driver path if configured
        String driverPath = CSSmartConfig.getInstance().getProperty("webdriver.gecko.driver");
        if (driverPath != null && !driverPath.isEmpty()) {
            System.setProperty("webdriver.gecko.driver", driverPath);
        }
        
        logger.info("Creating Firefox WebDriver with options: " + options.toString());
        return new FirefoxDriver(options);
    }
    
    /**
     * Create Edge WebDriver
     * 
     * @return EdgeDriver instance
     */
    private static WebDriver createEdgeDriver() {
        EdgeOptions options = new EdgeOptions();
        
        // Add common options
        options.setPageLoadStrategy(PageLoadStrategy.NORMAL);
        options.addArguments("--disable-extensions");
        options.addArguments("--disable-gpu");
        
        // Add proxy if configured
        addProxySettings(options);
        
        // Headless mode if configured
        if (CSSmartConfig.getInstance().isHeadless()) {
            options.addArguments("--headless=new");
            logger.info("Running Edge in headless mode");
        }
        
        // Set download preferences
        Map<String, Object> edgePrefs = new HashMap<>();
        edgePrefs.put("download.default_directory", getDownloadDir());
        options.setExperimentalOption("prefs", edgePrefs);
        
        // Set driver path if configured
        String driverPath = CSSmartConfig.getInstance().getProperty("webdriver.edge.driver");
        if (driverPath != null && !driverPath.isEmpty()) {
            System.setProperty("webdriver.edge.driver", driverPath);
        }
        
        logger.info("Creating Edge WebDriver with options: " + options.toString());
        return new EdgeDriver(options);
    }
    
    /**
     * Create Internet Explorer WebDriver
     * 
     * @return InternetExplorerDriver instance
     */
    private static WebDriver createIEDriver() {
        InternetExplorerOptions options = new InternetExplorerOptions();
        
        // Configure IE options
        options.setPageLoadStrategy(PageLoadStrategy.NORMAL);
        options.ignoreZoomSettings();
        options.introduceFlakinessByIgnoringSecurityDomains();
        
        // Set driver path if configured
        String driverPath = CSSmartConfig.getInstance().getProperty("webdriver.ie.driver");
        if (driverPath != null && !driverPath.isEmpty()) {
            System.setProperty("webdriver.ie.driver", driverPath);
        }
        
        logger.info("Creating Internet Explorer WebDriver with options: " + options.toString());
        return new InternetExplorerDriver(options);
    }
    
    /**
     * Create Safari WebDriver
     * 
     * @return SafariDriver instance
     */
    private static WebDriver createSafariDriver() {
        SafariOptions options = new SafariOptions();
        
        // Configure Safari options
        options.setPageLoadStrategy(PageLoadStrategy.NORMAL);
        
        // Additional Safari options if needed
        boolean useAutomaticInspection = Boolean.parseBoolean(
            CSSmartConfig.getInstance().getProperty("safari.automaticInspection", "false"));
        boolean useAutomaticProfiling = Boolean.parseBoolean(
            CSSmartConfig.getInstance().getProperty("safari.automaticProfiling", "false"));
        
        options.setAutomaticInspection(useAutomaticInspection);
        options.setAutomaticProfiling(useAutomaticProfiling);
        
        logger.info("Creating Safari WebDriver with options: " + options.toString());
        return new SafariDriver(options);
    }
    
    /**
     * Create Opera WebDriver
     * 
     * @return OperaDriver instance
     */
    private static WebDriver createOperaDriver() {
        OperaOptions options = new OperaOptions();
        
        // Configure Opera options
        options.addArguments("--disable-gpu");
        options.addArguments("--no-sandbox");
        
        // Add proxy if configured
        addProxySettings(options);
        
        // Headless mode if configured
        if (CSSmartConfig.getInstance().isHeadless()) {
            options.addArguments("--headless=new");
            logger.info("Running Opera in headless mode");
        }
        
        // Set binary location if configured
        String operaBinary = CSSmartConfig.getInstance().getProperty("opera.binary");
        if (operaBinary != null && !operaBinary.isEmpty()) {
            options.setBinary(operaBinary);
        }
        
        // Set driver path if configured
        String driverPath = CSSmartConfig.getInstance().getProperty("webdriver.opera.driver");
        if (driverPath != null && !driverPath.isEmpty()) {
            System.setProperty("webdriver.opera.driver", driverPath);
        }
        
        logger.info("Creating Opera WebDriver with options: " + options.toString());
        return new OperaDriver(options);
    }
    
    /**
     * Create Remote WebDriver
     * 
     * @return RemoteWebDriver instance
     */
    private static WebDriver createRemoteDriver() {
        // Get remote WebDriver configuration
        String hubUrl = CSSmartConfig.getInstance().getProperty("remote.hub.url");
        String browserName = CSSmartConfig.getInstance().getProperty("remote.browser", "chrome");
        
        if (hubUrl == null || hubUrl.isEmpty()) {
            throw new IllegalArgumentException("Remote hub URL not specified");
        }
        
        try {
            DesiredCapabilities capabilities = new DesiredCapabilities();
            capabilities.setBrowserName(browserName);
            
            // Additional capabilities from configuration
            String platform = CSSmartConfig.getInstance().getProperty("remote.platform");
            if (platform != null && !platform.isEmpty()) {
                capabilities.setPlatform(org.openqa.selenium.Platform.fromString(platform));
            }
            
            String version = CSSmartConfig.getInstance().getProperty("remote.browser.version");
            if (version != null && !version.isEmpty()) {
                capabilities.setVersion(version);
            }
            
            // Add any custom capabilities from config
            Map<String, String> customCapabilities = CSSmartConfig.getInstance().getPropertiesWithPrefix("remote.capability.");
            for (Map.Entry<String, String> entry : customCapabilities.entrySet()) {
                String capName = entry.getKey().substring("remote.capability.".length());
                capabilities.setCapability(capName, entry.getValue());
            }
            
            logger.info("Creating Remote WebDriver with hub URL: " + hubUrl + ", capabilities: " + capabilities.toString());
            return new RemoteWebDriver(new java.net.URL(hubUrl), capabilities);
        } catch (Exception e) {
            throw new RuntimeException("Failed to create Remote WebDriver", e);
        }
    }
    
    /**
     * Add proxy settings to browser options
     * 
     * @param options Browser options
     */
    private static void addProxySettings(Capabilities options) {
        String proxyHost = CSSmartConfig.getInstance().getProperty("proxy.host");
        String proxyPort = CSSmartConfig.getInstance().getProperty("proxy.port");
        
        if (proxyHost != null && !proxyHost.isEmpty() && proxyPort != null && !proxyPort.isEmpty()) {
            org.openqa.selenium.Proxy proxy = new org.openqa.selenium.Proxy();
            proxy.setHttpProxy(proxyHost + ":" + proxyPort);
            proxy.setSslProxy(proxyHost + ":" + proxyPort);
            
            if (options instanceof ChromeOptions) {
                ((ChromeOptions) options).setProxy(proxy);
            } else if (options instanceof FirefoxOptions) {
                ((FirefoxOptions) options).setProxy(proxy);
            } else if (options instanceof EdgeOptions) {
                ((EdgeOptions) options).setProxy(proxy);
            } else if (options instanceof OperaOptions) {
                ((OperaOptions) options).setProxy(proxy);
            }
            
            logger.info("Configured proxy: " + proxyHost + ":" + proxyPort);
        }
    }
    
    /**
     * Get download directory path
     * 
     * @return Download directory path
     */
    private static String getDownloadDir() {
        String downloadDir = CSSmartConfig.getInstance().getProperty("download.directory");
        
        if (downloadDir == null || downloadDir.isEmpty()) {
            downloadDir = Paths.get(System.getProperty("user.dir"), "downloads").toString();
            
            // Create directory if it doesn't exist
            File dir = new File(downloadDir);
            if (!dir.exists()) {
                dir.mkdirs();
            }
        }
        
        return downloadDir;
    }
    
    /**
     * Get current browser type for this thread
     * 
     * @return Browser type
     */
    public static BrowserType getCurrentBrowserType() {
        long threadId = Thread.currentThread().getId();
        return browserTypes.getOrDefault(threadId, defaultBrowserType);
    }
    
    /**
     * Get current browser name for this thread
     * 
     * @return Browser name
     */
    public static String getCurrentBrowserName() {
        return getCurrentBrowserType().name().toLowerCase();
    }
    
    /**
     * Close all browser windows and quit driver for this thread
     */
    public static void closeCurrentDriver() {
        long threadId = Thread.currentThread().getId();
        
        if (drivers.containsKey(threadId)) {
            try {
                WebDriver driver = drivers.get(threadId);
                if (driver != null) {
                    logger.info("Closing WebDriver for thread " + threadId);
                    driver.quit();
                }
            } catch (Exception e) {
                logger.warn("Exception while closing WebDriver", e);
            } finally {
                drivers.remove(threadId);
                browserTypes.remove(threadId);
            }
        }
    }
    
    /**
     * Close all browser windows and quit all drivers
     */
    public static void closeAllDrivers() {
        for (Map.Entry<Long, WebDriver> entry : drivers.entrySet()) {
            try {
                WebDriver driver = entry.getValue();
                if (driver != null) {
                    logger.info("Closing WebDriver for thread " + entry.getKey());
                    driver.quit();
                }
            } catch (Exception e) {
                logger.warn("Exception while closing WebDriver for thread " + entry.getKey(), e);
            }
        }
        
        drivers.clear();
        browserTypes.clear();
    }
}



package com.cssmart.config;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import com.cssmart.browser.CSSmartBrowserManager.BrowserType;
import com.cssmart.utils.CSSmartLogger;

/**
 * Configuration manager for CSSmart framework
 */
public class CSSmartConfig {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartConfig.class);
    private static final String DEFAULT_CONFIG_FILE = "cssmart.properties";
    private static CSSmartConfig instance;
    
    private final Properties properties = new Properties();
    private BrowserType browserType;
    private boolean headless = false;
    private String environment;
    
    /**
     * Private constructor for singleton pattern
     */
    private CSSmartConfig() {
        loadDefaultProperties();
    }
    
    /**
     * Get singleton instance
     * 
     * @return Configuration instance
     */
    public static synchronized CSSmartConfig getInstance() {
        if (instance == null) {
            instance = new CSSmartConfig();
        }
        return instance;
    }
    
    /**
     * Load default properties
     */
    private void loadDefaultProperties() {
        // Load from system property
        String configFile = System.getProperty("cssmart.config", DEFAULT_CONFIG_FILE);
        
        // Try to load from file
        Path configPath = Paths.get(configFile);
        if (Files.exists(configPath)) {
            try (InputStream is = new FileInputStream(configPath.toFile())) {
                properties.load(is);
                logger.info("Loaded configuration from: " + configPath.toAbsolutePath());
            } catch (IOException e) {
                logger.error("Failed to load configuration from: " + configPath.toAbsolutePath(), e);
            }
        } else {
            // Try to load from classpath
            try (InputStream is = getClass().getClassLoader().getResourceAsStream(configFile)) {
                if (is != null) {
                    properties.load(is);
                    logger.info("Loaded configuration from classpath: " + configFile);
                } else {
                    logger.warn("Configuration file not found: " + configFile);
                }
            } catch (IOException e) {
                logger.error("Failed to load configuration from classpath: " + configFile, e);
            }
        }
        
        // Set initial values from properties
        setInitialValues();
    }
    
    /**
     * Set initial values from properties
     */
    private void setInitialValues() {
        String browser = getProperty("browser", "chrome");
        browserType = BrowserType.valueOf(browser.toUpperCase());
        
        headless = Boolean.parseBoolean(getProperty("headless", "false"));
        environment = getProperty("environment", "test");
        
        logger.info("Initialized configuration with browser: " + browserType + 
                  ", headless: " + headless + 
                  ", environment: " + environment);
    }
    
    /**
     * Load configuration from file
     * 
     * @param filePath Configuration file path
     * @return true if successfully loaded, false otherwise
     */
    public boolean loadConfig(String filePath) {
        Path configPath = Paths.get(filePath);
        if (!Files.exists(configPath)) {
            logger.error("Configuration file not found: " + configPath.toAbsolutePath());
            return false;
        }
        
        try (InputStream is = new FileInputStream(configPath.toFile())) {
            properties.clear();
            properties.load(is);
            
            // Update values
            setInitialValues();
            
            logger.info("Loaded configuration from: " + configPath.toAbsolutePath());
            return true;
        } catch (IOException e) {
            logger.error("Failed to load configuration from: " + configPath.toAbsolutePath(), e);
            return false;
        }
    }
    
    /**
     * Get property value
     * 
     * @param key Property key
     * @return Property value or null if not found
     */
    public String getProperty(String key) {
        return properties.getProperty(key);
    }
    
    /**
     * Get property value with default
     * 
     * @param key Property key
     * @param defaultValue Default value
     * @return Property value or default if not found
     */
    public String getProperty(String key, String defaultValue) {
        return properties.getProperty(key, defaultValue);
    }
    
    /**
     * Set property value
     * 
     * @param key Property key
     * @param value Property value
     */
    public void setProperty(String key, String value) {
        properties.setProperty(key, value);
    }
    
    /**
     * Get all properties with prefix
     * 
     * @param prefix Property key prefix
     * @return Map of properties with prefix
     */
    public Map<String, String> getPropertiesWithPrefix(String prefix) {
        Map<String, String> result = new HashMap<>();
        
        for (String key : properties.stringPropertyNames()) {
            if (key.startsWith(prefix)) {
                result.put(key, properties.getProperty(key));
            }
        }
        
        return result;
    }
    
    /**
     * Get browser type
     * 
     * @return Browser type
     */
    public BrowserType getBrowserType() {
        return browserType;
    }
    
    /**
     * Set browser type
     * 
     * @param browserType Browser type
     */
    public void setBrowserType(BrowserType browserType) {
        this.browserType = browserType;
        setProperty("browser", browserType.name().toLowerCase());
    }
    
    /**
     * Set browser type by name
     * 
     * @param browserName Browser name
     */
    public void setBrowserType(String browserName) {
        try {
            setBrowserType(BrowserType.valueOf(browserName.toUpperCase()));
        } catch (IllegalArgumentException e) {
            logger.error("Invalid browser name: " + browserName);
        }
    }
    
    /**
     * Check if headless mode is enabled
     * 
     * @return true if headless, false otherwise
     */
    public boolean isHeadless() {
        return headless;
    }
    
    /**
     * Set headless mode
     * 
     * @param headless Headless mode flag
     */
    public void setHeadless(boolean headless) {
        this.headless = headless;
        setProperty("headless", String.valueOf(headless));
    }
    
    /**
     * Get environment
     * 
     * @return Environment name
     */
    public String getEnvironment() {
        return environment;
    }
    
    /**
     * Set environment
     * 
     * @param environment Environment name
     */
    public void setEnvironment(String environment) {
        this.environment = environment;
        setProperty("environment", environment);
    }

package com.cssmart.database;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;

import com.cssmart.config.CSSmartConfig;
import com.cssmart.utils.CSSmartLogger;

/**
 * Database manager for CSSmart framework supporting various database types
 * without using external libraries. Manages connections and provides utility methods
 * for database operations.
 */
public class CSSmartDatabaseManager {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartDatabaseManager.class);
    
    // Database connection pool (thread-safe)
    private static final Map<String, Connection> connections = new ConcurrentHashMap<>();
    
    // Default connection name
    private static final String DEFAULT_CONNECTION = "default";
    
    /**
     * Database types supported by the manager
     */
    public enum DatabaseType {
        MYSQL("com.mysql.cj.jdbc.Driver", "jdbc:mysql://%s:%s/%s"),
        POSTGRESQL("org.postgresql.Driver", "jdbc:postgresql://%s:%s/%s"),
        ORACLE("oracle.jdbc.OracleDriver", "jdbc:oracle:thin:@%s:%s:%s"),
        SQLSERVER("com.microsoft.sqlserver.jdbc.SQLServerDriver", "jdbc:sqlserver://%s:%s;databaseName=%s"),
        H2("org.h2.Driver", "jdbc:h2:%s"),
        SQLITE("org.sqlite.JDBC", "jdbc:sqlite:%s"),
        DB2("com.ibm.db2.jcc.DB2Driver", "jdbc:db2://%s:%s/%s"),
        MARIADB("org.mariadb.jdbc.Driver", "jdbc:mariadb://%s:%s/%s"),
        SYBASE("com.sybase.jdbc4.jdbc.SybDriver", "jdbc:sybase:Tds:%s:%s/%s");
        
        private final String driverClassName;
        private final String urlPattern;
        
        DatabaseType(String driverClassName, String urlPattern) {
            this.driverClassName = driverClassName;
            this.urlPattern = urlPattern;
        }
        
        public String getDriverClassName() {
            return driverClassName;
        }
        
        public String getUrlPattern() {
            return urlPattern;
        }
    }
    
    /**
     * Initialize database manager with configuration
     */
    public static void initialize() {
        // Get database configuration from CSSmartConfig
        String dbType = CSSmartConfig.getInstance().getProperty("database.type");
        if (dbType != null && !dbType.isEmpty()) {
            String host = CSSmartConfig.getInstance().getProperty("database.host");
            String port = CSSmartConfig.getInstance().getProperty("database.port");
            String name = CSSmartConfig.getInstance().getProperty("database.name");
            String username = CSSmartConfig.getInstance().getProperty("database.username");
            String password = CSSmartConfig.getInstance().getProperty("database.password");
            
            try {
                DatabaseType type = DatabaseType.valueOf(dbType.toUpperCase());
                connect(DEFAULT_CONNECTION, type, host, port, name, username, password);
                logger.info("Initialized database connection from configuration");
            } catch (IllegalArgumentException e) {
                logger.error("Invalid database type: " + dbType);
            } catch (Exception e) {
                logger.error("Failed to initialize database connection", e);
            }
        }
    }
    
    /**
     * Get default database connection
     * 
     * @return Database connection
     * @throws SQLException if connection fails
     */
    public static Connection getConnection() throws SQLException {
        return getConnection(DEFAULT_CONNECTION);
    }
    
    /**
     * Get named database connection
     * 
     * @param connectionName Connection name
     * @return Database connection
     * @throws SQLException if connection fails
     */
    public static Connection getConnection(String connectionName) throws SQLException {
        Connection connection = connections.get(connectionName);
        
        if (connection == null) {
            throw new SQLException("Database connection not found: " + connectionName);
        }
        
        if (connection.isClosed()) {
            logger.warn("Database connection closed, attempting to reconnect: " + connectionName);
            
            // Try to reconnect using same properties
            try {
                String url = connection.getMetaData().getURL();
                Properties props = connection.getClientInfo();
                
                connection = DriverManager.getConnection(url, props);
                connections.put(connectionName, connection);
                
                logger.info("Successfully reconnected to database: " + connectionName);
            } catch (SQLException e) {
                logger.error("Failed to reconnect to database: " + connectionName, e);
                throw e;
            }
        }
        
        return connection;
    }
    
    /**
     * Connect to database with MySQL, PostgreSQL, SQL Server, or MariaDB
     * 
     * @param connectionName Connection name
     * @param type Database type
     * @param host Database host
     * @param port Database port
     * @param databaseName Database name
     * @param username Database username
     * @param password Database password
     * @return Database connection
     * @throws SQLException if connection fails
     */
    public static Connection connect(String connectionName, DatabaseType type, 
                                    String host, String port, String databaseName,
                                    String username, String password) throws SQLException {
        try {
            // Load driver
            Class.forName(type.getDriverClassName());
            
            // Build connection URL
            String url;
            if (type == DatabaseType.SQLITE) {
                // SQLite uses file path instead of host/port/name
                url = String.format(type.getUrlPattern(), databaseName);
            } else if (type == DatabaseType.H2) {
                // H2 uses a different format
                url = String.format(type.getUrlPattern(), databaseName);
            } else if (type == DatabaseType.ORACLE) {
                // Oracle uses SID instead of database name
                url = String.format(type.getUrlPattern(), host, port, databaseName);
            } else {
                // Standard format for most databases
                url = String.format(type.getUrlPattern(), host, port, databaseName);
            }
            
            // Create connection properties
            Properties props = new Properties();
            if (username != null) {
                props.setProperty("user", username);
            }
            if (password != null) {
                props.setProperty("password", password);
            }
            
            // Add common properties
            props.setProperty("autoReconnect", "true");
            props.setProperty("useSSL", CSSmartConfig.getInstance().getProperty("database.useSSL", "false"));
            
            // Add database-specific properties
            if (type == DatabaseType.MYSQL || type == DatabaseType.MARIADB) {
                props.setProperty("serverTimezone", CSSmartConfig.getInstance().getProperty("database.timezone", "UTC"));
                props.setProperty("allowPublicKeyRetrieval", CSSmartConfig.getInstance().getProperty("database.allowPublicKeyRetrieval", "true"));
            }
            
            // Connect to database
            Connection connection = DriverManager.getConnection(url, props);
            
            // Store connection in pool
            connections.put(connectionName, connection);
            
            logger.info("Connected to " + type.name() + " database: " + url);
            return connection;
        } catch (ClassNotFoundException e) {
            logger.error("Database driver not found: " + type.getDriverClassName(), e);
            throw new SQLException("Database driver not found", e);
        } catch (SQLException e) {
            logger.error("Failed to connect to database: " + e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Connect to Oracle database with SID
     * 
     * @param connectionName Connection name
     * @param host Database host
     * @param port Database port
     * @param sid Oracle SID
     * @param username Database username
     * @param password Database password
     * @return Database connection
     * @throws SQLException if connection fails
     */
    public static Connection connectToOracle(String connectionName, String host, String port, 
                                           String sid, String username, String password) throws SQLException {
        return connect(connectionName, DatabaseType.ORACLE, host, port, sid, username, password);
    }
    
    /**
     * Connect to Oracle database with service name
     * 
     * @param connectionName Connection name
     * @param host Database host
     * @param port Database port
     * @param serviceName Oracle service name
     * @param username Database username
     * @param password Database password
     * @return Database connection
     * @throws SQLException if connection fails
     */
    public static Connection connectToOracleWithServiceName(String connectionName, String host, String port, 
                                                          String serviceName, String username, String password) throws SQLException {
        try {
            // Load driver
            Class.forName(DatabaseType.ORACLE.getDriverClassName());
            
            // Build connection URL with service name
            String url = "jdbc:oracle:thin:@//" + host + ":" + port + "/" + serviceName;
            
            // Create connection properties
            Properties props = new Properties();
            props.setProperty("user", username);
            props.setProperty("password", password);
            
            // Connect to database
            Connection connection = DriverManager.getConnection(url, props);
            
            // Store connection in pool
            connections.put(connectionName, connection);
            
            logger.info("Connected to Oracle database with service name: " + url);
            return connection;
        } catch (ClassNotFoundException e) {
            logger.error("Oracle driver not found", e);
            throw new SQLException("Oracle driver not found", e);
        } catch (SQLException e) {
            logger.error("Failed to connect to Oracle database: " + e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Connect to SQLite database
     * 
     * @param connectionName Connection name
     * @param databaseFilePath SQLite database file path
     * @return Database connection
     * @throws SQLException if connection fails
     */
    public static Connection connectToSQLite(String connectionName, String databaseFilePath) throws SQLException {
        return connect(connectionName, DatabaseType.SQLITE, null, null, databaseFilePath, null, null);
    }
    
    /**
     * Connect to H2 database
     * 
     * @param connectionName Connection name
     * @param databaseFilePath H2 database file path
     * @param username Database username
     * @param password Database password
     * @return Database connection
     * @throws SQLException if connection fails
     */
    public static Connection connectToH2(String connectionName, String databaseFilePath, 
                                      String username, String password) throws SQLException {
        return connect(connectionName, DatabaseType.H2, null, null, databaseFilePath, username, password);
    }
    
    /**
     * Execute SQL query and return result as list of maps
     * 
     * @param sql SQL query
     * @return List of maps representing rows
     * @throws SQLException if query fails
     */
    public static List<Map<String, Object>> executeQuery(String sql) throws SQLException {
        return executeQuery(DEFAULT_CONNECTION, sql);
    }
    
    /**
     * Execute SQL query with parameters and return result as list of maps
     * 
     * @param sql SQL query
     * @param params Query parameters
     * @return List of maps representing rows
     * @throws SQLException if query fails
     */
    public static List<Map<String, Object>> executeQuery(String sql, Object... params) throws SQLException {
        return executeQuery(DEFAULT_CONNECTION, sql, params);
    }
    
    /**
     * Execute SQL query on named connection and return result as list of maps
     * 
     * @param connectionName Connection name
     * @param sql SQL query
     * @return List of maps representing rows
     * @throws SQLException if query fails
     */
    public static List<Map<String, Object>> executeQuery(String connectionName, String sql) throws SQLException {
        Connection connection = getConnection(connectionName);
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            return resultSetToList(rs);
        }
    }
    
    /**
     * Execute SQL query with parameters on named connection and return result as list of maps
     * 
     * @param connectionName Connection name
     * @param sql SQL query
     * @param params Query parameters
     * @return List of maps representing rows
     * @throws SQLException if query fails
     */
    public static List<Map<String, Object>> executeQuery(String connectionName, String sql, Object... params) throws SQLException {
        Connection connection = getConnection(connectionName);
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            
            // Set parameters
            for (int i = 0; i < params.length; i++) {
                pstmt.setObject(i + 1, params[i]);
            }
            
            try (ResultSet rs = pstmt.executeQuery()) {
                return resultSetToList(rs);
            }
        }
    }
    
    /**
     * Execute SQL update (INSERT, UPDATE, DELETE) and return affected rows
     * 
     * @param sql SQL update statement
     * @return Number of affected rows
     * @throws SQLException if update fails
     */
    public static int executeUpdate(String sql) throws SQLException {
        return executeUpdate(DEFAULT_CONNECTION, sql);
    }
    
    /**
     * Execute SQL update (INSERT, UPDATE, DELETE) with parameters and return affected rows
     * 
     * @param sql SQL update statement
     * @param params Update parameters
     * @return Number of affected rows
     * @throws SQLException if update fails
     */
    public static int executeUpdate(String sql, Object... params) throws SQLException {
        return executeUpdate(DEFAULT_CONNECTION, sql, params);
    }
    
    /**
     * Execute SQL update (INSERT, UPDATE, DELETE) on named connection and return affected rows
     * 
     * @param connectionName Connection name
     * @param sql SQL update statement
     * @return Number of affected rows
     * @throws SQLException if update fails
     */
    public static int executeUpdate(String connectionName, String sql) throws SQLException {
        Connection connection = getConnection(connectionName);
        try (Statement stmt = connection.createStatement()) {
            return stmt.executeUpdate(sql);
        }
    }
    
    /**
     * Execute SQL update (INSERT, UPDATE, DELETE) with parameters on named connection and return affected rows
     * 
     * @param connectionName Connection name
     * @param sql SQL update statement
     * @param params Update parameters
     * @return Number of affected rows
     * @throws SQLException if update fails
     */
    public static int executeUpdate(String connectionName, String sql, Object... params) throws SQLException {
        Connection connection = getConnection(connectionName);
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            
            // Set parameters
            for (int i = 0; i < params.length; i++) {
                pstmt.setObject(i + 1, params[i]);
            }
            
            return pstmt.executeUpdate();
        }
    }
    
    /**
     * Execute SQL update and return generated keys
     * 
     * @param sql SQL update statement
     * @return Generated keys as list of maps
     * @throws SQLException if update fails
     */
    public static List<Map<String, Object>> executeUpdateWithGeneratedKeys(String sql) throws SQLException {
        return executeUpdateWithGeneratedKeys(DEFAULT_CONNECTION, sql);
    }
    
    /**
     * Execute SQL update with parameters and return generated keys
     * 
     * @param sql SQL update statement
     * @param params Update parameters
     * @return Generated keys as list of maps
     * @throws SQLException if update fails
     */
    public static List<Map<String, Object>> executeUpdateWithGeneratedKeys(String sql, Object... params) throws SQLException {
        return executeUpdateWithGeneratedKeys(DEFAULT_CONNECTION, sql, params);
    }
    
    /**
     * Execute SQL update on named connection and return generated keys
     * 
     * @param connectionName Connection name
     * @param sql SQL update statement
     * @return Generated keys as list of maps
     * @throws SQLException if update fails
     */
    public static List<Map<String, Object>> executeUpdateWithGeneratedKeys(String connectionName, String sql) throws SQLException {
        Connection connection = getConnection(connectionName);
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
            try (ResultSet rs = stmt.getGeneratedKeys()) {
                return resultSetToList(rs);
            }
        }
    }
    
    /**
     * Execute SQL update with parameters on named connection and return generated keys
     * 
     * @param connectionName Connection name
     * @param sql SQL update statement
     * @param params Update parameters
     * @return Generated keys as list of maps
     * @throws SQLException if update fails
     */
    public static List<Map<String, Object>> executeUpdateWithGeneratedKeys(String connectionName, String sql, Object... params) throws SQLException {
        Connection connection = getConnection(connectionName);
        try (PreparedStatement pstmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            
            // Set parameters
            for (int i = 0; i < params.length; i++) {
                pstmt.setObject(i + 1, params[i]);
            }
            
            pstmt.executeUpdate();
            
            try (ResultSet rs = pstmt.getGeneratedKeys()) {
                return resultSetToList(rs);
            }
        }
    }
    
    /**
     * Execute batch update and return affected rows for each batch
     * 
     * @param sql SQL update statement
     * @param paramsList List of parameter arrays
     * @return Array of affected rows for each batch
     * @throws SQLException if batch update fails
     */
    public static int[] executeBatchUpdate(String sql, List<Object[]> paramsList) throws SQLException {
        return executeBatchUpdate(DEFAULT_CONNECTION, sql, paramsList);
    }
    
    /**
     * Execute batch update on named connection and return affected rows for each batch
     * 
     * @param connectionName Connection name
     * @param sql SQL update statement
     * @param paramsList List of parameter arrays
     * @return Array of affected rows for each batch
     * @throws SQLException if batch update fails
     */
    public static int[] executeBatchUpdate(String connectionName, String sql, List<Object[]> paramsList) throws SQLException {
        Connection connection = getConnection(connectionName);
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            
            // Disable auto-commit for better performance
            boolean autoCommit = connection.getAutoCommit();
            connection.setAutoCommit(false);
            
            try {
                // Add batches
                for (Object[] params : paramsList) {
                    // Set parameters for this batch
                    for (int i = 0; i < params.length; i++) {
                        pstmt.setObject(i + 1, params[i]);
                    }
                    
                    pstmt.addBatch();
                }
                
                // Execute batch
                int[] results = pstmt.executeBatch();
                
                // Commit changes
                connection.commit();
                
                return results;
            } catch (SQLException e) {
                // Rollback on error
                connection.rollback();
                throw e;
            } finally {
                // Restore auto-commit
                connection.setAutoCommit(autoCommit);
            }
        }
    }
    
    /**
     * Execute stored procedure and return result as list of maps
     * 
     * @param procedureName Stored procedure name
     * @param params Procedure parameters
     * @return List of maps representing rows
     * @throws SQLException if procedure execution fails
     */
    public static List<Map<String, Object>> executeStoredProcedure(String procedureName, Object... params) throws SQLException {
        return executeStoredProcedure(DEFAULT_CONNECTION, procedureName, params);
    }
    
    /**
     * Execute stored procedure on named connection and return result as list of maps
     * 
     * @param connectionName Connection name
     * @param procedureName Stored procedure name
     * @param params Procedure parameters
     * @return List of maps representing rows
     * @throws SQLException if procedure execution fails
     */
    public static List<Map<String, Object>> executeStoredProcedure(String connectionName, String procedureName, Object... params) throws SQLException {
        Connection connection = getConnection(connectionName);
        
        // Build procedure call with parameter placeholders
        StringBuilder sb = new StringBuilder();
        sb.append("{call ").append(procedureName).append("(");
        
        for (int i = 0; i < params.length; i++) {
            if (i > 0) {
                sb.append(",");
            }
            sb.append("?");
        }
        
        sb.append(")}");
        
        String sql = sb.toString();
        
        try (java.sql.CallableStatement cstmt = connection.prepareCall(sql)) {
            
            // Set parameters
            for (int i = 0; i < params.length; i++) {
                cstmt.setObject(i + 1, params[i]);
            }
            
            // Execute and get result set
            boolean hasResults = cstmt.execute();
            
            if (hasResults) {
                try (ResultSet rs = cstmt.getResultSet()) {
                    return resultSetToList(rs);
                }
            } else {
                return new ArrayList<>();
            }
        }
    }
    
    /**
     * Test database connection
     * 
     * @return true if connection is valid, false otherwise
     */
    public static boolean testConnection() {
        return testConnection(DEFAULT_CONNECTION);
    }
    
    /**
     * Test named database connection
     * 
     * @param connectionName Connection name
     * @return true if connection is valid, false otherwise
     */
    public static boolean testConnection(String connectionName) {
        try {
            Connection connection = getConnection(connectionName);
            boolean isValid = connection.isValid(5); // 5-second timeout
            
            if (isValid) {
                // Get database information
                DatabaseMetaData metaData = connection.getMetaData();
                logger.info("Connected to " + metaData.getDatabaseProductName() + 
                          " version " + metaData.getDatabaseProductVersion() + 
                          " as " + metaData.getUserName());
            }
            
            return isValid;
        } catch (SQLException e) {
            logger.error("Database connection test failed: " + e.getMessage(), e);
            return false;
        }
    }
    
    /**
     * Get database metadata
     * 
     * @return Database metadata map
     * @throws SQLException if metadata retrieval fails
     */
    public static Map<String, Object> getDatabaseMetadata() throws SQLException {
        return getDatabaseMetadata(DEFAULT_CONNECTION);
    }
    
    /**
     * Get database metadata for named connection
     * 
     * @param connectionName Connection name
     * @return Database metadata map
     * @throws SQLException if metadata retrieval fails
     */
    public static Map<String, Object> getDatabaseMetadata(String connectionName) throws SQLException {
        Connection connection = getConnection(connectionName);
        DatabaseMetaData metaData = connection.getMetaData();
        
        Map<String, Object> result = new HashMap<>();
        result.put("databaseProductName", metaData.getDatabaseProductName());
        result.put("databaseProductVersion", metaData.getDatabaseProductVersion());
        result.put("driverName", metaData.getDriverName());
        result.put("driverVersion", metaData.getDriverVersion());
        result.put("url", metaData.getURL());
        result.put("username", metaData.getUserName());
        result.put("supportsBatchUpdates", metaData.supportsBatchUpdates());
        result.put("supportsTransactions", metaData.supportsTransactions());
        
        return result;
    }
    
    /**
     * Get table list from database
     * 
     * @return List of table names
     * @throws SQLException if metadata retrieval fails
     */
    public static List<String> getTableList() throws SQLException {
        return getTableList(DEFAULT_CONNECTION);
    }
    
    /**
     * Get table list from named database connection
     * 
     * @param connectionName Connection name
     * @return List of table names
     * @throws SQLException if metadata retrieval fails
     */
    public static List<String> getTableList(String connectionName) throws SQLException {
        Connection connection = getConnection(connectionName);
        DatabaseMetaData metaData = connection.getMetaData();
        
        List<String> tables = new ArrayList<>();
        
        try (ResultSet rs = metaData.getTables(null, null, null, new String[]{"TABLE"})) {
            while (rs.next()) {
                tables.add(rs.getString("TABLE_NAME"));
            }
        }
        
        return tables;
    }
    
    /**
     * Get column list for a table
     * 
     * @param tableName Table name
     * @return List of column names
     * @throws SQLException if metadata retrieval fails
     */
    public static List<Map<String, Object>> getColumnList(String tableName) throws SQLException {
        return getColumnList(DEFAULT_CONNECTION, tableName);
    }
    
    /**
     * Get column list for a table in named database connection
     * 
     * @param connectionName Connection name
     * @param tableName Table name
     * @return List of column details
     * @throws SQLException if metadata retrieval fails
     */
    public static List<Map<String, Object>> getColumnList(String connectionName, String tableName) throws SQLException {
        Connection connection = getConnection(connectionName);
        DatabaseMetaData metaData = connection.getMetaData();
        
        List<Map<String, Object>> columns = new ArrayList<>();
        
        try (ResultSet rs = metaData.getColumns(null, null, tableName, null)) {
            while (rs.next()) {
                Map<String, Object> column = new HashMap<>();
                column.put("name", rs.getString("COLUMN_NAME"));
                column.put("type", rs.getString("TYPE_NAME"));
                column.put("size", rs.getInt("COLUMN_SIZE"));
                column.put("nullable", rs.getBoolean("IS_NULLABLE"));
                column.put("position", rs.getInt("ORDINAL_POSITION"));
                column.put("defaultValue", rs.getString("COLUMN_DEF"));
                
                columns.add(column);
            }
        }
        
        return columns;
    }
    
    /**
     * Get primary key columns for a table
     * 
     * @param tableName Table name
     * @return List of primary key column names
     * @throws SQLException if metadata retrieval fails
     */
    public static List<String> getPrimaryKeys(String tableName) throws SQLException {
        return getPrimaryKeys(DEFAULT_CONNECTION, tableName);
    }
    
    /**
     * Get primary key columns for a table in named database connection
     * 
     * @param connectionName Connection name
     * @param tableName Table name
     * @return List of primary key column names
     * @throws SQLException if metadata retrieval fails
     */
    public static List<String> getPrimaryKeys(String connectionName, String tableName) throws SQLException {
        Connection connection = getConnection(connectionName);
        DatabaseMetaData metaData = connection.getMetaData();
        
        List<String> primaryKeys = new ArrayList<>();
        
        try (ResultSet rs = metaData.getPrimaryKeys(null, null, tableName)) {
            while (rs.next()) {
                primaryKeys.add(rs.getString("COLUMN_NAME"));
            }
        }
        
        return primaryKeys;
    }
    
    /**
     * Begin a database transaction
     * 
     * @throws SQLException if transaction begins fails
     */
    public static void beginTransaction() throws SQLException {
        beginTransaction(DEFAULT_CONNECTION);
    }
    
    /**
     * Begin a database transaction on named connection
     * 
     * @param connectionName Connection name
     * @throws SQLException if transaction begins fails
     */
    public static void beginTransaction(String connectionName) throws SQLException {
        Connection connection = getConnection(connectionName);
        connection.setAutoCommit(false);
        logger.info("Transaction begun on connection: " + connectionName);
    }
    
    /**
     * Commit a database transaction
     * 
     * @throws SQLException if commit fails
     */
    public static void commitTransaction() throws SQLException {
        commitTransaction(DEFAULT_CONNECTION);
    }
    
    /**
     * Commit a database transaction on named connection
     * 
     * @param connectionName Connection name
     * @throws SQLException if commit fails
     */
    public static void commitTransaction(String connectionName) throws SQLException {
        Connection connection = getConnection(connectionName);
        connection.commit();
        connection.setAutoCommit(true);
        logger.info("Transaction committed on connection: " + connectionName);
    }
    
    /**
     * Rollback a database transaction
     * 
     * @throws SQLException if rollback fails
     */
    public static void rollbackTransaction() throws SQLException {
        rollbackTransaction(DEFAULT_CONNECTION);
    }
    
    /**
     * Rollback a database transaction on named connection
     * 
     * @param connectionName Connection name
     * @throws SQLException if rollback fails
     */
    public static void rollbackTransaction(String connectionName) throws SQLException {
        Connection connection = getConnection(connectionName);
        connection.rollback();
        connection.setAutoCommit(true);
        logger.info("Transaction rolled back on connection: " + connectionName);
    }
    
    /**
     * Close all database connections
     */
    public static void closeAllConnections() {
        for (Map.Entry<String, Connection> entry : connections.entrySet()) {
            try {
                Connection connection = entry.getValue();
                if (connection != null && !connection.isClosed()) {
                    connection.close();
                    logger.info("Closed database connection: " + entry.getKey());
                }
            } catch (SQLException e) {
                logger.error("Error closing database connection: " + entry.getKey(), e);
            }
        }
        
        connections.clear();
    }
    
    /**
     * Close a specific database connection
     * 
     * @param connectionName Connection name
     */
    public static void closeConnection(String connectionName) {
        Connection connection = connections.get(connectionName);
        
        if (connection != null) {
            try {
                if (!connection.isClosed()) {
                    connection.close();
                    logger.info("Closed database connection: " + connectionName);
                }
            } catch (SQLException e) {
                logger.error("Error closing database connection: " + connectionName, e);
            } finally {
                connections.remove(connectionName);
            }
        }
    }
    
    /**
     * Convert ResultSet to List of Maps
     * 
     * @param rs ResultSet
     * @return List of maps representing rows
     * @throws SQLException if conversion fails
     */
    private static List<Map<String, Object>> resultSetToList(ResultSet rs) throws SQLException {
        List<Map<String, Object>> results = new ArrayList<>();
        ResultSetMetaData metaData = rs.getMetaData();
        int columnCount = metaData.getColumnCount();
        
        while (rs.next()) {
            Map<String, Object> row = new HashMap<>();
            
            for (int i = 1; i <= columnCount; i++) {
                String columnName = metaData.getColumnLabel(i);
                Object value = rs.getObject(i);
                row.put(columnName, value);
            }
            
            results.add(row);
        }
        
        return results;
    }
    
    /**
     * Validate SQL query for common security issues
     * 
     * @param sql SQL query
     * @return List of validation issues or empty list if valid
     */
    public static List<String> validateSqlSecurity(String sql) {
        List<String> issues = new ArrayList<>();
        
        // Check for unsafe SQL patterns
        
        // Check for SQL injection potential
        if (sql.toLowerCase().contains("drop table") || 
            sql.toLowerCase().contains("drop database") || 
            sql.toLowerCase().contains("truncate table")) {
            issues.add("Potentially harmful SQL command detected (DROP/TRUNCATE)");
        }
        
        // Check for direct concatenation indicators
        if (sql.contains("'+") || sql.contains("' +") || 
            sql.contains("+ '") || sql.contains("+'")) {
            issues.add("Potential SQL injection - string concatenation detected");
        }
        
        // Check for comment-based SQL injection
        if (sql.contains("--") || sql.contains("/*")) {
            issues.add("SQL comment markers detected - potential for SQL injection");
        }
        
        // Check for multiple statements
        if (sql.contains(";")) {
            issues.add("Multiple SQL statements detected - use prepared statements instead");
        }
        
        // Check for unsafe UNION-based injection
        if (sql.toUpperCase().contains("UNION") && 
            (sql.toUpperCase().contains("SELECT") && sql.toUpperCase().indexOf("SELECT") != sql.toUpperCase().lastIndexOf("SELECT"))) {
            issues.add("Multiple SELECT statements with UNION - potential for SQL injection");
        }
        
        return issues;
    }
    
    /**
     * Compare two database schemas (tables and columns)
     * 
     * @param sourceConnection Source connection name
     * @param targetConnection Target connection name
     * @return Map of differences
     * @throws SQLException if comparison fails
     */
    public static Map<String, List<String>> compareSchemas(String sourceConnection, String targetConnection) throws SQLException {
        Map<String, List<String>> differences = new HashMap<>();
        List<String> sourceTables = getTableList(sourceConnection);
        List<String> targetTables = getTableList(targetConnection);
        
        // Check for missing tables
        List<String> missingTables = new ArrayList<>();
        for (String sourceTable : sourceTables) {
            if (!targetTables.contains(sourceTable)) {
                missingTables.add(sourceTable);
            }
        }
        
        if (!missingTables.isEmpty()) {
            differences.put("missingTables", missingTables);
        }
        
        // Check for extra tables
        List<String> extraTables = new ArrayList<>();
        for (String targetTable : targetTables) {
            if (!sourceTables.contains(targetTable)) {
                extraTables.add(targetTable);
            }
        }
        
        if (!extraTables.isEmpty()) {
            differences.put("extraTables", extraTables);
        }
        
        // Check columns for common tables
        List<String> commonTables = new ArrayList<>(sourceTables);
        commonTables.retainAll(targetTables);
        
        List<String> columnDifferences = new ArrayList<>();
        
        for (String table : commonTables) {
            List<Map<String, Object>> sourceColumns = getColumnList(sourceConnection, table);
            List<Map<String, Object>> targetColumns = getColumnList(targetConnection, table);
            
            // Create maps of column name to details
            Map<String, Map<String, Object>> sourceColumnMap = new HashMap<>();
            for (Map<String, Object> column : sourceColumns) {
                sourceColumnMap.put((String) column.get("name"), column);
            }
            
            Map<String, Map<String, Object>> targetColumnMap = new HashMap<>();
            for (Map<String, Object> column : targetColumns) {
                targetColumnMap.put((String) column.get("name"), column);
            }
            
            // Check for missing columns
            for (String sourceColumnName : sourceColumnMap.keySet()) {
                if (!targetColumnMap.containsKey(sourceColumnName)) {
                    columnDifferences.add("Table '" + table + "' missing column '" + sourceColumnName + "' in target");
                } else {
                    // Compare column details
                    Map<String, Object> sourceColumn = sourceColumnMap.get(sourceColumnName);
                    Map<String, Object> targetColumn = targetColumnMap.get(sourceColumnName);
                    
                    if (!sourceColumn.get("type").equals(targetColumn.get("type"))) {
                        columnDifferences.add("Table '" + table + "' column '" + sourceColumnName + 
                                           "' has different type: source=" + sourceColumn.get("type") + 
                                           ", target=" + targetColumn.get("type"));
                    }
                    
                    if (!sourceColumn.get("size").equals(targetColumn.get("size"))) {
                        columnDifferences.add("Table '" + table + "' column '" + sourceColumnName + 
                                           "' has different size: source=" + sourceColumn.get("size") + 
                                           ", target=" + targetColumn.get("size"));
                    }
                    
                    if (!sourceColumn.get("nullable").equals(targetColumn.get("nullable"))) {
                        columnDifferences.add("Table '" + table + "' column '" + sourceColumnName + 
                                           "' has different nullable setting: source=" + sourceColumn.get("nullable") + 
                                           ", target=" + targetColumn.get("nullable"));
                    }
                }
            }
            
            // Check for extra columns
            for (String targetColumnName : targetColumnMap.keySet()) {
                if (!sourceColumnMap.containsKey(targetColumnName)) {
                    columnDifferences.add("Table '" + table + "' has extra column '" + targetColumnName + "' in target");
                }
            }
        }
        
        if (!columnDifferences.isEmpty()) {
            differences.put("columnDifferences", columnDifferences);
        }
        
        return differences;
    }
}


package com.cssmart.ai;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.openqa.selenium.By;
import org.openqa.selenium.Dimension;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.interactions.Actions;
import org.testng.ITestContext;
import org.testng.ITestResult;

import com.cssmart.browser.CSSmartBrowserManager;
import com.cssmart.reporting.CSSmartReporter;
import com.cssmart.utils.CSSmartLogger;

/**
 * AI-assisted testing capabilities for CSSmart framework without external libraries.
 * Uses simple machine learning techniques and heuristics to enhance automated testing.
 */
public class CSSmartAITesting {
    
    private static final CSSmartLogger logger = CSSmartLogger.getLogger(CSSmartAITesting.class);
    private static CSSmartAITesting instance;
    
    // Maps to store element learning data
    private final Map<String, ElementLearningData> elementLearningMap = new ConcurrentHashMap<>();
    
    // Maps to store page learning data
    private final Map<String, PageLearningData> pageLearningMap = new ConcurrentHashMap<>();
    
    // Maps to store test execution data
    private final Map<String, TestExecutionData> testExecutionMap = new ConcurrentHashMap<>();
    
    // Maps to store test data patterns
    private final Map<String, List<String>> testDataPatterns = new ConcurrentHashMap<>();
    
    // Cache for element locators
    private final Map<String, By> locatorCache = new ConcurrentHashMap<>();
    
    // Random for generating test data
    private final Random random = new Random();
    
    // Test data generators
    private final Map<String, Function<Integer, String>> dataGenerators = new HashMap<>();
    
    // Coefficients for smart waiting algorithm
    private double waitAlphaPrediction = 0.7;
    private double waitBetaCorrection = 0.3;
    
    // Flag to enable/disable self-healing
    private boolean selfHealingEnabled = true;
    
    // Threshold for similarity in self-healing (0.0 to 1.0)
    private double selfHealingThreshold = 0.8;
    
    // Learning data directory
    private String learningDataDirectory = "cssmart-ai-data";
    
    /**
     * Private constructor for singleton pattern
     */
    private CSSmartAITesting() {
        initializeDataGenerators();
        createLearningDataDirectory();
        loadLearningData();
    }
    
    /**
     * Get singleton instance
     * 
     * @return CSSmartAITesting instance
     */
    public static synchronized CSSmartAITesting getInstance() {
        if (instance == null) {
            instance = new CSSmartAITesting();
        }
        return instance;
    }
    
    /**
     * Configure AI testing
     * 
     * @param learningDataDir Learning data directory
     * @param enableSelfHealing Enable self-healing
     * @param selfHealingThreshold Self-healing threshold
     */
    public void configure(String learningDataDir, boolean enableSelfHealing, double selfHealingThreshold) {
        this.learningDataDirectory = learningDataDir;
        this.selfHealingEnabled = enableSelfHealing;
        this.selfHealingThreshold = selfHealingThreshold;
        
        createLearningDataDirectory();
        loadLearningData();
        
        logger.info("Configured AI testing with learning data directory: " + learningDataDir + 
                  ", self-healing: " + enableSelfHealing + 
                  ", threshold: " + selfHealingThreshold);
    }
    
    /**
     * Initialize data generators
     */
    private void initializeDataGenerators() {
        // Email generator
        dataGenerators.put("email", length -> {
            String username = generateRandomString(Math.max(4, length - 10));
            String domain = generateRandomString(5);
            return username + "@" + domain + ".com";
        });
        
        // Phone number generator
        dataGenerators.put("phone", length -> {
            StringBuilder phone = new StringBuilder();
            phone.append("+1");
            for (int i = 0; i < 10; i++) {
                phone.append(random.nextInt(10));
            }
            return phone.toString();
        });
        
        // Name generator
        dataGenerators.put("name", length -> {
            String[] firstNames = {
                "James", "Mary", "John", "Patricia", "Robert", "Jennifer", "Michael", "Linda", 
                "William", "Elizabeth", "David", "Barbara", "Richard", "Susan", "Joseph", "Jessica"
            };
            
            String[] lastNames = {
                "Smith", "Johnson", "Williams", "Jones", "Brown", "Davis", "Miller", "Wilson",
                "Moore", "Taylor", "Anderson", "Thomas", "Jackson", "White", "Harris", "Martin"
            };
            
            return firstNames[random.nextInt(firstNames.length)] + " " + 
                   lastNames[random.nextInt(lastNames.length)];
        });
        
        // Address generator
        dataGenerators.put("address", length -> {
            String[] streets = {
                "Main St", "Oak Ave", "Maple Dr", "Washington Blvd", "Park Rd", "Lake View"
            };
            
            String[] cities = {
                "New York", "Los Angeles", "Chicago", "Houston", "Phoenix", "Philadelphia"
            };
            
            String[] states = {
                "NY", "CA", "IL", "TX", "AZ", "PA", "FL", "OH", "GA", "NC"
            };
            
            return (100 + random.nextInt(9900)) + " " + 
                   streets[random.nextInt(streets.length)] + ", " +
                   cities[random.nextInt(cities.length)] + ", " +
                   states[random.nextInt(states.length)] + " " +
                   (10000 + random.nextInt(90000));
        });
        
        // Credit card generator (fake numbers that pass Luhn algorithm)
        dataGenerators.put("creditcard", length -> {
            String[] prefixes = {"4", "51", "36", "37"};  // Visa, Mastercard, Diners Club, Amex
            String prefix = prefixes[random.nextInt(prefixes.length)];
            
            StringBuilder number = new StringBuilder(prefix);
            int digitsToAdd = 16 - prefix.length();
            
            for (int i = 0; i < digitsToAdd - 1; i++) {
                number.append(random.nextInt(10));
            }
            
            // Apply Luhn algorithm to generate valid check digit
            int sum = 0;
            boolean alternate = false;
            
            for (int i = number.length() - 1; i >= 0; i--) {
                int digit = Integer.parseInt(number.substring(i, i + 1));
                
                if (alternate) {
                    digit *= 2;
                    if (digit > 9) {
                        digit -= 9;
                    }
                }
                
                sum += digit;
                alternate = !alternate;
            }
            
            int checkDigit = (10 - (sum % 10)) % 10;
            number.append(checkDigit);
            
            return number.toString();
        });
        
        // SSN generator (random format)
        dataGenerators.put("ssn", length -> {
            StringBuilder ssn = new StringBuilder();
            for (int i = 0; i < 9; i++) {
                if (i == 3 || i == 5) {
                    ssn.append("-");
                }
                ssn.append(random.nextInt(10));
            }
            return ssn.toString();
        });
        
        // Date generator
        dataGenerators.put("date", length -> {
            SimpleDateFormat format = new SimpleDateFormat("MM/dd/yyyy");
            Date date = new Date();
            date.setTime(date.getTime() - random.nextInt(365 * 5) * 24 * 60 * 60 * 1000L);
            return format.format(date);
        });
        
        // Username generator
        dataGenerators.put("username", length -> {
            String[] prefixes = {"user", "admin", "test", "dev", "qa"};
            return prefixes[random.nextInt(prefixes.length)] + random.nextInt(1000);
        });
        
        // Password generator
        dataGenerators.put("password", length -> {
            int actualLength = Math.max(8, length);
            StringBuilder password = new StringBuilder();
            
            String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";
            
            for (int i = 0; i < actualLength; i++) {
                password.append(chars.charAt(random.nextInt(chars.length())));
            }
            
            return password.toString();
        });
    }
    
    /**
     * Create learning data directory
     */
    private void createLearningDataDirectory() {
        try {
            Path dirPath = Paths.get(learningDataDirectory);
            if (!Files.exists(dirPath)) {
                Files.createDirectories(dirPath);
                logger.info("Created learning data directory: " + dirPath.toAbsolutePath());
            }
        } catch (IOException e) {
            logger.error("Failed to create learning data directory: " + learningDataDirectory, e);
        }
    }
    
    /**
     * Load learning data from files
     */
    private void loadLearningData() {
        try {
            // Load element learning data
            Path elementDataFile = Paths.get(learningDataDirectory, "element-learning.csv");
            if (Files.exists(elementDataFile)) {
                try (BufferedReader reader = new BufferedReader(new FileReader(elementDataFile.toFile()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        String[] parts = line.split(",");
                        if (parts.length >= 4) {
                            String elementKey = parts[0];
                            long totalInteractions = Long.parseLong(parts[1]);
                            long successfulInteractions = Long.parseLong(parts[2]);
                            long avgTimeMs = Long.parseLong(parts[3]);
                            
                            ElementLearningData data = new ElementLearningData(elementKey);
                            data.totalInteractions = totalInteractions;
                            data.successfulInteractions = successfulInteractions;
                            data.avgInteractionTimeMs = avgTimeMs;
                            
                            elementLearningMap.put(elementKey, data);
                        }
                    }
                }
                logger.info("Loaded element learning data: " + elementLearningMap.size() + " elements");
            }
            
            // Load page learning data
            Path pageDataFile = Paths.get(learningDataDirectory, "page-learning.csv");
            if (Files.exists(pageDataFile)) {
                try (BufferedReader reader = new BufferedReader(new FileReader(pageDataFile.toFile()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        String[] parts = line.split(",");
                        if (parts.length >= 4) {
                            String pageUrl = parts[0];
                            long avgLoadTimeMs = Long.parseLong(parts[1]);
                            long visitCount = Long.parseLong(parts[2]);
                            long lastVisitTime = Long.parseLong(parts[3]);
                            
                            PageLearningData data = new PageLearningData(pageUrl);
                            data.avgLoadTimeMs = avgLoadTimeMs;
                            data.visitCount = visitCount;
                            data.lastVisitTime = lastVisitTime;
                            
                            pageLearningMap.put(pageUrl, data);
                        }
                    }
                }
                logger.info("Loaded page learning data: " + pageLearningMap.size() + " pages");
            }
            
            // Load test execution data
            Path testDataFile = Paths.get(learningDataDirectory, "test-execution.csv");
            if (Files.exists(testDataFile)) {
                try (BufferedReader reader = new BufferedReader(new FileReader(testDataFile.toFile()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        String[] parts = line.split(",");
                        if (parts.length >= 5) {
                            String testName = parts[0];
                            long avgExecutionTimeMs = Long.parseLong(parts[1]);
                            long executionCount = Long.parseLong(parts[2]);
                            double successRate = Double.parseDouble(parts[3]);
                            long lastExecutionTime = Long.parseLong(parts[4]);
                            
                            TestExecutionData data = new TestExecutionData(testName);
                            data.avgExecutionTimeMs = avgExecutionTimeMs;
                            data.executionCount = executionCount;
                            data.successRate = successRate;
                            data.lastExecutionTime = lastExecutionTime;
                            
                            testExecutionMap.put(testName, data);
                        }
                    }
                }
                logger.info("Loaded test execution data: " + testExecutionMap.size() + " tests");
            }
            
            // Load test data patterns
            Path patternsDataFile = Paths.get(learningDataDirectory, "data-patterns.csv");
            if (Files.exists(patternsDataFile)) {
                try (BufferedReader reader = new BufferedReader(new FileReader(patternsDataFile.toFile()))) {
                    String line;
                    while ((line = reader.readLine()) != null) {
                        String[] parts = line.split(",", 2);
                        if (parts.length >= 2) {
                            String fieldName = parts[0];
                            String patterns = parts[1];
                            
                            List<String> patternList = Arrays.asList(patterns.split(";"));
                            testDataPatterns.put(fieldName, patternList);
                        }
                    }
                }
                logger.info("Loaded test data patterns: " + testDataPatterns.size() + " field patterns");
            }
            
        } catch (IOException | NumberFormatException e) {
            logger.error("Failed to load learning data", e);
        }
    }
    
    /**
     * Save learning data to files
     */
    public void saveLearningData() {
        try {
            // Save element learning data
            Path elementDataFile = Paths.get(learningDataDirectory, "element-learning.csv");
            StringBuilder elementData = new StringBuilder();
            
            for (Map.Entry<String, ElementLearningData> entry : elementLearningMap.entrySet()) {
                ElementLearningData data = entry.getValue();
                elementData.append(entry.getKey()).append(",")
                          .append(data.totalInteractions).append(",")
                          .append(data.successfulInteractions).append(",")
                          .append(data.avgInteractionTimeMs).append("\n");
            }
            
            Files.write(elementDataFile, elementData.toString().getBytes());
            
            // Save page learning data
            Path pageDataFile = Paths.get(learningDataDirectory, "page-learning.csv");
            StringBuilder pageData = new StringBuilder();
            
            for (Map.Entry<String, PageLearningData> entry : pageLearningMap.entrySet()) {
                PageLearningData data = entry.getValue();
                pageData.append(entry.getKey()).append(",")
                       .append(data.avgLoadTimeMs).append(",")
                       .append(data.visitCount).append(",")
                       .append(data.lastVisitTime).append("\n");
            }
            
            Files.write(pageDataFile, pageData.toString().getBytes());
            
            // Save test execution data
            Path testDataFile = Paths.get(learningDataDirectory, "test-execution.csv");
            StringBuilder testData = new StringBuilder();
            
            for (Map.Entry<String, TestExecutionData> entry : testExecutionMap.entrySet()) {
                TestExecutionData data = entry.getValue();
                testData.append(entry.getKey()).append(",")
                       .append(data.avgExecutionTimeMs).append(",")
                       .append(data.executionCount).append(",")
                       .append(data.successRate).append(",")
                       .append(data.lastExecutionTime).append("\n");
            }
            
            Files.write(testDataFile, testData.toString().getBytes());
            
            // Save test data patterns
            Path patternsDataFile = Paths.get(learningDataDirectory, "data-patterns.csv");
            StringBuilder patternsData = new StringBuilder();
            
            for (Map.Entry<String, List<String>> entry : testDataPatterns.entrySet()) {
                String fieldName = entry.getKey();
                List<String> patterns = entry.getValue();
                
                patternsData.append(fieldName).append(",")
                          .append(String.join(";", patterns)).append("\n");
            }
            
            Files.write(patternsDataFile, patternsData.toString().getBytes());
            
            logger.info("Saved learning data successfully");
            
        } catch (IOException e) {
            logger.error("Failed to save learning data", e);
        }
    }
    
    /**
     * Record page visit data
     * 
     * @param driver WebDriver
     * @param loadTimeMs Page load time in milliseconds
     */
    public void recordPageVisit(WebDriver driver, long loadTimeMs) {
        if (driver == null) {
            return;
        }
        
        try {
            String url = driver.getCurrentUrl();
            if (url == null || url.isEmpty()) {
                return;
            }
            
            // Normalize URL by removing query parameters
            String normalizedUrl = url.split("\\?")[0];
            
            // Get or create page learning data
            PageLearningData pageData = pageLearningMap.computeIfAbsent(
                normalizedUrl, PageLearningData::new);
            
            // Update page learning data
            synchronized (pageData) {
                pageData.visitCount++;
                pageData.lastVisitTime = System.currentTimeMillis();
                
                // Recalculate average load time
                pageData.avgLoadTimeMs = ((pageData.avgLoadTimeMs * (pageData.visitCount - 1)) + loadTimeMs) / pageData.visitCount;
            }
            
            // Analyze page structure and record common elements
            analyzePageStructure(driver, normalizedUrl);
            
        } catch (Exception e) {
            logger.error("Failed to record page visit", e);
        }
    }
    
    /**
     * Analyze page structure and record common elements
     * 
     * @param driver WebDriver
     * @param pageUrl Normalized page URL
     */
    private void analyzePageStructure(WebDriver driver, String pageUrl) {
        try {
            List<WebElement> interactiveElements = new ArrayList<>();
            
            // Find common interactive elements
            interactiveElements.addAll(driver.findElements(By.tagName("button")));
            interactiveElements.addAll(driver.findElements(By.tagName("a")));
            interactiveElements.addAll(driver.findElements(By.tagName("input")));
            interactiveElements.addAll(driver.findElements(By.tagName("select")));
            
            // Create fingerprints for elements
            for (WebElement element : interactiveElements) {
                try {
                    String elementKey = createElementFingerprint(element, pageUrl);
                    
                    if (elementKey != null && !elementKey.isEmpty()) {
                        // Add to element learning data if not exists
                        elementLearningMap.putIfAbsent(elementKey, new ElementLearningData(elementKey));
                    }
                } catch (Exception e) {
                    // Skip this element
                }
            }
            
            // Analyze form fields to learn data patterns
            analyzeFormFields(driver);
            
        } catch (Exception e) {
            logger.error("Failed to analyze page structure", e);
        }
    }
    
    /**
     * Analyze form fields to learn data patterns
     * 
     * @param driver WebDriver
     */
    private void analyzeFormFields(WebDriver driver) {
        try {
            List<WebElement> formFields = driver.findElements(By.tagName("input"));
            
            for (WebElement field : formFields) {
                try {
                    String type = field.getAttribute("type");
                    String id = field.getAttribute("id");
                    String name = field.getAttribute("name");
                    String placeholder = field.getAttribute("placeholder");
                    String label = findAssociatedLabel(driver, field);
                    
                    // Skip hidden fields
                    if ("hidden".equals(type)) {
                        continue;
                    }
                    
                    // Determine field purpose from attributes
                    String fieldPurpose = determineFieldPurpose(type, id, name, placeholder, label);
                    
                    if (fieldPurpose != null) {
                        // Get current value if any
                        String value = field.getAttribute("value");
                        
                        if (value != null && !value.isEmpty()) {
                            // Add pattern to learning data
                            addFieldPattern(fieldPurpose, value);
                        }
                    }
                } catch (Exception e) {
                    // Skip this field
                }
            }
        } catch (Exception e) {
            logger.error("Failed to analyze form fields", e);
        }
    }
    
    /**
     * Create fingerprint for element
     * 
     * @param element WebElement
     * @param pageUrl Page URL
     * @return Element fingerprint
     */
    private String createElementFingerprint(WebElement element, String pageUrl) {
        try {
            // Create a unique identifier for the element
            StringBuilder fingerprint = new StringBuilder();
            
            fingerprint.append(pageUrl).append(":");
            
            // Add tag name
            fingerprint.append(element.getTagName());
            
            // Add id if available
            String id = element.getAttribute("id");
            if (id != null && !id.isEmpty()) {
                fingerprint.append("#").append(id);
            }
            
            // Add name if available
            String name = element.getAttribute("name");
            if (name != null && !name.isEmpty()) {
                fingerprint.append("[name=").append(name).append("]");
            }
            
            // Add class if available
            String className = element.getAttribute("class");
            if (className != null && !className.isEmpty()) {
                fingerprint.append(".").append(className.replaceAll("\\s+", "."));
            }
            
            // Add text content for buttons and links
            if ("button".equals(element.getTagName()) || "a".equals(element.getTagName())) {
                String text = element.getText();
                if (text != null && !text.isEmpty()) {
                    fingerprint.append(":\"").append(text).append("\"");
                }
            }
            
            return fingerprint.toString();
        } catch (Exception e) {
            return null;
        }
    }
    
    /**
     * Find associated label for form field
     * 
     * @param driver WebDriver
     * @param field WebElement
     * @return Label text or null if not found
     */
    private String findAssociatedLabel(WebDriver driver, WebElement field) {
        try {
            String id = field.getAttribute("id");
            
            if (id != null && !id.isEmpty()) {
                // Find label with 'for' attribute
                List<WebElement> labels = driver.findElements(By.cssSelector("label[for='" + id + "']"));
                
                if (!labels.isEmpty()) {
                    return labels.get(0).getText();
                }
            }
            
            // Try to find parent label
            WebElement parent = getParent(field);
            
            if (parent != null && "label".equals(parent.getTagName())) {
                return parent.getText();
            }
            
            return null;
        } catch (Exception e) {
            return null;
        }
    }
    
    /**
     * Get parent element
     * 
     * @param element WebElement
     * @return Parent element or null
     */
    private WebElement getParent(WebElement element) {
        try {
            // Use JavaScript to get parent
            JavascriptExecutor js = (JavascriptExecutor) CSSmartBrowserManager.getDriver();
            return (WebElement) js.executeScript("return arguments[0].parentNode;", element);
        } catch (Exception e) {
            return null;
        }
    }
    
    /**
     * Determine field purpose from attributes
     * 
     * @param type Field type
     * @param id Field ID
     * @param name Field name
     * @param placeholder Field placeholder
     * @param label Field label
     * @return Field purpose or null if unknown
     */
    private String determineFieldPurpose(String type, String id, String name, String placeholder, String label) {
        // Check for email fields
        if ("email".equals(type) || containsIgnoreCase(id, "email") || 
            containsIgnoreCase(name, "email") || containsIgnoreCase(placeholder, "email") || 
            containsIgnoreCase(label, "email")) {
            return "email";
        }
        
        // Check for password fields
        if ("password".equals(type) || containsIgnoreCase(id, "password") || 
            containsIgnoreCase(name, "password") || containsIgnoreCase(placeholder, "password") || 
            containsIgnoreCase(label, "password")) {
            return "password";
        }
        
        // Check for phone fields
        if ("tel".equals(type) || containsIgnoreCase(id, "phone") || containsIgnoreCase(id, "mobile") || 
            containsIgnoreCase(name, "phone") || containsIgnoreCase(name, "mobile") || 
            containsIgnoreCase(placeholder, "phone") || containsIgnoreCase(placeholder, "mobile") || 
            containsIgnoreCase(label, "phone") || containsIgnoreCase(label, "mobile")) {
            return "phone";
        }
        
        // Check for name fields
        if (containsIgnoreCase(id, "name") || containsIgnoreCase(name, "name") || 
            containsIgnoreCase(placeholder, "name") || containsIgnoreCase(label, "name")) {
            if (containsIgnoreCase(id, "first") || containsIgnoreCase(name, "first") || 
                containsIgnoreCase(placeholder, "first") || containsIgnoreCase(label, "first")) {
                return "firstname";
            }
            if (containsIgnoreCase(id, "last") || containsIgnoreCase(name, "last") || 
                containsIgnoreCase(placeholder, "last") || containsIgnoreCase(label, "last")) {
                return "lastname";
            }
            return "name";
        }
        
        // Check for address fields
        if (containsIgnoreCase(id, "address") || containsIgnoreCase(name, "address") || 
            containsIgnoreCase(placeholder, "address") || containsIgnoreCase(label, "address")) {
            return "address";
        }
        
        // Check for city fields
        if (containsIgnoreCase(id, "city") || containsIgnoreCase(name, "city") || 
            containsIgnoreCase(placeholder, "city") || containsIgnoreCase(label, "city")) {
            return "city";
        }
        
        // Check for state/province fields
        if (containsIgnoreCase(id, "state") || containsIgnoreCase(id, "province") || 
            containsIgnoreCase(name, "state") || containsIgnoreCase(name, "province") || 
            containsIgnoreCase(placeholder, "state") || containsIgnoreCase(placeholder, "province") || 
            containsIgnoreCase(label, "state") || containsIgnoreCase(label, "province")) {
            return "state";
        }
        
        // Check for zip/postal code fields
        if (containsIgnoreCase(id, "zip") || containsIgnoreCase(id, "postal") || 
            containsIgnoreCase(name, "zip") || containsIgnoreCase(name, "postal") || 
            containsIgnoreCase(placeholder, "zip") || containsIgnoreCase(placeholder, "postal") || 
            containsIgnoreCase(label, "zip") || containsIgnoreCase(label, "postal")) {
            return "zipcode";
        }
        
        // Check for credit card fields
        if (containsIgnoreCase(id, "credit") || containsIgnoreCase(id, "card") || 
            containsIgnoreCase(name, "credit") || containsIgnoreCase(name, "card") || 
            containsIgnoreCase(placeholder, "credit") || containsIgnoreCase(placeholder, "card") || 
            containsIgnoreCase(label, "credit") || containsIgnoreCase(label, "card")) {
            return "creditcard";
        }
        
        // Check for date fields
        if ("date".equals(type) || containsIgnoreCase(id, "date") || 
            containsIgnoreCase(name, "date") || containsIgnoreCase(placeholder, "date") || 
            containsIgnoreCase(label, "date")) {
            return "date";
        }
        
        // Check for search fields
        if ("search".equals(type) || containsIgnoreCase(id, "search") || 
            containsIgnoreCase(name, "search") || containsIgnoreCase(placeholder, "search") || 
            containsIgnoreCase(label, "search")) {
            return "search";
        }
        
        // Check for username fields
        if (containsIgnoreCase(id, "username") || containsIgnoreCase(id, "user") || 
            containsIgnoreCase(name, "username") || containsIgnoreCase(name, "user") || 
            containsIgnoreCase(placeholder, "username") || containsIgnoreCase(placeholder, "user") || 
            containsIgnoreCase(label, "username") || containsIgnoreCase(label, "user")) {
            return "username";
        }
        
        return null;
    }
    
    /**
     * Add field pattern to learning data
     * 
     * @param fieldPurpose Field purpose
     * @param value Field value
     */
    private void addFieldPattern(String fieldPurpose, String value) {
        List<String> patterns = testDataPatterns.computeIfAbsent(
            fieldPurpose, k -> new ArrayList<>());
        
        // Add new pattern if not already exists
        if (!patterns.contains(value) && patterns.size() < 50) {  // Limit to 50 patterns per field
            patterns.add(value);
        }
    }
    
    /**
     * Record element interaction
     * 
     * @param element WebElement
     * @param pageUrl Page URL
     * @param successful Whether interaction was successful
     * @param timeMs Interaction time in milliseconds
     */
    public void recordElementInteraction(WebElement element, String pageUrl, boolean successful, long timeMs) {
        try {
            String elementKey = createElementFingerprint(element, pageUrl);
            
            if (elementKey != null && !elementKey.isEmpty()) {
                ElementLearningData data = elementLearningMap.computeIfAbsent(
                    elementKey, ElementLearningData::new);
                
                synchronized (data) {
                    data.totalInteractions++;
                    
                    if (successful) {
                        data.successfulInteractions++;
                    }
                    
                    // Recalculate average interaction time
                    data.avgInteractionTimeMs = ((data.avgInteractionTimeMs * (data.totalInteractions - 1)) + timeMs) / data.totalInteractions;
                }
            }
        } catch (Exception e) {
            logger.error("Failed to record element interaction", e);
        }
    }
    
    /**
     * Record test execution
     * 
     * @param testContext TestNG test context
     * @param result TestNG test result
     * @param executionTimeMs Execution time in milliseconds
     */
    public void recordTestExecution(ITestContext testContext, ITestResult result, long executionTimeMs) {
        try {
            String testName = result.getTestClass().getName() + "." + result.getName();
            boolean successful = result.getStatus() == ITestResult.SUCCESS;
            
            TestExecutionData data = testExecutionMap.computeIfAbsent(
                testName, TestExecutionData::new);
            
            synchronized (data) {
                data.executionCount++;
                data.lastExecutionTime = System.currentTimeMillis();
                
                // Recalculate average execution time
                data.avgExecutionTimeMs = ((data.avgExecutionTimeMs * (data.executionCount - 1)) + executionTimeMs) / data.executionCount;
                
                // Recalculate success rate
                double successCount = data.successRate * (data.executionCount - 1);
                if (successful) {
                    successCount++;
                }
                data.successRate = successCount / data.executionCount;
            }
            
            // Save learning data
            saveLearningData();
        } catch (Exception e) {
            logger.error("Failed to record test execution", e);
        }
    }
    
    /**
     * Generate smart wait time for element
     * 
     * @param element WebElement
     * @param pageUrl Page URL
     * @return Recommended wait time in milliseconds
     */
    public long getSmartWaitTime(WebElement element, String pageUrl) {
        try {
            String elementKey = createElementFingerprint(element, pageUrl);
            
            if (elementKey != null && !elementKey.isEmpty()) {
                ElementLearningData data = elementLearningMap.get(elementKey);
                
                if (data != null && data.totalInteractions > 0) {
                    // Use learned interaction time with a safety margin
                    return (long) (data.avgInteractionTimeMs * 1.5);
                }
            }
            
            // Use page load time if available
            PageLearningData pageData = pageLearningMap.get(pageUrl);
            
            if (pageData != null && pageData.visitCount > 0) {
                // Use a fraction of page load time
                return (long) (pageData.avgLoadTimeMs * 0.3);
            }
        } catch (Exception e) {
            logger.error("Error calculating smart wait time", e);
        }
        
        // Default wait time
        return 10000;
    }
    
    /**
     * Generate smart test data for a field
     * 
     * @param field WebElement
     * @param driver WebDriver
     * @return Generated test data
     */
    public String generateSmartTestData(WebElement field, WebDriver driver) {
        try {
            String type = field.getAttribute("type");
            String id = field.getAttribute("id");
            String name = field.getAttribute("name");
            String placeholder = field.getAttribute("placeholder");
            String label = findAssociatedLabel(driver, field);
            
            // Determine field purpose
            String fieldPurpose = determineFieldPurpose(type, id, name, placeholder, label);
            
            if (fieldPurpose != null) {
                // Use learned patterns if available
                List<String> patterns = testDataPatterns.get(fieldPurpose);
                
                if (patterns != null && !patterns.isEmpty()) {
                    // Return a random pattern
                    return patterns.get(random.nextInt(patterns.size()));
                }
                
                // Use generator if available
                Function<Integer, String> generator = dataGenerators.get(fieldPurpose);
                
                if (generator != null) {
                    // Generate random data
                    return generator.apply(10);
                }
            }
            
            // Handle specific input types
            if ("text".equals(type)) {
                return generateRandomString(10);
            } else if ("email".equals(type)) {
                return dataGenerators.get("email").apply(10);
            } else if ("tel".equals(type)) {
                return dataGenerators.get("phone").apply(10);
            } else if ("number".equals(type)) {
                return String.valueOf(random.nextInt(1000));
            } else if ("date".equals(type)) {
                return dataGenerators.get("date").apply(10);
            } else if ("password".equals(type)) {
                return dataGenerators.get("password").apply(10);
            }
            
            // Default to random string
            return generateRandomString(10);
        } catch (Exception e) {
            logger.error("Failed to generate smart test data", e);
            return generateRandomString(10);
        }
    }
    
    /**
     * Find element using self-healing locators
     * 
     * @param originalLocator Original locator
     * @param driver WebDriver
     * @return WebElement or null if not found
     */
    public WebElement findElementWithHealing(By originalLocator, WebDriver driver) {
        if (!selfHealingEnabled || driver == null) {
            // Use regular findElement if self-healing is disabled
            try {
                return driver.findElement(originalLocator);
            } catch (Exception e) {
                return null;
            }
        }
        
        try {
            // Try original locator first
            try {
                WebElement element = driver.findElement(originalLocator);
                return element;
            } catch (Exception e) {
                // Continue with self-healing
            }
            
            // Extract information from original locator
            String locatorString = originalLocator.toString();
            String locatorType = locatorString.substring(3, locatorString.indexOf(":")).trim().toLowerCase();
            String locatorValue = locatorString.substring(locatorString.indexOf(":") + 1).trim();
            
            // Try to heal the locator
            List<By> healedLocators = new ArrayList<>();
            
            if ("id".equals(locatorType)) {
                // Try similar IDs
                healedLocators.add(By.cssSelector("[id*='" + locatorValue + "']"));
                healedLocators.add(By.cssSelector("[data-id*='" + locatorValue + "']"));
            } else if ("name".equals(locatorType)) {
                // Try similar names
                healedLocators.add(By.cssSelector("[name*='" + locatorValue + "']"));
                healedLocators.add(By.cssSelector("[data-name*='" + locatorValue + "']"));
            } else if ("linktext".equals(locatorType)) {
                // Try partial link text
                healedLocators.add(By.partialLinkText(locatorValue));
                
                // Try link with similar text
                String[] words = locatorValue.split("\\s+");
                if (words.length > 1) {
                    for (String word : words) {
                        if (word.length() > 3) {  // Only consider significant words
                            healedLocators.add(By.partialLinkText(word));
                        }
                    }
                }
            } else if ("css".equals(locatorType) || "cssselector".equals(locatorType)) {
                // Try simplified CSS selectors
                if (locatorValue.contains("#")) {
                    // Extract ID from CSS
                    String idPart = locatorValue.substring(locatorValue.indexOf("#") + 1);
                    if (idPart.contains(" ") || idPart.contains("[") || idPart.contains(".")) {
                        idPart = idPart.split("[ \\.\\[]")[0];
                    }
                    healedLocators.add(By.cssSelector("[id*='" + idPart + "']"));
                }
                
                if (locatorValue.contains(".")) {
                    // Extract class from CSS
                    String classPart = locatorValue.substring(locatorValue.indexOf(".") + 1);
                    if (classPart.contains(" ") || classPart.contains("[") || classPart.contains("#")) {
                        classPart = classPart.split("[ #\\[]")[0];
                    }
                    healedLocators.add(By.cssSelector("[class*='" + classPart + "']"));
                }
            } else if ("xpath".equals(locatorType)) {
                // Try simplified XPath expressions
                if (locatorValue.contains("@id")) {
                    // Extract ID from XPath
                    Pattern pattern = Pattern.compile("@id=['\"](.*?)['\"]");
                    Matcher matcher = pattern.matcher(locatorValue);
                    if (matcher.find()) {
                        String idPart = matcher.group(1);
                        healedLocators.add(By.cssSelector("[id*='" + idPart + "']"));
                    }
                }
                
                if (locatorValue.contains("@class")) {
                    // Extract class from XPath
                    Pattern pattern = Pattern.compile("@class=['\"](.*?)['\"]");
                    Matcher matcher = pattern.matcher(locatorValue);
                    if (matcher.find()) {
                        String classPart = matcher.group(1);
                        healedLocators.add(By.cssSelector("[class*='" + classPart + "']"));
                    }
                }
                
                if (locatorValue.contains("text()")) {
                    // Extract text from XPath
                    Pattern pattern = Pattern.compile("text\\(\\)\\s*=\\s*['\"](.*?)['\"]");
                    Matcher matcher = pattern.matcher(locatorValue);
                    if (matcher.find()) {
                        String textPart = matcher.group(1);
                        healedLocators.add(By.xpath("//*[contains(text(), '" + textPart + "')]"));
                    }
                }
            }
            
            // Add generic locators by tag (last resort)
            if (locatorValue.toLowerCase().contains("button")) {
                healedLocators.add(By.tagName("button"));
            } else if (locatorValue.toLowerCase().contains("input")) {
                healedLocators.add(By.tagName("input"));
            } else if (locatorValue.toLowerCase().contains("link") || locatorValue.toLowerCase().contains("anchor")) {
                healedLocators.add(By.tagName("a"));
            }
            
            // Try each healed locator
            for (By healedLocator : healedLocators) {
                try {
                    List<WebElement> elements = driver.findElements(healedLocator);
                    
                    if (!elements.isEmpty()) {
                        // If multiple elements found, try to select the best match
                        if (elements.size() > 1) {
                            WebElement bestMatch = findBestMatch(elements, originalLocator);
                            if (bestMatch != null) {
                                logger.info("Self-healing found element using: " + healedLocator);
                                return bestMatch;
                            }
                        } else {
                            logger.info("Self-healing found element using: " + healedLocator);
                            return elements.get(0);
                        }
                    }
                } catch (Exception e) {
                    // Continue with next locator
                }
            }
            
            // Fall back to original implementation
            logger.warn("Self-healing failed for locator: " + originalLocator);
            return null;
        } catch (Exception e) {
            logger.error("Error in self-healing locator", e);
            
            // Fall back to original implementation
            try {
                return driver.findElement(originalLocator);
            } catch (Exception ex) {
                return null;
            }
        }
    }
    
    /**
     * Find best matching element from a list
     * 
     * @param elements List of WebElements
     * @param originalLocator Original locator
     * @return Best matching element or null
     */
    private WebElement findBestMatch(List<WebElement> elements, By originalLocator) {
        try {
            String locatorString = originalLocator.toString();
            String locatorValue = locatorString.substring(locatorString.indexOf(":") + 1).trim();
            
            WebElement bestMatch = null;
            double bestScore = 0;
            
            for (WebElement element : elements) {
                double score = calculateSimilarityScore(element, locatorValue);
                
                if (score > bestScore && score >= selfHealingThreshold) {
                    bestScore = score;
                    bestMatch = element;
                }
            }
            
            return bestMatch;
        } catch (Exception e) {
            logger.error("Error finding best match", e);
            return elements.get(0);  // Return first element as fallback
        }
    }
    
    /**
     * Calculate similarity score between element and locator
     * 
     * @param element WebElement
     * @param locatorValue Locator value
     * @return Similarity score (0.0 to 1.0)
     */
    private double calculateSimilarityScore(WebElement element, String locatorValue) {
        try {
            // Extract element attributes
            String id = element.getAttribute("id");
            String name = element.getAttribute("name");
            String className = element.getAttribute("class");
            String text = element.getText();
            String tag = element.getTagName();
            
            // Check direct matches
            if (id != null && id.equals(locatorValue)) {
                return 1.0;
            }
            
            if (name != null && name.equals(locatorValue)) {
                return 1.0;
            }
            
            if (text != null && text.equals(locatorValue)) {
                return 1.0;
            }
            
            // Calculate partial matches
            double score = 0.0;
            
            if (id != null && !id.isEmpty()) {
                score = Math.max(score, calculateStringSimilarity(id, locatorValue));
            }
            
            if (name != null && !name.isEmpty()) {
                score = Math.max(score, calculateStringSimilarity(name, locatorValue));
            }
            
            if (className != null && !className.isEmpty()) {
                score = Math.max(score, calculateStringSimilarity(className, locatorValue));
            }
            
            if (text != null && !text.isEmpty()) {
                score = Math.max(score, calculateStringSimilarity(text, locatorValue));
            }
            
            // Add bonus for visible elements
            if (element.isDisplayed()) {
                score += 0.1;
                if (score > 1.0) {
                    score = 1.0;
                }
            }
            
            return score;
        } catch (Exception e) {
            return 0.0;
        }
    }
    
    /**
     * Calculate string similarity using Levenshtein distance
     * 
     * @param str1 First string
     * @param str2 Second string
     * @return Similarity score (0.0 to 1.0)
     */
    private double calculateStringSimilarity(String str1, String str2) {
        // Convert to lowercase
        String s1 = str1.toLowerCase();
        String s2 = str2.toLowerCase();
        
        // Check if one contains the other
        if (s1.contains(s2) || s2.contains(s1)) {
            return 0.8;
        }
        
        // Calculate Levenshtein distance
        int[][] distance = new int[s1.length() + 1][s2.length() + 1];
        
        for (int i = 0; i <= s1.length(); i++) {
            distance[i][0] = i;
        }
        
        for (int j = 0; j <= s2.length(); j++) {
            distance[0][j] = j;
        }
        
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                int cost = (s1.charAt(i - 1) == s2.charAt(j - 1)) ? 0 : 1;
                distance[i][j] = Math.min(
                    Math.min(distance[i - 1][j] + 1, distance[i][j - 1] + 1),
                    distance[i - 1][j - 1] + cost
                );
            }
        }
        
        int maxLength = Math.max(s1.length(), s2.length());
        if (maxLength == 0) {
            return 1.0;
        }
        
        return 1.0 - ((double) distance[s1.length()][s2.length()] / maxLength);
    }
    
    /**
     * Generate test execution sequence recommendation
     * 
     * @param testNames List of test names
     * @return Recommended execution order
     */
    public List<String> recommendTestExecutionOrder(List<String> testNames) {
        // Create a map of test name to execution data
        Map<String, TestExecutionData> dataMap = new HashMap<>();
        
        for (String testName : testNames) {
            TestExecutionData data = testExecutionMap.get(testName);
            
            if (data != null) {
                dataMap.put(testName, data);
            }
        }
        
        // Sort tests based on various factors:
        // 1. Failed tests run first (higher priority)
        // 2. Tests that haven't run recently
        // 3. Tests with shorter execution time
        return testNames.stream()
            .sorted((t1, t2) -> {
                TestExecutionData d1 = dataMap.get(t1);
                TestExecutionData d2 = dataMap.get(t2);
                
                // If no data, put at the end
                if (d1 == null && d2 == null) return 0;
                if (d1 == null) return 1;
                if (d2 == null) return -1;
                
                // Failed tests first
                if (d1.successRate < 1.0 && d2.successRate >= 1.0) return -1;
                if (d1.successRate >= 1.0 && d2.successRate < 1.0) return 1;
                
                // Tests not run recently
                long timeDiff = d1.lastExecutionTime - d2.lastExecutionTime;
                if (Math.abs(timeDiff) > 3600000) {  // 1 hour difference
                    return timeDiff > 0 ? 1 : -1;
                }
                
                // Shorter tests first
                return Long.compare(d1.avgExecutionTimeMs, d2.avgExecutionTimeMs);
            })
            .collect(Collectors.toList());
    }
    
    /**
     * Take intelligent screenshot based on AI analysis
     * 
     * @param driver WebDriver
     * @param testName Test name
     * @return Path to screenshot file or null if failed
     */
    public String takeIntelligentScreenshot(WebDriver driver, String testName) {
        try {
            if (driver == null) {
                return null;
            }
            
            // Analyze page to find important elements
            Set<WebElement> importantElements = findImportantElements(driver);
            
            // Take full page screenshot as base
            TakesScreenshot screenshotDriver = (TakesScreenshot) driver;
            byte[] screenshot = screenshotDriver.getScreenshotAs(OutputType.BYTES);
            
            // Create unique screenshot name
            String screenshotName = "AI_" + testName.replaceAll("[^a-zA-Z0-9]", "_") + 
                                  "_" + System.currentTimeMillis() + ".png";
            
            // Highlight important elements if any found
            if (!importantElements.isEmpty()) {
                // Highlight elements using JavaScript
                JavascriptExecutor js = (JavascriptExecutor) driver;
                
                // Store original styles
                Map<WebElement, String> originalStyles = new HashMap<>();
                
                for (WebElement element : importantElements) {
                    try {
                        String originalStyle = element.getAttribute("style");
                        originalStyles.put(element, originalStyle != null ? originalStyle : "");
                        
                        // Add highlight
                        js.executeScript(
                            "arguments[0].setAttribute('style', arguments[1] + '; border: 2px solid red; background-color: yellow; z-index: 9999;');", 
                            element, originalStyles.get(element));
                    } catch (Exception e) {
                        // Skip this element
                    }
                }
                
                // Take screenshot with highlights
                screenshot = screenshotDriver.getScreenshotAs(OutputType.BYTES);
                
                // Restore original styles
                for (Map.Entry<WebElement, String> entry : originalStyles.entrySet()) {
                    try {
                        js.executeScript(
                            "arguments[0].setAttribute('style', arguments[1]);", 
                            entry.getKey(), entry.getValue());
                    } catch (Exception e) {
                        // Skip this element
                    }
                }
            }
            
            // Save screenshot using reporter
            return CSSmartReporter.getInstance().addScreenshot(screenshot, testName);
        } catch (Exception e) {
            logger.error("Failed to take intelligent screenshot", e);
            
            // Fall back to regular screenshot
            try {
                TakesScreenshot screenshotDriver = (TakesScreenshot) driver;
                byte[] screenshot = screenshotDriver.getScreenshotAs(OutputType.BYTES);
                
                String screenshotName = testName.replaceAll("[^a-zA-Z0-9]", "_") + 
                                      "_" + System.currentTimeMillis() + ".png";
                
                return CSSmartReporter.getInstance().addScreenshot(screenshot, testName);
            } catch (Exception ex) {
                return null;
            }
        }
    }
    
    /**
     * Find important elements in the page
     * 
     * @param driver WebDriver
     * @return Set of important WebElements
     */
    private Set<WebElement> findImportantElements(WebDriver driver) {
        Set<WebElement> importantElements = new HashSet<>();
        
        try {
            // Find error messages
            importantElements.addAll(driver.findElements(By.cssSelector(".error, .alert, .warning")));
            
            // Find elements with "error" or "alert" in class or ID
            importantElements.addAll(driver.findElements(By.cssSelector("[class*='error'], [class*='alert'], [id*='error'], [id*='alert']")));
            
            // Find elements with red or yellow background or text
            JavascriptExecutor js = (JavascriptExecutor) driver;
            List<WebElement> allElements = driver.findElements(By.cssSelector("*"));
            
            for (WebElement element : allElements) {
                try {
                    String color = (String) js.executeScript(
                        "return window.getComputedStyle(arguments[0]).getPropertyValue('color');", element);
                    String bgColor = (String) js.executeScript(
                        "return window.getComputedStyle(arguments[0]).getPropertyValue('background-color');", element);
                    
                    if ((color != null && (color.contains("rgb(255, 0, 0)") || color.contains("rgb(255, 255, 0)"))) ||
                        (bgColor != null && (bgColor.contains("rgb(255, 0, 0)") || bgColor.contains("rgb(255, 255, 0)")))) {
                        importantElements.add(element);
                    }
                } catch (Exception e) {
                    // Skip this element
                }
            }
            
            // Find form fields with values
            List<WebElement> formFields = driver.findElements(By.cssSelector("input, select, textarea"));
            for (WebElement field : formFields) {
                try {
                    String value = field.getAttribute("value");
                    if (value != null && !value.isEmpty()) {
                        importantElements.add(field);
                    }
                } catch (Exception e) {
                    // Skip this element
                }
            }
            
            // Find active elements
            WebElement activeElement = driver.switchTo().activeElement();
            if (activeElement != null && !"body".equals(activeElement.getTagName())) {
                importantElements.add(activeElement);
            }
        } catch (Exception e) {
            logger.error("Error finding important elements", e);
        }
        
        return importantElements;
    }
    
    /**
     * Generate heatmap of element usage
     * 
     * @param driver WebDriver
     * @param pageUrl Page URL
     * @return Path to heatmap image file or null if failed
     */
    public String generateHeatmap(WebDriver driver, String pageUrl) {
        try {
            if (driver == null) {
                return null;
            }
            
            // Normalize URL
            String normalizedUrl = pageUrl.split("\\?")[0];
            
            // Find all interactive elements
            List<WebElement> interactiveElements = new ArrayList<>();
            interactiveElements.addAll(driver.findElements(By.tagName("button")));
            interactiveElements.addAll(driver.findElements(By.tagName("a")));
            interactiveElements.addAll(driver.findElements(By.tagName("input")));
            interactiveElements.addAll(driver.findElements(By.tagName("select")));
            
            // Create JavaScript for heatmap
            StringBuilder heatmapJS = new StringBuilder();
            heatmapJS.append("var overlay = document.createElement('div');");
            heatmapJS.append("overlay.style.position = 'absolute';");
            heatmapJS.append("overlay.style.top = '0';");
            heatmapJS.append("overlay.style.left = '0';");
            heatmapJS.append("overlay.style.width = '100%';");
            heatmapJS.append("overlay.style.height = '100%';");
            heatmapJS.append("overlay.style.pointerEvents = 'none';");
            heatmapJS.append("overlay.style.zIndex = '9999';");
            heatmapJS.append("document.body.appendChild(overlay);");
            
            // Add heat points for each element
            for (WebElement element : interactiveElements) {
                try {
                    String elementKey = createElementFingerprint(element, normalizedUrl);
                    
                    if (elementKey != null && !elementKey.isEmpty()) {
                        ElementLearningData data = elementLearningMap.get(elementKey);
                        
                        if (data != null && data.totalInteractions > 0) {
                            // Calculate heat intensity based on interactions
                            double intensity = Math.min(1.0, data.totalInteractions / 10.0);
                            int red = (int) (255 * intensity);
                            int green = (int) (255 * (1 - intensity));
                            
                            // Create heat point
                            StringBuilder heatPoint = new StringBuilder();
                            heatPoint.append("var elementRect = arguments[").append(interactiveElements.indexOf(element)).append("].getBoundingClientRect();");
                            heatPoint.append("var heatPoint = document.createElement('div');");
                            heatPoint.append("heatPoint.style.position = 'absolute';");
                            heatPoint.append("heatPoint.style.top = (elementRect.top + window.scrollY) + 'px';");
                            heatPoint.append("heatPoint.style.left = (elementRect.left + window.scrollX) + 'px';");
                            heatPoint.append("heatPoint.style.width = elementRect.width + 'px';");
                            heatPoint.append("heatPoint.style.height = elementRect.height + 'px';");
                            heatPoint.append("heatPoint.style.backgroundColor = 'rgba(").append(red).append(",").append(green).append(",0,0.5)';");
                            heatPoint.append("heatPoint.style.borderRadius = '2px';");
                            heatPoint.append("heatPoint.style.pointerEvents = 'none';");
                            heatPoint.append("overlay.appendChild(heatPoint);");
                            
                            heatmapJS.append(heatPoint);
                        }
                    }
                } catch (Exception e) {
                    // Skip this element
                }
            }
            
            // Execute JavaScript to create heatmap
            JavascriptExecutor js = (JavascriptExecutor) driver;
            js.executeScript(heatmapJS.toString(), interactiveElements.toArray(new WebElement[0]));
            
            // Take screenshot with heatmap
            TakesScreenshot screenshotDriver = (TakesScreenshot) driver;
            byte[] screenshot = screenshotDriver.getScreenshotAs(OutputType.BYTES);
            
            // Create unique screenshot name
            String screenshotName = "Heatmap_" + normalizedUrl.replaceAll("[^a-zA-Z0-9]", "_") + 
                                  "_" + System.currentTimeMillis() + ".png";
            
            // Remove heatmap overlay
            js.executeScript("document.body.removeChild(overlay);");
            
            // Save screenshot using reporter
            return CSSmartReporter.getInstance().addScreenshot(screenshot, "Heatmap for " + normalizedUrl);
        } catch (Exception e) {
            logger.error("Failed to generate heatmap", e);
            return null;
        }
    }
    
    /**
     * Perform AI-guided exploratory testing
     * 
     * @param driver WebDriver
     * @param baseUrl Base URL to explore
     * @param maxPages Maximum number of pages to explore
     * @param maxDepth Maximum depth of exploration
     */
    public void performExploratoryTesting(WebDriver driver, String baseUrl, int maxPages, int maxDepth) {
        try {
            if (driver == null) {
                return;
            }
            
            // Set of visited URLs
            Set<String> visitedUrls = new HashSet<>();
            
            // Set of URLs to visit
            List<String> urlsToVisit = new ArrayList<>();
            urlsToVisit.add(baseUrl);
            
            // Start exploration
            int pagesVisited = 0;
            int currentDepth = 0;
            
            while (!urlsToVisit.isEmpty() && pagesVisited < maxPages && currentDepth < maxDepth) {
                // Get next URL to visit
                String currentUrl = urlsToVisit.remove(0);
                
                if (visitedUrls.contains(currentUrl)) {
                    continue;
                }
                
                // Visit the page
                driver.get(currentUrl);
                long loadStartTime = System.currentTimeMillis();
                
                // Wait for page to load
                try {
                    waitForPageLoad(driver);
                } catch (Exception e) {
                    logger.warn("Page load wait timed out: " + currentUrl);
                }
                
                long loadTime = System.currentTimeMillis() - loadStartTime;
                
                // Record page visit
                recordPageVisit(driver, loadTime);
                visitedUrls.add(currentUrl);
                pagesVisited++;
                
                logger.info("Exploratory testing - visited: " + currentUrl + " (" + pagesVisited + "/" + maxPages + ")");
                
                // Take screenshot
                takeIntelligentScreenshot(driver, "Exploratory_" + pagesVisited);
                
                // Find form fields and fill them randomly
                List<WebElement> formFields = driver.findElements(By.cssSelector("input:not([type='hidden']), textarea"));
                for (WebElement field : formFields) {
                    try {
                        if (field.isDisplayed() && field.isEnabled()) {
                            String data = generateSmartTestData(field, driver);
                            field.clear();
                            field.sendKeys(data);
                        }
                    } catch (Exception e) {
                        // Skip this field
                    }
                }
                
                // Find buttons and links for next pages
                List<WebElement> buttons = driver.findElements(By.tagName("button"));
                List<WebElement> links = driver.findElements(By.tagName("a"));
                
                // Extract links from buttons and anchor tags
                for (WebElement link : links) {
                    try {
                        String href = link.getAttribute("href");
                        
                        if (href != null && !href.isEmpty() && href.startsWith(baseUrl) && 
                            !href.contains("logout") && !href.contains("signout")) {
                            
                            // Normalize URL
                            String normalizedUrl = href.split("#")[0];
                            if (!visitedUrls.contains(normalizedUrl) && !urlsToVisit.contains(normalizedUrl)) {
                                urlsToVisit.add(normalizedUrl);
                            }
                        }
                    } catch (Exception e) {
                        // Skip this link
                    }
                }
                
                currentDepth++;
            }
            
            logger.info("Exploratory testing completed - visited " + pagesVisited + " pages");
        } catch (Exception e) {
            logger.error("Error during exploratory testing", e);
        }
    }
    
    /**
     * Wait for page to load
     * 
     * @param driver WebDriver
     * @throws InterruptedException if interrupted
     */
    private void waitForPageLoad(WebDriver driver) throws InterruptedException {
        // Wait for document ready state
        long startTime = System.currentTimeMillis();
        long timeout = 30000;  // 30 seconds timeout
        
        while (System.currentTimeMillis() - startTime < timeout) {
            try {
                JavascriptExecutor js = (JavascriptExecutor) driver;
                Object readyState = js.executeScript("return document.readyState");
                
                if ("complete".equals(readyState)) {
                    break;
                }
                
                Thread.sleep(100);
            } catch (Exception e) {
                // Ignore exceptions during wait
            }
        }
    }
    
    /**
     * Generate random string
     * 
     * @param length String length
     * @return Random string
     */
    private String generateRandomString(int length) {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        StringBuilder sb = new StringBuilder();
        
        for (int i = 0; i < length; i++) {
            sb.append(chars.charAt(random.nextInt(chars.length())));
        }
        
        return sb.toString();
    }
    
    /**
     * Check if string contains text (case insensitive)
     * 
     * @param source Source string
     * @param search Search text
     * @return true if source contains search, false otherwise
     */
    private boolean containsIgnoreCase(String source, String search) {
        return source != null && search != null && 
               source.toLowerCase().contains(search.toLowerCase());
    }
    
    /**
     * Element learning data class
     */
    private static class ElementLearningData {
        private final String elementKey;
        private long totalInteractions;
        private long successfulInteractions;
        private long avgInteractionTimeMs;
        
        public ElementLearningData(String elementKey) {
            this.elementKey = elementKey;
            this.totalInteractions = 0;
            this.successfulInteractions = 0;
            this.avgInteractionTimeMs = 0;
        }
    }
    
    /**
     * Page learning data class
     */
    private static class PageLearningData {
        private final String pageUrl;
        private long avgLoadTimeMs;
        private long visitCount;
        private long lastVisitTime;
        
        public PageLearningData(String pageUrl) {
            this.pageUrl = pageUrl;
            this.avgLoadTimeMs = 0;
            this.visitCount = 0;
            this.lastVisitTime = 0;
        }
    }
    
    /**
     * Test execution data class
     */
    private static class TestExecutionData {
        private final String testName;
        private long avgExecutionTimeMs;
        private long executionCount;
        private double successRate;
        private long lastExecutionTime;
        
        public TestExecutionData(String testName) {
            this.testName = testName;
            this.avgExecutionTimeMs = 0;
            this.executionCount = 0;
            this.successRate = 0.0;
            this.lastExecutionTime = 0;
        }
    }
}


# CSSmart Framework - Complete Folder Structure and Code Walkthrough Guide

## Folder Structure

Here's the complete folder structure for the CSSmart automation framework:

```
cssmart/

 src/
    main/
       java/
          com/
              cssmart/
                  ai/
                     CSSmartAITesting.java
                 
                  annotations/
                     CSSmartFindBy.java
                 
                  api/
                     client/
                        CSSmartHTTPClient.java
                     cucumber/
                        CSSmartAPIContext.java
                        CSSmartAPITestSteps.java
                     response/
                        CSSmartAPIResponse.java
                     utils/
                        CSSmartJSONUtils.java
                     validation/
                         CSSmartAPIResponseValidator.java
                 
                  browser/
                     CSSmartBrowserManager.java
                 
                  ci/
                     CSSmartAzureDevOpsIntegration.java
                 
                  config/
                     CSSmartConfig.java
                 
                  database/
                     CSSmartDatabaseManager.java
                 
                  exceptions/
                     CSSmartException.java
                 
                  listeners/
                     CSSmartTestListener.java
                     CSSmartRetryAnalyzer.java
                 
                  pages/
                     CSSmartBasePage.java
                 
                  parallel/
                     CSSmartParallelExecution.java
                 
                  reporting/
                     CSSmartReporter.java
                     CSSmartTestResult.java
                 
                  runner/
                     CSSmartTestRunner.java
                     CSSmartSuiteRunner.java
                 
                  tests/
                     CSSmartBaseTest.java
                 
                  utils/
                      CSSmartLogger.java
                      CSSmartDataLoader.java
                      CSSmartScreenshot.java
      
       resources/
           log4j2.xml
           cssmart.properties
   
    test/
        java/
           com/
               cssmart/
                   examples/
                      CSSmartPipelineExample.java
                      CSSmartDemoTest.java
                  
                   testcases/
                       [your test cases]
       
        resources/
            features/
               sample-api-test.feature
           
            schemas/
               users-schema.json
           
            testdata/
               test-data.xlsx
               test-data.csv
           
            testng.xml

 downloads/                                  # Default download directory

 cssmart-reports/                           # Generated reports directory
    screenshots/
    cssmart-report-[timestamp].html
    cssmart-report.css
    cssmart-report.js

 cssmart-ai-data/                           # AI learning data directory
    element-learning.csv
    page-learning.csv
    test-execution.csv
    data-patterns.csv

 logs/                                       # Log files directory

 pom.xml                                    # Maven project configuration
```

## Code Walkthrough Guide

### 1. Core Framework Components

#### CSSmartBasePage.java
- **Location**: `src/main/java/com/cssmart/pages/CSSmartBasePage.java`
- **Purpose**: Base class for all page objects
- **Key Features**:
  - Implements Page Object Model pattern
  - Handles element initialization with CSSmartFindBy annotations
  - Includes methods for common page interactions
  - Implements waiting mechanisms for elements
- **Troubleshooting**:
  - If elements aren't found, check the locator strategies in your page classes
  - For timing issues, adjust wait timeouts in the configuration

#### CSSmartBaseTest.java
- **Location**: `src/main/java/com/cssmart/tests/CSSmartBaseTest.java`
- **Purpose**: Base class for all test classes
- **Key Features**:
  - Handles TestNG annotations and lifecycle
  - Sets up browser instances
  - Configures report generation
  - Manages test context and result handling
- **Troubleshooting**:
  - For test initialization issues, check the `@BeforeClass` method
  - For reporting problems, verify the CSSmartReporter is properly initialized

#### CSSmartFindBy.java
- **Location**: `src/main/java/com/cssmart/annotations/CSSmartFindBy.java`
- **Purpose**: Custom annotation for element location
- **Key Features**:
  - Extends Selenium's FindBy with additional capabilities
  - Supports dynamic locator strategies
- **Troubleshooting**:
  - If the annotation isn't working, ensure proper import in your page classes
  - Verify the annotation processor is correctly registered

### 2. Configuration and Utilities

#### CSSmartConfig.java
- **Location**: `src/main/java/com/cssmart/config/CSSmartConfig.java`
- **Purpose**: Framework configuration management
- **Key Features**:
  - Loads properties from file or classpath
  - Provides singleton access to configuration
  - Manages browser and environment settings
- **Troubleshooting**:
  - If configuration isn't loading, check the file path or classpath resources
  - For environment-specific issues, verify the environment property is set correctly

#### CSSmartLogger.java
- **Location**: `src/main/java/com/cssmart/utils/CSSmartLogger.java`
- **Purpose**: Centralized logging system
- **Key Features**:
  - Uses Log4j2 for structured logging
  - Provides static access to loggers
  - Includes formatting for different log levels
- **Troubleshooting**:
  - If logs aren't appearing, check log4j2.xml configuration
  - Verify the logs directory has write permissions

#### CSSmartDataLoader.java
- **Location**: `src/main/java/com/cssmart/utils/CSSmartDataLoader.java`
- **Purpose**: Test data management
- **Key Features**:
  - Loads data from Excel, CSV, and other sources
  - Supports data-driven testing
  - Provides access to external test data
- **Troubleshooting**:
  - For data file issues, verify file format and permissions
  - For parsing errors, check the data structure matches expected format

### 3. Browser Management

#### CSSmartBrowserManager.java
- **Location**: `src/main/java/com/cssmart/browser/CSSmartBrowserManager.java`
- **Purpose**: Browser session management and switching
- **Key Features**:
  - Manages WebDriver instances for different browsers
  - Provides thread-safe access to browser instances
  - Handles browser switching during execution
  - Configures browser capabilities and options
- **Troubleshooting**:
  - For browser initialization failures, check driver executable paths
  - For switching issues, verify browser type enums match
  - If options aren't applied, check the createXXXDriver methods

### 4. Reporting System

#### CSSmartReporter.java
- **Location**: `src/main/java/com/cssmart/reporting/CSSmartReporter.java`
- **Purpose**: Test execution reporting
- **Key Features**:
  - Generates HTML reports with charts and statistics
  - Tracks test steps and screenshots
  - Provides detailed failure information
  - Creates interactive report elements
- **Troubleshooting**:
  - If reports aren't generating, check report directory permissions
  - For styling issues, verify CSS and JS resources are being copied
  - For test details, ensure proper test context capturing

#### CSSmartTestResult.java
- **Location**: `src/main/java/com/cssmart/reporting/CSSmartTestResult.java`
- **Purpose**: Test result representation
- **Key Features**:
  - Stores test execution details
  - Includes timing information
  - Captures error details and stack traces
- **Troubleshooting**:
  - For missing test results, check result object creation in listeners
  - For timing issues, verify start/end time capture

### 5. API Testing Framework

#### CSSmartHTTPClient.java
- **Location**: `src/main/java/com/cssmart/api/client/CSSmartHTTPClient.java`
- **Purpose**: Native HTTP client for API testing
- **Key Features**:
  - Supports all HTTP methods
  - Handles authentication mechanisms
  - Configures request headers and timeouts
  - Processes multipart requests
- **Troubleshooting**:
  - For connection issues, check network settings and proxy configuration
  - For authentication failures, verify credentials and token format
  - For request/response problems, enable debug logging

#### CSSmartAPIResponse.java
- **Location**: `src/main/java/com/cssmart/api/response/CSSmartAPIResponse.java`
- **Purpose**: API response representation
- **Key Features**:
  - Stores HTTP response details
  - Provides methods for JSON parsing
  - Extracts values using JSONPath
- **Troubleshooting**:
  - For parsing issues, check response format
  - For extraction problems, verify JSONPath expressions

#### CSSmartAPIResponseValidator.java
- **Location**: `src/main/java/com/cssmart/api/validation/CSSmartAPIResponseValidator.java`
- **Purpose**: API response validation
- **Key Features**:
  - Validates responses against schemas
  - Compares with expected JSON
  - Verifies against database results
  - Validates individual fields
- **Troubleshooting**:
  - For schema validation issues, check schema files
  - For comparison failures, inspect validation details

#### CSSmartAPITestSteps.java
- **Location**: `src/main/java/com/cssmart/api/cucumber/CSSmartAPITestSteps.java`
- **Purpose**: BDD-style API test steps
- **Key Features**:
  - Implements Cucumber step definitions
  - Provides zero-code approach for API testing
  - Handles request building and response validation
- **Troubleshooting**:
  - For step definition issues, check regular expressions
  - For Cucumber integration problems, verify Gherkin syntax

### 6. Database Testing

#### CSSmartDatabaseManager.java
- **Location**: `src/main/java/com/cssmart/database/CSSmartDatabaseManager.java`
- **Purpose**: Database connection and testing
- **Key Features**:
  - Supports multiple database types
  - Manages connection pooling
  - Executes SQL queries and updates
  - Compares database schemas
- **Troubleshooting**:
  - For connection issues, check database credentials and URL
  - For query failures, verify SQL syntax and parameters
  - For driver problems, ensure JDBC drivers are in classpath

### 7. CI/CD Integration

#### CSSmartAzureDevOpsIntegration.java
- **Location**: `src/main/java/com/cssmart/ci/CSSmartAzureDevOpsIntegration.java`
- **Purpose**: Azure DevOps integration
- **Key Features**:
  - Updates test results in DevOps
  - Triggers pipelines
  - Creates work items
  - Monitors build status
- **Troubleshooting**:
  - For authentication issues, check PAT token
  - For API errors, verify organization and project names
  - For test result updates, check test plan and suite IDs

### 8. AI-Assisted Testing

#### CSSmartAITesting.java
- **Location**: `src/main/java/com/cssmart/ai/CSSmartAITesting.java`
- **Purpose**: AI capabilities for testing
- **Key Features**:
  - Self-healing locators
  - Smart test data generation
  - Test execution optimization
  - Exploratory testing assistance
  - Heatmap generation
- **Troubleshooting**:
  - For learning data issues, check permissions on the data directory
  - For self-healing problems, adjust threshold values
  - For test data generation, verify field pattern recognition

### 9. Parallel Execution

#### CSSmartParallelExecution.java
- **Location**: `src/main/java/com/cssmart/parallel/CSSmartParallelExecution.java`
- **Purpose**: Parallel test execution
- **Key Features**:
  - Manages thread pools for execution
  - Handles test dependencies
  - Optimizes resource usage
- **Troubleshooting**:
  - For thread issues, check pool configuration
  - For test isolation problems, verify thread-local variables
  - For performance issues, adjust thread counts

## Common Troubleshooting Scenarios

### 1. WebDriver Initialization Failures

**Problem**: Tests fail with driver initialization errors.

**Solution**:
1. Check driver executable paths in `cssmart.properties`
2. Verify driver versions match browser versions
3. Ensure driver executables have proper permissions
4. Look for browser compatibility issues
5. Check network settings if downloading drivers

**Code Reference**: `CSSmartBrowserManager.createDriver()` method

### 2. Element Not Found Exceptions

**Problem**: Tests fail with `ElementNotFoundException`.

**Solution**:
1. Check locator strategies in page classes
2. Verify page structure hasn't changed
3. Increase wait timeouts in configuration
4. Enable self-healing locators in AI testing
5. Check if elements are in iframes or shadow DOM

**Code Reference**: `CSSmartBasePage.findElement()` method

### 3. API Test Failures

**Problem**: API tests fail with connection or validation errors.

**Solution**:
1. Verify API endpoint URLs
2. Check authentication settings
3. Inspect request and response payloads
4. Verify schema files for validation
5. Check network connectivity and proxy settings

**Code Reference**: `CSSmartHTTPClient.send*()` methods and `CSSmartAPIResponseValidator` class

### 4. Database Connection Issues

**Problem**: Database tests fail with connection errors.

**Solution**:
1. Verify database credentials
2. Check connection URL format
3. Ensure database server is accessible
4. Verify JDBC drivers are available
5. Check database permissions

**Code Reference**: `CSSmartDatabaseManager.connect()` methods

### 5. Reporting Problems

**Problem**: Reports aren't generating or are incomplete.

**Solution**:
1. Check report directory permissions
2. Verify proper test lifecycle capture
3. Ensure screenshots are being saved correctly
4. Check for JavaScript errors in console
5. Verify CSS and JS resources are available

**Code Reference**: `CSSmartReporter.generateReport()` method

### 6. Parallel Execution Issues

**Problem**: Tests interfere with each other during parallel execution.

**Solution**:
1. Verify thread-safe access to shared resources
2. Check thread-local variables for driver instances
3. Adjust thread count in configuration
4. Ensure test isolation with proper annotations
5. Check for static variables causing state issues

**Code Reference**: `CSSmartParallelExecution` class

### 7. AI Learning Data Corruption

**Problem**: AI features not working or producing unexpected results.

**Solution**:
1. Check permissions on AI data directory
2. Verify CSV format for learning data
3. Potentially reset corrupted learning files
4. Check for exceptions in AI operations
5. Adjust thresholds for self-healing

**Code Reference**: `CSSmartAITesting.loadLearningData()` method

## Configuration Reference

### cssmart.properties

```properties
# Browser Configuration
browser=chrome
headless=false
timeout=30

# Webdriver Paths (Optional, system will try to auto-detect)
webdriver.chrome.driver=path/to/chromedriver
webdriver.gecko.driver=path/to/geckodriver
webdriver.edge.driver=path/to/msedgedriver

# Test Execution
parallel.threads=4
retry.count=1

# Reporting
report.directory=cssmart-reports
screenshot.onFailure=true

# Database Configuration
database.type=mysql
database.host=localhost
database.port=3306
database.name=testdb
database.username=user
database.password=password

# API Testing
api.timeout=30
api.baseUrl=https://api.example.com

# Azure DevOps Integration
ado.organization=myorganization
ado.project=myproject
ado.testPlanId=12345
ado.testSuiteId=6789

# AI Testing Configuration
ai.learning.directory=cssmart-ai-data
ai.selfHealing=true
ai.selfHealingThreshold=0.8
```

## Maven Dependencies

```xml
<dependencies>
    <!-- Selenium -->
    <dependency>
        <groupId>org.seleniumhq.selenium</groupId>
        <artifactId>selenium-java</artifactId>
        <version>4.10.0</version>
    </dependency>
    
    <!-- TestNG -->
    <dependency>
        <groupId>org.testng</groupId>
        <artifactId>testng</artifactId>
        <version>7.7.1</version>
    </dependency>
    
    <!-- Cucumber -->
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-java</artifactId>
        <version>7.11.1</version>
    </dependency>
    <dependency>
        <groupId>io.cucumber</groupId>
        <artifactId>cucumber-testng</artifactId>
        <version>7.11.1</version>
    </dependency>
    
    <!-- Logging -->
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-api</artifactId>
        <version>2.20.0</version>
    </dependency>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-core</artifactId>
        <version>2.20.0</version>
    </dependency>
    
    <!-- JSON Handling -->
    <dependency>
        <groupId>org.json</groupId>
        <artifactId>json</artifactId>
        <version>20230227</version>
    </dependency>
    
    <!-- Database Drivers -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.33</version>
    </dependency>
    
    <!-- Add other database drivers as needed -->
</dependencies>
```

## Getting Started

1. **Clone the framework**:
   - Set up the folder structure as shown above
   - Copy the class files to their correct locations

2. **Configure properties**:
   - Modify `cssmart.properties` for your environment
   - Set browser, database, and other configurations

3. **Create your first test**:
   - Extend `CSSmartBaseTest` for your test class
   - Create page objects extending `CSSmartBasePage`
   - Use `CSSmartFindBy` annotations for elements

4. **Run tests**:
   - Use `CSSmartTestRunner` to execute tests
   - Or set up TestNG XML files with listeners

5. **View reports**:
   - Check the `cssmart-reports` directory for HTML reports
   - Examine screenshots for failures

By following this guide, you should be able to effectively use the CSSmart framework and troubleshoot any issues that arise during test development and execution.
