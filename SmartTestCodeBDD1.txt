package com.cssmart.ui.recorder.generator;

import com.cssmart.ui.recorder.model.RecordedStep;
import com.cssmart.ui.recorder.model.TestCase;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

/**
 * Generator for Cucumber feature files from recorded test steps
 */
@Slf4j
public class BDDFeatureGenerator {

    private static final Pattern ELEMENT_NAME_PATTERN = Pattern.compile("([a-z]+)\\s+([a-z]+|field|button|dropdown|checkbox|radio|link|icon|menu|tab|panel|modal|dialog|form|image|text|label)");
    
    /**
     * Generate a feature file from a test case
     * @param testCase The recorded test case
     * @return Generated feature file content as string
     */
    public String generateFeatureFile(TestCase testCase) {
        log.info("Generating feature file for: {}", testCase.getName());
        
        try {
            StringBuilder featureFile = new StringBuilder();
            
            // Feature header
            featureFile.append("Feature: ").append(formatFeatureTitle(testCase.getName())).append("\n");
            featureFile.append("  ").append(testCase.getDescription()).append("\n\n");
            
            // Background if needed (common setup steps)
            if (hasCommonSetupSteps(testCase.getSteps())) {
                featureFile.append("  Background: Common setup steps\n");
                
                // Typically the navigation step
                RecordedStep firstStep = testCase.getSteps().get(0);
                if ("NAVIGATE".equals(firstStep.getAction())) {
                    featureFile.append("    Given the user navigates to ").append(formatUrl(firstStep.getValue())).append("\n\n");
                }
            }
            
            // Scenario from test case
            featureFile.append("  Scenario: ").append(formatScenarioTitle(testCase.getName())).append("\n");
            
            // Skip navigation step if it's in background
            int startIndex = ("NAVIGATE".equals(testCase.getSteps().get(0).getAction())) ? 1 : 0;
            
            // Generate steps
            for (int i = startIndex; i < testCase.getSteps().size(); i++) {
                RecordedStep step = testCase.getSteps().get(i);
                String gherkinStep = convertToGherkinStep(step, i == startIndex);
                featureFile.append("    ").append(gherkinStep).append("\n");
            }
            
            return featureFile.toString();
        } catch (Exception e) {
            log.error("Error generating feature file", e);
            throw new RuntimeException("Failed to generate feature file: " + e.getMessage(), e);
        }
    }
    
    /**
     * Generate step definitions for the test steps
     * @param testCase The recorded test case
     * @return Step definitions as Java code
     */
    public String generateStepDefinitions(TestCase testCase) {
        log.info("Generating step definitions for: {}", testCase.getName());
        
        try {
            StringBuilder stepDefs = new StringBuilder();
            
            // Class header
            String className = testCase.getClassName().replace("Test", "Steps");
            
            stepDefs.append("package com.cssmart.stepdefs;\n\n");
            stepDefs.append("import io.cucumber.java.en.Given;\n");
            stepDefs.append("import io.cucumber.java.en.When;\n");
            stepDefs.append("import io.cucumber.java.en.Then;\n");
            stepDefs.append("import io.cucumber.java.en.And;\n");
            stepDefs.append("import com.cssmart.core.base.BaseSteps;\n");
            stepDefs.append("import org.openqa.selenium.WebElement;\n");
            stepDefs.append("import org.testng.Assert;\n\n");
            
            stepDefs.append("/**\n");
            stepDefs.append(" * Step definitions for ").append(formatFeatureTitle(testCase.getName())).append("\n");
            stepDefs.append(" */\n");
            stepDefs.append("public class ").append(className).append(" extends BaseSteps {\n\n");
            
            // Element locator mapping
            Map<String, String> elementLocators = generateElementLocators(testCase.getSteps());
            
            // Add element locators as constants
            for (Map.Entry<String, String> locator : elementLocators.entrySet()) {
                stepDefs.append("    // Element locator for ").append(locator.getKey()).append("\n");
                stepDefs.append("    private static final String ").append(convertToConstantName(locator.getKey()))
                       .append(" = \"").append(locator.getValue()).append("\";\n");
            }
            stepDefs.append("\n");
            
            // Generate step definition methods
            Set<String> generatedMethods = new HashSet<>();
            
            for (RecordedStep step : testCase.getSteps()) {
                // Generate method for step
                String methodDef = generateStepMethod(step, generatedMethods);
                if (methodDef != null && !methodDef.isEmpty()) {
                    stepDefs.append(methodDef).append("\n");
                    // Add to set of generated methods to avoid duplicates
                    generatedMethods.add(standardizeStepText(convertToGherkinStep(step, false)));
                }
            }
            
            stepDefs.append("}\n");
            
            return stepDefs.toString();
        } catch (Exception e) {
            log.error("Error generating step definitions", e);
            throw new RuntimeException("Failed to generate step definitions: " + e.getMessage(), e);
        }
    }
    
    /**
     * Format feature title to be more readable
     */
    private String formatFeatureTitle(String title) {
        // Remove "Test" suffix if present
        if (title.endsWith(" Test")) {
            title = title.substring(0, title.length() - 5);
        }
        
        return title;
    }
    
    /**
     * Format scenario title to be more specific
     */
    private String formatScenarioTitle(String title) {
        // Remove "Test" suffix if present
        if (title.endsWith(" Test")) {
            title = title.substring(0, title.length() - 5);
        }
        
        return "Verify " + title.toLowerCase();
    }
    
    /**
     * Format URL for better readability in feature files
     */
    private String formatUrl(String url) {
        // Remove protocol
        if (url.startsWith("http://")) {
            url = url.substring(7);
        } else if (url.startsWith("https://")) {
            url = url.substring(8);
        }
        
        return url;
    }
    
    /**
     * Check if the test has common setup steps that should go in Background
     */
    private boolean hasCommonSetupSteps(List<RecordedStep> steps) {
        if (steps == null || steps.isEmpty()) {
            return false;
        }
        
        // Consider navigation as common setup
        return "NAVIGATE".equals(steps.get(0).getAction());
    }
    
    /**
     * Convert a recorded step to a Gherkin step
     * @param step The recorded step
     * @param isFirst Whether this is the first step in the scenario
     * @return Gherkin step text
     */
    private String convertToGherkinStep(RecordedStep step, boolean isFirst) {
        String prefix = isFirst ? "Given " : "And ";
        
        switch (step.getAction()) {
            case "NAVIGATE":
                return prefix + "the user navigates to " + formatUrl(step.getValue());
                
            case "CLICK":
                return prefix + "the user clicks on the " + formatElementName(step.getElement());
                
            case "TYPE":
                return prefix + "the user enters \"" + step.getValue() + "\" in the " + formatElementName(step.getElement());
                
            case "SELECT":
                return prefix + "the user selects \"" + step.getValue() + "\" from the " + formatElementName(step.getElement());
                
            case "VERIFY_PRESENCE":
                return "Then the " + formatElementName(step.getElement()) + " should be visible";
                
            case "VERIFY_VISIBILITY":
                return "Then the " + formatElementName(step.getElement()) + " should be visible";
                
            case "VERIFY_TEXT":
                return "Then the " + formatElementName(step.getElement()) + " should contain text \"" + step.getValue() + "\"";
                
            case "VERIFY_STATE":
                return "Then the " + formatElementName(step.getElement()) + " should be in \"" + step.getValue() + "\" state";
                
            case "WAIT":
                return prefix + "the user waits for the " + formatElementName(step.getElement()) + " to appear";
                
            case "HOVER":
                return prefix + "the user hovers over the " + formatElementName(step.getElement());
                
            default:
                return prefix + "the user performs " + step.getAction() + " on the " + formatElementName(step.getElement());
        }
    }
    
    /**
     * Format element name to be more readable in feature files
     */
    private String formatElementName(String element) {
        if (element == null || element.isEmpty()) {
            return "element";
        }
        
        // Improve naming for common elements
        Matcher matcher = ELEMENT_NAME_PATTERN.matcher(element.toLowerCase());
        if (matcher.find()) {
            return matcher.group(1) + " " + matcher.group(2);
        }
        
        return element;
    }
    
    /**
     * Convert normal string to constant name format
     */
    private String convertToConstantName(String input) {
        return input.toUpperCase().replaceAll("[^A-Z0-9]", "_") + "_LOCATOR";
    }
    
    /**
     * Generate element locators from test steps
     */
    private Map<String, String> generateElementLocators(List<RecordedStep> steps) {
        Map<String, String> locators = new HashMap<>();
        
        for (RecordedStep step : steps) {
            if (step.getElement() != null && !step.getElement().isEmpty()) {
                String elementName = formatElementName(step.getElement());
                
                // Generate proper locator strategy based on element type
                String locator = generateLocatorStrategy(elementName, step.getElement());
                
                locators.put(elementName, locator);
            }
        }
        
        return locators;
    }
    
    /**
     * Generate appropriate locator strategy based on element type
     */
    private String generateLocatorStrategy(String formattedName, String originalElement) {
        // Attempt to determine the most appropriate locator strategy
        if (formattedName.contains("button")) {
            if (formattedName.contains("login") || formattedName.contains("submit") || 
                formattedName.contains("search") || formattedName.contains("save")) {
                return "//button[contains(text(), '" + formattedName.replace(" button", "") + "')]";
            } else {
                return "//button[@id='" + convertToIdFormat(formattedName) + "']";
            }
        } else if (formattedName.contains("field") || formattedName.contains("input")) {
            String fieldName = formattedName.replace(" field", "").replace(" input", "");
            return "//input[@id='" + convertToIdFormat(fieldName) + "' or @name='" + convertToIdFormat(fieldName) + "']";
        } else if (formattedName.contains("dropdown") || formattedName.contains("select")) {
            String selectName = formattedName.replace(" dropdown", "").replace(" select", "");
            return "//select[@id='" + convertToIdFormat(selectName) + "' or @name='" + convertToIdFormat(selectName) + "']";
        } else if (formattedName.contains("checkbox")) {
            String checkboxName = formattedName.replace(" checkbox", "");
            return "//input[@type='checkbox' and (@id='" + convertToIdFormat(checkboxName) + "' or @name='" + convertToIdFormat(checkboxName) + "')]";
        } else if (formattedName.contains("link")) {
            String linkText = formattedName.replace(" link", "");
            return "//a[contains(text(), '" + linkText + "')]";
        } else if (formattedName.contains("text") || formattedName.contains("message")) {
            return "//*[contains(text(), '" + formattedName + "')]";
        } else {
            // Default to a general purpose locator
            return "//*[@id='" + convertToIdFormat(formattedName) + "' or contains(@class, '" + 
                   convertToClassFormat(formattedName) + "') or contains(text(), '" + formattedName + "')]";
        }
    }
    
    /**
     * Convert element name to ID format (camelCase)
     */
    private String convertToIdFormat(String name) {
        String[] parts = name.split("\\s+");
        StringBuilder idBuilder = new StringBuilder(parts[0].toLowerCase());
        
        for (int i = 1; i < parts.length; i++) {
            if (parts[i].length() > 0) {
                idBuilder.append(Character.toUpperCase(parts[i].charAt(0)));
                if (parts[i].length() > 1) {
                    idBuilder.append(parts[i].substring(1).toLowerCase());
                }
            }
        }
        
        return idBuilder.toString();
    }
    
    /**
     * Convert element name to CSS class format (kebab-case)
     */
    private String convertToClassFormat(String name) {
        return name.toLowerCase().replaceAll("\\s+", "-");
    }
    
    /**
     * Generate method for step definition
     */
    private String generateStepMethod(RecordedStep step, Set<String> existingMethods) {
        String gherkinStep = convertToGherkinStep(step, false);
        String standardizedStep = standardizeStepText(gherkinStep);
        
        // Skip if we already generated this method
        if (existingMethods.contains(standardizedStep)) {
            return null;
        }
        
        StringBuilder method = new StringBuilder();
        
        // Determine annotation type
        String annotationType;
        if (gherkinStep.startsWith("Given ")) {
            annotationType = "Given";
        } else if (gherkinStep.startsWith("When ")) {
            annotationType = "When";
        } else if (gherkinStep.startsWith("Then ")) {
            annotationType = "Then";
        } else if (gherkinStep.startsWith("And ")) {
            // Determine the appropriate type based on step action
            if (step.getAction().startsWith("VERIFY")) {
                annotationType = "Then";
            } else if (step.getAction().equals("NAVIGATE")) {
                annotationType = "Given";
            } else {
                annotationType = "When";
            }
        } else {
            annotationType = "When"; // Default
        }
        
        // Extract step text without the prefix
        String stepText = gherkinStep;
        if (stepText.startsWith("Given ")) {
            stepText = stepText.substring(6);
        } else if (stepText.startsWith("When ")) {
            stepText = stepText.substring(5);
        } else if (stepText.startsWith("Then ")) {
            stepText = stepText.substring(5);
        } else if (stepText.startsWith("And ")) {
            stepText = stepText.substring(4);
        }
        
        // Create method signature with appropriate parameters
        String methodName = generateMethodName(step, stepText);
        String regex = createStepRegex(stepText);
        List<String> parameters = extractParameters(step, stepText);
        
        method.append("    @").append(annotationType).append("(\"").append(regex).append("\")\n");
        method.append("    public void ").append(methodName).append("(");
        
        // Add parameters
        if (!parameters.isEmpty()) {
            method.append(String.join(", ", parameters));
        }
        
        method.append(") {\n");
        
        // Method implementation
        method.append(generateMethodImplementation(step, parameters));
        
        method.append("    }\n");
        
        return method.toString();
    }
    
    /**
     * Standardize step text to check for duplicates
     */
    private String standardizeStepText(String gherkinStep) {
        // Remove prefix (Given/When/Then/And)
        String[] parts = gherkinStep.split(" ", 2);
        if (parts.length < 2) {
            return gherkinStep;
        }
        
        // Remove quotes and specific values
        return parts[1].replaceAll("\"[^\"]*\"", "\"\"");
    }
    
    /**
     * Generate method name from step
     */
    private String generateMethodName(RecordedStep step, String stepText) {
        // Convert step text to camel case method name
        String baseMethodName;
        
        switch (step.getAction()) {
            case "NAVIGATE":
                baseMethodName = "navigateTo";
                break;
            case "CLICK":
                baseMethodName = "clickOn";
                break;
            case "TYPE":
                baseMethodName = "enterValueIn";
                break;
            case "SELECT":
                baseMethodName = "selectValueFrom";
                break;
            case "VERIFY_PRESENCE":
            case "VERIFY_VISIBILITY":
                baseMethodName = "verifyElementVisible";
                break;
            case "VERIFY_TEXT":
                baseMethodName = "verifyTextInElement";
                break;
            case "WAIT":
                baseMethodName = "waitForElement";
                break;
            case "HOVER":
                baseMethodName = "hoverOverElement";
                break;
            default:
                baseMethodName = "perform" + step.getAction().substring(0, 1).toUpperCase() + 
                               step.getAction().substring(1).toLowerCase();
        }
        
        // Add element name if applicable
        if (step.getElement() != null && !step.getElement().isEmpty()) {
            String elementName = formatElementName(step.getElement());
            String[] nameParts = elementName.split("\\s+");
            
            StringBuilder elementNameCamel = new StringBuilder();
            for (String part : nameParts) {
                if (elementNameCamel.length() == 0) {
                    elementNameCamel.append(part.toLowerCase());
                } else {
                    elementNameCamel.append(part.substring(0, 1).toUpperCase());
                    if (part.length() > 1) {
                        elementNameCamel.append(part.substring(1).toLowerCase());
                    }
                }
            }
            
            baseMethodName += "The" + 
                            elementNameCamel.substring(0, 1).toUpperCase() + 
                            elementNameCamel.substring(1);
        }
        
        return baseMethodName;
    }
    
    /**
     * Create regex pattern for step definition
     */
    private String createStepRegex(String stepText) {
        // Convert string literals in quotes to regex capture groups
        return stepText.replaceAll("\"([^\"]*)\"", "\"(.*)\"")
                      // Convert element names to capture groups if they're not already
                      .replaceAll("the ([a-z\\s]+) (button|field|dropdown|checkbox|link|icon|tab)", "the (.*) $2");
    }
    
    /**
     * Extract parameters from step text
     */
    private List<String> extractParameters(RecordedStep step, String stepText) {
        List<String> parameters = new ArrayList<>();
        
        // Extract string parameters
        Pattern pattern = Pattern.compile("\"([^\"]*)\"");
        Matcher matcher = pattern.matcher(stepText);
        
        int paramCount = 0;
        while (matcher.find()) {
            paramCount++;
            parameters.add("String param" + paramCount);
        }
        
        // Extract element parameters if not already captured
        if (step.getElement() != null && !step.getElement().isEmpty() && 
            !stepText.contains("\"" + step.getElement() + "\"")) {
            Pattern elementPattern = Pattern.compile("the ([a-z\\s]+) (button|field|dropdown|checkbox|link|icon|tab)");
            Matcher elementMatcher = elementPattern.matcher(stepText);
            
            if (elementMatcher.find()) {
                parameters.add("String elementName");
            }
        }
        
        return parameters;
    }
    
    /**
     * Generate method implementation
     */
    private String generateMethodImplementation(RecordedStep step, List<String> parameters) {
        StringBuilder implementation = new StringBuilder();
        String formattedElement = step.getElement() != null ? formatElementName(step.getElement()) : null;
        String locatorConstant = formattedElement != null ? convertToConstantName(formattedElement) : null;
        
        switch (step.getAction()) {
            case "NAVIGATE":
                if (parameters.isEmpty()) {
                    implementation.append("        driver.get(\"").append(step.getValue()).append("\");\n");
                } else {
                    implementation.append("        driver.get(param1);\n");
                }
                break;
                
            case "CLICK":
                implementation.append("        // Find and click on the element\n");
                if (locatorConstant != null) {
                    implementation.append("        WebElement element = elementFinder.findElement(").append(locatorConstant).append(");\n");
                } else {
                    implementation.append("        WebElement element = elementFinder.findElement(getLocator(elementName));\n");
                }
                implementation.append("        element.click();\n");
                break;
                
            case "TYPE":
                implementation.append("        // Find the element and enter text\n");
                if (locatorConstant != null) {
                    implementation.append("        WebElement element = elementFinder.findElement(").append(locatorConstant).append(");\n");
                } else {
                    implementation.append("        WebElement element = elementFinder.findElement(getLocator(elementName));\n");
                }
                implementation.append("        element.clear();\n");
                if (parameters.size() > 0) {
                    implementation.append("        element.sendKeys(param1);\n");
                } else {
                    implementation.append("        element.sendKeys(\"").append(step.getValue()).append("\");\n");
                }
                break;
                
            case "SELECT":
                implementation.append("        // Find the dropdown and select option\n");
                if (locatorConstant != null) {
                    implementation.append("        WebElement element = elementFinder.findElement(").append(locatorConstant).append(");\n");
                } else {
                    implementation.append("        WebElement element = elementFinder.findElement(getLocator(elementName));\n");
                }
                implementation.append("        org.openqa.selenium.support.ui.Select select = new org.openqa.selenium.support.ui.Select(element);\n");
                if (parameters.size() > 0) {
                    implementation.append("        select.selectByVisibleText(param1);\n");
                } else {
                    implementation.append("        select.selectByVisibleText(\"").append(step.getValue()).append("\");\n");
                }
                break;
                
            case "VERIFY_PRESENCE":
            case "VERIFY_VISIBILITY":
                implementation.append("        // Verify element is visible\n");
                if (locatorConstant != null) {
                    implementation.append("        boolean isVisible = elementFinder.isElementVisible(").append(locatorConstant).append(");\n");
                } else {
                    implementation.append("        boolean isVisible = elementFinder.isElementVisible(getLocator(elementName));\n");
                }
                implementation.append("        Assert.assertTrue(isVisible, \"Element should be visible\");\n");
                break;
                
            case "VERIFY_TEXT":
                implementation.append("        // Verify element contains text\n");
                if (locatorConstant != null) {
                    implementation.append("        WebElement element = elementFinder.findElement(").append(locatorConstant).append(");\n");
                } else {
                    implementation.append("        WebElement element = elementFinder.findElement(getLocator(elementName));\n");
                }
                if (parameters.size() > 0) {
                    implementation.append("        Assert.assertTrue(element.getText().contains(param1), \"Element should contain the expected text\");\n");
                } else {
                    implementation.append("        Assert.assertTrue(element.getText().contains(\"").append(step.getValue()).append("\"), \"Element should contain the expected text\");\n");
                }
                break;
                
            case "WAIT":
                implementation.append("        // Wait for element to be visible\n");
                if (locatorConstant != null) {
                    implementation.append("        elementFinder.waitForElementVisible(").append(locatorConstant).append(");\n");
                } else {
                    implementation.append("        elementFinder.waitForElementVisible(getLocator(elementName));\n");
                }
                break;
                
            case "HOVER":
                implementation.append("        // Hover over element\n");
                if (locatorConstant != null) {
                    implementation.append("        WebElement element = elementFinder.findElement(").append(locatorConstant).append(");\n");
                } else {
                    implementation.append("        WebElement element = elementFinder.findElement(getLocator(elementName));\n");
                }
                implementation.append("        actions.moveToElement(element).perform();\n");
                break;
                
            default:
                implementation.append("        // TODO: Implement action for ").append(step.getAction()).append("\n");
                break;
        }
        
        // Add helper method for dynamic locator if needed
        if (locatorConstant == null && step.getElement() != null && !step.getElement().isEmpty()) {
            implementation.append("\n        // Helper method to determine locator\n");
            implementation.append("        private String getLocator(String elementName) {\n");
            implementation.append("            // Generate appropriate locator based on element name\n");
            implementation.append("            if (elementName.contains(\"button\")) {\n");
            implementation.append("                return \"//button[contains(text(), '\" + elementName.replace(\" button\", \"\") + \"')]\";\n");
            implementation.append("            } else if (elementName.contains(\"field\") || elementName.contains(\"input\")) {\n");
            implementation.append("                String fieldName = elementName.replace(\" field\", \"\").replace(\" input\", \"\");\n");
            implementation.append("                return \"//input[@id='\" + toCamelCase(fieldName) + \"' or @name='\" + toCamelCase(fieldName) + \"']\";\n");
            implementation.append("            }\n");
            implementation.append("            // Default fallback\n");
            implementation.append("            return \"//*[contains(text(), '\" + elementName + \"')]\";\n");
            implementation.append("        }\n");
        }
        
        return implementation.toString();
    }
}


package com.cssmart.ui.recorder.generator;

import lombok.extern.slf4j.Slf4j;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

/**
 * Utilities for generating step definitions from recorded test steps
 */
@Slf4j
public class StepDefinitionUtils {
    
    private static final Pattern ELEMENT_TYPE_PATTERN = Pattern.compile("([a-zA-Z]+)\\s+(button|field|dropdown|select|checkbox|radio|link|icon|menu|tab|panel)");
    
    /**
     * Generate an element identifier from an element description
     * @param elementDesc Element description (e.g. "login button", "username field")
     * @return Element identifier in camelCase (e.g. "loginButton", "usernameField")
     */
    public static String generateElementId(String elementDesc) {
        if (elementDesc == null || elementDesc.isEmpty()) {
            return "element";
        }
        
        Matcher matcher = ELEMENT_TYPE_PATTERN.matcher(elementDesc.toLowerCase());
        
        if (matcher.find()) {
            String name = matcher.group(1);
            String type = matcher.group(2);
            
            return toCamelCase(name) + capitalize(type);
        } else {
            // If pattern doesn't match, just convert the whole string to camelCase
            return toCamelCase(elementDesc);
        }
    }
    
    /**
     * Generate an element locator based on element description
     * @param elementDesc Element description
     * @return XPath or CSS selector for the element
     */
    public static String generateElementLocator(String elementDesc) {
        if (elementDesc == null || elementDesc.isEmpty()) {
            return "//body";
        }
        
        elementDesc = elementDesc.toLowerCase();
        Matcher matcher = ELEMENT_TYPE_PATTERN.matcher(elementDesc);
        
        if (matcher.find()) {
            String name = matcher.group(1);
            String type = matcher.group(2);
            
            // Generate locator based on element type
            switch (type) {
                case "button":
                    return String.format("//button[contains(text(),'%s') or @id='%s' or @name='%s']", 
                        name, toCamelCase(name + "Button"), toCamelCase(name + "Button"));
                    
                case "field":
                case "input":
                    return String.format("//input[@id='%s' or @name='%s']", 
                        toCamelCase(name + "Field"), toCamelCase(name + "Field"));
                    
                case "dropdown":
                case "select":
                    return String.format("//select[@id='%s' or @name='%s']", 
                        toCamelCase(name + "Select"), toCamelCase(name));
                    
                case "checkbox":
                    return String.format("//input[@type='checkbox' and (@id='%s' or @name='%s')]", 
                        toCamelCase(name + "Checkbox"), toCamelCase(name));
                    
                case "radio":
                    return String.format("//input[@type='radio' and (@id='%s' or @name='%s')]", 
                        toCamelCase(name + "Radio"), toCamelCase(name));
                    
                case "link":
                    return String.format("//a[contains(text(),'%s') or @id='%s' or @title='%s']", 
                        name, toCamelCase(name + "Link"), name);
                    
                case "icon":
                    return String.format("//*[contains(@class,'icon') and contains(@class,'%s')]", 
                        toKebabCase(name));
                    
                case "menu":
                    return String.format("//*[contains(@class,'menu') and contains(text(),'%s')]", name);
                    
                case "tab":
                    return String.format("//*[contains(@class,'tab') and contains(text(),'%s')]", name);
                    
                case "panel":
                    return String.format("//*[contains(@class,'panel') and contains(@id,'%s')]", 
                        toCamelCase(name + "Panel"));
                    
                default:
                    return String.format("//*[contains(text(),'%s') or @id='%s' or @name='%s']", 
                        elementDesc, toCamelCase(elementDesc), toCamelCase(elementDesc));
            }
        } else {
            // Generic locator if no specific pattern is matched
            return String.format("//*[contains(text(),'%s') or @id='%s' or @name='%s']", 
                elementDesc, toCamelCase(elementDesc), toCamelCase(elementDesc));
        }
    }
    
    /**
     * Create a Gherkin step regex from a plain text step
     * @param step Plain text step (e.g. "the user clicks on the login button")
     * @return Regex pattern for step definition (e.g. "the user clicks on the (.*) button")
     */
    public static String createStepRegex(String step) {
        // Replace literal values in quotes with regex capture groups
        String regex = step.replaceAll("\"([^\"]*)\"", "\"(.*)\"");
        
        // Replace element descriptions with regex capture groups
        Matcher matcher = ELEMENT_TYPE_PATTERN.matcher(regex);
        if (matcher.find()) {
            regex = regex.replaceAll("the ([a-zA-Z]+) (button|field|dropdown|select|checkbox|radio|link|icon|menu|tab|panel)",
                                    "the (.*) $2");
        }
        
        return "^" + regex + "$";
    }
    
    /**
     * Extract parameter types from a step
     * @param step Gherkin step
     * @return List of parameter types for the step definition method
     */
    public static List<String> extractParameterTypes(String step) {
        List<String> params = new ArrayList<>();
        
        // Extract string literals in quotes
        Pattern stringPattern = Pattern.compile("\"([^\"]*)\"");
        Matcher stringMatcher = stringPattern.matcher(step);
        
        while (stringMatcher.find()) {
            params.add("String");
        }
        
        // Extract element names
        Pattern elementPattern = Pattern.compile("the ([a-zA-Z]+) (button|field|dropdown|select|checkbox|radio|link|icon|menu|tab|panel)");
        Matcher elementMatcher = elementPattern.matcher(step);
        
        while (elementMatcher.find()) {
            params.add("String");
        }
        
        return params;
    }
    
    /**
     * Generate a method name from a Gherkin step
     * @param step Gherkin step
     * @return Camel case method name
     */
    public static String generateMethodName(String step) {
        // Remove prefix (Given/When/Then/And)
        String[] parts = step.split(" ", 2);
        String stepText = parts.length > 1 ? parts[1] : step;
        
        // Replace element type patterns with simpler tokens
        Matcher matcher = ELEMENT_TYPE_PATTERN.matcher(stepText);
        if (matcher.find()) {
            stepText = stepText.replaceAll("the ([a-zA-Z]+) (button|field|dropdown|select|checkbox|radio|link|icon|menu|tab|panel)",
                                         "$1_$2");
        }
        
        // Remove quotes and their content
        stepText = stepText.replaceAll("\"[^\"]*\"", "Value");
        
        // Convert to camel case
        return toCamelCase(stepText);
    }
    
    /**
     * Convert a string to camelCase
     * @param input Input string
     * @return camelCase string
     */
    public static String toCamelCase(String input) {
        if (input == null || input.isEmpty()) {
            return "";
        }
        
        StringBuilder result = new StringBuilder();
        boolean capitalizeNext = false;
        
        for (char c : input.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                if (capitalizeNext) {
                    result.append(Character.toUpperCase(c));
                    capitalizeNext = false;
                } else {
                    result.append(Character.toLowerCase(c));
                }
            } else {
                capitalizeNext = true;
            }
        }
        
        // Ensure the first character is lowercase
        if (result.length() > 0) {
            char firstChar = result.charAt(0);
            result.setCharAt(0, Character.toLowerCase(firstChar));
        }
        
        return result.toString();
    }
    
    /**
     * Convert a string to kebab-case
     * @param input Input string
     * @return kebab-case string
     */
    public static String toKebabCase(String input) {
        if (input == null || input.isEmpty()) {
            return "";
        }
        
        return input.toLowerCase().replaceAll("[^a-z0-9]", "-").replaceAll("-+", "-");
    }
    
    /**
     * Capitalize the first letter of a string
     * @param input Input string
     * @return String with first letter capitalized
     */
    public static String capitalize(String input) {
        if (input == null || input.isEmpty()) {
            return input;
        }
        
        return Character.toUpperCase(input.charAt(0)) + (input.length() > 1 ? input.substring(1) : "");
    }
}

package com.cssmart.ui.service;

import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.recorder.model.RecordedStep;
import com.cssmart.ui.recorder.generator.BDDFeatureGenerator;
import com.cssmart.ui.recorder.generator.StepDefinitionUtils;
import com.cssmart.ai.engine.AIEngine;
import lombok.extern.slf4j.Slf4j;
import lombok.Data;
import lombok.Builder;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Map;
import java.util.HashMap;
import java.util.UUID;

/**
 * Service for generating BDD tests from recorded test cases
 */
@Slf4j
@Service
public class BDDTestGeneratorService {

    private final AIEngine aiEngine;
    private final BDDFeatureGenerator featureGenerator;
    private static final String FEATURE_FILES_DIR = "src/test/resources/features";
    private static final String STEP_DEFS_DIR = "src/test/java/com/cssmart/stepdefs";
    private final Map<String, BDDTestSuite> generatedSuites = new HashMap<>();
    
    @Autowired
    public BDDTestGeneratorService(AIEngine aiEngine) {
        this.aiEngine = aiEngine;
        this.featureGenerator = new BDDFeatureGenerator();
        
        // Ensure directories exist
        createDirectories();
    }
    
    /**
     * Generate BDD tests from a recorded test case
     * @param testCase Recorded test case
     * @return BDD test suite with feature file and step definitions
     */
    public BDDTestSuite generateBDDTests(TestCase testCase) {
        log.info("Generating BDD tests for test case: {}", testCase.getName());
        
        try {
            // Generate a unique ID for this test suite
            String suiteId = UUID.randomUUID().toString();
            
            // Use AI to enhance test steps if available
            TestCase enhancedTestCase = enhanceTestCase(testCase);
            
            // Generate feature file
            String featureContent = featureGenerator.generateFeatureFile(enhancedTestCase);
            
            // Generate step definitions
            String stepDefsContent = featureGenerator.generateStepDefinitions(enhancedTestCase);
            
            // Generate runner class
            String runnerClass = generateRunnerClass(enhancedTestCase);
            
            // Generate page object for the test
            String pageObjectContent = generatePageObject(enhancedTestCase);
            
            // Create BDD test suite object
            BDDTestSuite testSuite = BDDTestSuite.builder()
                .id(suiteId)
                .testCaseName(enhancedTestCase.getName())
                .featureFile(featureContent)
                .stepDefinitions(stepDefsContent)
                .runnerClass(runnerClass)
                .pageObject(pageObjectContent)
                .build();
            
            // Save to disk
            saveTestSuiteToDisk(testSuite, enhancedTestCase);
            
            // Store in memory
            generatedSuites.put(suiteId, testSuite);
            
            return testSuite;
        } catch (Exception e) {
            log.error("Error generating BDD tests", e);
            throw new RuntimeException("Failed to generate BDD tests: " + e.getMessage(), e);
        }
    }
    
    /**
     * Get a previously generated BDD test suite by ID
     * @param id Test suite ID
     * @return BDD test suite or null if not found
     */
    public BDDTestSuite getBDDTestSuite(String id) {
        return generatedSuites.get(id);
    }
    
    /**
     * Use AI to enhance test steps
     * @param testCase Original test case
     * @return Enhanced test case
     */
    private TestCase enhanceTestCase(TestCase testCase) {
        // Clone the test case to avoid modifying the original
        TestCase enhancedTestCase = new TestCase();
        enhancedTestCase.setId(testCase.getId());
        enhancedTestCase.setName(testCase.getName());
        enhancedTestCase.setDescription(testCase.getDescription());
        enhancedTestCase.setClassName(testCase.getClassName());
        enhancedTestCase.setMethodName(testCase.getMethodName());
        enhancedTestCase.setCode(testCase.getCode());
        enhancedTestCase.setStartTime(testCase.getStartTime());
        enhancedTestCase.setEndTime(testCase.getEndTime());
        
        // Enhance with AI if possible
        if (aiEngine != null && testCase.getSteps() != null) {
            try {
                // AI-based enhancement would happen here
                // For now, we'll just make some basic improvements manually
                enhancedTestCase.setSteps(enhanceSteps(testCase.getSteps()));
            } catch (Exception e) {
                log.warn("Could not enhance test steps with AI, using original steps", e);
                enhancedTestCase.setSteps(testCase.getSteps());
            }
        } else {
            enhancedTestCase.setSteps(testCase.getSteps());
        }
        
        return enhancedTestCase;
    }
    
    /**
     * Enhance recorded steps with better naming and descriptions
     * @param steps Original steps
     * @return Enhanced steps
     */
    private java.util.List<RecordedStep> enhanceSteps(java.util.List<RecordedStep> steps) {
        if (steps == null || steps.isEmpty()) {
            return steps;
        }
        
        java.util.List<RecordedStep> enhancedSteps = new java.util.ArrayList<>(steps.size());
        
        for (RecordedStep step : steps) {
            RecordedStep enhancedStep = new RecordedStep();
            enhancedStep.setAction(step.getAction());
            enhancedStep.setTimestamp(step.getTimestamp());
            
            // Improve element names
            if (step.getElement() != null && !step.getElement().isEmpty()) {
                String elementDesc = step.getElement();
                
                // Check if element already has a type suffix
                if (!elementDesc.toLowerCase().matches(".*(button|field|dropdown|select|checkbox|radio|link|icon|menu|tab|panel).*")) {
                    // Guess element type based on action
                    if ("CLICK".equals(step.getAction())) {
                        elementDesc += " button";
                    } else if ("TYPE".equals(step.getAction())) {
                        elementDesc += " field";
                    } else if ("SELECT".equals(step.getAction())) {
                        elementDesc += " dropdown";
                    }
                }
                
                enhancedStep.setElement(elementDesc);
            } else {
                enhancedStep.setElement(step.getElement());
            }
            
            enhancedStep.setValue(step.getValue());
            
            // Improve step descriptions
            if (step.getDescription() == null || step.getDescription().isEmpty()) {
                enhancedStep.setDescription(generateStepDescription(step));
            } else {
                enhancedStep.setDescription(step.getDescription());
            }
            
            enhancedSteps.add(enhancedStep);
        }
        
        return enhancedSteps;
    }
    
    /**
     * Generate a descriptive step description
     * @param step Recorded step
     * @return Human-readable description
     */
    private String generateStepDescription(RecordedStep step) {
        String elementDesc = step.getElement() != null ? step.getElement() : "element";
        
        switch (step.getAction()) {
            case "NAVIGATE":
                return "Navigate to " + step.getValue();
                
            case "CLICK":
                return "Click on the " + elementDesc;
                
            case "TYPE":
                return "Enter '" + step.getValue() + "' in the " + elementDesc;
                
            case "SELECT":
                return "Select '" + step.getValue() + "' from the " + elementDesc;
                
            case "VERIFY_PRESENCE":
                return "Verify the " + elementDesc + " is present";
                
            case "VERIFY_VISIBILITY":
                return "Verify the " + elementDesc + " is visible";
                
            case "VERIFY_TEXT":
                return "Verify the " + elementDesc + " contains text '" + step.getValue() + "'";
                
            case "WAIT":
                return "Wait for the " + elementDesc + " to appear";
                
            case "HOVER":
                return "Hover over the " + elementDesc;
                
            default:
                return step.getAction() + " on " + elementDesc;
        }
    }
    
    /**
     * Generate a Cucumber runner class
     * @param testCase Test case
     * @return Java code for runner class
     */
    private String generateRunnerClass(TestCase testCase) {
        String className = testCase.getClassName().replace("Test", "Runner");
        String featureName = testCase.getName().replace(" Test", "").replace(" ", "");
        
        StringBuilder code = new StringBuilder();
        code.append("package com.cssmart.runner;\n\n");
        code.append("import io.cucumber.testng.AbstractTestNGCucumberTests;\n");
        code.append("import io.cucumber.testng.CucumberOptions;\n\n");
        
        code.append("/**\n");
        code.append(" * Cucumber runner for ").append(testCase.getName()).append("\n");
        code.append(" */\n");
        code.append("@CucumberOptions(\n");
        code.append("    features = \"src/test/resources/features/").append(featureName).append(".feature\",\n");
        code.append("    glue = {\"com.cssmart.stepdefs\"},\n");
        code.append("    plugin = {\n");
        code.append("        \"pretty\",\n");
        code.append("        \"html:target/cucumber-reports/").append(featureName).append(".html\",\n");
        code.append("        \"json:target/cucumber-reports/").append(featureName).append(".json\"\n");
        code.append("    },\n");
        code.append("    monochrome = true\n");
        code.append(")\n");
        code.append("public class ").append(className).append(" extends AbstractTestNGCucumberTests {\n");
        code.append("    // Runner class\n");
        code.append("}\n");
        
        return code.toString();
    }
    
    /**
     * Generate a page object for the test case
     * @param testCase Test case
     * @return Java code for page object
     */
    private String generatePageObject(TestCase testCase) {
        String pageName = testCase.getName().replace(" Test", "Page").replace(" ", "");
        
        StringBuilder code = new StringBuilder();
        code.append("package com.cssmart.pages;\n\n");
        code.append("import com.cssmart.core.base.BasePage;\n");
        code.append("import org.openqa.selenium.WebDriver;\n");
        code.append("import org.openqa.selenium.WebElement;\n");
        code.append("import org.openqa.selenium.support.FindBy;\n");
        code.append("import org.openqa.selenium.support.PageFactory;\n\n");
        
        code.append("/**\n");
        code.append(" * Page object for ").append(testCase.getName()).append("\n");
        code.append(" */\n");
        code.append("public class ").append(pageName).append(" extends BasePage {\n\n");
        
        // Add element locators
        if (testCase.getSteps() != null) {
            for (RecordedStep step : testCase.getSteps()) {
                if (step.getElement() != null && !step.getElement().isEmpty()) {
                    String elementId = StepDefinitionUtils.generateElementId(step.getElement());
                    String locator = StepDefinitionUtils.generateElementLocator(step.getElement());
                    
                    code.append("    @FindBy(xpath = \"").append(locator).append("\")\n");
                    code.append("    private WebElement ").append(elementId).append(";\n\n");
                }
            }
        }
        
        // Constructor
        code.append("    /**\n");
        code.append("     * Constructor\n");
        code.append("     * @param driver WebDriver instance\n");
        code.append("     */\n");
        code.append("    public ").append(pageName).append("(WebDriver driver) {\n");
        code.append("        super(driver);\n");
        code.append("        PageFactory.initElements(driver, this);\n");
        code.append("    }\n\n");
        
        // Add methods for each step
        if (testCase.getSteps() != null) {
            for (RecordedStep step : testCase.getSteps()) {
                if (step.getElement() != null && !step.getElement().isEmpty()) {
                    String elementId = StepDefinitionUtils.generateElementId(step.getElement());
                    
                    switch (step.getAction()) {
                        case "CLICK":
                            code.append("    /**\n");
                            code.append("     * Click on ").append(step.getElement()).append("\n");
                            code.append("     */\n");
                            code.append("    public void click").append(StepDefinitionUtils.capitalize(elementId)).append("() {\n");
                            code.append("        waitForElementClickable(").append(elementId).append(");\n");
                            code.append("        ").append(elementId).append(".click();\n");
                            code.append("    }\n\n");
                            break;
                            
                        case "TYPE":
                            code.append("    /**\n");
                            code.append("     * Enter text in ").append(step.getElement()).append("\n");
                            code.append("     * @param text Text to enter\n");
                            code.append("     */\n");
                            code.append("    public void enter").append(StepDefinitionUtils.capitalize(elementId)).append("(String text) {\n");
                            code.append("        waitForElementVisible(").append(elementId).append(");\n");
                            code.append("        ").append(elementId).append(".clear();\n");
                            code.append("        ").append(elementId).append(".sendKeys(text);\n");
                            code.append("    }\n\n");
                            break;
                            
                        case "SELECT":
                            code.append("    /**\n");
                            code.append("     * Select option from ").append(step.getElement()).append("\n");
                            code.append("     * @param option Option to select\n");
                            code.append("     */\n");
                            code.append("    public void select").append(StepDefinitionUtils.capitalize(elementId)).append("(String option) {\n");
                            code.append("        waitForElementVisible(").append(elementId).append(");\n");
                            code.append("        selectByVisibleText(").append(elementId).append(", option);\n");
                            code.append("    }\n\n");
                            break;
                            
                        case "VERIFY_PRESENCE":
                        case "VERIFY_VISIBILITY":
                            code.append("    /**\n");
                            code.append("     * Check if ").append(step.getElement()).append(" is visible\n");
                            code.append("     * @return true if element is visible\n");
                            code.append("     */\n");
                            code.append("    public boolean is").append(StepDefinitionUtils.capitalize(elementId)).append("Visible() {\n");
                            code.append("        return isElementVisible(").append(elementId).append(");\n");
                            code.append("    }\n\n");
                            break;
                            
                        case "VERIFY_TEXT":
                            code.append("    /**\n");
                            code.append("     * Get text from ").append(step.getElement()).append("\n");
                            code.append("     * @return Element text\n");
                            code.append("     */\n");
                            code.append("    public String get").append(StepDefinitionUtils.capitalize(elementId)).append("Text() {\n");
                            code.append("        waitForElementVisible(").append(elementId).append(");\n");
                            code.append("        return ").append(elementId).append(".getText();\n");
                            code.append("    }\n\n");
                            break;
                    }
                }
            }
        }
        
        code.append("}\n");
        return code.toString();
    }
    
    /**
     * Create necessary directories
     */
    private void createDirectories() {
        try {
            // Create feature files directory
            File featuresDir = new File(FEATURE_FILES_DIR);
            if (!featuresDir.exists()) {
                featuresDir.mkdirs();
            }
            
            // Create step definitions directory
            File stepDefsDir = new File(STEP_DEFS_DIR);
            if (!stepDefsDir.exists()) {
                stepDefsDir.mkdirs();
            }
            
            // Create runners directory
            File runnersDir = new File("src/test/java/com/cssmart/runner");
            if (!runnersDir.exists()) {
                runnersDir.mkdirs();
            }
            
            // Create page objects directory
            File pagesDir = new File("src/test/java/com/cssmart/pages");
            if (!pagesDir.exists()) {
                pagesDir.mkdirs();
            }
        } catch (Exception e) {
            log.error("Error creating directories", e);
        }
    }
    
    /**
     * Save test suite to disk
     * @param testSuite BDD test suite
     * @param testCase Original test case
     */
    private void saveTestSuiteToDisk(BDDTestSuite testSuite, TestCase testCase) {
        try {
            String featureName = testCase.getName().replace(" Test", "").replace(" ", "");
            String stepClassName = testCase.getClassName().replace("Test", "Steps");
            String runnerClassName = testCase.getClassName().replace("Test", "Runner");
            String pageName = testCase.getName().replace(" Test", "Page").replace(" ", "");
            
            // Save feature file
            String featurePath = FEATURE_FILES_DIR + "/" + featureName + ".feature";
            Files.write(Paths.get(featurePath), testSuite.getFeatureFile().getBytes());
            log.info("Saved feature file: {}", featurePath);
            
            // Save step definitions
            String stepDefsPath = STEP_DEFS_DIR + "/" + stepClassName + ".java";
            Files.write(Paths.get(stepDefsPath), testSuite.getStepDefinitions().getBytes());
            log.info("Saved step definitions: {}", stepDefsPath);
            
            // Save runner class
            String runnerPath = "src/test/java/com/cssmart/runner/" + runnerClassName + ".java";
            Files.write(Paths.get(runnerPath), testSuite.getRunnerClass().getBytes());
            log.info("Saved runner class: {}", runnerPath);
            
            // Save page object
            String pagePath = "src/test/java/com/cssmart/pages/" + pageName + ".java";
            Files.write(Paths.get(pagePath), testSuite.getPageObject().getBytes());
            log.info("Saved page object: {}", pagePath);
        } catch (Exception e) {
            log.error("Error saving test suite to disk", e);
        }
    }
    
    /**
     * BDD Test Suite data structure
     */
    @Data
    @Builder
    public static class BDDTestSuite {
        private String id;
        private String testCaseName;
        private String featureFile;
        private String stepDefinitions;
        private String runnerClass;
        private String pageObject;
    }
}


import React, { useState } from 'react';
import { Tabs, Tab } from '@/components/ui/tabs';
import Button from '../common/Button';
import Spinner from '../common/Spinner';
import Alert from '../common/Alert';

const BDDTestViewer = ({ bddTest, loading, onRun }) => {
  const [activeTab, setActiveTab] = useState('feature');
  const [copied, setCopied] = useState(false);
  const [runningTests, setRunningTests] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);
  
  if (!bddTest && !loading) {
    return (
      <div className="bg-white rounded-lg shadow p-6">
        <div className="text-center py-6 text-gray-500">
          No BDD tests generated yet. Generate BDD tests to see them here.
        </div>
      </div>
    );
  }
  
  // Handle copy to clipboard
  const copyToClipboard = (content) => {
    navigator.clipboard.writeText(content).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    });
  };
  
  // Handle running tests
  const handleRunTests = () => {
    setRunningTests(true);
    setError(null);
    setSuccess(null);
    
    if (onRun) {
      onRun()
        .then(result => {
          setSuccess('Tests executed successfully!');
        })
        .catch(err => {
          setError('Failed to run tests: ' + err.message);
        })
        .finally(() => {
          setRunningTests(false);
        });
    } else {
      // Simulate test execution
      setTimeout(() => {
        setSuccess('Tests executed successfully!');
        setRunningTests(false);
      }, 2000);
    }
  };
  
  // Determine which content to show
  const getContent = () => {
    if (loading) {
      return (
        <div className="flex justify-center items-center py-12">
          <Spinner size="lg" className="mr-3" />
          <span className="text-gray-600">Generating BDD Tests...</span>
        </div>
      );
    }
    
    let content = '';
    switch (activeTab) {
      case 'feature':
        content = bddTest.featureFile;
        break;
      case 'steps':
        content = bddTest.stepDefinitions;
        break;
      case 'runner':
        content = bddTest.runnerClass;
        break;
      case 'pageObject':
        content = bddTest.pageObject;
        break;
      default:
        content = 'Unknown tab';
    }
    
    return (
      <div>
        <div className="flex justify-between items-center mb-2">
          <div>
            <span className="text-xs text-gray-500">
              {activeTab === 'feature' ? 'Cucumber Feature File' : 
               activeTab === 'steps' ? 'Step Definitions' : 
               activeTab === 'runner' ? 'Test Runner' : 'Page Object'}
            </span>
          </div>
          <Button 
            variant={copied ? "success" : "secondary"} 
            size="sm"
            onClick={() => copyToClipboard(content)}
          >
            {copied ? "Copied!" : "Copy Code"}
          </Button>
        </div>
        
        <div className="bg-gray-900 text-white rounded-md overflow-auto">
          <pre className="p-4 text-sm font-mono overflow-x-auto whitespace-pre">
            {content}
          </pre>
        </div>
      </div>
    );
  };
  
  return (
    <div className="bg-white rounded-lg shadow">
      <div className="p-4 border-b">
        <div className="flex justify-between items-center">
          <h3 className="text-lg font-medium">BDD Test Suite</h3>
          <Button
            variant="primary"
            size="sm"
            onClick={handleRunTests}
            disabled={loading || runningTests}
          >
            {runningTests ? (
              <>
                <Spinner size="sm" color="white" className="mr-2" />
                Running Tests...
              </>
            ) : 'Run BDD Tests'}
          </Button>
        </div>
      </div>
      
      {error && (
        <div className="px-4 pt-4">
          <Alert
            type="error"
            title="Error"
            onClose={() => setError(null)}
          >
            {error}
          </Alert>
        </div>
      )}
      
      {success && (
        <div className="px-4 pt-4">
          <Alert
            type="success"
            title="Success"
            onClose={() => setSuccess(null)}
          >
            {success}
          </Alert>
        </div>
      )}
      
      <div className="p-4 border-b">
        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <Tab value="feature" label="Feature File" />
          <Tab value="steps" label="Step Definitions" />
          <Tab value="runner" label="Runner" />
          <Tab value="pageObject" label="Page Object" />
        </Tabs>
      </div>
      
      <div className="p-4">
        {getContent()}
      </div>
    </div>
  );
};

export default BDDTestViewer;


// src/main/webapp/src/components/recorder/TestRecorder.jsx
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import RecordedSteps from './RecordedSteps';
import RecorderConfig from './RecorderConfig';
import TestCodeViewer from './TestCodeViewer';
import BDDTestViewer from './BDDTestViewer';
import Button from '../common/Button';
import Card from '../common/Card';
import Alert from '../common/Alert';
import Spinner from '../common/Spinner';
import { Tab, Tabs } from '@/components/ui/tabs';
import { useNotification } from '../../context/NotificationContext';

const TestRecorder = () => {
  const navigate = useNavigate();
  const { addNotification } = useNotification();
  const [isRecording, setIsRecording] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [recordedSteps, setRecordedSteps] = useState([]);
  const [testCase, setTestCase] = useState(null);
  const [bddTestSuite, setBddTestSuite] = useState(null);
  const [loadingBdd, setLoadingBdd] = useState(false);
  const [isGeneratingCode, setIsGeneratingCode] = useState(false);
  const [error, setError] = useState(null);
  const [successMessage, setSuccessMessage] = useState(null);
  const [testFormat, setTestFormat] = useState('testng'); // 'testng' or 'bdd'
  const [config, setConfig] = useState({
    url: 'https://example.com',
    browser: 'chrome',
    headless: false
  });
  const websocket = useRef(null);
  
  // Handle WebSocket cleanup on component unmount
  useEffect(() => {
    return () => {
      if (websocket.current) {
        websocket.current.close();
      }
    };
  }, []);
  
  // Connect to WebSocket when starting recording
  const connectWebSocket = () => {
    try {
      setIsConnecting(true);
      setError(null);
      
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/recorder`;
      
      websocket.current = new WebSocket(wsUrl);
      
      websocket.current.onopen = () => {
        console.log('WebSocket connected');
        setIsConnecting(false);
        
        // Send recording configuration to the server
        websocket.current.send(JSON.stringify({ 
          type: 'START_RECORDING',
          data: config
        }));
      };
      
      websocket.current.onmessage = (event) => {
        const message = JSON.parse(event.data);
        
        if (message.type === 'RECORDING_STARTED') {
          console.log('Recording started');
          setIsRecording(true);
          addNotification('Recording started successfully!', 'success');
        } else if (message.type === 'ACTION_RECORDED') {
          console.log('Action recorded');
        } else if (message.type === 'STEP_RECORDED') {
          console.log('Step recorded:', message.data);
          setRecordedSteps(prev => [...prev, message.data]);
        } else if (message.type === 'TEST_CASE') {
          console.log('Test case received:', message.data);
          setTestCase(message.data);
          setIsRecording(false);
          setIsGeneratingCode(false);
          addNotification('Test recorded successfully!', 'success');
          
          // Reset BDD test suite when new test is recorded
          setBddTestSuite(null);
        } else if (message.type === 'ERROR') {
          console.error('WebSocket error:', message.data);
          setError(`Error: ${message.data}`);
          setIsRecording(false);
          setIsConnecting(false);
          setIsGeneratingCode(false);
          addNotification(`Recording error: ${message.data}`, 'error');
        }
      };
      
      websocket.current.onerror = (error) => {
        console.error('WebSocket error:', error);
        setError('Failed to connect to the recording service. Please check if the server is running.');
        setIsRecording(false);
        setIsConnecting(false);
        addNotification('Failed to connect to recording service', 'error');
      };
      
      websocket.current.onclose = () => {
        console.log('WebSocket disconnected');
        if (isRecording) {
          setIsRecording(false);
          addNotification('Recording connection closed', 'warning');
        }
      };
      
      return true;
    } catch (error) {
      console.error('Error connecting to WebSocket:', error);
      setError(`Connection error: ${error.message}`);
      setIsRecording(false);
      setIsConnecting(false);
      addNotification(`Connection error: ${error.message}`, 'error');
      return false;
    }
  };
  
  // Start recording
  const startRecording = () => {
    setRecordedSteps([]);
    setTestCase(null);
    setBddTestSuite(null);
    setError(null);
    setSuccessMessage(null);
    
    const connected = connectWebSocket();
    if (!connected) {
      setError('Failed to start recording. Could not connect to server.');
    }
  };
  
  // Stop recording
  const stopRecording = () => {
    if (websocket.current && websocket.current.readyState === WebSocket.OPEN) {
      websocket.current.send(JSON.stringify({ type: 'STOP_RECORDING' }));
      setIsGeneratingCode(true);
    } else {
      setError('WebSocket is not connected. Cannot stop recording.');
      addNotification('Cannot stop recording: connection lost', 'error');
    }
  };
  
  // Update configuration
  const updateConfig = (newConfig) => {
    setConfig(newConfig);
  };
  
  // Save test case
  const saveTestCase = async () => {
    if (!testCase) return;
    
    try {
      const response = await fetch('/api/recorder/save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(testCase),
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      setSuccessMessage('Test case saved successfully!');
      addNotification('Test case saved successfully!', 'success');
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(null), 3000);
      
    } catch (error) {
      console.error('Error saving test case:', error);
      setError(`Failed to save test case: ${error.message}`);
      addNotification(`Failed to save test case: ${error.message}`, 'error');
    }
  };
  
  // Generate BDD tests from TestNG test
  const generateBDDTests = async () => {
    if (!testCase || !testCase.id) {
      setError('Please save the test case first');
      return;
    }
    
    try {
      setLoadingBdd(true);
      setError(null);
      
      const response = await fetch(`/api/bdd/generate/${testCase.id}`, {
        method: 'POST',
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      setBddTestSuite(data);
      setTestFormat('bdd');
      setSuccessMessage('BDD tests generated successfully!');
      addNotification('BDD tests generated successfully!', 'success');
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (error) {
      console.error('Error generating BDD tests:', error);
      setError(`Failed to generate BDD tests: ${error.message}`);
      addNotification(`Failed to generate BDD tests: ${error.message}`, 'error');
    } finally {
      setLoadingBdd(false);
    }
  };
  
  // Run BDD tests
  const runBDDTests = async () => {
    if (!bddTestSuite || !bddTestSuite.id) {
      setError('No BDD test suite available to run');
      return;
    }
    
    try {
      const response = await fetch(`/api/bdd/${bddTestSuite.id}/run`, {
        method: 'POST',
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      return result;
    } catch (error) {
      console.error('Error running BDD tests:', error);
      throw error;
    }
  };
  
  // Edit in Test Generator
  const editInGenerator = () => {
    if (!testCase || !testCase.id) {
      addNotification('Please save the test first', 'warning');
      return;
    }
    
    // Navigate to Test Generator with the current test
    navigate('/generator', { state: { testCase } });
  };
  
  // Run test
  const runTest = async () => {
    if (!testCase || !testCase.id) {
      setError('Please save the test first');
      return;
    }
    
    try {
      const response = await fetch(`/api/recorder/${testCase.id}/run`, {
        method: 'POST',
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      setSuccessMessage('Test execution started successfully!');
      addNotification('Test execution started. Check Reports for results.', 'success');
      
      // Redirect to reports page after a delay
      setTimeout(() => {
        navigate('/reports');
      }, 3000);
    } catch (error) {
      console.error('Error running test:', error);
      setError(`Failed to run test: ${error.message}`);
      addNotification(`Failed to run test: ${error.message}`, 'error');
    }
  };
  
  return (
    <div className="space-y-6">
      {/* Header with action buttons */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold">Test Recorder</h1>
        <div className="flex space-x-2">
          {!isRecording ? (
            <Button
              variant="primary"
              disabled={isConnecting}
              onClick={startRecording}
            >
              {isConnecting ? (
                <>
                  <Spinner size="sm" color="white" className="mr-2" />
                  Connecting...
                </>
              ) : (
                'Start Recording'
              )}
            </Button>
          ) : (
            <Button
              variant="danger"
              onClick={stopRecording}
            >
              Stop Recording
            </Button>
          )}
        </div>
      </div>
      
      {/* Error and success messages */}
      {error && (
        <Alert
          type="error"
          title="Recording Error"
          onClose={() => setError(null)}
        >
          {error}
        </Alert>
      )}
      
      {successMessage && (
        <Alert
          type="success"
          title="Success"
          onClose={() => setSuccessMessage(null)}
        >
          {successMessage}
        </Alert>
      )}
      
      {/* Configuration and steps */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <RecorderConfig 
          config={config} 
          updateConfig={updateConfig} 
          disabled={isRecording || isConnecting} 
        />
        
        <RecordedSteps 
          steps={recordedSteps} 
          isRecording={isRecording}
        />
      </div>
      
      {/* Generated code - loading state */}
      {isGeneratingCode && !testCase && (
        <Card>
          <div className="flex justify-center items-center py-6">
            <Spinner size="md" className="mr-3" />
            <span>Generating test code...</span>
          </div>
        </Card>
      )}
      
      {/* Generated code - test case available */}
      {testCase && (
        <Card>
          <div className="p-4 border-b">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-semibold">Generated Test</h2>
              <div className="flex space-x-2">
                <Button
                  variant="secondary"
                  onClick={editInGenerator}
                >
                  Edit in Test Generator
                </Button>
                <Button
                  variant="primary"
                  onClick={saveTestCase}
                >
                  Save Test
                </Button>
                {!bddTestSuite && (
                  <Button
                    variant="outline"
                    onClick={generateBDDTests}
                    disabled={loadingBdd}
                  >
                    {loadingBdd ? (
                      <>
                        <Spinner size="sm" className="mr-2" />
                        Generating BDD...
                      </>
                    ) : 'Generate BDD'}
                  </Button>
                )}
                <Button
                  variant="success"
                  onClick={runTest}
                >
                  Run Test
                </Button>
              </div>
            </div>
            <div className="mb-4">
              <p><strong>Test Name:</strong> {testCase.name}</p>
              <p><strong>Description:</strong> {testCase.description}</p>
            </div>
          </div>
          
          {/* Tabs for TestNG and BDD */}
          {bddTestSuite ? (
            <div>
              <div className="px-4 py-2 border-b">
                <Tabs value={testFormat} onValueChange={setTestFormat}>
                  <Tab value="testng" label="TestNG Code" />
                  <Tab value="bdd" label="BDD Tests" />
                </Tabs>
              </div>
              
              <div className="p-4">
                {testFormat === 'testng' ? (
                  <TestCodeViewer code={testCase.code} />
                ) : (
                  <BDDTestViewer 
                    bddTest={bddTestSuite} 
                    loading={loadingBdd}
                    onRun={runBDDTests}
                  />
                )}
              </div>
            </div>
          ) : (
            <div className="p-4">
              <TestCodeViewer code={testCase.code} />
            </div>
          )}
        </Card>
      )}
      
      {/* Recording indicator */}
      {isRecording && (
        <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-red-600 text-white px-4 py-2 rounded-md shadow-lg animate-pulse">
          Recording in progress... Actions performed in the browser are being captured.
        </div>
      )}
    </div>
  );
};

export default TestRecorder;


// src/main/webapp/src/components/ui/tabs.jsx
import React, { useState, useEffect } from 'react';

export const Tabs = ({ children, value, onValueChange, className = '' }) => {
  const [activeTab, setActiveTab] = useState(value || '');
  
  useEffect(() => {
    if (value !== undefined) {
      setActiveTab(value);
    }
  }, [value]);
  
  const handleTabChange = (tabValue) => {
    if (onValueChange) {
      onValueChange(tabValue);
    } else {
      setActiveTab(tabValue);
    }
  };
  
  // Filter children to only include Tab components
  const tabs = React.Children.toArray(children).filter(
    (child) => React.isValidElement(child) && child.type === Tab
  );
  
  return (
    <div className={`space-y-4 ${className}`}>
      <div className="flex space-x-1 border-b">
        {tabs.map((tab) => {
          const isActive = tab.props.value === activeTab;
          return React.cloneElement(tab, {
            key: tab.props.value,
            isActive,
            onClick: () => handleTabChange(tab.props.value),
          });
        })}
      </div>
    </div>
  );
};

export const Tab = ({ value, label, isActive, onClick }) => {
  return (
    <button
      type="button"
      className={`px-4 py-2 text-sm font-medium border-b-2 ${
        isActive 
          ? 'text-indigo-600 border-indigo-600' 
          : 'text-gray-500 border-transparent hover:text-gray-700 hover:border-gray-300'
      }`}
      onClick={onClick}
    >
      {label}
    </button>
  );
};

package com.cssmart.ui.recorder.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;
import java.time.LocalDateTime;

/**
 * Extended recorded step model with BDD specific fields
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExtendedRecordedStep {
    
    // Base properties from RecordedStep
    private String action;
    private String element;
    private String value;
    private String description;
    private LocalDateTime timestamp;
    
    // BDD specific properties
    private String gherkinStep;      // Complete Gherkin step text (e.g., "Given the user navigates to example.com")
    private String gherkinKeyword;   // Gherkin keyword (Given, When, Then, And)
    private String stepMethod;       // Method name for step definition
    private String elementId;        // Element identifier in camelCase (e.g., "loginButton")
    private String elementLocator;   // Element locator for the UI element (e.g., XPath, CSS selector)
    
    /**
     * Convert a basic RecordedStep to an ExtendedRecordedStep
     * @param step Basic recorded step
     * @return Extended step with BDD properties
     */
    public static ExtendedRecordedStep fromRecordedStep(RecordedStep step) {
        return ExtendedRecordedStep.builder()
            .action(step.getAction())
            .element(step.getElement())
            .value(step.getValue())
            .description(step.getDescription())
            .timestamp(step.getTimestamp())
            .build();
    }
    
    /**
     * Convert back to a basic RecordedStep
     * @return Basic recorded step
     */
    public RecordedStep toRecordedStep() {
        RecordedStep step = new RecordedStep();
        step.setAction(this.action);
        step.setElement(this.element);
        step.setValue(this.value);
        step.setDescription(this.description);
        step.setTimestamp(this.timestamp);
        return step;
    }
}


package com.cssmart.core.base;

import io.cucumber.java.After;
import io.cucumber.java.Before;
import io.cucumber.java.Scenario;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.By;
import lombok.extern.slf4j.Slf4j;

import java.time.Duration;

/**
 * Base class for step definitions
 * Provides common functionality for BDD tests
 */
@Slf4j
public class BaseSteps {
    
    protected WebDriver driver;
    protected WebDriverWait wait;
    protected Actions actions;
    protected final int DEFAULT_TIMEOUT = 10; // seconds
    
    /**
     * Setup before each scenario
     * @param scenario Current scenario
     */
    @Before
    public void setup(Scenario scenario) {
        log.info("Starting scenario: {}", scenario.getName());
        
        // Initialize WebDriver
        driver = DriverFactory.getDriver();
        wait = new WebDriverWait(driver, Duration.ofSeconds(DEFAULT_TIMEOUT));
        actions = new Actions(driver);
        
        driver.manage().window().maximize();
        driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(5));
    }
    
    /**
     * Teardown after each scenario
     * @param scenario Current scenario
     */
    @After
    public void teardown(Scenario scenario) {
        if (scenario.isFailed()) {
            // Take screenshot if scenario fails
            try {
                byte[] screenshot = ((TakesScreenshot) driver).getScreenshotAs(OutputType.BYTES);
                scenario.attach(screenshot, "image/png", "Screenshot");
                log.info("Attached screenshot to failed scenario: {}", scenario.getName());
            } catch (Exception e) {
                log.error("Failed to take screenshot", e);
            }
        }
        
        // Quit WebDriver
        if (driver != null) {
            driver.quit();
        }
        
        log.info("Completed scenario: {} - {}", scenario.getName(), scenario.getStatus());
    }
    
    /**
     * Find an element
     * @param locator Element locator
     * @return WebElement
     */
    protected WebElement findElement(String locator) {
        return driver.findElement(By.xpath(locator));
    }
    
    /**
     * Find an element with CSS selector
     * @param cssSelector CSS selector
     * @return WebElement
     */
    protected WebElement findElementByCSS(String cssSelector) {
        return driver.findElement(By.cssSelector(cssSelector));
    }
    
    /**
     * Wait for element to be visible
     * @param locator Element locator
     * @return WebElement
     */
    protected WebElement waitForElementVisible(String locator) {
        return wait.until(ExpectedConditions.visibilityOfElementLocated(By.xpath(locator)));
    }
    
    /**
     * Wait for element to be clickable
     * @param locator Element locator
     * @return WebElement
     */
    protected WebElement waitForElementClickable(String locator) {
        return wait.until(ExpectedConditions.elementToBeClickable(By.xpath(locator)));
    }
    
    /**
     * Wait for element to be clickable
     * @param element Element
     * @return WebElement
     */
    protected WebElement waitForElementClickable(WebElement element) {
        return wait.until(ExpectedConditions.elementToBeClickable(element));
    }
    
    /**
     * Check if element is visible
     * @param locator Element locator
     * @return true if element is visible
     */
    protected boolean isElementVisible(String locator) {
        try {
            return driver.findElement(By.xpath(locator)).isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Check if element is visible
     * @param element Element
     * @return true if element is visible
     */
    protected boolean isElementVisible(WebElement element) {
        try {
            return element.isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Select option from dropdown by visible text
     * @param element Dropdown element
     * @param text Option text
     */
    protected void selectByVisibleText(WebElement element, String text) {
        new org.openqa.selenium.support.ui.Select(element).selectByVisibleText(text);
    }
    
    /**
     * Helper method to format element locator
     * @param elementName Element name
     * @param elementType Element type (button, field, dropdown, etc.)
     * @return XPath locator
     */
    protected String formatLocator(String elementName, String elementType) {
        switch (elementType) {
            case "button":
                return String.format("//button[contains(text(),'%s') or @id='%s' or contains(@class,'%s')]", 
                    elementName, toCamelCase(elementName), toKebabCase(elementName));
            case "field":
            case "input":
                return String.format("//input[@id='%s' or @name='%s' or @placeholder='%s']", 
                    toCamelCase(elementName), toCamelCase(elementName), elementName);
            case "dropdown":
            case "select":
                return String.format("//select[@id='%s' or @name='%s']", 
                    toCamelCase(elementName), toCamelCase(elementName));
            case "checkbox":
                return String.format("//input[@type='checkbox' and (@id='%s' or @name='%s')]", 
                    toCamelCase(elementName), toCamelCase(elementName));
            case "link":
                return String.format("//a[contains(text(),'%s') or @href='*%s*']", 
                    elementName, elementName.toLowerCase());
            default:
                return String.format("//*[contains(text(),'%s') or @id='%s' or @name='%s']", 
                    elementName, toCamelCase(elementName), toCamelCase(elementName));
        }
    }
    
    /**
     * Convert string to camelCase
     * @param input Input string
     * @return camelCase string
     */
    protected String toCamelCase(String input) {
        if (input == null || input.isEmpty()) {
            return "";
        }
        
        StringBuilder result = new StringBuilder();
        boolean capitalizeNext = false;
        
        for (char c : input.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                if (capitalizeNext) {
                    result.append(Character.toUpperCase(c));
                    capitalizeNext = false;
                } else {
                    result.append(Character.toLowerCase(c));
                }
            } else {
                capitalizeNext = true;
            }
        }
        
        // Ensure first character is lowercase
        if (result.length() > 0) {
            char firstChar = result.charAt(0);
            result.setCharAt(0, Character.toLowerCase(firstChar));
        }
        
        return result.toString();
    }
    
    /**
     * Convert string to kebab-case
     * @param input Input string
     * @return kebab-case string
     */
    protected String toKebabCase(String input) {
        if (input == null || input.isEmpty()) {
            return "";
        }
        
        return input.toLowerCase().replaceAll("[^a-z0-9]", "-").replaceAll("-+", "-");
    }
}


package com.cssmart.core.base;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.By;
import lombok.extern.slf4j.Slf4j;

import java.time.Duration;

/**
 * Base page class for page object pattern
 * Provides common functionality for all page objects
 */
@Slf4j
public class BasePage {
    
    protected WebDriver driver;
    protected WebDriverWait wait;
    protected Actions actions;
    protected JavascriptExecutor js;
    protected final int DEFAULT_TIMEOUT = 10; // seconds
    
    /**
     * Constructor
     * @param driver WebDriver instance
     */
    public BasePage(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(DEFAULT_TIMEOUT));
        this.actions = new Actions(driver);
        this.js = (JavascriptExecutor) driver;
    }
    
    /**
     * Navigate to URL
     * @param url URL to navigate to
     */
    public void navigateTo(String url) {
        driver.get(url);
    }
    
    /**
     * Get current URL
     * @return Current URL
     */
    public String getCurrentUrl() {
        return driver.getCurrentUrl();
    }
    
    /**
     * Get page title
     * @return Page title
     */
    public String getPageTitle() {
        return driver.getTitle();
    }
    
    /**
     * Wait for element to be visible
     * @param element WebElement
     * @return WebElement
     */
    protected WebElement waitForElementVisible(WebElement element) {
        return wait.until(ExpectedConditions.visibilityOf(element));
    }
    
    /**
     * Wait for element to be clickable
     * @param element WebElement
     * @return WebElement
     */
    protected WebElement waitForElementClickable(WebElement element) {
        return wait.until(ExpectedConditions.elementToBeClickable(element));
    }
    
    /**
     * Check if element is visible
     * @param element WebElement
     * @return true if element is visible
     */
    protected boolean isElementVisible(WebElement element) {
        try {
            return element.isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Wait for element with the given locator to be visible
     * @param locator By locator
     * @return WebElement
     */
    protected WebElement waitForElementVisible(By locator) {
        return wait.until(ExpectedConditions.visibilityOfElementLocated(locator));
    }
    
    /**
     * Wait for element with the given locator to be clickable
     * @param locator By locator
     * @return WebElement
     */
    protected WebElement waitForElementClickable(By locator) {
        return wait.until(ExpectedConditions.elementToBeClickable(locator));
    }
    
    /**
     * Check if element with the given locator is visible
     * @param locator By locator
     * @return true if element is visible
     */
    protected boolean isElementVisible(By locator) {
        try {
            return driver.findElement(locator).isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Click on element
     * @param element Element to click
     */
    protected void click(WebElement element) {
        waitForElementClickable(element).click();
    }
    
    /**
     * Enter text in element
     * @param element Element to enter text in
     * @param text Text to enter
     */
    protected void enterText(WebElement element, String text) {
        WebElement visibleElement = waitForElementVisible(element);
        visibleElement.clear();
        visibleElement.sendKeys(text);
    }
    
    /**
     * Select option from dropdown by visible text
     * @param element Dropdown element
     * @param text Option text
     */
    protected void selectByVisibleText(WebElement element, String text) {
        waitForElementVisible(element);
        new org.openqa.selenium.support.ui.Select(element).selectByVisibleText(text);
    }
    
    /**
     * Select option from dropdown by value
     * @param element Dropdown element
     * @param value Option value
     */
    protected void selectByValue(WebElement element, String value) {
        waitForElementVisible(element);
        new org.openqa.selenium.support.ui.Select(element).selectByValue(value);
    }
    
    /**
     * Hover over element
     * @param element Element to hover over
     */
    protected void hoverOverElement(WebElement element) {
        waitForElementVisible(element);
        actions.moveToElement(element).perform();
    }
    
    /**
     * Scroll to element
     * @param element Element to scroll to
     */
    protected void scrollToElement(WebElement element) {
        js.executeScript("arguments[0].scrollIntoView(true);", element);
    }
    
    /**
     * Take screenshot
     * @return Screenshot as byte array
     */
    public byte[] takeScreenshot() {
        return ((org.openqa.selenium.TakesScreenshot) driver).getScreenshotAs(org.openqa.selenium.OutputType.BYTES);
    }
}

package com.cssmart.core.base;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.firefox.FirefoxDriver;
import org.openqa.selenium.firefox.FirefoxOptions;
import org.openqa.selenium.edge.EdgeDriver;
import org.openqa.selenium.edge.EdgeOptions;
import org.openqa.selenium.safari.SafariDriver;
import io.github.bonigarcia.wdm.WebDriverManager;
import lombok.extern.slf4j.Slf4j;

/**
 * Factory for creating WebDriver instances
 */
@Slf4j
public class DriverFactory {
    
    private static final ThreadLocal<WebDriver> drivers = new ThreadLocal<>();
    
    /**
     * Get a WebDriver instance
     * @return WebDriver
     */
    public static WebDriver getDriver() {
        return getDriver("chrome", false);
    }

    
    /**
     * Get a WebDriver instance
     * @param browser Browser type (chrome, firefox, edge, safari)
     * @return WebDriver
     */
    public static WebDriver getDriver(String browser) {
        return getDriver(browser, false);
    }
    
    /**
     * Get a WebDriver instance
     * @param browser Browser type (chrome, firefox, edge, safari)
     * @param headless Whether to run in headless mode
     * @return WebDriver
     */
    public static WebDriver getDriver(String browser, boolean headless) {
        WebDriver driver = drivers.get();
        
        if (driver == null) {
            driver = createDriver(browser, headless);
            drivers.set(driver);
        }
        
        return driver;
    }
    
    /**
     * Create a new WebDriver instance
     * @param browser Browser type (chrome, firefox, edge, safari)
     * @param headless Whether to run in headless mode
     * @return WebDriver
     */
    private static WebDriver createDriver(String browser, boolean headless) {
        WebDriver driver;
        
        switch (browser.toLowerCase()) {
            case "chrome":
                WebDriverManager.chromedriver().setup();
                ChromeOptions chromeOptions = new ChromeOptions();
                if (headless) {
                    chromeOptions.addArguments("--headless");
                }
                chromeOptions.addArguments("--start-maximized");
                chromeOptions.addArguments("--disable-notifications");
                chromeOptions.addArguments("--disable-infobars");
                chromeOptions.setAcceptInsecureCerts(true);
                driver = new ChromeDriver(chromeOptions);
                break;
                
            case "firefox":
                WebDriverManager.firefoxdriver().setup();
                FirefoxOptions firefoxOptions = new FirefoxOptions();
                if (headless) {
                    firefoxOptions.addArguments("--headless");
                }
                firefoxOptions.addArguments("--start-maximized");
                firefoxOptions.setAcceptInsecureCerts(true);
                driver = new FirefoxDriver(firefoxOptions);
                break;
                
            case "edge":
                WebDriverManager.edgedriver().setup();
                EdgeOptions edgeOptions = new EdgeOptions();
                if (headless) {
                    edgeOptions.addArguments("--headless");
                }
                edgeOptions.addArguments("--start-maximized");
                driver = new EdgeDriver(edgeOptions);
                break;
                
            case "safari":
                driver = new SafariDriver();
                break;
                
            default:
                log.warn("Unsupported browser: {}. Using Chrome instead.", browser);
                WebDriverManager.chromedriver().setup();
                driver = new ChromeDriver();
        }
        
        log.info("Created new {} WebDriver instance", browser);
        return driver;
    }
    
    /**
     * Quit the WebDriver instance
     */
    public static void quitDriver() {
        WebDriver driver = drivers.get();
        if (driver != null) {
            driver.quit();
            drivers.remove();
            log.info("WebDriver instance quit and removed from thread local");
        }
    }

package com.cssmart.runner;

import io.cucumber.testng.AbstractTestNGCucumberTests;
import io.cucumber.testng.CucumberOptions;
import org.testng.annotations.DataProvider;

/**
 * Runner for Cucumber tests
 * Configures Cucumber to run with TestNG
 */
@CucumberOptions(
    features = "src/test/resources/features",
    glue = {"com.cssmart.stepdefs"},
    plugin = {
        "pretty",
        "html:target/cucumber-reports/cucumber-pretty.html",
        "json:target/cucumber-reports/cucumber.json",
        "junit:target/cucumber-reports/cucumber-results.xml"
    },
    monochrome = true,
    dryRun = false
)
public class CucumberRunner extends AbstractTestNGCucumberTests {
    
    /**
     * Enable parallel execution of scenarios
     */
    @Override
    @DataProvider(parallel = true)
    public Object[][] scenarios() {
        return super.scenarios();
    }
}

package com.cssmart.core.base;

import org.openqa.selenium.WebDriver;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.ITestResult;
import lombok.extern.slf4j.Slf4j;
import java.lang.reflect.Method;

/**
 * Base class for all TestNG tests
 */
@Slf4j
public class CSSmartTestBase {
    
    protected WebDriver driver;
    protected ElementFinder elementFinder;
    
    /**
     * Setup before each test method
     * @param method Test method
     */
    @BeforeMethod
    public void setUp(Method method) {
        log.info("Setting up test: {}", method.getName());
        
        // Get test description if available
        String description = "";
        CSSmartTest annotation = method.getAnnotation(CSSmartTest.class);
        if (annotation != null) {
            description = annotation.description();
        }
        
        log.info("Test description: {}", description);
        
        // Get WebDriver
        driver = DriverFactory.getDriver();
        
        // Initialize ElementFinder
        elementFinder = new ElementFinder(driver);
        
        log.info("Test setup complete");
    }
    
    /**
     * Teardown after each test method
     * @param result Test result
     */
    @AfterMethod
    public void tearDown(ITestResult result) {
        String testName = result.getMethod().getMethodName();
        log.info("Tearing down test: {}", testName);
        
        // Take screenshot if test failed
        if (result.getStatus() == ITestResult.FAILURE) {
            log.info("Test failed, taking screenshot");
            takeScreenshot(testName);
        }
        
        // Quit WebDriver
        DriverFactory.quitDriver();
        
        log.info("Test teardown complete");
    }
    
    /**
     * Take screenshot
     * @param testName Test name
     */
    private void takeScreenshot(String testName) {
        try {
            // Implementation for taking screenshots
            log.info("Screenshot saved for failed test: {}", testName);
        } catch (Exception e) {
            log.error("Failed to take screenshot", e);
        }
    }
}

package com.cssmart.core.base;

import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.By;
import org.openqa.selenium.NoSuchElementException;
import org.openqa.selenium.TimeoutException;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;
import lombok.extern.slf4j.Slf4j;

import java.time.Duration;
import java.util.List;

/**
 * Utility class for finding elements with smart locator strategies
 */
@Slf4j
public class ElementFinder {
    
    private final WebDriver driver;
    private final WebDriverWait wait;
    private final int DEFAULT_TIMEOUT = 10; // seconds
    
    /**
     * Constructor
     * @param driver WebDriver instance
     */
    public ElementFinder(WebDriver driver) {
        this.driver = driver;
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(DEFAULT_TIMEOUT));
    }
    
    /**
     * Find element by locator (smart detection of locator type)
     * @param locator Element locator
     * @return WebElement
     */
    public WebElement findElement(String locator) {
        try {
            // Determine locator type and find element
            By by = parseLocator(locator);
            return driver.findElement(by);
        } catch (NoSuchElementException e) {
            log.error("Element not found: {}", locator);
            throw e;
        }
    }
    
    /**
     * Find elements by locator (smart detection of locator type)
     * @param locator Element locator
     * @return List of WebElements
     */
    public List<WebElement> findElements(String locator) {
        try {
            // Determine locator type and find elements
            By by = parseLocator(locator);
            return driver.findElements(by);
        } catch (Exception e) {
            log.error("Error finding elements: {}", locator, e);
            throw e;
        }
    }
    
    /**
     * Wait for element to be visible
     * @param locator Element locator
     * @return WebElement
     */
    public WebElement waitForElementVisible(String locator) {
        try {
            By by = parseLocator(locator);
            return wait.until(ExpectedConditions.visibilityOfElementLocated(by));
        } catch (TimeoutException e) {
            log.error("Timeout waiting for element to be visible: {}", locator);
            throw e;
        }
    }
    
    /**
     * Wait for element to be clickable
     * @param locator Element locator
     * @return WebElement
     */
    public WebElement waitForElementClickable(String locator) {
        try {
            By by = parseLocator(locator);
            return wait.until(ExpectedConditions.elementToBeClickable(by));
        } catch (TimeoutException e) {
            log.error("Timeout waiting for element to be clickable: {}", locator);
            throw e;
        }
    }
    
    /**
     * Wait for element to be present
     * @param locator Element locator
     * @return WebElement
     */
    public WebElement waitForElement(String locator) {
        try {
            By by = parseLocator(locator);
            return wait.until(ExpectedConditions.presenceOfElementLocated(by));
        } catch (TimeoutException e) {
            log.error("Timeout waiting for element to be present: {}", locator);
            throw e;
        }
    }
    
    /**
     * Check if element is visible
     * @param locator Element locator
     * @return true if element is visible
     */
    public boolean isElementVisible(String locator) {
        try {
            By by = parseLocator(locator);
            return !driver.findElements(by).isEmpty() && driver.findElement(by).isDisplayed();
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Parse locator string to By object
     * @param locator Locator string
     * @return By object
     */
    private By parseLocator(String locator) {
        if (locator.startsWith("//") || locator.startsWith("(//")) {
            // XPath
            return By.xpath(locator);
        } else if (locator.startsWith("#")) {
            // ID
            return By.id(locator.substring(1));
        } else if (locator.startsWith(".")) {
            // Class name
            return By.className(locator.substring(1));
        } else if (locator.matches("^[a-zA-Z]+\\.[a-zA-Z]+.*")) {
            // CSS selector with class
            return By.cssSelector(locator);
        } else if (locator.matches("^\\[.*\\]$")) {
            // Attribute
            return By.cssSelector(locator);
        } else if (locator.contains("=")) {
            // Name=value pair
            String[] parts = locator.split("=", 2);
            switch (parts[0].toLowerCase()) {
                case "id":
                    return By.id(parts[1]);
                case "name":
                    return By.name(parts[1]);
                case "class":
                    return By.className(parts[1]);
                case "tag":
                    return By.tagName(parts[1]);
                case "css":
                    return By.cssSelector(parts[1]);
                case "xpath":
                    return By.xpath(parts[1]);
                case "linktext":
                    return By.linkText(parts[1]);
                case "partiallinktext":
                    return By.partialLinkText(parts[1]);
                default:
                    // Default to attribute
                    return By.cssSelector(String.format("[%s='%s']", parts[0], parts[1]));
            }
        } else {
            // Default to ID
            return By.id(locator);
        }
    }
}

package com.cssmart.core.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation for CS Smart Test Framework test methods
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface CSSmartTest {
    
    /**
     * Test description
     * @return Test description
     */
    String description() default "";
    
    /**
     * Test category
     * @return Test category
     */
    String category() default "";
    
    /**
     * Test tags
     * @return Test tags
     */
    String[] tags() default {};
    
    /**
     * Test priority
     * @return Test priority
     */
    int priority() default 0;
    
    /**
     * Test owners
     * @return Test owners
     */
    String[] owners() default {};
    
    /**
     * Whether to capture screenshots
     * @return true to capture screenshots
     */
    boolean captureScreenshots() default true;
    
    /**
     * Whether to record video
     * @return true to record video
     */
    boolean recordVideo() default false;
    
    /**
     * Test data provider
     * @return Test data provider
     */
    String dataProvider() default "";
    
    /**
     * Test data provider class
     * @return Test data provider class
     */
    Class<?> dataProviderClass() default Object.class;
}

package com.cssmart.ui.controller;

import com.cssmart.ui.service.BDDTestGeneratorService;
import com.cssmart.ui.service.BDDTestGeneratorService.BDDTestSuite;
import com.cssmart.ui.service.TestRecordingService;
import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.service.TestExecutionService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import lombok.extern.slf4j.Slf4j;

import java.util.Map;
import java.util.HashMap;

/**
 * REST controller for BDD test generation operations
 */
@Slf4j
@RestController
@RequestMapping("/api/bdd")
public class BDDTestController {
    
    private final BDDTestGeneratorService bddTestGeneratorService;
    private final TestRecordingService testRecordingService;
    private final TestExecutionService testExecutionService;
    
    @Autowired
    public BDDTestController(BDDTestGeneratorService bddTestGeneratorService, 
                            TestRecordingService testRecordingService,
                            TestExecutionService testExecutionService) {
        this.bddTestGeneratorService = bddTestGeneratorService;
        this.testRecordingService = testRecordingService;
        this.testExecutionService = testExecutionService;
    }
    
    /**
     * Generate BDD tests from a recorded test case
     * @param testCaseId Recorded test case ID
     * @return Generated BDD test suite
     */
    @PostMapping("/generate/{testCaseId}")
    public ResponseEntity<BDDTestSuite> generateBDDTests(@PathVariable("testCaseId") String testCaseId) {
        log.info("Generating BDD tests for test case ID: {}", testCaseId);
        
        try {
            // Get the recorded test case
            TestCase testCase = testRecordingService.getRecordedTest(testCaseId);
            
            if (testCase == null) {
                log.warn("Test case not found with ID: {}", testCaseId);
                return ResponseEntity.notFound().build();
            }
            
            // Generate BDD tests
            BDDTestSuite testSuite = bddTestGeneratorService.generateBDDTests(testCase);
            
            return ResponseEntity.ok(testSuite);
        } catch (Exception e) {
            log.error("Error generating BDD tests", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Get a generated BDD test suite by ID
     * @param id BDD test suite ID
     * @return BDD test suite details
     */
    @GetMapping("/{id}")
    public ResponseEntity<BDDTestSuite> getBDDTestSuite(@PathVariable("id") String id) {
        log.info("Fetching BDD test suite with ID: {}", id);
        
        try {
            BDDTestSuite testSuite = bddTestGeneratorService.getBDDTestSuite(id);
            
            if (testSuite == null) {
                log.warn("BDD test suite not found with ID: {}", id);
                return ResponseEntity.notFound().build();
            }
            
            return ResponseEntity.ok(testSuite);
        } catch (Exception e) {
            log.error("Error fetching BDD test suite", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Get individual components of a BDD test suite
     * @param id BDD test suite ID
     * @param component Component to retrieve (feature, steps, runner, pageObject)
     * @return Component content
     */
    @GetMapping("/{id}/{component}")
    public ResponseEntity<Map<String, String>> getBDDTestComponent(
            @PathVariable("id") String id,
            @PathVariable("component") String component) {
        
        log.info("Fetching component {} for BDD test suite with ID: {}", component, id);
        
        try {
            BDDTestSuite testSuite = bddTestGeneratorService.getBDDTestSuite(id);
            
            if (testSuite == null) {
                log.warn("BDD test suite not found with ID: {}", id);
                return ResponseEntity.notFound().build();
            }
            
            Map<String, String> result = new HashMap<>();
            
            switch (component.toLowerCase()) {
                case "feature":
                    result.put("content", testSuite.getFeatureFile());
                    result.put("type", "feature");
                    break;
                    
                case "steps":
                    result.put("content", testSuite.getStepDefinitions());
                    result.put("type", "java");
                    break;
                    
                case "runner":
                    result.put("content", testSuite.getRunnerClass());
                    result.put("type", "java");
                    break;
                    
                case "pageobject":
                    result.put("content", testSuite.getPageObject());
                    result.put("type", "java");
                    break;
                    
                default:
                    log.warn("Unknown component: {}", component);
                    return ResponseEntity.badRequest().body(null);
            }
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("Error fetching BDD test suite component", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Run generated BDD tests
     * @param id BDD test suite ID
     * @return Execution status
     */
    @PostMapping("/{id}/run")
    public ResponseEntity<Map<String, Object>> runBDDTests(@PathVariable("id") String id) {
        log.info("Running BDD tests for suite ID: {}", id);
        
        try {
            BDDTestSuite testSuite = bddTestGeneratorService.getBDDTestSuite(id);
            
            if (testSuite == null) {
                log.warn("BDD test suite not found with ID: {}", id);
                return ResponseEntity.notFound().build();
            }
            
            // Execute the Cucumber BDD test using TestExecutionService
            String executionId = testExecutionService.runBDDTest(testSuite);
            
            Map<String, Object> result = new HashMap<>();
            result.put("status", "success");
            result.put("message", "BDD tests execution started");
            result.put("executionId", executionId);
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("Error running BDD tests", e);
            Map<String, Object> result = new HashMap<>();
            result.put("status", "error");
            result.put("message", "Failed to run BDD tests: " + e.getMessage());
            return ResponseEntity.status(500).body(result);
        }
    }
}


package com.cssmart.core.processors;

import com.cssmart.core.annotations.CSSmartTest;
import com.cssmart.core.reporting.ReportingManager;
import org.testng.ITestContext;
import org.testng.ITestListener;
import org.testng.ITestResult;

import lombok.extern.slf4j.Slf4j;
import java.lang.reflect.Method;
import java.util.Arrays;

/**
 * TestNG listener to process CSSmartTest annotations
 */
@Slf4j
public class CSSmartTestProcessor implements ITestListener {

    private ReportingManager reportingManager = ReportingManager.getInstance();

    @Override
    public void onTestStart(ITestResult result) {
        try {
            Method method = result.getMethod().getConstructorOrMethod().getMethod();
            CSSmartTest annotation = method.getAnnotation(CSSmartTest.class);
            
            if (annotation != null) {
                // Process annotation attributes
                log.info("Starting test with description: {}", annotation.description());
                
                // Set test attributes in TestNG context
                ITestContext context = result.getTestContext();
                context.setAttribute("test.description", annotation.description());
                context.setAttribute("test.category", annotation.category());
                context.setAttribute("test.tags", annotation.tags());
                context.setAttribute("test.priority", annotation.priority());
                context.setAttribute("test.owners", annotation.owners());
                
                // Configure screenshot and video recording
                context.setAttribute("captureScreenshots", annotation.captureScreenshots());
                context.setAttribute("recordVideo", annotation.recordVideo());
                
                // Log test metadata
                log.info("Test metadata - Category: {}, Tags: {}, Priority: {}, Owners: {}", 
                    annotation.category(),
                    Arrays.toString(annotation.tags()),
                    annotation.priority(),
                    Arrays.toString(annotation.owners())
                );
                
                // Initialize test in reporting system
                reportingManager.startTest(
                    result.getMethod().getMethodName(),
                    annotation.description(),
                    annotation.category(),
                    annotation.tags()
                );
            } else {
                // Initialize test without metadata
                reportingManager.startTest(
                    result.getMethod().getMethodName(),
                    "",
                    "",
                    new String[0]
                );
            }
        } catch (Exception e) {
            log.error("Error processing CSSmartTest annotation", e);
        }
    }

    @Override
    public void onTestSuccess(ITestResult result) {
        try {
            log.info("Test passed: {}", result.getMethod().getMethodName());
            
            // Update test status in reporting system
            reportingManager.endTest(
                result.getMethod().getMethodName(),
                "PASSED",
                null,
                result.getEndMillis() - result.getStartMillis()
            );
        } catch (Exception e) {
            log.error("Error updating test success status", e);
        }
    }

    @Override
    public void onTestFailure(ITestResult result) {
        try {
            log.error("Test failed: {}", result.getMethod().getMethodName());
            
            // Get exception details
            Throwable throwable = result.getThrowable();
            String errorMessage = throwable != null ? throwable.getMessage() : "Unknown error";
            
            // Update test status in reporting system
            reportingManager.endTest(
                result.getMethod().getMethodName(),
                "FAILED",
                errorMessage,
                result.getEndMillis() - result.getStartMillis()
            );
            
            // Capture screenshot if enabled
            Method method = result.getMethod().getConstructorOrMethod().getMethod();
            CSSmartTest annotation = method.getAnnotation(CSSmartTest.class);
            
            if (annotation != null && annotation.captureScreenshots()) {
                reportingManager.captureScreenshot(result.getMethod().getMethodName());
            }
        } catch (Exception e) {
            log.error("Error updating test failure status", e);
        }
    }

    @Override
    public void onTestSkipped(ITestResult result) {
        try {
            log.info("Test skipped: {}", result.getMethod().getMethodName());
            
            // Update test status in reporting system
            reportingManager.endTest(
                result.getMethod().getMethodName(),
                "SKIPPED",
                "Test was skipped",
                0
            );
        } catch (Exception e) {
            log.error("Error updating test skipped status", e);
        }
    }

    @Override
    public void onStart(ITestContext context) {
        log.info("Starting test execution: {}", context.getName());
        reportingManager.startExecution(context.getName());
    }

    @Override
    public void onFinish(ITestContext context) {
        log.info("Finished test execution: {}", context.getName());
        reportingManager.endExecution(context.getName());
    }
}

package com.cssmart.core.reporting;

import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;
import com.cssmart.core.base.DriverFactory;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * Manager for test reporting
 */
@Slf4j
public class ReportingManager {
    
    private static final String REPORTS_DIR = "reports";
    private static final String SCREENSHOTS_DIR = REPORTS_DIR + "/screenshots";
    private static volatile ReportingManager instance;
    private final Map<String, TestReport> testReports = new HashMap<>();
    private String currentExecutionId;
    
    private ReportingManager() {
        // Create report directories
        createDirectories();
    }
    
    /**
     * Get singleton instance
     * @return ReportingManager instance
     */
    public static ReportingManager getInstance() {
        if (instance == null) {
            synchronized (ReportingManager.class) {
                if (instance == null) {
                    instance = new ReportingManager();
                }
            }
        }
        return instance;
    }
    
    /**
     * Start test execution
     * @param executionName Execution name
     */
    public void startExecution(String executionName) {
        currentExecutionId = generateExecutionId();
        log.info("Started test execution: {} with ID: {}", executionName, currentExecutionId);
    }
    
    /**
     * End test execution
     * @param executionName Execution name
     */
    public void endExecution(String executionName) {
        log.info("Ended test execution: {} with ID: {}", executionName, currentExecutionId);
        
        // Generate execution report
        generateExecutionReport();
    }
    
    /**
     * Start a test
     * @param testName Test name
     * @param description Test description
     * @param category Test category
     * @param tags Test tags
     */
    public void startTest(String testName, String description, String category, String[] tags) {
        String testId = UUID.randomUUID().toString();
        
        TestReport report = TestReport.builder()
            .id(testId)
            .name(testName)
            .description(description)
            .category(category)
            .tags(tags)
            .status("RUNNING")
            .startTime(LocalDateTime.now())
            .build();
        
        testReports.put(testId, report);
        log.info("Started test: {} with ID: {}", testName, testId);
    }
    
    /**
     * End a test
     * @param testName Test name
     * @param status Test status
     * @param errorMessage Error message (if failed)
     * @param duration Test duration in milliseconds
     */
    public void endTest(String testName, String status, String errorMessage, long duration) {
        // Find test report by name
        TestReport report = testReports.values().stream()
            .filter(r -> r.getName().equals(testName))
            .findFirst()
            .orElse(null);
        
        if (report != null) {
            report.setStatus(status);
            report.setEndTime(LocalDateTime.now());
            report.setDuration(duration);
            
            if (errorMessage != null) {
                report.setErrorMessage(errorMessage);
            }
            
            // Save test report
            saveTestReport(report);
            
            log.info("Ended test: {} with status: {}", testName, status);
        } else {
            log.warn("Test report not found for test: {}", testName);
        }
    }
    
    /**
     * Capture screenshot
     * @param testName Test name
     * @return Screenshot file path
     */
    public String captureScreenshot(String testName) {
        try {
            WebDriver driver = DriverFactory.getDriver();
            
            if (driver instanceof TakesScreenshot) {
                File screenshotFile = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
                
                String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
                String filename = testName + "_" + timestamp + ".png";
                Path destination = Paths.get(SCREENSHOTS_DIR, filename);
                
                Files.copy(screenshotFile.toPath(), destination);
                
                log.info("Captured screenshot: {}", destination);
                return destination.toString();
            } else {
                log.warn("WebDriver does not support taking screenshots");
                return null;
            }
        } catch (Exception e) {
            log.error("Error capturing screenshot", e);
            return null;
        }
    }
    
    /**
     * Create report directories
     */
    private void createDirectories() {
        try {
            Path reportsPath = Paths.get(REPORTS_DIR);
            Path screenshotsPath = Paths.get(SCREENSHOTS_DIR);
            
            if (!Files.exists(reportsPath)) {
                Files.createDirectories(reportsPath);
            }
            
            if (!Files.exists(screenshotsPath)) {
                Files.createDirectories(screenshotsPath);
            }
        } catch (Exception e) {
            log.error("Error creating report directories", e);
        }
    }
    
    /**
     * Generate unique execution ID
     * @return Execution ID
     */
    private String generateExecutionId() {
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
        return "exec_" + timestamp;
    }
    
    /**
     * Generate execution report
     */
    private void generateExecutionReport() {
        // Generate HTML report
        try {
            StringBuilder html = new StringBuilder();
            html.append("<!DOCTYPE html>\n");
            html.append("<html>\n");
            html.append("<head>\n");
            html.append("  <title>Test Execution Report</title>\n");
            html.append("  <style>\n");
            html.append("    body { font-family: Arial, sans-serif; margin: 20px; }\n");
            html.append("    h1 { color: #333; }\n");
            html.append("    table { border-collapse: collapse; width: 100%; }\n");
            html.append("    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n");
            html.append("    th { background-color: #f2f2f2; }\n");
            html.append("    tr:nth-child(even) { background-color: #f9f9f9; }\n");
            html.append("    .passed { color: green; }\n");
            html.append("    .failed { color: red; }\n");
            html.append("    .skipped { color: orange; }\n");
            html.append("  </style>\n");
            html.append("</head>\n");
            html.append("<body>\n");
            html.append("  <h1>Test Execution Report</h1>\n");
            html.append("  <p>Execution ID: ").append(currentExecutionId).append("</p>\n");
            html.append("  <p>Execution Time: ").append(LocalDateTime.now()).append("</p>\n");
            html.append("  <table>\n");
            html.append("    <tr>\n");
            html.append("      <th>Test Name</th>\n");
            html.append("      <th>Description</th>\n");
            html.append("      <th>Status</th>\n");
            html.append("      <th>Duration</th>\n");
            html.append("      <th>Start Time</th>\n");
            html.append("      <th>End Time</th>\n");
            html.append("    </tr>\n");
            
            // Add test reports
            for (TestReport report : testReports.values()) {
                String statusClass = report.getStatus().toLowerCase();
                
                html.append("    <tr>\n");
                html.append("      <td>").append(report.getName()).append("</td>\n");
                html.append("      <td>").append(report.getDescription()).append("</td>\n");
                html.append("      <td class=\"").append(statusClass).append("\">").append(report.getStatus()).append("</td>\n");
                html.append("      <td>").append(report.getDuration()).append(" ms</td>\n");
                html.append("      <td>").append(report.getStartTime()).append("</td>\n");
                html.append("      <td>").append(report.getEndTime()).append("</td>\n");
                html.append("    </tr>\n");
            }
            
            html.append("  </table>\n");
            html.append("</body>\n");
            html.append("</html>\n");
            
            // Write report to file
            String reportFilename = currentExecutionId + ".html";
            Path reportPath = Paths.get(REPORTS_DIR, reportFilename);
            Files.writeString(reportPath, html.toString());
            
            log.info("Generated execution report: {}", reportPath);
        } catch (Exception e) {
            log.error("Error generating execution report", e);
        }
    }
    
    /**
     * Save test report
     * @param report Test report
     */
    private void saveTestReport(TestReport report) {
        try {
            // Create JSON report
            String jsonFilename = report.getId() + ".json";
            Path jsonPath = Paths.get(REPORTS_DIR, jsonFilename);
            
            // Convert to JSON using Jackson
            com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();
            mapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule());
            mapper.configure(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
            
            mapper.writeValue(jsonPath.toFile(), report);
            
            log.info("Saved test report: {}", jsonPath);
        } catch (Exception e) {
            log.error("Error saving test report", e);
        }
    }
}

package com.cssmart.core.reporting;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * Test report model
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TestReport {
    
    private String id;
    private String name;
    private String description;
    private String category;
    private String[] tags;
    private String status;
    private long duration;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String errorMessage;
    private String stackTrace;
    private String browser;
    private String environment;
    private String className;
    private String methodName;
    private List<String> screenshots;
    private Map<String, Object> metadata;
}

package com.cssmart.ui.service;

import com.cssmart.core.base.CSSmartTestBase;
import com.cssmart.core.driver.DriverManager;
import com.cssmart.core.reporting.ReportingManager;
import com.cssmart.ui.service.BDDTestGeneratorService.BDDTestSuite;
import com.cssmart.ui.recorder.model.TestCase;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Method;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

/**
 * Service for executing tests
 */
@Slf4j
@Service
public class TestExecutionService {
    
    private final ReportingManager reportingManager;
    private final ExecutorService executorService;
    private final Map<String, TestExecutionTask> runningTests;
    private final Map<String, BatchExecutionStatus> batchStatuses;
    
    @Autowired
    public TestExecutionService() {
        this.reportingManager = ReportingManager.getInstance();
        this.executorService = Executors.newCachedThreadPool();
        this.runningTests = new ConcurrentHashMap<>();
        this.batchStatuses = new ConcurrentHashMap<>();
    }
    
    /**
     * Run a specific test by ID
     * @param id Test ID
     * @return Execution ID
     */
    public String runTest(String id) throws Exception {
        log.info("Running test with ID: {}", id);
        
        // Find test class and method based on ID
        TestInfo testInfo = getTestInfo(id);
        
        // Create execution task
        TestExecutionTask task = new TestExecutionTask(testInfo);
        String executionId = UUID.randomUUID().toString();
        runningTests.put(executionId, task);
        
        // Execute test asynchronously
        executorService.submit(() -> {
            try {
                task.executeTest();
            } catch (Exception e) {
                log.error("Error executing test", e);
            } finally {
                runningTests.remove(executionId);
            }
        });
        
        return executionId;
    }
    
    /**
     * Rerun a test from a previous execution
     * @param id Previous execution ID
     * @return Execution ID
     */
    public String rerunTest(String id) throws Exception {
        log.info("Rerunning test with execution ID: {}", id);
        
        // Sample test info based on ID
        TestInfo testInfo = new TestInfo();
        testInfo.setClassName("com.cssmart.examples.web.LoginTest");
        testInfo.setMethodName("testLogin");
        
        // Create execution task
        TestExecutionTask task = new TestExecutionTask(testInfo);
        String executionId = UUID.randomUUID().toString();
        runningTests.put(executionId, task);
        
        // Execute test asynchronously
        executorService.submit(() -> {
            try {
                task.executeTest();
            } catch (Exception e) {
                log.error("Error executing test", e);
            } finally {
                runningTests.remove(executionId);
            }
        });
        
        return executionId;
    }
    
    /**
     * Run BDD test
     * @param testSuite BDD test suite
     * @return Execution ID
     */
    public String runBDDTest(BDDTestSuite testSuite) {
        log.info("Running BDD test: {}", testSuite.getTestCaseName());
        
        String executionId = UUID.randomUUID().toString();
        
        // Execute BDD test asynchronously
        executorService.submit(() -> {
            try {
                // Start test execution in reporting system
                reportingManager.startExecution("BDD: " + testSuite.getTestCaseName());
                
                // Start test
                reportingManager.startTest(
                    testSuite.getTestCaseName(),
                    "BDD test: " + testSuite.getTestCaseName(),
                    "BDD",
                    new String[]{"bdd", "cucumber"}
                );
                
                // Use ProcessBuilder to execute the Cucumber test
                ProcessBuilder processBuilder = new ProcessBuilder(
                    "mvn", "test", "-Dcucumber.options=--tags @" + 
                    testSuite.getTestCaseName().replaceAll("[^a-zA-Z0-9]", "")
                );
                
                processBuilder.redirectErrorStream(true);
                Process process = processBuilder.start();
                
                // Wait for the process to complete
                int exitCode = process.waitFor();
                
                // End test with appropriate status
                if (exitCode == 0) {
                    reportingManager.endTest(
                        testSuite.getTestCaseName(),
                        "PASSED",
                        null,
                        0
                    );
                } else {
                    reportingManager.endTest(
                        testSuite.getTestCaseName(),
                        "FAILED",
                        "BDD test failed with exit code: " + exitCode,
                        0
                    );
                }
                
                // End test execution
                reportingManager.endExecution("BDD: " + testSuite.getTestCaseName());
                
                log.info("BDD test completed with exit code: {}", exitCode);
            } catch (Exception e) {
                log.error("Error executing BDD test", e);
                
                // End test with error
                reportingManager.endTest(
                    testSuite.getTestCaseName(),
                    "FAILED",
                    "Error executing BDD test: " + e.getMessage(),
                    0
                );
                
                // End test execution
                reportingManager.endExecution("BDD: " + testSuite.getTestCaseName());
            }
        });
        
        return executionId;
    }
    
    /**
     * Run multiple tests
     * @param testIds List of test IDs to run
     * @return Batch execution status
     */
    public BatchExecutionStatus runBatchTests(List<String> testIds) {
        log.info("Running batch of {} tests", testIds.size());
        
        // Create batch ID
        String batchId = UUID.randomUUID().toString();
        
        // Create batch status
        BatchExecutionStatus status = new BatchExecutionStatus();
        status.setBatchId(batchId);
        status.setTotalTests(testIds.size());
        status.setCompletedTests(0);
        status.setInProgress(true);
        
        // Store batch status
        batchStatuses.put(batchId, status);
        
        // Run tests asynchronously
        executorService.submit(() -> {
            try {
                for (String testId : testIds) {
                    try {
                        runTest(testId);
                    } catch (Exception e) {
                        log.error("Error running test with ID: {}", testId, e);
                    }
                    
                    // Update status
                    status.setCompletedTests(status.getCompletedTests() + 1);
                }
                
                // Mark batch as complete
                status.setInProgress(false);
            } catch (Exception e) {
                log.error("Error in batch execution", e);
                status.setInProgress(false);
            }
        });
        
        return status;
    }
    
    /**
     * Get status of a batch execution
     * @param batchId Batch ID
     * @return Batch execution status
     */
    public BatchExecutionStatus getBatchStatus(String batchId) {
        return batchStatuses.get(batchId);
    }
    
    /**
     * Stop an ongoing test execution
     * @param id Test execution ID
     * @return True if stopped successfully
     */
    public boolean stopTestExecution(String id) {
        TestExecutionTask task = runningTests.get(id);
        
        if (task != null) {
            task.stop();
            runningTests.remove(id);
            return true;
        }
        
        return false;
    }
    
    /**
     * Get test information from test ID
     */
    private TestInfo getTestInfo(String id) {
        // In a real implementation, this would look up the test class and method
        // from a database or repository based on the ID
        
        // For now, try to load from the test files directory
        try {
            TestInfo info = new TestInfo();
            
            // Check if ID is for a recorded test
            File testFile = new File("recorded-tests/" + id + ".json");
            if (testFile.exists()) {
                // Read test class name and method from file
                com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();
                TestCase testCase = mapper.readValue(testFile, TestCase.class);
                
                info.setClassName(testCase.getClassName());
                info.setMethodName(testCase.getMethodName());
                return info;
            }
            
            // Default test info for demo
            info.setClassName("com.cssmart.tests.generated." + id);
            info.setMethodName("test" + id);
            return info;
        } catch (Exception e) {
            log.error("Error getting test info for ID: {}", id, e);
            
            // Fallback to default
            TestInfo info = new TestInfo();
            info.setClassName("com.cssmart.examples.web.LoginTest");
            info.setMethodName("testLogin");
            return info;
        }
    }
    
    /**
     * Test information class
     */
    private static class TestInfo {
        private String className;
        private String methodName;
        
        public String getClassName() {
            return className;
        }
        
        public void setClassName(String className) {
            this.className = className;
        }
        
        public String getMethodName() {
            return methodName;
        }
        
        public void setMethodName(String methodName) {
            this.methodName = methodName;
        }
    }
    
    /**
     * Task for executing a test
     */
    private class TestExecutionTask {
        private final TestInfo testInfo;
        private volatile boolean stopped = false;
        
        public TestExecutionTask(TestInfo testInfo) {
            this.testInfo = testInfo;
        }
        
        /**
         * Execute the test
         */
        public void executeTest() throws Exception {
            long startTime = System.currentTimeMillis();
            
            try {
                // Start test execution in reporting
                reportingManager.startExecution(testInfo.getClassName() + "." + testInfo.getMethodName());
                
                // Start test
                reportingManager.startTest(
                    testInfo.getMethodName(),
                    "Test execution for " + testInfo.getClassName() + "#" + testInfo.getMethodName(),
                    "TestNG",
                    new String[]{"testng", "automated"}
                );
                
                // In a real implementation, this would use reflection to
                // instantiate the test class and invoke the test method
                log.info("Executing test: {}#{}", testInfo.getClassName(), testInfo.getMethodName());
                
                // For demo purposes, we'll simulate test execution
                if (!stopped) {
                    // Try to load and execute the actual test class
                    try {
                        Class<?> testClass = Class.forName(testInfo.getClassName());
                        Object testInstance = testClass.getDeclaredConstructor().newInstance();
                        
                        if (testInstance instanceof CSSmartTestBase) {
                            // Call setup method
                            Method setUpMethod = testClass.getMethod("setUp", Method.class);
                            Method testMethod = testClass.getMethod(testInfo.getMethodName());
                            setUpMethod.invoke(testInstance, testMethod);
                            
                            // Execute test method
                            testMethod.invoke(testInstance);
                            
                            // Call teardown method
                            Method tearDownMethod = testClass.getMethod("tearDown", org.testng.ITestResult.class);
                            tearDownMethod.invoke(testInstance, new MockTestResult(testInfo.getMethodName(), true));
                            
                            // End test with success
                            reportingManager.endTest(
                                testInfo.getMethodName(),
                                "PASSED",
                                null,
                                System.currentTimeMillis() - startTime
                            );
                        } else {
                            log.warn("Test class does not extend CSSmartTestBase: {}", testInfo.getClassName());
                            
                            // End test with error
                            reportingManager.endTest(
                                testInfo.getMethodName(),
                                "FAILED",
                                "Test class does not extend CSSmartTestBase",
                                System.currentTimeMillis() - startTime
                            );
                        }
                    } catch (ClassNotFoundException e) {
                        log.warn("Test class not found: {}", testInfo.getClassName());
                        
                        // Simulate test success for demo
                        Thread.sleep(3000); // Simulate test execution time
                        
                        // End test with success
                        reportingManager.endTest(
                            testInfo.getMethodName(),
                            "PASSED",
                            null,
                            System.currentTimeMillis() - startTime
                        );
                    }
                } else {
                    // Test was stopped
                    reportingManager.endTest(
                        testInfo.getMethodName(),
                        "SKIPPED",
                        "Test execution was stopped",
                        System.currentTimeMillis() - startTime
                    );
                }
                
                // End test execution
                reportingManager.endExecution(testInfo.getClassName() + "." + testInfo.getMethodName());
                
                log.info("Test execution completed");
            } catch (Exception e) {
                log.error("Error executing test", e);
                
                // End test with error
                reportingManager.endTest(
                    testInfo.getMethodName(),
                    "FAILED",
                    e.getMessage(),
                    System.currentTimeMillis() - startTime
                );
                
                // End test execution
                reportingManager.endExecution(testInfo.getClassName() + "." + testInfo.getMethodName());
                
                throw e;
            }
        }
        
        /**
         * Stop the test execution
         */
        public void stop() {
            this.stopped = true;
        }
    }
    
    /**
     * Mock implementation of ITestResult for test execution
     */
    private static class MockTestResult implements org.testng.ITestResult {
        private String methodName;
        private boolean success;
        
        public MockTestResult(String methodName, boolean success) {
            this.methodName = methodName;
            this.success = success;
        }
        
        @Override
        public int getStatus() {
            return success ? 1 : 2; // 1 = SUCCESS, 2 = FAILURE
        }
        
        @Override
        public void setStatus(int status) {
            // Not implemented
        }
        
        @Override
        public org.testng.ITestNGMethod getMethod() {
            // Mock implementation
            return new org.testng.ITestNGMethod() {
                @Override
                public String getMethodName() {
                    return methodName;
                }
                
                @Override
                public Object[] getInstances() {
                    return new Object[0];
                }
                
                @Override
                public Object getInstance() {
                    return null;
                }
                
                @Override
                public long[] getInstanceHashCodes() {
                    return new long[0];
                }
                
                @Override
                public String[] getGroups() {
                    return new String[0];
                }
                
                @Override
                public String[] getGroupsDependedUpon() {
                    return new String[0];
                }
                
                @Override
                public String getMissingGroup() {
                    return null;
                }
                
                @Override
                public void setMissingGroup(String group) {
                    // Not implemented
                }
                
                @Override
                public String[] getBeforeGroups() {
                    return new String[0];
                }
                
                @Override
                public String[] getAfterGroups() {
                    return new String[0];
                }
                
                @Override
                public String[] getMethodsDependedUpon() {
                    return new String[0];
                }
                
                @Override
                public void addMethodDependedUpon(String methodName) {
                    // Not implemented
                }
                
                @Override
                public boolean isTest() {
                    return true;
                }
                
                @Override
                public boolean isBeforeMethodConfiguration() {
                    return false;
                }
                
                @Override
                public boolean isAfterMethodConfiguration() {
                    return false;
                }
                
                @Override
                public boolean isBeforeClassConfiguration() {
                    return false;
                }
                
                @Override
                public boolean isAfterClassConfiguration() {
                    return false;
                }
                
                @Override
                public boolean isBeforeSuiteConfiguration() {
                    return false;
                }
                
                @Override
                public boolean isAfterSuiteConfiguration() {
                    return false;
                }
                
                @Override
                public boolean isBeforeTestConfiguration() {
                    return false;
                }
                
                @Override
                public boolean isAfterTestConfiguration() {
                    return false;
                }
                
                @Override
                public boolean isBeforeGroupsConfiguration() {
                    return false;
                }
                
                @Override
                public boolean isAfterGroupsConfiguration() {
                    return false;
                }
                
                @Override
                public long getTimeOut() {
                    return 0;
                }
                
                @Override
                public void setTimeOut(long timeOut) {
                    // Not implemented
                }
                
                @Override
                public int getInvocationCount() {
                    return 0;
                }
                
                @Override
                public void setInvocationCount(int count) {
                    // Not implemented
                }
                
                @Override
                public int getSuccessPercentage() {
                    return 0;
                }
                
                @Override
                public String getId() {
                    return null;
                }
                
                @Override
                public void setId(String id) {
                    // Not implemented
                }
                
                @Override
                public long getDate() {
                    return 0;
                }
                
                @Override
                public void setDate(long date) {
                    // Not implemented
                }
                
                @Override
                public boolean canRunFromClass(org.testng.IClass testClass) {
                    return false;
                }
                
                @Override
                public boolean isAlwaysRun() {
                    return false;
                }
                
                @Override
                public int getThreadPoolSize() {
                    return 0;
                }
                
                @Override
                public void setThreadPoolSize(int threadPoolSize) {
                    // Not implemented
                }
                
                @Override
                public boolean getEnabled() {
                    return true;
                }
                
                @Override
                public String getDescription() {
                    return "";
                }
                
                @Override
                public void setDescription(String description) {
                    // Not implemented
                }
                
                @Override
                public void incrementCurrentInvocationCount() {
                    // Not implemented
                }
                
                @Override
                public int getCurrentInvocationCount() {
                    return 0;
                }
                
                @Override
                public void setParameterInvocationCount(int count) {
                    // Not implemented
                }
                
                @Override
                public int getParameterInvocationCount() {
                    return 0;
                }
                
                @Override
                public void setMoreInvocationChecker(Runnable moreInvocationChecker) {
                    // Not implemented
                }
                
                @Override
                public boolean hasMoreInvocation() {
                    return false;
                }
                
                @Override
                public org.testng.ITestClass getTestClass() {
                    return null;
                }
                
                @Override
                public boolean isDataDriven() {
                    return false;
                }
                
                @Override
                public java.lang.reflect.Method getConstructorOrMethod() {
                    try {
                        return Object.class.getMethod("toString");
                    } catch (Exception e) {
                        return null;
                    }
                }
                
                @Override
                public org.testng.IRetryAnalyzer getRetryAnalyzer() {
                    return null;
                }
                
                @Override
                public void setRetryAnalyzer(org.testng.IRetryAnalyzer retryAnalyzer) {
                    // Not implemented
                }
                
                @Override
                public boolean skipFailedInvocations() {
                    return false;
                }
                
                @Override
                public void setSkipFailedInvocations(boolean skip) {
                    // Not implemented
                }
                
                @Override
                public long getInvocationTimeOut() {
                    return 0;
                }
                
                @Override
                public boolean ignoreMissingDependencies() {
                    return false;
                }
                
                @Override
                public void setIgnoreMissingDependencies(boolean ignore) {
                    // Not implemented
                }
                
                @Override
                public List<Integer> getInvocationNumbers() {
                    return null;
                }
                
                @Override
                public void setInvocationNumbers(List<Integer> numbers) {
                    // Not implemented
                }
                
                @Override
                public void addFailedInvocationNumber(int number) {
                    // Not implemented
                }
                
                @Override
                public List<Integer> getFailedInvocationNumbers() {
                    return null;
                }
                
                @Override
                public int getPriority() {
                    return 0;
                }
                
                @Override
                public void setPriority(int priority) {
                    // Not implemented
                }
                
                @Override
                public int getInterceptedPriority() {
                    return 0;
                }
                
                @Override
                public void setInterceptedPriority(int priority) {
                    // Not implemented
                }
            };
        }
        
        @Override
        public Object[] getParameters() {
            return new Object[0];
        }
        
        @Override
        public void setParameters(Object[] parameters) {
            // Not implemented
        }
        
        @Override
        public Class[] getParameterTypes() {
            return new Class[0];
        }
        
        @Override
        public void setParameterTypes(Class[] parameterTypes) {
            // Not implemented
        }
        
        @Override
        public Throwable getThrowable() {
            return null;
        }
        
        @Override
        public void setThrowable(Throwable throwable) {
            // Not implemented
        }
        
        @Override
        public long getStartMillis() {
            return System.currentTimeMillis() - 1000;
        }
        
        @Override
        public long getEndMillis() {
            return System.currentTimeMillis();
        }
        
        @Override
        public void setEndMillis(long millis) {
            // Not implemented
        }
        
        @Override
        public String getName() {
            return methodName;
        }
        
        @Override
        public boolean isSuccess() {
            return success;
        }
        
        @Override
        public String getHost() {
            return "localhost";
        }
        
        @Override
        public Object getInstance() {
            return null;
        }
        
        @Override
        public String getTestName() {
            return methodName;
        }
        
        @Override
        public String getInstanceName() {
            return "mockInstance";
        }
        
        @Override
        public org.testng.ITestContext getTestContext() {
            return null;
        }
        
        @Override
        public void setTestName(String name) {
            // Not implemented
        }
        
        @Override
        public boolean wasRetried() {
            return false;
        }
        
        @Override
        public void setWasRetried(boolean wasRetried) {
            // Not implemented
        }
        
        @Override
        public int compareTo(org.testng.ITestResult o) {
            return 0;
        }
        
        @Override
        public Object getAttribute(String name) {
            return null;
        }
        
        @Override
        public void setAttribute(String name, Object value) {
            // Not implemented
        }
        
        @Override
        public java.util.Set<String> getAttributeNames() {
            return new java.util.HashSet<>();
        }
        
        @Override
        public Object removeAttribute(String name) {
            return null;
        }
    }
    
    /**
     * Batch execution status class
     */
    public static class BatchExecutionStatus {
        private String batchId;
        private int totalTests;
        private int completedTests;
        private boolean inProgress;
        
        public String getBatchId() {
            return batchId;
        }
        
        public void setBatchId(String batchId) {
            this.batchId = batchId;
        }
        
        public int getTotalTests() {
            return totalTests;
        }
        
        public void setTotalTests(int totalTests) {
            this.totalTests = totalTests;
        }
        
        public int getCompletedTests() {
            return completedTests;
        }
        
        public void setCompletedTests(int completedTests) {
            this.completedTests = completedTests;
        }
        
        public boolean isInProgress() {
            return inProgress;
        }
        
        public void setInProgress(boolean inProgress) {
            this.inProgress = inProgress;
        }
    }
}


package com.cssmart.ui.controller;

import com.cssmart.ui.service.TestExecutionService;
import com.cssmart.ui.service.TestExecutionService.BatchExecutionStatus;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Map;
import java.util.HashMap;

/**
 * REST controller for test execution operations
 */
@Slf4j
@RestController
@RequestMapping("/api/tests")
public class TestController {
    
    private final TestExecutionService testExecutionService;
    
    @Autowired
    public TestController(TestExecutionService testExecutionService) {
        this.testExecutionService = testExecutionService;
    }
    
    /**
     * Run a specific test by ID
     * @param id Test ID
     * @return Test execution result
     */
    @PostMapping("/{id}/run")
    public ResponseEntity<Map<String, Object>> runTest(@PathVariable String id) {
        log.info("Running test with ID: {}", id);
        
        try {
            String executionId = testExecutionService.runTest(id);
            
            Map<String, Object> response = new HashMap<>();
            response.put("status", "success");
            response.put("message", "Test execution started");
            response.put("executionId", executionId);
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error running test with ID: {}", id, e);
            
            Map<String, Object> response = new HashMap<>();
            response.put("status", "error");
            response.put("message", "Failed to run test: " + e.getMessage());
            
            return ResponseEntity.status(500).body(response);
        }
    }
    
    /**
     * Rerun a test from a previous execution
     * @param id Test execution ID
     * @return Test execution result
     */
    @PostMapping("/{id}/rerun")
    public ResponseEntity<Map<String, Object>> rerunTest(@PathVariable String id) {
        log.info("Rerunning test with execution ID: {}", id);
        
        try {
            String executionId = testExecutionService.rerunTest(id);
            
            Map<String, Object> response = new HashMap<>();
            response.put("status", "success");
            response.put("message", "Test execution started");
            response.put("executionId", executionId);
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error rerunning test with execution ID: {}", id, e);
            
            Map<String, Object> response = new HashMap<>();
            response.put("status", "error");
            response.put("message", "Failed to rerun test: " + e.getMessage());
            
            return ResponseEntity.status(500).body(response);
        }
    }
    
    /**
     * Run multiple tests
     * @param testIds List of test IDs to run
     * @return Status of the batch execution
     */
    @PostMapping("/run-batch")
    public ResponseEntity<BatchExecutionStatus> runBatchTests(@RequestBody List<String> testIds) {
        log.info("Running batch of {} tests", testIds.size());
        
        try {
            BatchExecutionStatus status = testExecutionService.runBatchTests(testIds);
            return ResponseEntity.ok(status);
        } catch (Exception e) {
            log.error("Error running batch tests", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Get status of a batch execution
     * @param batchId Batch ID
     * @return Status of the batch execution
     */
    @GetMapping("/batch/{batchId}")
    public ResponseEntity<BatchExecutionStatus> getBatchStatus(@PathVariable String batchId) {
        log.info("Getting status of batch execution: {}", batchId);
        
        try {
            BatchExecutionStatus status = testExecutionService.getBatchStatus(batchId);
            
            if (status == null) {
                return ResponseEntity.notFound().build();
            }
            
            return ResponseEntity.ok(status);
        } catch (Exception e) {
            log.error("Error getting batch status", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Stop an ongoing test execution
     * @param id Test execution ID
     * @return Status of the stop operation
     */
    @PostMapping("/{id}/stop")
    public ResponseEntity<Map<String, Object>> stopTestExecution(@PathVariable String id) {
        log.info("Stopping test execution with ID: {}", id);
        
        try {
            boolean stopped = testExecutionService.stopTestExecution(id);
            
            Map<String, Object> response = new HashMap<>();
            if (stopped) {
                response.put("status", "success");
                response.put("message", "Test execution stopped successfully");
            } else {
                response.put("status", "warning");
                response.put("message", "Failed to stop test execution. It may have already completed.");
            }
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error stopping test execution with ID: {}", id, e);
            
            Map<String, Object> response = new HashMap<>();
            response.put("status", "error");
            response.put("message", "Error stopping test execution: " + e.getMessage());
            
            return ResponseEntity.status(500).body(response);
        }
    }
}

package com.cssmart.ui.controller;

import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.service.TestRecordingService;
import com.cssmart.ui.service.TestExecutionService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.UUID;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

/**
 * REST controller for test recorder operations
 */
@Slf4j
@RestController
@RequestMapping("/api/recorder")
public class RecorderController {
    
    private final TestRecordingService testRecordingService;
    private final TestExecutionService testExecutionService;
    
    @Autowired
    public RecorderController(
            TestRecordingService testRecordingService,
            TestExecutionService testExecutionService) {
        this.testRecordingService = testRecordingService;
        this.testExecutionService = testExecutionService;
    }
    
    /**
     * Save a recorded test case
     * @param testCase Recorded test case
     * @return Saved test case
     */
    @PostMapping("/save")
    public ResponseEntity<TestCase> saveTestCase(@RequestBody TestCase testCase) {
        log.info("Saving recorded test case: {}", testCase.getName());
        
        try {
            // Ensure the test case has an ID
            if (testCase.getId() == null || testCase.getId().isEmpty()) {
                testCase.setId(UUID.randomUUID().toString());
            }
            
            // Save the test case
            TestCase savedTestCase = testRecordingService.saveRecordedTest(testCase);
            
            return ResponseEntity.ok(savedTestCase);
        } catch (Exception e) {
            log.error("Error saving test case", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Run a recorded test
     * @param id Test case ID
     * @return Execution status
     */
    @PostMapping("/{id}/run")
    public ResponseEntity<Map<String, Object>> runTest(@PathVariable("id") String id) {
        log.info("Running recorded test: {}", id);
        
        try {
            // Get the test case
            TestCase testCase = testRecordingService.getRecordedTest(id);
            
            if (testCase == null) {
                log.warn("Test case not found with ID: {}", id);
                
                Map<String, Object> response = new HashMap<>();
                response.put("status", "error");
                response.put("message", "Test case not found with ID: " + id);
                
                return ResponseEntity.status(404).body(response);
            }
            
            // Run the test using TestExecutionService
            String executionId = testExecutionService.runTest(id);
            
            Map<String, Object> response = new HashMap<>();
            response.put("status", "success");
            response.put("message", "Test execution started");
            response.put("executionId", executionId);
            response.put("testName", testCase.getName());
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error running test", e);
            
            Map<String, Object> response = new HashMap<>();
            response.put("status", "error");
            response.put("message", "Failed to run test: " + e.getMessage());
            
            return ResponseEntity.status(500).body(response);
        }
    }
    
    /**
     * Get browser configuration options
     * @return Browser configuration
     */
    @GetMapping("/browser-config")
    public ResponseEntity<BrowserConfig> getBrowserConfig() {
        log.info("Fetching browser configuration options");
        
        try {
            BrowserConfig config = new BrowserConfig();
            config.addBrowserOption("chrome", "Chrome");
            config.addBrowserOption("firefox", "Firefox");
            config.addBrowserOption("edge", "Edge");
            config.addBrowserOption("safari", "Safari");
            
            return ResponseEntity.ok(config);
        } catch (Exception e) {
            log.error("Error fetching browser configuration", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Get all recorded tests
     * @return List of recorded tests
     */
    @GetMapping
    public ResponseEntity<List<TestCase>> getAllRecordedTests() {
        log.info("Fetching all recorded tests");
        
        try {
            List<TestCase> tests = testRecordingService.getAllRecordedTests();
            return ResponseEntity.ok(tests);
        } catch (Exception e) {
            log.error("Error fetching recorded tests", e);
            return ResponseEntity.status(500).body(new ArrayList<>());
        }
    }
    
    /**
     * Get a recorded test by ID
     * @param id Test ID
     * @return Test case
     */
    @GetMapping("/{id}")
    public ResponseEntity<TestCase> getTestCase(@PathVariable("id") String id) {
        log.info("Fetching recorded test with ID: {}", id);
        
        try {
            TestCase testCase = testRecordingService.getRecordedTest(id);
            
            if (testCase == null) {
                return ResponseEntity.notFound().build();
            }
            
            return ResponseEntity.ok(testCase);
        } catch (Exception e) {
            log.error("Error fetching recorded test", e);
            return ResponseEntity.status(500).body(null);
        }
    }
    
    /**
     * Delete a recorded test
     * @param id Test ID
     * @return Success status
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Map<String, Object>> deleteTestCase(@PathVariable("id") String id) {
        log.info("Deleting recorded test with ID: {}", id);
        
        try {
            boolean deleted = testRecordingService.deleteRecordedTest(id);
            
            Map<String, Object> response = new HashMap<>();
            
            if (deleted) {
                response.put("status", "success");
                response.put("message", "Test case deleted successfully");
                return ResponseEntity.ok(response);
            } else {
                response.put("status", "error");
                response.put("message", "Test case not found");
                return ResponseEntity.status(404).body(response);
            }
        } catch (Exception e) {
            log.error("Error deleting recorded test", e);
            
            Map<String, Object> response = new HashMap<>();
            response.put("status", "error");
            response.put("message", "Failed to delete test case: " + e.getMessage());
            
            return ResponseEntity.status(500).body(response);
        }
    }
}

/**
 * Browser configuration options
 */
class BrowserConfig {
    private List<BrowserOption> browsers = new ArrayList<>();
    
    public void addBrowserOption(String value, String label) {
        browsers.add(new BrowserOption(value, label));
    }
    
    public List<BrowserOption> getBrowsers() {
        return browsers;
    }
    
    public void setBrowsers(List<BrowserOption> browsers) {
        this.browsers = browsers;
    }
    
    static class BrowserOption {
        private String value;
        private String label;
        
        public BrowserOption(String value, String label) {
            this.value = value;
            this.label = label;
        }
        
        public String getValue() {
            return value;
        }
        
        public void setValue(String value) {
            this.value = value;
        }
        
        public String getLabel() {
            return label;
        }
        
        public void setLabel(String label) {
            this.label = label;
        }
    }
}

package com.cssmart.ui.service;

import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.controller.GeneratedTest;
import com.cssmart.ai.engine.AIEngine;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.UUID;
import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.Path;

/**
 * Service for managing recorded tests, including storing and converting between
 * recorded TestCase objects and GeneratedTest objects for the Test Generator
 */
@Slf4j
@Service
public class TestRecordingService {
    
    private final AIEngine aiEngine;
    private final Map<String, TestCase> recordedTests;
    private static final String RECORDED_TESTS_DIR = "recorded-tests";
    
    @Autowired
    public TestRecordingService(AIEngine aiEngine) {
        this.aiEngine = aiEngine;
        this.recordedTests = new ConcurrentHashMap<>();
        
        // Ensure recorded tests directory exists
        File dir = new File(RECORDED_TESTS_DIR);
        if (!dir.exists()) {
            dir.mkdirs();
        }
        
        // Load existing tests
        loadExistingTests();
    }
    
    /**
     * Load existing tests from disk
     */
    private void loadExistingTests() {
        try {
            File dir = new File(RECORDED_TESTS_DIR);
            File[] files = dir.listFiles((d, name) -> name.endsWith(".json"));
            
            if (files != null) {
                com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();
                mapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule());
                mapper.configure(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
                
                for (File file : files) {
                    try {
                        TestCase testCase = mapper.readValue(file, TestCase.class);
                        recordedTests.put(testCase.getId(), testCase);
                        log.info("Loaded recorded test: {}", testCase.getName());
                    } catch (Exception e) {
                        log.error("Error loading test from file: {}", file.getName(), e);
                    }
                }
                
                log.info("Loaded {} recorded tests", recordedTests.size());
            }
        } catch (Exception e) {
            log.error("Error loading existing tests", e);
        }
    }
    
    /**
     * Save a recorded test case
     * @param testCase The test case to save
     * @return The saved test case with ID
     */
    public TestCase saveRecordedTest(TestCase testCase) {
        try {
            log.info("Saving recorded test: {}", testCase.getName());
            
            // Ensure test case has an ID
            if (testCase.getId() == null || testCase.getId().isEmpty()) {
                testCase.setId(UUID.randomUUID().toString());
            }
            
            // Store in memory
            recordedTests.put(testCase.getId(), testCase);
            
            // Save to file system
            saveTestToFile(testCase);
            
            return testCase;
        } catch (Exception e) {
            log.error("Error saving recorded test", e);
            throw new RuntimeException("Failed to save recorded test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Get a recorded test by ID
     * @param id Test ID
     * @return Test case or null if not found
     */
    public TestCase getRecordedTest(String id) {
        return recordedTests.get(id);
    }
    
    /**
     * Get all recorded tests
     * @return List of all recorded tests
     */
    public List<TestCase> getAllRecordedTests() {
        return new ArrayList<>(recordedTests.values());
    }
    
    /**
     * Delete a recorded test
     * @param id Test ID
     * @return true if deleted, false if not found
     */
    public boolean deleteRecordedTest(String id) {
        TestCase testCase = recordedTests.remove(id);
        
        if (testCase != null) {
            try {
                // Delete file
                File file = new File(RECORDED_TESTS_DIR, id + ".json");
                if (file.exists()) {
                    file.delete();
                }
                
                // Delete Java file if it exists
                String className = testCase.getClassName();
                if (className != null && !className.isEmpty()) {
                    File javaFile = new File("src/main/java/com/cssmart/tests/generated", className + ".java");
                    if (javaFile.exists()) {
                        javaFile.delete();
                    }
                }
                
                return true;
            } catch (Exception e) {
                log.error("Error deleting test file", e);
                return true; // Still return true since it was removed from memory
            }
        }
        
        return false;
    }
    
    /**
     * Convert a recorded TestCase to a GeneratedTest for the Test Generator
     * @param testCase The test case to convert
     * @return A GeneratedTest object
     */
    public GeneratedTest convertToGeneratedTest(TestCase testCase) {
        try {
            log.info("Converting recorded test to generated test: {}", testCase.getName());
            
            GeneratedTest generatedTest = new GeneratedTest();
            generatedTest.setId(testCase.getId());
            generatedTest.setName(testCase.getName());
            generatedTest.setDescription(testCase.getDescription());
            generatedTest.setClassName(testCase.getClassName());
            generatedTest.setMethodName(testCase.getMethodName());
            generatedTest.setCode(testCase.getCode());
            
            // Convert steps
            if (testCase.getSteps() != null) {
                generatedTest.setSteps(testCase.getSteps());
            }
            
            return generatedTest;
        } catch (Exception e) {
            log.error("Error converting recorded test to generated test", e);
            throw new RuntimeException("Failed to convert test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Convert a GeneratedTest to a TestCase
     * @param generatedTest The generated test to convert
     * @return A TestCase object
     */
    public TestCase convertToTestCase(GeneratedTest generatedTest) {
        try {
            log.info("Converting generated test to test case: {}", generatedTest.getName());
            
            TestCase testCase = new TestCase();
            testCase.setId(generatedTest.getId());
            testCase.setName(generatedTest.getName());
            testCase.setDescription(generatedTest.getDescription());
            testCase.setClassName(generatedTest.getClassName());
            testCase.setMethodName(generatedTest.getMethodName());
            testCase.setCode(generatedTest.getCode());
            
            // Convert steps
            if (generatedTest.getSteps() != null) {
                testCase.setSteps(generatedTest.getSteps());
            }
            
            return testCase;
        } catch (Exception e) {
            log.error("Error converting generated test to test case", e);
            throw new RuntimeException("Failed to convert test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Enhance a test case with AI
     * @param testCase The test case to enhance
     * @return The enhanced test case
     */
    public TestCase enhanceTestCase(TestCase testCase) {
        try {
            log.info("Enhancing test case with AI: {}", testCase.getName());
            
            // Use AI engine to enhance the test case
            // This is a placeholder for the actual AI enhancement
            if (aiEngine != null) {
                return aiEngine.enhanceTestCase(testCase);
            }
            
            return testCase;
        } catch (Exception e) {
            log.error("Error enhancing test case", e);
            
            // Return the original test case if enhancement fails
            return testCase;
        }
    }
    
    /**
     * Save a test case to file
     * @param testCase The test case to save
     */
    private void saveTestToFile(TestCase testCase) {
        try {
            // Create directories if they don't exist
            File testDir = new File(RECORDED_TESTS_DIR);
            if (!testDir.exists()) {
                testDir.mkdirs();
            }
            
            // Save test case as JSON
            File testFile = new File(RECORDED_TESTS_DIR, testCase.getId() + ".json");
            
            // Use Jackson to serialize to JSON
            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
            objectMapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule());
            objectMapper.disable(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
            
            objectMapper.writeValue(testFile, testCase);
            
            log.info("Saved test case to file: {}", testFile.getAbsolutePath());
            
            // If code is present, also save it as a Java file
            if (testCase.getCode() != null && !testCase.getCode().isEmpty() &&
                testCase.getClassName() != null && !testCase.getClassName().isEmpty()) {
                
                String packageDir = "src/main/java/com/cssmart/tests/generated";
                
                // Create package directories if they don't exist
                File packagePath = new File(packageDir);
                if (!packagePath.exists()) {
                    packagePath.mkdirs();
                }
                
                File javaFile = new File(packageDir, testCase.getClassName() + ".java");
                Files.writeString(javaFile.toPath(), testCase.getCode());
                
                log.info("Saved test code to: {}", javaFile.getAbsolutePath());
            }
        } catch (Exception e) {
            log.error("Error saving test case to file", e);
            throw new RuntimeException("Failed to save test to file: " + e.getMessage(), e);
        }
    }
}


// src/main/webapp/src/components/recorder/TestRecorder.jsx
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import RecordedSteps from './RecordedSteps';
import RecorderConfig from './RecorderConfig';
import TestCodeViewer from './TestCodeViewer';
import BDDTestViewer from './BDDTestViewer';
import Button from '../common/Button';
import Card from '../common/Card';
import Alert from '../common/Alert';
import Spinner from '../common/Spinner';
import { Tab, Tabs } from '@/components/ui/tabs';
import { useNotification } from '../../context/NotificationContext';

const TestRecorder = () => {
  const navigate = useNavigate();
  const { addNotification } = useNotification();
  const [isRecording, setIsRecording] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [recordedSteps, setRecordedSteps] = useState([]);
  const [testCase, setTestCase] = useState(null);
  const [bddTestSuite, setBddTestSuite] = useState(null);
  const [loadingBdd, setLoadingBdd] = useState(false);
  const [isGeneratingCode, setIsGeneratingCode] = useState(false);
  const [isRunningTest, setIsRunningTest] = useState(false);
  const [error, setError] = useState(null);
  const [successMessage, setSuccessMessage] = useState(null);
  const [testFormat, setTestFormat] = useState('testng'); // 'testng' or 'bdd'
  const [config, setConfig] = useState({
    url: 'https://example.com',
    browser: 'chrome',
    headless: false
  });
  const websocket = useRef(null);
  
  // Handle WebSocket cleanup on component unmount
  useEffect(() => {
    return () => {
      if (websocket.current) {
        websocket.current.close();
      }
    };
  }, []);
  
  // Connect to WebSocket when starting recording
  const connectWebSocket = () => {
    try {
      setIsConnecting(true);
      setError(null);
      
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/recorder`;
      
      websocket.current = new WebSocket(wsUrl);
      
      websocket.current.onopen = () => {
        console.log('WebSocket connected');
        setIsConnecting(false);
        
        // Send recording configuration to the server
        websocket.current.send(JSON.stringify({ 
          type: 'START_RECORDING',
          data: config
        }));
      };
      
      websocket.current.onmessage = (event) => {
        const message = JSON.parse(event.data);
        
        if (message.type === 'RECORDING_STARTED') {
          console.log('Recording started');
          setIsRecording(true);
          addNotification('Recording started successfully!', 'success');
        } else if (message.type === 'ACTION_RECORDED') {
          console.log('Action recorded');
        } else if (message.type === 'STEP_RECORDED') {
          console.log('Step recorded:', message.data);
          setRecordedSteps(prev => [...prev, message.data]);
        } else if (message.type === 'TEST_CASE') {
          console.log('Test case received:', message.data);
          setTestCase(message.data);
          setIsRecording(false);
          setIsGeneratingCode(false);
          addNotification('Test recorded successfully!', 'success');
          
          // Reset BDD test suite when new test is recorded
          setBddTestSuite(null);
        } else if (message.type === 'ERROR') {
          console.error('WebSocket error:', message.data);
          setError(`Error: ${message.data}`);
          setIsRecording(false);
          setIsConnecting(false);
          setIsGeneratingCode(false);
          addNotification(`Recording error: ${message.data}`, 'error');
        }
      };
      
      websocket.current.onerror = (error) => {
        console.error('WebSocket error:', error);
        setError('Failed to connect to the recording service. Please check if the server is running.');
        setIsRecording(false);
        setIsConnecting(false);
        addNotification('Failed to connect to recording service', 'error');
      };
      
      websocket.current.onclose = () => {
        console.log('WebSocket disconnected');
        if (isRecording) {
          setIsRecording(false);
          addNotification('Recording connection closed', 'warning');
        }
      };
      
      return true;
    } catch (error) {
      console.error('Error connecting to WebSocket:', error);
      setError(`Connection error: ${error.message}`);
      setIsRecording(false);
      setIsConnecting(false);
      addNotification(`Connection error: ${error.message}`, 'error');
      return false;
    }
  };
  
  // Start recording
  const startRecording = () => {
    setRecordedSteps([]);
    setTestCase(null);
    setBddTestSuite(null);
    setError(null);
    setSuccessMessage(null);
    
    const connected = connectWebSocket();
    if (!connected) {
      setError('Failed to start recording. Could not connect to server.');
    }
  };
  
  // Stop recording
  const stopRecording = () => {
    if (websocket.current && websocket.current.readyState === WebSocket.OPEN) {
      websocket.current.send(JSON.stringify({ type: 'STOP_RECORDING' }));
      setIsGeneratingCode(true);
    } else {
      setError('WebSocket is not connected. Cannot stop recording.');
      addNotification('Cannot stop recording: connection lost', 'error');
    }
  };
  
  // Update configuration
  const updateConfig = (newConfig) => {
    setConfig(newConfig);
  };
  
  // Save test case
  const saveTestCase = async () => {
    if (!testCase) return;
    
    try {
      const response = await fetch('/api/recorder/save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(testCase),
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      setTestCase(data); // Update with saved data that contains ID
      setSuccessMessage('Test case saved successfully!');
      addNotification('Test case saved successfully!', 'success');
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(null), 3000);
      
    } catch (error) {
      console.error('Error saving test case:', error);
      setError(`Failed to save test case: ${error.message}`);
      addNotification(`Failed to save test case: ${error.message}`, 'error');
    }
  };
  
  // Generate BDD tests from TestNG test
  const generateBDDTests = async () => {
    if (!testCase || !testCase.id) {
      setError('Please save the test case first');
      addNotification('Please save the test case first', 'warning');
      return;
    }
    
    try {
      setLoadingBdd(true);
      setError(null);
      
      const response = await fetch(`/api/bdd/generate/${testCase.id}`, {
        method: 'POST',
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      setBddTestSuite(data);
      setTestFormat('bdd');
      setSuccessMessage('BDD tests generated successfully!');
      addNotification('BDD tests generated successfully!', 'success');
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (error) {
      console.error('Error generating BDD tests:', error);
      setError(`Failed to generate BDD tests: ${error.message}`);
      addNotification(`Failed to generate BDD tests: ${error.message}`, 'error');
    } finally {
      setLoadingBdd(false);
    }
  };
  
  // Run BDD tests
  const runBDDTests = async () => {
    if (!bddTestSuite || !bddTestSuite.id) {
      setError('No BDD test suite available to run');
      return;
    }
    
    try {
      const response = await fetch(`/api/bdd/${bddTestSuite.id}/run`, {
        method: 'POST',
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      return result;
    } catch (error) {
      console.error('Error running BDD tests:', error);
      throw error;
    }
  };
  
  // Edit in Test Generator
  const editInGenerator = () => {
    if (!testCase || !testCase.id) {
      addNotification('Please save the test first', 'warning');
      return;
    }
    
    // Navigate to Test Generator with the current test
    navigate('/generator', { state: { testCase } });
  };
  
  // Run test
  const runTest = async () => {
    if (!testCase || !testCase.id) {
      setError('Please save the test first');
      addNotification('Please save the test first', 'warning');
      return;
    }
    
    try {
      setIsRunningTest(true);
      
      // Run the recorded test
      const response = await fetch(`/api/recorder/${testCase.id}/run`, {
        method: 'POST',
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      console.log('Test execution started:', result);
      
      if (result.status === 'success') {
        setSuccessMessage(`Test execution started: ${result.testName}`);
        addNotification('Test execution started. Check Reports for results.', 'success');
        
        // Redirect to reports page after a delay
        setTimeout(() => {
          navigate('/reports');
        }, 3000);
      } else {
        throw new Error(result.message || 'Unknown error');
      }
    } catch (error) {
      console.error('Error running test:', error);
      setError(`Failed to run test: ${error.message}`);
      addNotification(`Failed to run test: ${error.message}`, 'error');
    } finally {
      setIsRunningTest(false);
    }
  };
  
  return (
    <div className="space-y-6">
      {/* Header with action buttons */}
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold">Test Recorder</h1>
        <div className="flex space-x-2">
          {!isRecording ? (
            <Button
              variant="primary"
              disabled={isConnecting}
              onClick={startRecording}
            >
              {isConnecting ? (
                <>
                  <Spinner size="sm" color="white" className="mr-2" />
                  Connecting...
                </>
              ) : (
                'Start Recording'
              )}
            </Button>
          ) : (
            <Button
              variant="danger"
              onClick={stopRecording}
            >
              Stop Recording
            </Button>
          )}
        </div>
      </div>
      
      {/* Error and success messages */}
      {error && (
        <Alert
          type="error"
          title="Error"
          onClose={() => setError(null)}
        >
          {error}
        </Alert>
      )}
      
      {successMessage && (
        <Alert
          type="success"
          title="Success"
          onClose={() => setSuccessMessage(null)}
        >
          {successMessage}
        </Alert>
      )}
      
      {/* Configuration and steps */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <RecorderConfig 
          config={config} 
          updateConfig={updateConfig} 
          disabled={isRecording || isConnecting} 
        />
        
        <RecordedSteps 
          steps={recordedSteps} 
          isRecording={isRecording}
        />
      </div>
      
      {/* Generated code - loading state */}
      {isGeneratingCode && !testCase && (
        <Card>
          <div className="flex justify-center items-center py-6">
            <Spinner size="md" className="mr-3" />
            <span>Generating test code...</span>
          </div>
        </Card>
      )}
      
      {/* Generated code - test case available */}
      {testCase && (
        <Card>
          <div className="p-4 border-b">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-semibold">Generated Test</h2>
              <div className="flex space-x-2">
                <Button
                  variant="secondary"
                  onClick={editInGenerator}
                >
                  Edit in Test Generator
                </Button>
                <Button
                  variant="primary"
                  onClick={saveTestCase}
                >
                  Save Test
                </Button>
                {!bddTestSuite && (
                  <Button
                    variant="outline"
                    onClick={generateBDDTests}
                    disabled={loadingBdd || !testCase.id}
                  >
                    {loadingBdd ? (
                      <>
                        <Spinner size="sm" className="mr-2" />
                        Generating BDD...
                      </>
                    ) : 'Generate BDD'}
                  </Button>
                )}
                <Button
                  variant="success"
                  onClick={runTest}
                  disabled={isRunningTest || !testCase.id}
                >
                  {isRunningTest ? (
                    <>
                      <Spinner size="sm" color="white" className="mr-2" />
                      Running...
                    </>
                  ) : 'Run Test'}
                </Button>
              </div>
            </div>
            <div className="mb-4">
              <p><strong>Test Name:</strong> {testCase.name}</p>
              <p><strong>Description:</strong> {testCase.description}</p>
              {testCase.id && <p><strong>ID:</strong> {testCase.id}</p>}
            </div>
          </div>
          
          {/* Tabs for TestNG and BDD */}
          {bddTestSuite ? (
            <div>
              <div className="px-4 py-2 border-b">
                <Tabs value={testFormat} onValueChange={setTestFormat}>
                  <Tab value="testng" label="TestNG Code" />
                  <Tab value="bdd" label="BDD Tests" />
                </Tabs>
              </div>
              
              <div className="p-4">
                {testFormat === 'testng' ? (
                  <TestCodeViewer code={testCase.code} />
                ) : (
                  <BDDTestViewer 
                    bddTest={bddTestSuite} 
                    loading={loadingBdd}
                    onRun={runBDDTests}
                  />
                )}
              </div>
            </div>
          ) : (
            <div className="p-4">
              <TestCodeViewer code={testCase.code} />
            </div>
          )}
        </Card>
      )}
      
      {/* Recording indicator */}
      {isRecording && (
        <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-red-600 text-white px-4 py-2 rounded-md shadow-lg animate-pulse">
          Recording in progress... Actions performed in the browser are being captured.
        </div>
      )}
    </div>
  );
};

export default TestRecorder;


// src/main/webapp/src/components/reports/Reports.jsx
import React, { useState, useEffect } from 'react';
import { useLocation } from 'react-router-dom';
import Card from '../common/Card';
import Button from '../common/Button';
import Alert from '../common/Alert';
import Spinner from '../common/Spinner';
import { Tab, Tabs } from '@/components/ui/tabs';
import { useNotification } from '../../context/NotificationContext';

const Reports = () => {
  const location = useLocation();
  const { addNotification } = useNotification();
  const [reports, setReports] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [activeTab, setActiveTab] = useState('all');
  const [selectedReport, setSelectedReport] = useState(null);
  const [filter, setFilter] = useState({
    status: '',
    dateRange: 'last7days',
    search: ''
  });
  
  // Load reports on component mount or when filter changes
  useEffect(() => {
    fetchReports();
  }, [filter]);
  
  // Check for executionId in location state or query params
  useEffect(() => {
    // Check for executionId in location state
    const executionId = location.state?.executionId;
    
    if (executionId) {
      // Highlight the test with this execution ID
      addNotification(`Test execution started with ID: ${executionId}`, 'info');
    }
    
    // Check for executionId in query params
    const params = new URLSearchParams(location.search);
    const queryExecutionId = params.get('executionId');
    
    if (queryExecutionId) {
      addNotification(`Test execution started with ID: ${queryExecutionId}`, 'info');
    }
  }, [location]);
  
  // Fetch reports from API
  const fetchReports = async () => {
    setLoading(true);
    setError(null);
    
    try {
      // Build query params
      const params = new URLSearchParams();
      if (filter.status) params.append('status', filter.status);
      if (filter.dateRange) params.append('dateRange', filter.dateRange);
      if (filter.search) params.append('search', filter.search);
      
      const response = await fetch(`/api/reports?${params.toString()}`);
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      setReports(data);
    } catch (error) {
      console.error('Error fetching reports:', error);
      setError(`Failed to fetch reports: ${error.message}`);
      
      // Set sample data for development if API is not available
      setReports(generateSampleReports());
    } finally {
      setLoading(false);
    }
  };
  
  // Delete a report
  const deleteReport = async (id) => {
    if (!window.confirm('Are you sure you want to delete this report?')) {
      return;
    }
    
    try {
      const response = await fetch(`/api/reports/${id}`, {
        method: 'DELETE'
      });
      
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      
      // Remove report from state
      setReports(reports.filter(report => report.id !== id));
      
      // If the deleted report was selected, deselect it
      if (selectedReport && selectedReport.id === id) {
        setSelectedReport(null);
      }
      
      addNotification('Report deleted successfully', 'success');
    } catch (error) {
      console.error('Error deleting report:', error);
      setError(`Failed to delete report: ${error.message}`);
      addNotification(`Failed to delete report: ${error.message}`, 'error');
    }
  };
  
  // Export reports
  const exportReports = async (format) => {
    try {
      window.open(`/api/reports/export?format=${format}`, '_blank');
      addNotification(`Reports exported as ${format.toUpperCase()}`, 'success');
    } catch (error) {
      console.error('Error exporting reports:', error);
      setError(`Failed to export reports: ${error.message}`);
      addNotification(`Failed to export reports: ${error.message}`, 'error');
    }
  };
  
  // Update filter
  const handleFilterChange = (field, value) => {
    setFilter({
      ...filter,
      [field]: value
    });
  };
  
  // Filter reports based on active tab
  const filteredReports = reports.filter(report => {
    if (activeTab === 'all') return true;
    if (activeTab === 'passed') return report.status === 'PASSED';
    if (activeTab === 'failed') return report.status === 'FAILED';
    if (activeTab === 'skipped') return report.status === 'SKIPPED';
    return true;
  });
  
  // Generate sample reports for development
  const generateSampleReports = () => {
    const statuses = ['PASSED', 'FAILED', 'SKIPPED'];
    const sampleReports = [];
    
    for (let i = 0; i < 10; i++) {
      const status = statuses[Math.floor(Math.random() * statuses.length)];
      const date = new Date();
      date.setHours(date.getHours() - i);
      
      sampleReports.push({
        id: `report-${i}`,
        name: `Test Report ${i + 1}`,
        description: `Sample test report #${i + 1}`,
        status: status,
        duration: Math.floor(Math.random() * 10000) + 1000,
        startTime: new Date(date.getTime() - 5000),
        endTime: date,
        browser: ['chrome', 'firefox', 'edge'][Math.floor(Math.random() * 3)],
        environment: ['dev', 'qa', 'staging'][Math.floor(Math.random() * 3)],
        className: `com.cssmart.tests.SampleTest${i}`,
        methodName: `testMethod${i}`
      });
    }
    
    return sampleReports;
  };
  
  // Render loading spinner
  if (loading && reports.length === 0) {
    return (
      <div className="flex justify-center items-center h-64">
        <Spinner size="lg" />
        <span className="ml-3 text-gray-600">Loading reports...</span>
      </div>
    );
  }
  
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold">Test Reports</h1>
        <div className="flex space-x-2">
          <div className="relative">
            <select 
              className="rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              value={filter.dateRange}
              onChange={(e) => handleFilterChange('dateRange', e.target.value)}
            >
              <option value="today">Today</option>
              <option value="yesterday">Yesterday</option>
              <option value="last7days">Last 7 Days</option>
              <option value="last30days">Last 30 Days</option>
              <option value="thisMonth">This Month</option>
              <option value="lastMonth">Last Month</option>
            </select>
          </div>
          <div className="relative">
            <input
              type="text"
              placeholder="Search tests..."
              className="rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              value={filter.search}
              onChange={(e) => handleFilterChange('search', e.target.value)}
            />
          </div>
          <Button
            variant="outline"
            onClick={() => exportReports('pdf')}
          >
            Export PDF
          </Button>
          <Button
            variant="outline"
            onClick={() => exportReports('html')}
          >
            Export HTML
          </Button>
          <Button
            variant="primary"
            onClick={() => fetchReports()}
          >
            Refresh
          </Button>
        </div>
      </div>
      
      {/* Error message */}
      {error && (
        <Alert
          type="error"
          title="Error"
          onClose={() => setError(null)}
        >
          {error}
        </Alert>
      )}
      
      <Card>
        {/* Tabs for filtering by status */}
        <div className="border-b">
          <Tabs value={activeTab} onValueChange={setActiveTab}>
            <Tab value="all" label="All Tests" />
            <Tab value="passed" label="Passed" />
            <Tab value="failed" label="Failed" />
            <Tab value="skipped" label="Skipped" />
          </Tabs>
        </div>
        
        {/* Reports list */}
        <div className="p-4">
          {filteredReports.length === 0 ? (
            <div className="text-center py-8 text-gray-500">
              No reports found.
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Test Name</th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Duration</th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">End Time</th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Browser</th>
                    <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {filteredReports.map(report => (
                    <tr 
                      key={report.id}
                      className={`hover:bg-gray-50 ${selectedReport?.id === report.id ? 'bg-blue-50' : ''}`}
                      onClick={() => setSelectedReport(report)}
                    >
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="font-medium text-gray-900">{report.name}</div>
                        <div className="text-sm text-gray-500">{report.description}</div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                          report.status === 'PASSED' ? 'bg-green-100 text-green-800' :
                          report.status === 'FAILED' ? 'bg-red-100 text-red-800' :
                          'bg-yellow-100 text-yellow-800'
                        }`}>
                          {report.status}
                        </span>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {(report.duration / 1000).toFixed(2)}s
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {new Date(report.endTime).toLocaleString()}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                        {report.browser}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                        <button
                          className="text-indigo-600 hover:text-indigo-900 mr-3"
                          onClick={(e) => {
                            e.stopPropagation();
                            window.open(`/api/reports/${report.id}/view`, '_blank');
                          }}
                        >
                          View
                        </button>
                        <button
                          className="text-red-600 hover:text-red-900"
                          onClick={(e) => {
                            e.stopPropagation();
                            deleteReport(report.id);
                          }}
                        >
                          Delete
                        </button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
        </div>
      </Card>
      
      {/* Report details */}
      {selectedReport && (
        <Card title={`Test Details: ${selectedReport.name}`}>
          <div className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <h3 className="text-lg font-medium">Test Information</h3>
                <div className="mt-2 space-y-2">
                  <p><strong>Test Name:</strong> {selectedReport.name}</p>
                  <p><strong>Description:</strong> {selectedReport.description}</p>
                  <p><strong>Class:</strong> {selectedReport.className}</p>
                  <p><strong>Method:</strong> {selectedReport.methodName}</p>
                </div>
              </div>
              <div>
                <h3 className="text-lg font-medium">Execution Details</h3>
                <div className="mt-2 space-y-2">
                  <p><strong>Status:</strong> 
                    <span className={`ml-2 inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                      selectedReport.status === 'PASSED' ? 'bg-green-100 text-green-800' :
                      selectedReport.status === 'FAILED' ? 'bg-red-100 text-red-800' :
                      'bg-yellow-100 text-yellow-800'
                    }`}>
                      {selectedReport.status}
                    </span>
                  </p>
                  <p><strong>Start Time:</strong> {new Date(selectedReport.startTime).toLocaleString()}</p>
                  <p><strong>End Time:</strong> {new Date(selectedReport.endTime).toLocaleString()}</p>
                  <p><strong>Duration:</strong> {(selectedReport.duration / 1000).toFixed(2)}s</p>
                  <p><strong>Browser:</strong> {selectedReport.browser}</p>
                  <p><strong>Environment:</strong> {selectedReport.environment}</p>
                </div>
              </div>
            </div>
            
            {selectedReport.status === 'FAILED' && selectedReport.errorMessage && (
              <div className="mt-4">
                <h3 className="text-lg font-medium text-red-700">Error Details</h3>
                <div className="mt-2 p-4 bg-red-50 rounded border border-red-200 text-red-800 font-mono text-sm whitespace-pre-wrap">
                  {selectedReport.errorMessage}
                </div>
              </div>
            )}
            
            <div className="mt-4 flex justify-end space-x-2">
              <Button
                variant="outline"
                onClick={() => {
                  // Rerun test
                }}
              >
                Rerun Test
              </Button>
              <Button
                variant="primary"
                onClick={() => {
                  window.open(`/api/reports/${selectedReport.id}/view`, '_blank');
                }}
              >
                View Full Report
              </Button>
            </div>
          </div>
        </Card>
      )}
    </div>
  );
};

export default Reports;

package com.cssmart.ui.service;

import com.cssmart.core.base.CSSmartTestBase;
import com.cssmart.core.driver.DriverManager;
import com.cssmart.reporting.ReportManager;
import com.cssmart.reporting.model.TestReport;
import com.cssmart.reporting.model.TestStatus;
import com.cssmart.ui.controller.BatchExecutionStatus;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Service for executing tests
 */
@Slf4j
@Service
public class TestExecutionService {
    
    private final ReportManager reportManager;
    private final ExecutorService executorService;
    private final Map<String, TestExecutionTask> runningTests;
    private final Map<String, BatchExecutionStatus> batchStatuses;
    
    @Autowired
    public TestExecutionService(ReportManager reportManager) {
        this.reportManager = reportManager;
        this.executorService = Executors.newCachedThreadPool();
        this.runningTests = new ConcurrentHashMap<>();
        this.batchStatuses = new ConcurrentHashMap<>();
    }
    
    /**
     * Run a specific test by ID
     * @param id Test ID
     * @return Test execution report
     */
    public TestReport runTest(String id) throws Exception {
        log.info("Running test with ID: {}", id);
        
        // Find test class and method based on ID
        TestInfo testInfo = getTestInfo(id);
        
        // Create execution task
        TestExecutionTask task = new TestExecutionTask(testInfo);
        String executionId = UUID.randomUUID().toString();
        runningTests.put(executionId, task);
        
        // Execute test
        TestReport report = task.executeTest();
        
        // Clean up
        runningTests.remove(executionId);
        
        return report;
    }
    
    /**
     * Rerun a test from a previous execution
     * @param id Previous execution ID
     * @return Test execution report
     */
    public TestReport rerunTest(String id) throws Exception {
        log.info("Rerunning test with execution ID: {}", id);
        
        // Find previous test report
        TestReport previousReport = null;
        List<TestReport> allReports = reportManager.getRecentReports();
        for (TestReport report : allReports) {
            if (report.getId().equals(id)) {
                previousReport = report;
                break;
            }
        }
        
        if (previousReport == null) {
            throw new IllegalArgumentException("No test report found with ID: " + id);
        }
        
        // Create test info from previous report
        TestInfo testInfo = new TestInfo();
        testInfo.setClassName(previousReport.getClassName());
        testInfo.setMethodName(previousReport.getMethodName());
        
        // Create execution task
        TestExecutionTask task = new TestExecutionTask(testInfo);
        String executionId = UUID.randomUUID().toString();
        runningTests.put(executionId, task);
        
        // Execute test
        TestReport report = task.executeTest();
        
        // Clean up
        runningTests.remove(executionId);
        
        return report;
    }
    
    /**
     * Run multiple tests
     * @param testIds List of test IDs to run
     * @return Batch execution status
     */
    public BatchExecutionStatus runBatchTests(List<String> testIds) {
        log.info("Running batch of {} tests", testIds.size());
        
        // Create batch ID
        String batchId = UUID.randomUUID().toString();
        
        // Create batch status
        BatchExecutionStatus status = new BatchExecutionStatus();
        status.setBatchId(batchId);
        status.setTotalTests(testIds.size());
        status.setCompletedTests(0);
        status.setInProgress(true);
        
        // Store batch status
        batchStatuses.put(batchId, status);
        
        // Run tests asynchronously
        executorService.submit(() -> {
            try {
                for (String testId : testIds) {
                    try {
                        runTest(testId);
                    } catch (Exception e) {
                        log.error("Error running test with ID: {}", testId, e);
                    }
                    
                    // Update status
                    status.setCompletedTests(status.getCompletedTests() + 1);
                }
                
                // Mark batch as complete
                status.setInProgress(false);
            } catch (Exception e) {
                log.error("Error in batch execution", e);
                status.setInProgress(false);
            }
        });
        
        return status;
    }
    
    /**
     * Get status of a batch execution
     * @param batchId Batch ID
     * @return Batch execution status
     */
    public BatchExecutionStatus getBatchStatus(String batchId) {
        return batchStatuses.get(batchId);
    }
    
    /**
     * Stop an ongoing test execution
     * @param id Test execution ID
     * @return True if stopped successfully
     */
    public boolean stopTestExecution(String id) {
        TestExecutionTask task = runningTests.get(id);
        
        if (task != null) {
            task.stop();
            runningTests.remove(id);
            return true;
        }
        
        return false;
    }
    
    /**
     * Get test information from test ID
     */
    private TestInfo getTestInfo(String id) {
        // In a real implementation, this would look up the test class and method
        // from a database or repository based on the ID
        TestInfo info = new TestInfo();
        info.setClassName("com.cssmart.examples.web.LoginTest");
        info.setMethodName("testLogin");
        return info;
    }
    
    /**
     * Test information class
     */
    private static class TestInfo {
        private String className;
        private String methodName;
        
        public String getClassName() {
            return className;
        }
        
        public void setClassName(String className) {
            this.className = className;
        }
        
        public String getMethodName() {
            return methodName;
        }
        
        public void setMethodName(String methodName) {
            this.methodName = methodName;
        }
    }
    
    /**
     * Task for executing a test
     */
    private class TestExecutionTask {
        private final TestInfo testInfo;
        private volatile boolean stopped = false;
        
        public TestExecutionTask(TestInfo testInfo) {
            this.testInfo = testInfo;
        }
        
        /**
         * Execute the test
         */
        public TestReport executeTest() throws Exception {
            try {
                // In a real implementation, this would use reflection to
                // instantiate the test class and invoke the test method
                
                // For simulation purposes, create a test report
                TestReport report = TestReport.builder()
                    .id(UUID.randomUUID().toString())
                    .name("Test Execution")
                    .description("Test execution for " + testInfo.getClassName() + "#" + testInfo.getMethodName())
                    .status(TestStatus.PASSED)
                    .duration(5000) // 5 seconds
                    .startTime(java.time.LocalDateTime.now().minusSeconds(5))
                    .endTime(java.time.LocalDateTime.now())
                    .className(testInfo.getClassName())
                    .methodName(testInfo.getMethodName())
                    .browser("chrome")
                    .environment("test")
                    .build();
                
                // Add report to manager
                // Depending on your ReportManager's API, you might need to adjust this
                reportManager.addTestReport(report);
                
                return report;
            } catch (Exception e) {
                log.error("Error executing test", e);
                throw e;
            }
        }
        
        /**
         * Stop the test execution
         */
        public void stop() {
            this.stopped = true;
        }
    }
}



package com.cssmart.ui.service;

import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.recorder.model.RecordedStep;
import com.cssmart.ui.controller.GeneratedTest;
import com.cssmart.ai.codegen.model.TestStep;
import com.cssmart.ai.engine.AIEngine;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.util.Map;
import java.util.UUID;
import java.util.List;
import java.util.ArrayList;
import java.util.stream.Collectors;
import java.util.concurrent.ConcurrentHashMap;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;

/**
 * Service for managing recorded tests, including storing and converting between
 * recorded TestCase objects and GeneratedTest objects for the Test Generator
 */
@Slf4j
@Service
public class TestRecordingService {
    
    private final AIEngine aiEngine;
    private final Map<String, TestCase> recordedTests;
    private static final String RECORDED_TESTS_DIR = "recorded-tests";
    
    @Autowired
    public TestRecordingService(AIEngine aiEngine) {
        this.aiEngine = aiEngine;
        this.recordedTests = new ConcurrentHashMap<>();
        
        // Ensure recorded tests directory exists
        File dir = new File(RECORDED_TESTS_DIR);
        if (!dir.exists()) {
            dir.mkdirs();
        }
    }
    
    /**
     * Save a recorded test case
     * @param testCase The test case to save
     * @return The saved test case with ID
     */
    public TestCase saveRecordedTest(TestCase testCase) {
        try {
            log.info("Saving recorded test: {}", testCase.getName());
            
            // Ensure test case has an ID
            if (testCase.getId() == null || testCase.getId().isEmpty()) {
                testCase.setId(UUID.randomUUID().toString());
            }
            
            // Store in memory
            recordedTests.put(testCase.getId(), testCase);
            
            // Save to file system
            saveTestToFile(testCase);
            
            return testCase;
        } catch (Exception e) {
            log.error("Error saving recorded test", e);
            throw new RuntimeException("Failed to save recorded test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Get a recorded test by ID
     * @param id Test ID
     * @return Test case or null if not found
     */
    public TestCase getRecordedTest(String id) {
        return recordedTests.get(id);
    }
    
    /**
     * Convert a recorded TestCase to a GeneratedTest for the Test Generator
     * @param testCase The test case to convert
     * @return A GeneratedTest object
     */
    public GeneratedTest convertToGeneratedTest(TestCase testCase) {
        try {
            log.info("Converting recorded test to generated test: {}", testCase.getName());
            
            GeneratedTest generatedTest = new GeneratedTest();
            generatedTest.setId(testCase.getId());
            generatedTest.setName(testCase.getName());
            generatedTest.setDescription(testCase.getDescription());
            generatedTest.setClassName(testCase.getClassName());
            generatedTest.setMethodName(testCase.getMethodName());
            generatedTest.setCode(testCase.getCode());
            
            // Convert steps from RecordedStep to TestStep
            if (testCase.getSteps() != null) {
                List<TestStep> testSteps = convertToTestSteps(testCase.getSteps());
                generatedTest.setSteps(testSteps);
            } else {
                generatedTest.setSteps(new ArrayList<>());
            }
            
            return generatedTest;
        } catch (Exception e) {
            log.error("Error converting recorded test to generated test", e);
            throw new RuntimeException("Failed to convert test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Convert RecordedStep list to TestStep list
     */
    private List<TestStep> convertToTestSteps(List<RecordedStep> recordedSteps) {
        if (recordedSteps == null) {
            return new ArrayList<>();
        }
        
        return recordedSteps.stream()
            .map(this::convertToTestStep)
            .collect(Collectors.toList());
    }
    
    /**
     * Convert a single RecordedStep to TestStep
     */
    private TestStep convertToTestStep(RecordedStep recordedStep) {
        TestStep testStep = new TestStep();
        testStep.setAction(recordedStep.getAction());
        testStep.setElement(recordedStep.getElement());
        testStep.setValue(recordedStep.getValue());
        testStep.setDescription(recordedStep.getDescription());
        // Copy any other fields that TestStep has
        
        return testStep;
    }
    
    /**
     * Convert a GeneratedTest to a TestCase
     * @param generatedTest The generated test to convert
     * @return A TestCase object
     */
    public TestCase convertToTestCase(GeneratedTest generatedTest) {
        try {
            log.info("Converting generated test to test case: {}", generatedTest.getName());
            
            TestCase testCase = new TestCase();
            testCase.setId(generatedTest.getId());
            testCase.setName(generatedTest.getName());
            testCase.setDescription(generatedTest.getDescription());
            testCase.setClassName(generatedTest.getClassName());
            testCase.setMethodName(generatedTest.getMethodName());
            testCase.setCode(generatedTest.getCode());
            
            // Convert steps from TestStep to RecordedStep
            if (generatedTest.getSteps() != null) {
                List<RecordedStep> recordedSteps = convertToRecordedSteps(generatedTest.getSteps());
                testCase.setSteps(recordedSteps);
            }
            
            return testCase;
        } catch (Exception e) {
            log.error("Error converting generated test to test case", e);
            throw new RuntimeException("Failed to convert test: " + e.getMessage(), e);
        }
    }
    
    /**
     * Convert TestStep list to RecordedStep list
     */
    private List<RecordedStep> convertToRecordedSteps(List<TestStep> testSteps) {
        if (testSteps == null) {
            return new ArrayList<>();
        }
        
        return testSteps.stream()
            .map(this::convertToRecordedStep)
            .collect(Collectors.toList());
    }
    
    /**
     * Convert a single TestStep to RecordedStep
     */
    private RecordedStep convertToRecordedStep(TestStep testStep) {
        RecordedStep recordedStep = new RecordedStep();
        recordedStep.setAction(testStep.getAction());
        recordedStep.setElement(testStep.getElement());
        recordedStep.setValue(testStep.getValue());
        recordedStep.setDescription(testStep.getDescription());
        recordedStep.setTimestamp(java.time.LocalDateTime.now());
        // Copy any other fields that RecordedStep has
        
        return recordedStep;
    }
    
    /**
     * Enhance a test case with AI
     * @param testCase The test case to enhance
     * @return The enhanced test case
     */
    public TestCase enhanceTestCase(TestCase testCase) {
        try {
            log.info("Enhancing test case with AI: {}", testCase.getName());
            
            // Use AI engine to enhance the test case if available
            if (aiEngine != null) {
                // Improve the test name if it's generic
                if (testCase.getName() == null || testCase.getName().contains("Recorded Test")) {
                    if (testCase.getSteps() != null && !testCase.getSteps().isEmpty()) {
                        // Generate a more descriptive name based on the steps
                        String firstAction = testCase.getSteps().get(0).getAction();
                        String firstElement = testCase.getSteps().get(0).getElement();
                        
                        if (firstAction != null && firstElement != null) {
                            testCase.setName("Test " + firstAction + " on " + firstElement);
                        }
                    }
                }
                
                // Improve the description
                if (testCase.getDescription() == null || testCase.getDescription().isEmpty() || 
                        testCase.getDescription().equals("Automatically recorded test case")) {
                    testCase.setDescription("Automated test to verify functionality of the application");
                }
                
                // In a real implementation, you would use aiEngine methods here
                // testCase = aiEngine.enhanceTestCase(testCase);
            }
            
            return testCase;
        } catch (Exception e) {
            log.error("Error enhancing test case", e);
            // Return the original test case if enhancement fails
            return testCase;
        }
    }
    
    /**
     * Save a test case to file
     * @param testCase The test case to save
     */
    private void saveTestToFile(TestCase testCase) {
        try {
            // Ensure directory exists
            File dir = new File(RECORDED_TESTS_DIR);
            if (!dir.exists()) {
                dir.mkdirs();
            }
            
            // Save test case to file
            File testFile = new File(RECORDED_TESTS_DIR, testCase.getId() + ".json");
            
            // Use Jackson to serialize to JSON
            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
            objectMapper.registerModule(new com.fasterxml.jackson.datatype.jsr310.JavaTimeModule());
            objectMapper.disable(com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
            
            objectMapper.writeValue(testFile, testCase);
            
            log.info("Saved test case to file: {}", testFile.getAbsolutePath());
            
            // If code is present, also save it as a Java file
            if (testCase.getCode() != null && !testCase.getCode().isEmpty()) {
                String packageDir = "src/main/java/com/cssmart/tests/generated".replace('.', '/');
                File packagePath = new File(packageDir);
                if (!packagePath.exists()) {
                    packagePath.mkdirs();
                }
                
                File javaFile = new File(packageDir, testCase.getClassName() + ".java");
                Files.writeString(javaFile.toPath(), testCase.getCode());
                
                log.info("Saved test code to: {}", javaFile.getAbsolutePath());
            }
        } catch (Exception e) {
            log.error("Error saving test case to file", e);
            throw new RuntimeException("Failed to save test to file: " + e.getMessage(), e);
        }
    }
}



