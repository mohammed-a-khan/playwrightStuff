package com.cssmart.ui.recorder;

import com.cssmart.ai.engine.AIEngine;
import com.cssmart.ai.engine.model.Action;
import com.cssmart.ai.engine.model.ActionType;
import com.cssmart.core.pom.PageObjectModel;
import com.cssmart.core.pom.PageElement;
import com.cssmart.core.pom.PageAction;
import com.cssmart.core.pom.PageVerification;
import com.cssmart.ui.recorder.model.RecordedStep;
import com.cssmart.ui.recorder.model.TestCase;
import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Enhanced test recorder that generates Page Object Models
 * from the pages visited during test recording
 */
@Slf4j
public class POMTestRecorder extends TestRecorder {
    
    private final Map<String, PageObjectModel> pageObjects = new HashMap<>();
    private String currentUrl;
    private String currentPageTitle;
    private PageObjectModel currentPageObject;
    private final AIEngine aiEngine;
    
    /**
     * Constructor
     */
    public POMTestRecorder() {
        super();
        this.aiEngine = AIEngine.getInstance();
        log.info("POMTestRecorder initialized");
    }
    
    /**
     * Alternative constructor with recorder API URL
     * @param recorderApiUrl URL of the recorder API
     */
    public POMTestRecorder(String recorderApiUrl) {
        super(recorderApiUrl);
        this.aiEngine = AIEngine.getInstance();
        log.info("POMTestRecorder initialized with API URL: {}", recorderApiUrl);
    }
    
    /**
     * Start recording with page object detection
     * @param browserType Browser type (chrome, firefox, etc.)
     * @param url URL to navigate to
     */
    @Override
    public void startRecording(String browserType, String url) {
        log.info("Starting POM recording with browser: {} and URL: {}", browserType, url);
        super.startRecording(browserType, url);
        
        // Initialize current URL and page title
        WebDriver driver = getDriver();
        if (driver != null) {
            currentUrl = driver.getCurrentUrl();
            currentPageTitle = driver.getTitle();
            detectPageObject();
            log.info("Initial page detected: {} - {}", currentPageTitle, currentUrl);
        } else {
            log.error("Failed to get WebDriver instance");
        }
    }
    
    /**
     * Stop recording
     * @return Test case with page objects
     */
    @Override
    public TestCase stopRecording() {
        log.info("Stopping POM recording");
        TestCase testCase = super.stopRecording();
        
        // Add page objects to test case
        testCase.setPageObjects(new ArrayList<>(pageObjects.values()));
        
        // Generate page object code for all page objects
        generatePageObjectCode();
        
        return testCase;
    }
    
    /**
     * Record an action with page object detection
     * @param action Action to record
     * @param element Element locator
     * @param value Value (if applicable)
     */
    @Override
    public void recordAction(Action action, String element, String value) {
        log.info("Recording action: {} on element: {} with value: {}", action, element, value);
        super.recordAction(action, element, value);
        
        // Check if page has changed
        WebDriver driver = getDriver();
        if (driver != null) {
            String newUrl = driver.getCurrentUrl();
            String newTitle = driver.getTitle();
            
            if (!newUrl.equals(currentUrl) || !newTitle.equals(currentPageTitle)) {
                log.info("Page changed from: {} to: {}", currentUrl, newUrl);
                // Update current URL and title
                currentUrl = newUrl;
                currentPageTitle = newTitle;
                
                // Detect page object for new page
                detectPageObject();
            }
            
            // Detect element for the action
            if (element != null && !element.isEmpty()) {
                detectElement(element, action, value);
            }
        } else {
            log.error("Failed to get WebDriver instance for action recording");
        }
    }
    
    /**
     * Detect page object for the current page
     */
    private void detectPageObject() {
        WebDriver driver = getDriver();
        if (driver == null) {
            log.error("WebDriver is null, cannot detect page object");
            return;
        }
        
        try {
            // Generate a page name from the title or URL
            String pageName = currentPageTitle;
            if (pageName == null || pageName.isEmpty()) {
                pageName = extractPageNameFromUrl(currentUrl);
            }
            
            // Check if this page already has a page object
            String pageKey = generatePageKey(currentUrl);
            if (pageObjects.containsKey(pageKey)) {
                log.info("Using existing page object for: {}", pageName);
                currentPageObject = pageObjects.get(pageKey);
                return;
            }
            
            // Create a new page object model using the Lombok @Builder annotation
            log.info("Creating new page object for: {}", pageName);
            
            currentPageObject = PageObjectModel.builder()
                .id(UUID.randomUUID().toString())
                .name(pageName)
                .pageUrl(currentUrl)
                .packageName("com.cssmart.pom.pages")
                .className(generateClassName(pageName))
                .description("Page Object for " + pageName)
                .elements(new ArrayList<>())
                .actions(new ArrayList<>())
                .verifications(new ArrayList<>())
                .build();
            
            // Store the page object
            pageObjects.put(pageKey, currentPageObject);
            
            // Detect important elements on the page
            detectImportantElements();
            
        } catch (Exception e) {
            log.error("Error detecting page object", e);
        }
    }
    
    /**
     * Detect important elements on the current page
     */
    private void detectImportantElements() {
        WebDriver driver = getDriver();
        if (driver == null) {
            log.error("WebDriver is null, cannot detect elements");
            return;
        }
        
        try {
            log.info("Detecting important elements on page: {}", currentPageObject.getName());
            
            // Find form elements (inputs, buttons, selects)
            List<WebElement> formElements = new ArrayList<>();
            formElements.addAll(driver.findElements(By.tagName("input")));
            formElements.addAll(driver.findElements(By.tagName("button")));
            formElements.addAll(driver.findElements(By.tagName("select")));
            formElements.addAll(driver.findElements(By.tagName("textarea")));
            
            for (WebElement element : formElements) {
                // Skip hidden elements
                if (!element.isDisplayed()) {
                    continue;
                }
                
                String elementId = element.getAttribute("id");
                String elementName = element.getAttribute("name");
                String elementType = element.getTagName();
                String elementText = element.getText();
                String elementClass = element.getAttribute("class");
                
                // Skip elements with no identifiable attributes
                if ((elementId == null || elementId.isEmpty()) && 
                    (elementName == null || elementName.isEmpty()) &&
                    (elementText == null || elementText.isEmpty()) &&
                    (elementClass == null || elementClass.isEmpty())) {
                    continue;
                }
                
                // Determine best locator
                PageElement.LocatorType locatorType;
                String locatorValue;
                
                if (elementId != null && !elementId.isEmpty()) {
                    locatorType = PageElement.LocatorType.ID;
                    locatorValue = elementId;
                } else if (elementName != null && !elementName.isEmpty()) {
                    locatorType = PageElement.LocatorType.NAME;
                    locatorValue = elementName;
                } else {
                    // Generate XPath
                    locatorType = PageElement.LocatorType.XPATH;
                    locatorValue = generateXPath(element);
                }
                
                // Generate a user-friendly name for the element
                String displayName = generateElementName(element, elementType);
                
                // Create PageElement using Lombok @Builder
                PageElement pageElement = PageElement.builder()
                        .name(displayName)
                        .type(elementType)
                        .locatorType(locatorType)
                        .locatorValue(locatorValue)
                        .description("Element on " + currentPageObject.getName())
                        .isList(false)
                        .build();
                
                // Add element to page object
                currentPageObject.addElement(pageElement);
                log.info("Added element to page object: {}", pageElement.getName());
            }
            
            // Find links
            List<WebElement> links = driver.findElements(By.tagName("a"));
            
            for (WebElement link : links) {
                // Skip hidden links
                if (!link.isDisplayed()) {
                    continue;
                }
                
                String linkText = link.getText();
                String linkHref = link.getAttribute("href");
                
                // Skip links with no text or href
                if ((linkText == null || linkText.isEmpty()) &&
                    (linkHref == null || linkHref.isEmpty())) {
                    continue;
                }
                
                // Determine best locator
                PageElement.LocatorType locatorType;
                String locatorValue;
                
                if (linkText != null && !linkText.isEmpty()) {
                    locatorType = PageElement.LocatorType.LINK_TEXT;
                    locatorValue = linkText;
                } else {
                    // Generate XPath
                    locatorType = PageElement.LocatorType.XPATH;
                    locatorValue = generateXPath(link);
                }
                
                // Create PageElement
                PageElement pageElement = PageElement.builder()
                        .name(linkText != null && !linkText.isEmpty() ? linkText + " Link" : "Link to " + linkHref)
                        .type("link")
                        .locatorType(locatorType)
                        .locatorValue(locatorValue)
                        .description("Link on " + currentPageObject.getName())
                        .isList(false)
                        .build();
                
                // Add element to page object
                currentPageObject.addElement(pageElement);
                log.info("Added link to page object: {}", pageElement.getName());
            }
            
        } catch (Exception e) {
            log.error("Error detecting important elements", e);
        }
    }
    
    /**
     * Detect element for a specific action
     * @param elementLocator Element locator
     * @param action Action performed
     * @param value Value (if applicable)
     */
    private void detectElement(String elementLocator, Action action, String value) {
        WebDriver driver = getDriver();
        if (driver == null || currentPageObject == null) {
            return;
        }
        
        try {
            log.info("Detecting element for action: {}", action.getType());
            
            // Find element
            WebElement element = findElement(driver, elementLocator);
            if (element == null) {
                log.warn("Element not found: {}", elementLocator);
                return;
            }
            
            // Extract element properties
            String elementType = element.getTagName();
            String elementId = element.getAttribute("id");
            String elementName = element.getAttribute("name");
            String elementText = element.getText();
            
            // Generate a user-friendly name for the element
            String displayName = generateElementName(element, elementType);
            
            // Determine best locator
            PageElement.LocatorType locatorType;
            String locatorValue;
            
            // Use the provided locator if it's already in a valid format
            if (elementLocator.startsWith("id=")) {
                locatorType = PageElement.LocatorType.ID;
                locatorValue = elementLocator.substring(3);
            } else if (elementLocator.startsWith("name=")) {
                locatorType = PageElement.LocatorType.NAME;
                locatorValue = elementLocator.substring(5);
            } else if (elementLocator.startsWith("css=")) {
                locatorType = PageElement.LocatorType.CSS;
                locatorValue = elementLocator.substring(4);
            } else if (elementLocator.startsWith("xpath=")) {
                locatorType = PageElement.LocatorType.XPATH;
                locatorValue = elementLocator.substring(6);
            } else if (elementLocator.startsWith("linkText=")) {
                locatorType = PageElement.LocatorType.LINK_TEXT;
                locatorValue = elementLocator.substring(9);
            } else {
                // Use element attributes to determine best locator
                if (elementId != null && !elementId.isEmpty()) {
                    locatorType = PageElement.LocatorType.ID;
                    locatorValue = elementId;
                } else if (elementName != null && !elementName.isEmpty()) {
                    locatorType = PageElement.LocatorType.NAME;
                    locatorValue = elementName;
                } else {
                    // Generate XPath
                    locatorType = PageElement.LocatorType.XPATH;
                    locatorValue = generateXPath(element);
                }
            }
            
            // Check if element already exists in page object
            boolean elementExists = false;
            if (currentPageObject.getElements() != null) {
                for (PageElement pageElement : currentPageObject.getElements()) {
                    if (pageElement.getLocatorType().equals(locatorType) && 
                        pageElement.getLocatorValue().equals(locatorValue)) {
                        elementExists = true;
                        log.info("Element already exists in page object: {}", pageElement.getName());
                        break;
                    }
                }
            }
            
            // Add element if it doesn't exist
            if (!elementExists) {
                PageElement pageElement = PageElement.builder()
                        .name(displayName)
                        .type(elementType)
                        .locatorType(locatorType)
                        .locatorValue(locatorValue)
                        .description("Element used in action: " + action.getType())
                        .isList(false)
                        .build();
                
                // Add element to page object
                currentPageObject.addElement(pageElement);
                log.info("Added element to page object: {}", pageElement.getName());
                
                // Also add an action for this element based on the action type
                addActionForElement(pageElement, action, value);
            }
            
        } catch (Exception e) {
            log.warn("Error detecting element for action", e);
        }
    }
    
    /**
     * Add an action for an element based on the action type
     * @param element Page element
     * @param action Action performed
     * @param value Value (if applicable)
     */
    private void addActionForElement(PageElement element, Action action, String value) {
        try {
            // Determine action type
            PageAction.ActionType actionType;
            String actionName;
            Map<String, String> parameters = null;
            
            switch (action.getType()) {
                case CLICK:
                    actionType = PageAction.ActionType.CLICK;
                    actionName = "click" + capitalize(element.getName());
                    break;
                case TYPE:
                    actionType = PageAction.ActionType.TYPE;
                    actionName = "enter" + capitalize(element.getName());
                    parameters = new HashMap<>();
                    parameters.put("value", "Text to enter");
                    break;
                case SELECT:
                    actionType = PageAction.ActionType.SELECT;
                    actionName = "select" + capitalize(element.getName());
                    parameters = new HashMap<>();
                    parameters.put("option", "Option to select");
                    break;
                case HOVER:
                    actionType = PageAction.ActionType.HOVER;
                    actionName = "hoverOver" + capitalize(element.getName());
                    break;
                case WAIT:
                    actionType = PageAction.ActionType.WAIT;
                    actionName = "waitFor" + capitalize(element.getName());
                    break;
                default:
                    actionType = PageAction.ActionType.CUSTOM;
                    actionName = "interactWith" + capitalize(element.getName());
                    break;
            }
            
            // Create action using Lombok @Builder
            PageAction pageAction = PageAction.builder()
                    .name(actionName)
                    .description("Perform " + action.getType() + " on " + element.getName())
                    .type(actionType)
                    .elementName(element.getName())
                    .parameters(parameters)
                    .returnsPage(true)
                    .build();
            
            // Add action to page object
            currentPageObject.addAction(pageAction);
            log.info("Added action to page object: {}", pageAction.getName());
            
            // Add verification for the element
            addVerificationForElement(element);
            
        } catch (Exception e) {
            log.warn("Error adding action for element", e);
        }
    }
    
    /**
     * Add verification for an element
     * @param element Page element
     */
    private void addVerificationForElement(PageElement element) {
        try {
            String verificationName = "verify" + capitalize(element.getName()) + "IsPresent";
            
            // Check if verification already exists
            if (currentPageObject.getVerifications() != null) {
                for (PageVerification verification : currentPageObject.getVerifications()) {
                    if (verification.getName().equals(verificationName)) {
                        return; // Verification already exists
                    }
                }
            }
            
            // Create verification using Lombok @Builder
            PageVerification verification = PageVerification.builder()
                    .name(verificationName)
                    .description("Verify that " + element.getName() + " is present")
                    .type(PageVerification.VerificationType.ELEMENT_PRESENT)
                    .elementName(element.getName())
                    .build();
            
            // Add verification to page object
            currentPageObject.addVerification(verification);
            log.info("Added verification to page object: {}", verification.getName());
            
        } catch (Exception e) {
            log.warn("Error adding verification for element", e);
        }
    }
    
    /**
     * Find element using locator
     * @param driver WebDriver instance
     * @param locator Element locator
     * @return WebElement if found, null otherwise
     */
    private WebElement findElement(WebDriver driver, String locator) {
        try {
            if (locator.startsWith("id=")) {
                return driver.findElement(By.id(locator.substring(3)));
            } else if (locator.startsWith("name=")) {
                return driver.findElement(By.name(locator.substring(5)));
            } else if (locator.startsWith("css=")) {
                return driver.findElement(By.cssSelector(locator.substring(4)));
            } else if (locator.startsWith("xpath=")) {
                return driver.findElement(By.xpath(locator.substring(6)));
            } else if (locator.startsWith("linkText=")) {
                return driver.findElement(By.linkText(locator.substring(9)));
            } else {
                // Try different locator strategies
                try {
                    return driver.findElement(By.id(locator));
                } catch (Exception e) {
                    try {
                        return driver.findElement(By.name(locator));
                    } catch (Exception e2) {
                        try {
                            return driver.findElement(By.cssSelector(locator));
                        } catch (Exception e3) {
                            try {
                                return driver.findElement(By.xpath(locator));
                            } catch (Exception e4) {
                                return null;
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            log.warn("Error finding element with locator: {}", locator, e);
            return null;
        }
    }
    
    /**
     * Generate XPath for an element
     * @param element WebElement
     * @return XPath locator
     */
    private String generateXPath(WebElement element) {
        WebDriver driver = getDriver();
        if (driver == null) {
            return "";
        }
        
        try {
            // Use JavaScript to get XPath
            JavascriptExecutor js = (JavascriptExecutor) driver;
            return (String) js.executeScript(
                "function getXPath(element) {" +
                "    if (element.id !== '') return '//*[@id=\"' + element.id + '\"]';" +
                "    if (element === document.body) return '/html/body';" +
                "    var ix = 0;" +
                "    var siblings = element.parentNode.childNodes;" +
                "    for (var i = 0; i < siblings.length; i++) {" +
                "        var sibling = siblings[i];" +
                "        if (sibling === element) return getXPath(element.parentNode) + '/' + element.tagName.toLowerCase() + '[' + (ix + 1) + ']';" +
                "        if (sibling.nodeType === 1 && sibling.tagName === element.tagName) ix++;" +
                "    }" +
                "}", element);
        } catch (Exception e) {
            log.warn("Error generating XPath", e);
            
            // Fallback to a simple XPath
            String elementId = element.getAttribute("id");
            String elementName = element.getAttribute("name");
            String elementClass = element.getAttribute("class");
            
            if (elementId != null && !elementId.isEmpty()) {
                return "//*[@id='" + elementId + "']";
            } else if (elementName != null && !elementName.isEmpty()) {
                return "//*[@name='" + elementName + "']";
            } else if (elementClass != null && !elementClass.isEmpty()) {
                return "//*[@class='" + elementClass + "']";
            } else {
                return "//unidentified-element";
            }
        }
    }
    
    /**
     * Generate a user-friendly name for an element
     * @param element WebElement
     * @param elementType Element type (tag name)
     * @return User-friendly name
     */
    private String generateElementName(WebElement element, String elementType) {
        String elementId = element.getAttribute("id");
        String elementName = element.getAttribute("name");
        String elementText = element.getText();
        String elementPlaceholder = element.getAttribute("placeholder");
        String elementValue = element.getAttribute("value");
        String elementLabel = findLabelText(element);
        
        // Try to use the most informative attribute for the name
        if (elementLabel != null && !elementLabel.isEmpty()) {
            return elementLabel + " " + capitalize(elementType);
        } else if (elementText != null && !elementText.isEmpty() && elementText.length() < 30) {
            return elementText + " " + capitalize(elementType);
        } else if (elementPlaceholder != null && !elementPlaceholder.isEmpty()) {
            return elementPlaceholder + " " + capitalize(elementType);
        } else if (elementValue != null && !elementValue.isEmpty() && !elementValue.matches("^\\s*$")) {
            return elementValue + " " + capitalize(elementType);
        } else if (elementName != null && !elementName.isEmpty()) {
            // Clean up name (remove underscores, dashes, etc.)
            String cleanName = elementName.replaceAll("[_\\-.]", " ");
            return capitalize(cleanName) + " " + capitalize(elementType);
        } else if (elementId != null && !elementId.isEmpty()) {
            // Clean up ID (remove underscores, dashes, etc.)
            String cleanId = elementId.replaceAll("[_\\-.]", " ");
            return capitalize(cleanId) + " " + capitalize(elementType);
        } else {
            return "Unnamed " + capitalize(elementType);
        }
    }
    
    /**
     * Find label text for an element
     * @param element WebElement
     * @return Label text if found, null otherwise
     */
    private String findLabelText(WebElement element) {
        WebDriver driver = getDriver();
        if (driver == null) {
            return null;
        }
        
        try {
            String elementId = element.getAttribute("id");
            if (elementId != null && !elementId.isEmpty()) {
                List<WebElement> labels = driver.findElements(By.cssSelector("label[for='" + elementId + "']"));
                if (!labels.isEmpty() && labels.get(0).getText() != null && !labels.get(0).getText().isEmpty()) {
                    return labels.get(0).getText();
                }
            }
            
            // Check if element is wrapped in a label
            WebElement parent = (WebElement) ((JavascriptExecutor) driver)
                    .executeScript("return arguments[0].parentNode;", element);
            
            if (parent.getTagName().equalsIgnoreCase("label") && 
                parent.getText() != null && !parent.getText().isEmpty()) {
                return parent.getText();
            }
            
            return null;
        } catch (Exception e) {
            log.warn("Error finding label text", e);
            return null;
        }
    }
    
    /**
     * Extract page name from URL
     * @param url URL
     * @return Page name
     */
    private String extractPageNameFromUrl(String url) {
        if (url == null || url.isEmpty()) {
            return "Unknown Page";
        }
        
        try {
            // Remove protocol and domain
            String path = url.replaceFirst("^https?://[^/]+", "");
            
            // Remove query string and fragment
            path = path.replaceFirst("\\?.*$", "").replaceFirst("#.*$", "");
            
            // Split path by slashes
            String[] parts = path.split("/");
            
            // Use last non-empty part as page name
            for (int i = parts.length - 1; i >= 0; i--) {
                if (parts[i] != null && !parts[i].isEmpty()) {
                    // Clean up and capitalize
                    String pageName = parts[i].replaceAll("[_\\-.]", " ");
                    return capitalize(pageName) + " Page";
                }
            }
            
            // If no suitable part found, use domain name
            String domain = url.replaceFirst("^https?://", "").replaceFirst("/.*$", "");
            return capitalize(domain) + " Home Page";
        } catch (Exception e) {
            log.warn("Error extracting page name from URL", e);
            return "Unknown Page";
        }
    }
    
    /**
     * Generate a key for identifying a page
     * @param url URL
     * @return Page key
     */
    private String generatePageKey(String url) {
        if (url == null || url.isEmpty()) {
            return "unknown-page";
        }
        
        // Remove protocol
        String key = url.replaceFirst("^https?://", "");
        
        // Remove query string and fragment
        key = key.replaceFirst("\\?.*$", "").replaceFirst("#.*$", "");
        
        // Remove trailing slash
        key = key.replaceFirst("/$", "");
        
        return key;
    }
    
    /**
     * Generate class name from page name
     * @param pageName Page name
     * @return Class name
     */
    private String generateClassName(String pageName) {
        if (pageName == null || pageName.isEmpty()) {
            return "UnknownPage";
        }
        
        // Remove "Page" suffix if present - we'll add it back
        if (pageName.endsWith(" Page")) {
            pageName = pageName.substring(0, pageName.length() - 5);
        }
        
        // Replace non-alphanumeric with spaces and split into words
        String[] words = pageName.replaceAll("[^a-zA-Z0-9]", " ").trim().split("\\s+");
        
        StringBuilder className = new StringBuilder();
        for (String word : words) {
            if (!word.isEmpty()) {
                className.append(Character.toUpperCase(word.charAt(0)))
                       .append(word.substring(1).toLowerCase());
            }
        }
        
        // Add "Page" suffix if not already present
        if (!className.toString().endsWith("Page")) {
            className.append("Page");
        }
        
        return className.toString();
    }
    
    /**
     * Capitalize a string
     * @param str String to capitalize
     * @return Capitalized string
     */
    private String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        
        // Split by non-alphanumeric characters and capitalize each word
        String[] words = str.split("\\s+");
        StringBuilder result = new StringBuilder();
        
        for (String word : words) {
            if (word.length() > 0) {
                result.append(Character.toUpperCase(word.charAt(0)));
                if (word.length() > 1) {
                    result.append(word.substring(1).toLowerCase());
                }
                result.append(" ");
            }
        }
        
        return result.toString().trim();
    }
    
    /**
     * Generate code for all page objects
     */
    private void generatePageObjectCode() {
        log.info("Generating code for {} page objects", pageObjects.size());
        
        for (PageObjectModel pageObject : pageObjects.values()) {
            try {
                String code = pageObject.generateCode();
                log.info("Generated code for page object: {}", pageObject.getName());
                
                // Store code in page object - no need for reflection since we can use Lombok's getters/setters
                
            } catch (Exception e) {
                log.error("Error generating code for page object: {}", pageObject.getName(), e);
            }
        }
    }
    
    /**
     * Get all page objects detected during recording
     * @return Map of page objects
     */
    public Map<String, PageObjectModel> getPageObjects() {
        return Collections.unmodifiableMap(pageObjects);
    }
    
    /**
     * Get page object for current page
     * @return Current page object
     */
    public PageObjectModel getCurrentPageObject() {
        return currentPageObject;
    }
}

---------------------------------------------------

package com.cssmart.ui.recorder;

import com.cssmart.core.pom.PageObjectModel;
import com.cssmart.core.pom.PageElement;
import com.cssmart.ui.recorder.model.RecordedStep;
import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.recorder.model.POMTestCase;

import org.openqa.selenium.By;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.JavascriptExecutor;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;
import java.time.LocalDateTime;
import java.net.URL;

/**
 * Enhanced test recorder with Page Object Model support
 */
@Slf4j
public class POMTestRecorder extends TestRecorder {
    
    private List<PageObjectModel> pageObjects;
    private PageObjectModel currentPageObject;
    private Map<String, String> currentPage;
    private final boolean pomEnabled;
    private String currentUrl;
    
    /**
     * Constructor for POMTestRecorder
     * @param recorderApiUrl Base URL for recorder API
     */
    public POMTestRecorder(String recorderApiUrl) {
        super(recorderApiUrl); // Call the parent constructor with the API URL
        this.pageObjects = new ArrayList<>();
        this.currentPage = new HashMap<>();
        this.pomEnabled = true;
        log.info("Created POMTestRecorder with API URL: {}", recorderApiUrl);
    }
    
    /**
     * Convert regular TestCase to POMTestCase
     */
    private POMTestCase convertToPOMTestCase(TestCase testCase) {
        try {
            // Create new POMTestCase with the same properties as TestCase
            POMTestCase pomTestCase = new POMTestCase();
            pomTestCase.setId(testCase.getId());
            pomTestCase.setName(testCase.getName());
            pomTestCase.setDescription(testCase.getDescription());
            pomTestCase.setSteps(testCase.getSteps());
            pomTestCase.setStartTime(testCase.getStartTime());
            pomTestCase.setEndTime(testCase.getEndTime());
            pomTestCase.setClassName(testCase.getClassName());
            pomTestCase.setMethodName(testCase.getMethodName());
            
            // Add page objects
            pomTestCase.setPageObjects(this.pageObjects);
            
            // Generate POM-based code
            String pomCode = generatePOMCode(pomTestCase);
            pomTestCase.setCode(pomCode);
            
            return pomTestCase;
        } catch (Exception e) {
            log.error("Error converting to POM test case: {}", e.getMessage(), e);
            // Return a new POMTestCase with the original test case properties if conversion fails
            return new POMTestCase(testCase);
        }
    }
    
    /**
     * Generate POM-based test code
     */
    private String generatePOMCode(POMTestCase pomTestCase) {
        StringBuilder code = new StringBuilder();
        
        // Add imports and class declaration
        code.append("package com.cssmart.tests.generated;\n\n");
        code.append("import com.cssmart.core.base.CSSmartTestBase;\n");
        code.append("import com.cssmart.core.annotations.CSSmartTest;\n");
        code.append("import org.testng.annotations.Test;\n");
        code.append("import com.cssmart.core.pom.PageObjectModel;\n");
        code.append("import com.cssmart.core.pom.PageElement;\n");
        code.append("import org.testng.Assert;\n");
        code.append("import lombok.extern.slf4j.Slf4j;\n\n");
        
        // Add imports for page objects
        for (PageObjectModel pageObject : pomTestCase.getPageObjects()) {
            code.append("import com.cssmart.tests.generated.pageobjects.")
                .append(pageObject.getClassName())
                .append(";\n");
        }
        
        code.append("\n/**\n");
        code.append(" * ").append(pomTestCase.getDescription()).append("\n");
        code.append(" * Generated with Page Object Model support\n");
        code.append(" */\n");
        code.append("@Slf4j\n");
        code.append("public class ").append(pomTestCase.getClassName()).append(" extends CSSmartTestBase {\n\n");
        
        // Add test method
        code.append("    @Test\n");
        code.append("    @CSSmartTest(description = \"").append(pomTestCase.getDescription()).append("\")\n");
        code.append("    public void ").append(pomTestCase.getMethodName()).append("() {\n");
        code.append("        log.info(\"Starting test: ").append(pomTestCase.getDescription()).append("\");\n\n");
        
        // Create page object instances
        Map<String, String> pageInstances = new HashMap<>();
        int pageCount = 0;
        
        for (PageObjectModel pageObject : pomTestCase.getPageObjects()) {
            String className = pageObject.getClassName();
            String instanceName = toCamelCase(className);
            
            // Ensure unique instance names
            if (pageInstances.containsValue(instanceName)) {
                instanceName = instanceName + (++pageCount);
            }
            
            code.append("        // Initialize ").append(className).append("\n");
            code.append("        ").append(className)
                .append(" ").append(instanceName)
                .append(" = new ").append(className)
                .append("(driver, elementFinder);\n\n");
            
            pageInstances.put(className, instanceName);
        }
        
        // Add test steps using page objects
        if (pomTestCase.getSteps() != null && !pomTestCase.getSteps().isEmpty()) {
            for (RecordedStep step : pomTestCase.getSteps()) {
                code.append("        // ").append(step.getDescription()).append("\n");
                
                // Special case for navigation
                if ("NAVIGATE".equals(step.getAction())) {
                    code.append("        driver.get(\"").append(step.getValue()).append("\");\n");
                } else {
                    // Try to find a page object that can handle this step
                    String pageInstance = findPageForElement(step.getElement(), pomTestCase.getPageObjects(), pageInstances);
                    
                    if (pageInstance != null) {
                        // Generate call to page object method
                        code.append(generatePageObjectMethodCall(pageInstance, step));
                    } else {
                        // Fall back to direct WebDriver calls
                        code.append(generateDirectWebDriverCall(step));
                    }
                }
                
                code.append("\n");
            }
        }
        
        code.append("        log.info(\"Test completed successfully\");\n");
        code.append("    }\n");
        code.append("}\n");
        
        return code.toString();
    }
    
    /**
     * Find which page object can handle a specific element
     */
    private String findPageForElement(String element, List<PageObjectModel> pageObjects, Map<String, String> pageInstances) {
        for (PageObjectModel pageObject : pageObjects) {
            for (PageElement pageElement : pageObject.getElements()) {
                // Check if this element matches
                if (element.contains(pageElement.getLocatorValue()) || 
                    pageElement.getLocatorValue().contains(element)) {
                    return pageInstances.get(pageObject.getClassName());
                }
            }
        }
        return null;
    }
    
    /**
     * Generate a method call using a page object
     */
    private String generatePageObjectMethodCall(String pageInstance, RecordedStep step) {
        StringBuilder code = new StringBuilder();
        
        switch (step.getAction()) {
            case "CLICK":
                String clickElementName = findMethodNameForElement(step.getElement());
                code.append("        ").append(pageInstance).append(".click")
                    .append(toPascalCase(clickElementName)).append("();\n");
                break;
            case "TYPE":
                String typeElementName = findMethodNameForElement(step.getElement());
                code.append("        ").append(pageInstance).append(".set")
                    .append(toPascalCase(typeElementName))
                    .append("(\"").append(step.getValue()).append("\");\n");
                break;
            case "SELECT":
                String selectElementName = findMethodNameForElement(step.getElement());
                code.append("        ").append(pageInstance).append(".select")
                    .append(toPascalCase(selectElementName))
                    .append("(\"").append(step.getValue()).append("\");\n");
                break;
            case "VERIFY_PRESENCE":
                String verifyElementName = findMethodNameForElement(step.getElement());
                code.append("        Assert.assertTrue(")
                    .append(pageInstance).append(".is")
                    .append(toPascalCase(verifyElementName)).append("Displayed()")
                    .append(", \"").append(verifyElementName).append(" should be present\");\n");
                break;
            default:
                // Fall back to direct WebDriver code
                code.append(generateDirectWebDriverCall(step));
        }
        
        return code.toString();
    }
    
    /**
     * Generate direct WebDriver calls for steps without page objects
     */
    private String generateDirectWebDriverCall(RecordedStep step) {
        StringBuilder code = new StringBuilder();
        
        switch (step.getAction()) {
            case "CLICK":
                code.append("        WebElement element = elementFinder.findElement(\"")
                    .append(step.getElement()).append("\");\n");
                code.append("        element.click();\n");
                break;
            case "TYPE":
                code.append("        WebElement element = elementFinder.findElement(\"")
                    .append(step.getElement()).append("\");\n");
                code.append("        element.clear();\n");
                code.append("        element.sendKeys(\"").append(step.getValue()).append("\");\n");
                break;
            case "SELECT":
                code.append("        WebElement element = elementFinder.findElement(\"")
                    .append(step.getElement()).append("\");\n");
                code.append("        new org.openqa.selenium.support.ui.Select(element)")
                    .append(".selectByVisibleText(\"").append(step.getValue()).append("\");\n");
                break;
            case "VERIFY_PRESENCE":
                code.append("        WebElement element = elementFinder.findElement(\"")
                    .append(step.getElement()).append("\");\n");
                code.append("        Assert.assertTrue(element.isDisplayed(), \"")
                    .append(step.getElement()).append(" should be present\");\n");
                break;
            default:
                code.append("        // Unsupported action: ").append(step.getAction()).append("\n");
        }
        
        return code.toString();
    }
    
    /**
     * Extract a clean method name from an element selector
     */
    private String findMethodNameForElement(String element) {
        // Clean up element identifier for use in method name
        return toCamelCase(cleanElementName(element));
    }
    
    /**
     * Convert string to PascalCase
     */
    private String toPascalCase(String input) {
        if (input == null || input.isEmpty()) return "Unknown";
        
        // Replace non-alphanumeric with spaces
        String cleaned = input.replaceAll("[^a-zA-Z0-9]", " ");
        
        // Split by whitespace
        String[] words = cleaned.split("\\s+");
        StringBuilder result = new StringBuilder();
        
        for (String word : words) {
            if (word.isEmpty()) continue;
            // Capitalize first letter, lowercase rest
            result.append(Character.toUpperCase(word.charAt(0)))
                  .append(word.substring(1).toLowerCase());
        }
        
        return result.toString();
    }
    
    /**
     * Convert string to camelCase
     */
    private String toCamelCase(String input) {
        if (input == null || input.isEmpty()) return "unknown";
        
        String pascalCase = toPascalCase(input);
        return Character.toLowerCase(pascalCase.charAt(0)) + pascalCase.substring(1);
    }
}
    
    /**
     * Determine the appropriate locator type based on the element string
     */
    private String determineLocatorType(String element) {
        if (element.startsWith("#")) {
            return "ID";
        } else if (element.startsWith(".")) {
            return "CLASS_NAME";
        } else if (element.startsWith("/")) {
            return "XPATH";
        } else if (element.startsWith("[name=")) {
            return "NAME";
        } else if (element.contains("=")) {
            return "CSS_SELECTOR";
        } else {
            return "CSS_SELECTOR"; // Default
        }
    }
    
    /**
     * Clean element name for use as variable name
     */
    private String cleanElementName(String element) {
        // Remove CSS selectors and other special characters
        String cleaned = element.replaceAll("^[#.]", "")
                              .replaceAll("\\[.*\\]", "")
                              .replaceAll("[^a-zA-Z0-9\\s]", " ")
                              .trim();
        
        if (cleaned.isEmpty()) {
            // If nothing left after cleaning, use generic name + hash
            return "element" + Math.abs(element.hashCode() % 1000);
        }
        
        return cleaned;
    }
    
    /**
     * Generate a class name from page name
     */
    private String generateClassName(String pageName) {
        // Remove "Page" suffix if present
        if (pageName.endsWith("Page")) {
            pageName = pageName.substring(0, pageName.length() - 4);
        }
        
        // Convert to PascalCase
        pageName = toPascalCase(pageName);
        
        // Add Page suffix
        return pageName + "Page";
    }
    
    /**
     * Extract a sensible page name from title or URL
     */
    private String extractPageName(String title, String url) {
        // First try to use the page title
        if (title != null && !title.isEmpty() && !"about:blank".equals(title)) {
            // Clean up title and convert to PascalCase
            String cleanTitle = title.replaceAll("[-_|].*$", "").trim();
            return toPascalCase(cleanTitle) + "Page";
        }
        
        // Fall back to URL
        try {
            java.net.URL parsedUrl = new java.net.URL(url);
            String path = parsedUrl.getPath();
            if (path != null && !path.isEmpty() && !"/".equals(path)) {
                // Use last part of path as page name
                String[] pathParts = path.split("/");
                String lastPart = pathParts[pathParts.length - 1];
                if (!lastPart.isEmpty()) {
                    return toPascalCase(lastPart) + "Page";
                }
            }
            
            // If no path, use hostname
            String host = parsedUrl.getHost();
            if (host != null && !host.isEmpty()) {
                // Remove www. and .com/.org/etc.
                host = host.replaceAll("^www\\.", "").replaceAll("\\.(com|org|net|io)$", "");
                return toPascalCase(host) + "Page";
            }
        } catch (Exception e) {
            log.warn("Error parsing URL for page name: {}", e.getMessage());
        }
        
        // Default page name if all else fails
        return "UnknownPage";
    }
    
    /**
     * Group recorded steps by page
     */
    private Map<String, List<RecordedStep>> groupStepsByPage(List<RecordedStep> steps) {
        Map<String, List<RecordedStep>> stepsByPage = new HashMap<>();
        String currentPage = "HomePage";
        
        for (RecordedStep step : steps) {
            // If this is a navigation action, it might indicate a new page
            if ("NAVIGATE".equals(step.getAction())) {
                currentPage = "HomePage"; // Default for first navigation
                
                // Extract page name from URL
                String url = step.getValue();
                if (url != null && !url.isEmpty()) {
                    // Try to derive a page name from the URL path
                    try {
                        java.net.URL parsedUrl = new java.net.URL(url);
                        String path = parsedUrl.getPath();
                        if (path != null && !path.isEmpty() && !"/".equals(path)) {
                            // Use last part of path as page name
                            String[] pathParts = path.split("/");
                            String lastPart = pathParts[pathParts.length - 1];
                            if (!lastPart.isEmpty()) {
                                // Convert to PascalCase for page name
                                currentPage = toPascalCase(lastPart) + "Page";
                            }
                        }
                    } catch (Exception e) {
                        log.warn("Error parsing URL for page name: {}", e.getMessage());
                    }
                }
            }
            
            // Add step to current page
            stepsByPage.computeIfAbsent(currentPage, k -> new ArrayList<>()).add(step);
        }
        
        return stepsByPage;
    }
    
    /**
     * Create a page object model from steps using Lombok's builder pattern
     */
    private PageObjectModel createPageObjectModel(String pageName, List<RecordedStep> steps) {
        try {
            // Create a new PageObjectModel instance using Lombok's builder
            PageObjectModel.PageObjectModelBuilder builder = PageObjectModel.builder()
                .id(UUID.randomUUID().toString())
                .name(pageName)
                .className(generateClassName(pageName))
                .packageName("com.cssmart.pom.pages")
                .description("Page Object for " + pageName)
                .elements(new ArrayList<>())
                .actions(new ArrayList<>())
                .verifications(new ArrayList<>());
            
            // Extract page URL from navigation step if present
            for (RecordedStep step : steps) {
                if ("NAVIGATE".equals(step.getAction()) && step.getValue() != null) {
                    builder.pageUrl(step.getValue());
                    break;
                }
            }
            
            // Extract unique elements from steps
            Map<String, PageElement> elementMap = new HashMap<>();
            
            for (RecordedStep step : steps) {
                String elementName = step.getElement();
                
                // Skip steps without element information
                if (elementName == null || elementName.isEmpty() || "NAVIGATE".equals(step.getAction())) {
                    continue;
                }
                
                // Create or update element if not already present
                if (!elementMap.containsKey(elementName)) {
                    // Create PageElement using Lombok's builder
                    PageElement element = createPageElement(elementName, step);
                    
                    if (element != null) {
                        elementMap.put(elementName, element);
                    }
                }
            }
            
            // Add all elements to the builder
            builder.elements(new ArrayList<>(elementMap.values()));
            
            // Build the PageObjectModel
            return builder.build();
            
        } catch (Exception e) {
            log.error("Error creating page object model: {}", e.getMessage(), e);
            return null;
        }
    }
    
    /**
     * Create a PageElement using Lombok's builder
     */
    private PageElement createPageElement(String elementName, RecordedStep step) {
        try {
            // Determine locator type based on the element string
            String locatorType = determineLocatorType(elementName);
            String locatorValue = elementName;
            
            // Create element with Lombok's builder pattern
            return PageElement.builder()
                .id(UUID.randomUUID().toString())
                .name(toCamelCase(cleanElementName(elementName)))
                .locatorType(locatorType)
                .locatorValue(locatorValue)
                .description(step.getDescription())
                .isList(false)
                .build();
            
        } catch (Exception e) {
            log.error("Error creating page element: {}", e.getMessage(), e);
            return null;
        }
    }
    
    /**
     * Add a corresponding action method for an element
     */
    private void addActionForElement(PageElement element) {
        if (currentPageObject == null) return;
        
        try {
            // Different actions based on element type
            String description;
            String methodName;
            
            if (element.getDescription().contains("input") || 
                element.getDescription().contains("text")) {
                methodName = "set" + toPascalCase(element.getName());
                description = "Set value for " + element.getName();
            } else {
                methodName = "click" + toPascalCase(element.getName());
                description = "Click on " + element.getName();
            }
            
            // Add action to page object using Lombok builder
            // Actions would be defined in your model as needed
        } catch (Exception e) {
            log.error("Error adding action for element: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Add a corresponding verification method for an element
     */
    private void addVerificationForElement(PageElement element) {
        if (currentPageObject == null) return;
        
        try {
            // Add verification to page object
            String methodName = "is" + toPascalCase(element.getName()) + "Displayed";
            String description = "Verify " + element.getName() + " is displayed";
            
            // Add verification to page object using Lombok builder
            // Verifications would be defined in your model as needed
        } catch (Exception e) {
            log.error("Error adding verification for element: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Add an element to the current page based on a recorded action
     */
    private void addElementToCurrentPage(String element, String actionType, String value) {
        try {
            if (element == null || element.isEmpty() || currentPageObject == null) return;
            
            // Determine the element type based on action
            String elementType;
            if ("TYPE".equals(actionType)) {
                elementType = "input";
            } else if ("SELECT".equals(actionType)) {
                elementType = "select";
            } else {
                elementType = "element";
            }
            
            // Determine locator type
            String locatorType = determineLocatorType(element);
            String locatorValue = element;
            
            // Create a display name from the element
            String displayName = toCamelCase(cleanElementName(element));
            
            // Add to page object
            addElementToPageObject(displayName, elementType + " element", locatorType, locatorValue);
            
        } catch (Exception e) {
            log.error("Error adding element to current page: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Extract page objects from recorded steps
     */
    private void extractPageObjects() {
        log.info("Extracting page objects from recorded steps");
        
        try {
            // Get current steps
            List<RecordedStep> steps = getSteps();
            if (steps.isEmpty()) {
                log.info("No steps to analyze for page objects");
                return;
            }
            
            // If we already have page objects from recording, just return
            if (!pageObjects.isEmpty()) {
                log.info("Using {} page objects detected during recording", pageObjects.size());
                return;
            }
            
            // Analyze steps to identify pages
            Map<String, List<RecordedStep>> stepsByPage = groupStepsByPage(steps);
            
            // For each page, create a page object
            for (Map.Entry<String, List<RecordedStep>> entry : stepsByPage.entrySet()) {
                String pageName = entry.getKey();
                List<RecordedStep> pageSteps = entry.getValue();
                
                // Create page object
                PageObjectModel pageObject = createPageObjectModel(pageName, pageSteps);
                
                if (pageObject != null && !pageObject.getElements().isEmpty()) {
                    log.info("Created page object {} with {} elements", 
                            pageObject.getName(), pageObject.getElements().size());
                    pageObjects.add(pageObject);
                }
            }
            
            log.info("Extracted {} page objects", pageObjects.size());
        } catch (Exception e) {
            log.error("Error extracting page objects: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Get the list of detected page objects
     */
    public List<PageObjectModel> getPageObjects() {
        return this.pageObjects;
    }
    
    /**
     * Detect and create a page object for the current page
     */
    private void detectPageObject() {
        try {
            if (getDriver() == null) {
                log.warn("WebDriver is null, cannot detect page object");
                return;
            }
            
            // Get current URL and title
            String url = getDriver().getCurrentUrl();
            String title = getDriver().getTitle();
            
            // Extract page name from title or URL
            String pageName = extractPageName(title, url);
            
            log.info("Detecting page object for: {} ({})", pageName, url);
            
            // Create a new page object using Lombok's builder pattern
            currentPageObject = PageObjectModel.builder()
                .id(UUID.randomUUID().toString())
                .name(pageName)
                .pageUrl(url)
                .packageName("com.cssmart.pom.pages")
                .className(generateClassName(pageName))
                .description("Page Object for " + pageName)
                .elements(new ArrayList<>())
                .actions(new ArrayList<>())
                .verifications(new ArrayList<>())
                .build();
            
            // Find key elements on the page and add them to page object
            findInitialPageElements();
            
            // Add to collection
            pageObjects.add(currentPageObject);
            
            log.info("Created page object: {}", currentPageObject.getName());
            
        } catch (Exception e) {
            log.error("Error detecting page object: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Find initial elements on current page for page object
     */
    private void findInitialPageElements() {
        try {
            if (getDriver() == null || currentPageObject == null) return;
            
            // Find all form elements
            List<WebElement> formElements = getDriver().findElements(By.cssSelector("input, select, button, textarea"));
            for (WebElement webElement : formElements) {
                try {
                    String id = webElement.getAttribute("id");
                    String name = webElement.getAttribute("name");
                    String type = webElement.getAttribute("type");
                    
                    // Skip elements without good identifiers
                    if ((id == null || id.isEmpty()) && (name == null || name.isEmpty())) {
                        continue;
                    }
                    
                    // Choose best locator strategy
                    String locatorType;
                    String locatorValue;
                    String elementName;
                    
                    if (id != null && !id.isEmpty()) {
                        locatorType = "ID";
                        locatorValue = id;
                        elementName = toCamelCase(id);
                    } else {
                        locatorType = "NAME";
                        locatorValue = name;
                        elementName = toCamelCase(name);
                    }
                    
                    // Create element using Lombok's builder pattern
                    addElementToPageObject(elementName, type + " element", locatorType, locatorValue);
                    
                } catch (Exception e) {
                    // Skip problematic elements
                    log.debug("Error processing form element: {}", e.getMessage());
                }
            }
            
            // Find links and buttons with text
            List<WebElement> clickables = getDriver().findElements(By.cssSelector("a, button"));
            for (WebElement webElement : clickables) {
                try {
                    String text = webElement.getText().trim();
                    String id = webElement.getAttribute("id");
                    
                    // Skip empty elements
                    if ((text.isEmpty() && (id == null || id.isEmpty()))) {
                        continue;
                    }
                    
                    String locatorType;
                    String locatorValue;
                    String elementName;
                    
                    if (id != null && !id.isEmpty()) {
                        locatorType = "ID";
                        locatorValue = id;
                        elementName = toCamelCase(id);
                    } else if (!text.isEmpty()) {
                        locatorType = "LINK_TEXT";
                        locatorValue = text;
                        elementName = toCamelCase(text) + "Link";
                    } else {
                        continue;
                    }
                    
                    // Add element to page object
                    addElementToPageObject(elementName, webElement.getTagName() + " element", locatorType, locatorValue);
                    
                } catch (Exception e) {
                    // Skip problematic elements
                    log.debug("Error processing clickable: {}", e.getMessage());
                }
            }
        } catch (Exception e) {
            log.warn("Error finding initial page elements: {}", e.getMessage());
        }
    }
    
    /**
     * Add an element to the current page object
     */
    private void addElementToPageObject(String name, String description, String locatorType, String locatorValue) {
        if (currentPageObject == null) return;
        
        try {
            // Check if element already exists
            boolean elementExists = currentPageObject.getElements().stream()
                .anyMatch(e -> e.getName().equals(name) || 
                         (e.getLocatorType().equals(locatorType) && e.getLocatorValue().equals(locatorValue)));
            
            if (elementExists) return;
            
            // Create page element using Lombok's builder pattern
            PageElement pageElement = PageElement.builder()
                .id(UUID.randomUUID().toString())
                .name(name)
                .description(description)
                .locatorType(locatorType)
                .locatorValue(locatorValue)
                .isList(false)
                .build();
            
            // Add element to page object
            List<PageElement> elements = new ArrayList<>(currentPageObject.getElements());
            elements.add(pageElement);
            
            // Create updated page object (immutable objects)
            currentPageObject = PageObjectModel.builder()
                .id(currentPageObject.getId())
                .name(currentPageObject.getName())
                .pageUrl(currentPageObject.getPageUrl())
                .packageName(currentPageObject.getPackageName())
                .className(currentPageObject.getClassName())
                .description(currentPageObject.getDescription())
                .elements(elements)
                .actions(currentPageObject.getActions())
                .verifications(currentPageObject.getVerifications())
                .build();
            
            // Update in collections
            for (int i = 0; i < pageObjects.size(); i++) {
                if (pageObjects.get(i).getId().equals(currentPageObject.getId())) {
                    pageObjects.set(i, currentPageObject);
                    break;
                }
            }
            
            // Add corresponding actions and verifications for this element
            addActionForElement(pageElement);
            addVerificationForElement(pageElement);
            
            log.debug("Added element '{}' to page object '{}'", name, currentPageObject.getName());
            
        } catch (Exception e) {
            log.error("Error adding element to page object: {}", e.getMessage(), e);
        }
    }
    
    @Override
    public void startRecording(String browserType, String url) {
        log.info(">>> POMTestRecorder.startRecording called with browser: {}, url: {}", browserType, url);
        
        // Call the parent method to initialize browser and basic recording
        super.startRecording(browserType, url);
        
        // Initialize POM-specific components
        this.pageObjects = new ArrayList<>();
        this.currentUrl = url;
        this.currentPage.put("url", url);
        
        try {
            // Extract page title for better naming
            if (getDriver() != null) {
                String title = getDriver().getTitle();
                this.currentPage.put("title", title);
                log.info("Initial page title: {}", title);
                
                // Create initial page object
                detectPageObject();
            } else {
                this.currentPage.put("title", "HomePage");
            }
        } catch (Exception e) {
            log.warn("Could not get page title: {}", e.getMessage());
            this.currentPage.put("title", "HomePage");
        }
        
        log.info("POM recording started with session ID: {}", getSessionId());
        log.info("<<< POMTestRecorder.startRecording completed");
    }
    
    @Override
    public TestCase stopRecording() {
        log.info(">>> POMTestRecorder.stopRecording called");
        
        // First, extract page objects from recorded steps
        extractPageObjects();
        
        // Then, call parent to stop recording and get test case
        TestCase testCase = super.stopRecording();
        
        // Convert to POMTestCase
        POMTestCase pomTestCase = convertToPOMTestCase(testCase);
        
        log.info("POM recording stopped, extracted {} page objects", pageObjects.size());
        log.info("<<< POMTestRecorder.stopRecording completed");
        
        return pomTestCase;
    }
    
    @Override
    public void recordAction(String actionType, String element, String value) {
        log.info(">>> POMTestRecorder.recordAction called with action: {}, element: {}", actionType, element);
        
        // Call parent to record the action
        super.recordAction(actionType, element, value);
        
        // Check if we've navigated to a new page
        if ("NAVIGATE".equals(actionType) && getDriver() != null) {
            String url = value;
            if (!url.equals(currentUrl)) {
                currentUrl = url;
                detectPageObject();
            }
        } else if (getDriver() != null && pomEnabled && currentPageObject != null) {
            // Add element to current page object if not already present
            addElementToCurrentPage(element, actionType, value);
        }
        
        log.info("<<< POMTestRecorder.recordAction completed");
    }
-------------------------------------------------------------------------------

package com.cssmart.ui.recorder;

import com.cssmart.core.pom.PageObjectModel;
import com.cssmart.core.pom.PageElement;
import com.cssmart.core.pom.LocatorType;
import com.cssmart.ui.recorder.model.RecordedStep;
import com.cssmart.ui.recorder.model.TestCase;
import com.cssmart.ui.recorder.model.POMTestCase;

import org.openqa.selenium.By;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.JavascriptExecutor;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;
import java.time.LocalDateTime;
import java.net.URL;

/**
 * Enhanced test recorder with Page Object Model support
 */
@Slf4j
public class POMTestRecorder extends TestRecorder {
    
    private List<PageObjectModel> pageObjects;
    private PageObjectModel currentPageObject;
    private Map<String, String> currentPage;
    private final boolean pomEnabled;
    private String currentUrl;
    
    /**
     * Constructor for POMTestRecorder
     * @param recorderApiUrl Base URL for recorder API
     */
    public POMTestRecorder(String recorderApiUrl) {
        super(recorderApiUrl); // Call the parent constructor with the API URL
        this.pageObjects = new ArrayList<>();
        this.currentPage = new HashMap<>();
        this.pomEnabled = true;
        log.info("Created POMTestRecorder with API URL: {}", recorderApiUrl);
    }
    
    @Override
    public void startRecording(String browserType, String url) {
        log.info(">>> POMTestRecorder.startRecording called with browser: {}, url: {}", browserType, url);
        
        // Call the parent method to initialize browser and basic recording
        super.startRecording(browserType, url);
        
        // Initialize POM-specific components
        this.pageObjects = new ArrayList<>();
        this.currentUrl = url;
        this.currentPage.put("url", url);
        
        try {
            // Extract page title for better naming
            if (getDriver() != null) {
                String title = getDriver().getTitle();
                this.currentPage.put("title", title);
                log.info("Initial page title: {}", title);
                
                // Create initial page object
                detectPageObject();
            } else {
                this.currentPage.put("title", "HomePage");
            }
        } catch (Exception e) {
            log.warn("Could not get page title: {}", e.getMessage());
            this.currentPage.put("title", "HomePage");
        }
        
        log.info("POM recording started with session ID: {}", getSessionId());
        log.info("<<< POMTestRecorder.startRecording completed");
    }
    
    @Override
    public TestCase stopRecording() {
        log.info(">>> POMTestRecorder.stopRecording called");
        
        // First, extract page objects from recorded steps
        extractPageObjects();
        
        // Then, call parent to stop recording and get test case
        TestCase testCase = super.stopRecording();
        
        // Convert to POMTestCase
        POMTestCase pomTestCase = convertToPOMTestCase(testCase);
        
        log.info("POM recording stopped, extracted {} page objects", pageObjects.size());
        log.info("<<< POMTestRecorder.stopRecording completed");
        
        return pomTestCase;
    }
    
    @Override
    public void recordAction(String actionType, String element, String value) {
        log.info(">>> POMTestRecorder.recordAction called with action: {}, element: {}", actionType, element);
        
        // Call parent to record the action
        super.recordAction(actionType, element, value);
        
        // Check if we've navigated to a new page
        if ("NAVIGATE".equals(actionType) && getDriver() != null) {
            String url = value;
            if (!url.equals(currentUrl)) {
                currentUrl = url;
                detectPageObject();
            }
        } else if (getDriver() != null && pomEnabled && currentPageObject != null) {
            // Add element to current page object if not already present
            addElementToCurrentPage(element, actionType, value);
        }
        
        log.info("<<< POMTestRecorder.recordAction completed");
    }
    
    /**
     * Get the list of detected page objects
     */
    public List<PageObjectModel> getPageObjects() {
        return this.pageObjects;
    }
    
    /**
     * Detect and create a page object for the current page
     */
    private void detectPageObject() {
        try {
            if (getDriver() == null) {
                log.warn("WebDriver is null, cannot detect page object");
                return;
            }
            
            // Get current URL and title
            String url = getDriver().getCurrentUrl();
            String title = getDriver().getTitle();
            
            // Extract page name from title or URL
            String pageName = extractPageName(title, url);
            
            log.info("Detecting page object for: {} ({})", pageName, url);
            
            // Create a new page object using Lombok's builder pattern
            currentPageObject = PageObjectModel.builder()
                .id(UUID.randomUUID().toString())
                .name(pageName)
                .pageUrl(url)
                .packageName("com.cssmart.pom.pages")
                .className(generateClassName(pageName))
                .description("Page Object for " + pageName)
                .elements(new ArrayList<>())
                .build();
            
            // Find key elements on the page and add them to page object
            findInitialPageElements();
            
            // Add to collection
            pageObjects.add(currentPageObject);
            
            log.info("Created page object: {}", currentPageObject.getName());
            
        } catch (Exception e) {
            log.error("Error detecting page object: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Find initial elements on current page for page object
     */
    private void findInitialPageElements() {
        try {
            if (getDriver() == null || currentPageObject == null) return;
            
            // Find all form elements
            List<WebElement> formElements = getDriver().findElements(By.cssSelector("input, select, button, textarea"));
            for (WebElement webElement : formElements) {
                try {
                    String id = webElement.getAttribute("id");
                    String name = webElement.getAttribute("name");
                    String type = webElement.getAttribute("type");
                    
                    // Skip elements without good identifiers
                    if ((id == null || id.isEmpty()) && (name == null || name.isEmpty())) {
                        continue;
                    }
                    
                    // Choose best locator strategy
                    LocatorType locatorType;
                    String locatorValue;
                    String elementName;
                    
                    if (id != null && !id.isEmpty()) {
                        locatorType = LocatorType.ID;
                        locatorValue = id;
                        elementName = toCamelCase(id);
                    } else {
                        locatorType = LocatorType.NAME;
                        locatorValue = name;
                        elementName = toCamelCase(name);
                    }
                    
                    // Create element using Lombok's builder pattern
                    addElementToPageObject(elementName, type + " element", locatorType, locatorValue);
                    
                } catch (Exception e) {
                    // Skip problematic elements
                    log.debug("Error processing form element: {}", e.getMessage());
                }
            }
            
            // Find links and buttons with text
            List<WebElement> clickables = getDriver().findElements(By.cssSelector("a, button"));
            for (WebElement webElement : clickables) {
                try {
                    String text = webElement.getText().trim();
                    String id = webElement.getAttribute("id");
                    
                    // Skip empty elements
                    if ((text.isEmpty() && (id == null || id.isEmpty()))) {
                        continue;
                    }
                    
                    LocatorType locatorType;
                    String locatorValue;
                    String elementName;
                    
                    if (id != null && !id.isEmpty()) {
                        locatorType = LocatorType.ID;
                        locatorValue = id;
                        elementName = toCamelCase(id);
                    } else if (!text.isEmpty()) {
                        locatorType = LocatorType.LINK_TEXT;
                        locatorValue = text;
                        elementName = toCamelCase(text) + "Link";
                    } else {
                        continue;
                    }
                    
                    // Add element to page object
                    addElementToPageObject(elementName, webElement.getTagName() + " element", locatorType, locatorValue);
                    
                } catch (Exception e) {
                    // Skip problematic elements
                    log.debug("Error processing clickable: {}", e.getMessage());
                }
            }
        } catch (Exception e) {
            log.warn("Error finding initial page elements: {}", e.getMessage());
        }
    }
    
    /**
     * Add an element to the current page object
     */
    private void addElementToPageObject(String name, String description, LocatorType locatorType, String locatorValue) {
        if (currentPageObject == null) return;
        
        try {
            // Check if element already exists
            boolean elementExists = currentPageObject.getElements().stream()
                .anyMatch(e -> e.getName().equals(name) || 
                         (e.getLocatorType().equals(locatorType) && e.getLocatorValue().equals(locatorValue)));
            
            if (elementExists) return;
            
            // Create page element using Lombok's builder pattern
            PageElement pageElement = PageElement.builder()
                .id(UUID.randomUUID().toString())
                .name(name)
                .description(description)
                .locatorType(locatorType)
                .locatorValue(locatorValue)
                .isList(false)
                .build();
            
            // Add element to page object
            List<PageElement> elements = new ArrayList<>(currentPageObject.getElements());
            elements.add(pageElement);
            
            // Create updated page object (immutable objects)
            currentPageObject = PageObjectModel.builder()
                .id(currentPageObject.getId())
                .name(currentPageObject.getName())
                .pageUrl(currentPageObject.getPageUrl())
                .packageName(currentPageObject.getPackageName())
                .className(currentPageObject.getClassName())
                .description(currentPageObject.getDescription())
                .elements(elements)
                .build();
            
            // Update in collections
            for (int i = 0; i < pageObjects.size(); i++) {
                if (pageObjects.get(i).getId().equals(currentPageObject.getId())) {
                    pageObjects.set(i, currentPageObject);
                    break;
                }
            }
            
            log.debug("Added element '{}' to page object '{}'", name, currentPageObject.getName());
            
        } catch (Exception e) {
            log.error("Error adding element to page object: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Add an element to the current page based on a recorded action
     */
    private void addElementToCurrentPage(String element, String actionType, String value) {
        try {
            if (element == null || element.isEmpty() || currentPageObject == null) return;
            
            // Determine the element type based on action
            String elementType;
            if ("TYPE".equals(actionType)) {
                elementType = "input";
            } else if ("SELECT".equals(actionType)) {
                elementType = "select";
            } else {
                elementType = "element";
            }
            
            // Determine locator type
            LocatorType locatorType = determineLocatorType(element);
            String locatorValue = element;
            
            // Create a display name from the element
            String displayName = toCamelCase(cleanElementName(element));
            
            // Add to page object
            addElementToPageObject(displayName, elementType + " element", locatorType, locatorValue);
            
        } catch (Exception e) {
            log.error("Error adding element to current page: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Extract page objects from recorded steps
     */
    private void extractPageObjects() {
        log.info("Extracting page objects from recorded steps");
        
        try {
            // Get current steps
            List<RecordedStep> steps = getSteps();
            if (steps.isEmpty()) {
                log.info("No steps to analyze for page objects");
                return;
            }
            
            // If we already have page objects from recording, just return
            if (!pageObjects.isEmpty()) {
                log.info("Using {} page objects detected during recording", pageObjects.size());
                return;
            }
            
            // Analyze steps to identify pages
            Map<String, List<RecordedStep>> stepsByPage = groupStepsByPage(steps);
            
            // For each page, create a page object
            for (Map.Entry<String, List<RecordedStep>> entry : stepsByPage.entrySet()) {
                String pageName = entry.getKey();
                List<RecordedStep> pageSteps = entry.getValue();
                
                // Create page object
                PageObjectModel pageObject = createPageObjectModel(pageName, pageSteps);
                
                if (pageObject != null && !pageObject.getElements().isEmpty()) {
                    log.info("Created page object {} with {} elements", 
                            pageObject.getName(), pageObject.getElements().size());
                    pageObjects.add(pageObject);
                }
            }
            
            log.info("Extracted {} page objects", pageObjects.size());
        } catch (Exception e) {
            log.error("Error extracting page objects: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Group recorded steps by page
     */
    private Map<String, List<RecordedStep>> groupStepsByPage(List<RecordedStep> steps) {
        Map<String, List<RecordedStep>> stepsByPage = new HashMap<>();
        String currentPage = "HomePage";
        
        for (RecordedStep step : steps) {
            // If this is a navigation action, it might indicate a new page
            if ("NAVIGATE".equals(step.getAction())) {
                currentPage = "HomePage"; // Default for first navigation
                
                // Extract page name from URL
                String url = step.getValue();
                if (url != null && !url.isEmpty()) {
                    // Try to derive a page name from the URL path
                    try {
                        java.net.URL parsedUrl = new java.net.URL(url);
                        String path = parsedUrl.getPath();
                        if (path != null && !path.isEmpty() && !"/".equals(path)) {
                            // Use last part of path as page name
                            String[] pathParts = path.split("/");
                            String lastPart = pathParts[pathParts.length - 1];
                            if (!lastPart.isEmpty()) {
                                // Convert to PascalCase for page name
                                currentPage = toPascalCase(lastPart) + "Page";
                            }
                        }
                    } catch (Exception e) {
                        log.warn("Error parsing URL for page name: {}", e.getMessage());
                    }
                }
            }
            
            // Add step to current page
            stepsByPage.computeIfAbsent(currentPage, k -> new ArrayList<>()).add(step);
        }
        
        return stepsByPage;
    }
    
    /**
     * Create a page object model from steps using Lombok's builder pattern
     */
    private PageObjectModel createPageObjectModel(String pageName, List<RecordedStep> steps) {
        try {
            // Create a new PageObjectModel instance using Lombok's builder
            PageObjectModel.PageObjectModelBuilder builder = PageObjectModel.builder()
                .id(UUID.randomUUID().toString())
                .name(pageName)
                .className(generateClassName(pageName))
                .packageName("com.cssmart.pom.pages")
                .description("Page Object for " + pageName);
            
            // Extract page URL from navigation step if present
            for (RecordedStep step : steps) {
                if ("NAVIGATE".equals(step.getAction()) && step.getValue() != null) {
                    builder.pageUrl(step.getValue());
                    break;
                }
            }
            
            // Extract unique elements from steps
            Map<String, PageElement> elementMap = new HashMap<>();
            
            for (RecordedStep step : steps) {
                String elementName = step.getElement();
                
                // Skip steps without element information
                if (elementName == null || elementName.isEmpty() || "NAVIGATE".equals(step.getAction())) {
                    continue;
                }
                
                // Create or update element if not already present
                if (!elementMap.containsKey(elementName)) {
                    // Create PageElement using Lombok's builder
                    PageElement element = createPageElement(elementName, step);
                    
                    if (element != null) {
                        elementMap.put(elementName, element);
                    }
                }
            }
            
            // Add all elements to the builder
            builder.elements(new ArrayList<>(elementMap.values()));
            
            // Build the PageObjectModel
            return builder.build();
            
        } catch (Exception e) {
            log.error("Error creating page object model: {}", e.getMessage(), e);
            return null;
        }
    }
    
    /**
     * Create a PageElement using Lombok's builder
     */
    private PageElement createPageElement(String elementName, RecordedStep step) {
        try {
            // Determine locator type based on the element string
            LocatorType locatorType = determineLocatorType(elementName);
            String locatorValue = elementName;
            
            // Create element with Lombok's builder pattern
            return PageElement.builder()
                .id(UUID.randomUUID().toString())
                .name(toCamelCase(cleanElementName(elementName)))
                .locatorType(locatorType)
                .locatorValue(locatorValue)
                .description(step.getDescription())
                .isList(false)
                .build();
            
        } catch (Exception e) {
            log.error("Error creating page element: {}", e.getMessage(), e);
            return null;
        }
    }
    
    /**
     * Determine the appropriate locator type based on the element string
     */
    private LocatorType determineLocatorType(String element) {
        if (element.startsWith("#")) {
            return LocatorType.ID;
        } else if (element.startsWith(".")) {
            return LocatorType.CLASS_NAME;
        } else if (element.startsWith("/")) {
            return LocatorType.XPATH;
        } else if (element.startsWith("[name=")) {
            return LocatorType.NAME;
        } else if (element.contains("=")) {
            return LocatorType.CSS_SELECTOR;
        } else {
            return LocatorType.CSS_SELECTOR; // Default
        }
    }
    
    /**
     * Clean element name for use as variable name
     */
    private String cleanElementName(String element) {
        // Remove CSS selectors and other special characters
        String cleaned = element.replaceAll("^[#.]", "")
                              .replaceAll("\\[.*\\]", "")
                              .replaceAll("[^a-zA-Z0-9\\s]", " ")
                              .trim();
        
        if (cleaned.isEmpty()) {
            // If nothing left after cleaning, use generic name + hash
            return "element" + Math.abs(element.hashCode() % 1000);
        }
        
        return cleaned;
    }
    
    /**
     * Generate a class name from page name
     */
    private String generateClassName(String pageName) {
        // Remove "Page" suffix if present
        if (pageName.endsWith("Page")) {
            pageName = pageName.substring(0, pageName.length() - 4);
        }
        
        // Convert to PascalCase
        pageName = toPascalCase(pageName);
        
        // Add Page suffix
        return pageName + "Page";
    }
    
    /**
     * Extract a sensible page name from title or URL
     */
    private String extractPageName(String title, String url) {
        // First try to use the page title
        if (title != null && !title.isEmpty() && !"about:blank".equals(title)) {
            // Clean up title and convert to PascalCase
            String cleanTitle = title.replaceAll("[-_|].*$", "").trim();
            return toPascalCase(cleanTitle) + "Page";
        }
        
        // Fall back to URL
        try {
            java.net.URL parsedUrl = new java.net.URL(url);
            String path = parsedUrl.getPath();
            if (path != null && !path.isEmpty() && !"/".equals(path)) {
                // Use last part of path as page name
                String[] pathParts = path.split("/");
                String lastPart = pathParts[pathParts.length - 1];
                if (!lastPart.isEmpty()) {
                    return toPascalCase(lastPart) + "Page";
                }
            }
            
            // If no path, use hostname
            String host = parsedUrl.getHost();
            if (host != null && !host.isEmpty()) {
                // Remove www. and .com/.org/etc.
                host = host.replaceAll("^www\\.", "").replaceAll("\\.(com|org|net|io)$", "");
                return toPascalCase(host) + "Page";
            }
        } catch (Exception e) {
            log.warn("Error parsing URL for page name: {}", e.getMessage());
        }
        
        // Default page name if all else fails
        return "UnknownPage";
    }
    
    /**
     * Convert regular TestCase to POMTestCase
     */
    private POMTestCase convertToPOMTestCase(TestCase testCase) {
        try {
            // Create new POMTestCase with the same properties as TestCase
            POMTestCase pomTestCase = new POMTestCase();
            pomTestCase.setId(testCase.getId());
            pomTestCase.setName(testCase.getName());
            pomTestCase.setDescription(testCase.getDescription());
            pomTestCase.setSteps(testCase.getSteps());
            pomTestCase.setStartTime(testCase.getStartTime());
            pomTestCase.setEndTime(testCase.getEndTime());
            pomTestCase.setClassName(testCase.getClassName());
            pomTestCase.setMethodName(testCase.getMethodName());
            
            // Add page objects
            pomTestCase.setPageObjects(this.pageObjects);
            
            // Generate POM-based code
            String pomCode = generatePOMCode(pomTestCase);
            pomTestCase.setCode(pomCode);
            
            return pomTestCase;
        } catch (Exception e) {
            log.error("Error converting to POM test case: {}", e.getMessage(), e);
            // Return a new POMTestCase with the original test case properties if conversion fails
            return new POMTestCase(testCase);
        }
    }
    
    /**
     * Generate POM-based test code
     */
    private String generatePOMCode(POMTestCase pomTestCase) {
        StringBuilder code = new StringBuilder();
        
        // Add imports and class declaration
        code.append("package com.cssmart.tests.generated;\n\n");
        code.append("import com.cssmart.core.base.CSSmartTestBase;\n");
        code.append("import com.cssmart.core.annotations.CSSmartTest;\n");
        code.append("import org.testng.annotations.Test;\n");
        code.append("import com.cssmart.core.pom.PageObjectModel;\n");
        code.append("import com.cssmart.core.pom.PageElement;\n");
        code.append("import org.testng.Assert;\n");
        code.append("import lombok.extern.slf4j.Slf4j;\n\n");
        
        // Add imports for page objects
        for (PageObjectModel pageObject : pomTestCase.getPageObjects()) {
            code.append("import com.cssmart.tests.generated.pageobjects.")
                .append(pageObject.getClassName())
                .append(";\n");
        }
        
        code.append("\n/**\n");
        code.append(" * ").append(pomTestCase.getDescription()).append("\n");
        code.append(" * Generated with Page Object Model support\n");
        code.append(" */\n");
        code.append("@Slf4j\n");
        code.append("public class ").append(pomTestCase.getClassName()).append(" extends CSSmartTestBase {\n\n");
        
        // Add test method
        code.append("    @Test\n");
        code.append("    @CSSmartTest(description = \"").append(pomTestCase.getDescription()).append("\")\n");
        code.append("    public void ").append(pomTestCase.getMethodName()).append("() {\n");
        code.append("        log.info(\"Starting test: ").append(pomTestCase.getDescription()).append("\");\n\n");
        
        // Create page object instances
        Map<String, String> pageInstances = new HashMap<>();
        int pageCount = 0;
        
        for (PageObjectModel pageObject : pomTestCase.getPageObjects()) {
            String className = pageObject.getClassName();
            String instanceName = toCamelCase(className);
            
            // Ensure unique instance names
            if (pageInstances.containsValue(instanceName)) {
                instanceName = instanceName + (++pageCount);
            }
            
            code.append("        // Initialize ").append(className).append("\n");
            code.append("        ").append(className)
                .append(" ").append(instanceName)
                .append(" = new ").append(className)
                .append("(driver, elementFinder);\n\n");
            
            pageInstances.put(className, instanceName);
        }
        
        // Add test steps using page objects
        if (pomTestCase.getSteps() != null && !pomTestCase.getSteps().isEmpty()) {
            for (RecordedStep step : pomTestCase.getSteps()) {
                code.append("        // ").append(step.getDescription()).append("\n");
                
                // Special case for navigation
                if ("NAVIGATE".equals(step.getAction())) {
                    code.append("        driver.get(\"").append(step.getValue()).append("\");\n");
                } else {
                    // Try to find a page object that can handle this step
                    String pageInstance = findPageForElement(step.getElement(), pomTestCase.getPageObjects(), pageInstances);
                    
                    if (pageInstance != null) {
                        // Generate call to page object method
                        code.append(generatePageObjectMethodCall(pageInstance, step));
                    } else {
                        // Fall back to direct WebDriver calls
                        code.append(generateDirectWebDriverCall(step));
                    }
                }
                
                code.append("\n");
            }
        }
        
        code.append("        log.info(\"Test completed successfully\");\n");
        code.append("    }\n");
        code.append("}\n");
        
        return code.toString();
    }
    
    /**
     * Find which page object can handle a specific element
     */
    private String findPageForElement(String element, List<PageObjectModel> pageObjects, Map<String, String> pageInstances) {
        for (PageObjectModel pageObject : pageObjects) {
            for (PageElement pageElement : pageObject.getElements()) {
                // Check if this element matches
                if (element.contains(pageElement.getLocatorValue()) || 
                    pageElement.getLocatorValue().contains(element)) {
                    return pageInstances.get(pageObject.getClassName());
                }
            }
        }
        return null;
    }
    
    /**
     * Generate a method call using a page object
     */
    private String generatePageObjectMethodCall(String pageInstance, RecordedStep step) {
        StringBuilder code = new StringBuilder();
        
        switch (step.getAction()) {
            case "CLICK":
                String clickElementName = findMethodNameForElement(step.getElement());
                code.append("        ").append(pageInstance).append(".click")
                    .append(toPascalCase(clickElementName)).append("();\n");
                break;
            case "TYPE":
                String typeElementName = findMethodNameForElement(step.getElement());
                code.append("        ").append(pageInstance).append(".set")
                    .append(toPascalCase(typeElementName))
                    .append("(\"").append(step.getValue()).append("\");\n");
                break;
            case "SELECT":
                String selectElementName = findMethodNameForElement(step.getElement());
                code.append("        ").append(pageInstance).append(".select")
                    .append(toPascalCase(selectElementName))
                    .append("(\"").append(step.getValue()).append("\");\n");
                break;
            case "VERIFY_PRESENCE":
                String verifyElementName = findMethodNameForElement(step.getElement());
                code.append("        Assert.assertTrue(")
                    .append(pageInstance).append(".is")
                    .append(toPascalCase(verifyElementName)).append("Displayed()")
                    .append(", \"").append(verifyElementName).append(" should be present\");\n");
                break;
            default:
                // Fall back to direct WebDriver code
                code.append(generateDirectWebDriverCall(step));
        }
        
        return code.toString();
    }
    
    /**
     * Generate direct WebDriver calls for steps without page objects
     */
    private String generateDirectWebDriverCall(RecordedStep step) {
        StringBuilder code = new StringBuilder();
        
        switch (step.getAction()) {
            case "CLICK":
                code.append("        WebElement element = elementFinder.findElement(\"")
                    .append(step.getElement()).append("\");\n");
                code.append("        element.click();\n");
                break;
            case "TYPE":
                code.append("        WebElement element = elementFinder.findElement(\"")
                    .append(step.getElement()).append("\");\n");
                code.append("        element.clear();\n");
                code.append("        element.sendKeys(\"").append(step.getValue()).append("\");\n");
                break;
            case "SELECT":
                code.append("        WebElement element = elementFinder.findElement(\"")
                    .append(step.getElement()).append("\");\n");
                code.append("        new org.openqa.selenium.support.ui.Select(element)")
                    .append(".selectByVisibleText(\"").append(step.getValue()).append("\");\n");
                break;
            case "VERIFY_PRESENCE":
                code.append("        WebElement element = elementFinder.findElement(\"")
                    .append(step.getElement()).append("\");\n");
                code.append("        Assert.assertTrue(element.isDisplayed(), \"")
                    .append(step.getElement()).append(" should be present\");\n");
                break;
            default:
                code.append("        // Unsupported action: ").append(step.getAction()).append("\n");
        }
        
        return code.toString();
    }
    
    /**
     * Extract a clean method name from an element selector
     */
    private String findMethodNameForElement(String element) {
        // Clean up element identifier for use in method name
        return toCamelCase(cleanElementName(element));
    }
    
    /**
     * Convert string to PascalCase
     */
    private String toPascalCase(String input) {
        if (input == null || input.isEmpty()) return "Unknown";
        
        // Replace non-alphanumeric with spaces
        String cleaned = input.replaceAll("[^a-zA-Z0-9]", " ");
        
        // Split by whitespace
        String[] words = cleaned.split("\\s+");
        StringBuilder result = new StringBuilder();
        
        for (String word : words) {
            if (word.isEmpty()) continue;
            // Capitalize first letter, lowercase rest
            result.append(Character.toUpperCase(word.charAt(0)))
                  .append(word.substring(1).toLowerCase());
        }
        
        return result.toString();
    }
    
    /**
     * Convert string to camelCase
     */
    private String toCamelCase(String input) {
        if (input == null || input.isEmpty()) return "unknown";
        
        String pascalCase = toPascalCase(input);
        return Character.toLowerCase(pascalCase.charAt(0)) + pascalCase.substring(1);
    }
}
